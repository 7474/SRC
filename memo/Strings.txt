SRC.NET/AbilityData.cs:            if (Strings.InStr(NicknameRet, "(") > 0)
SRC.NET/AbilityData.cs:                NicknameRet = Strings.Left(NicknameRet, Strings.InStr(NicknameRet, "(") - 1);
SRC.NET/AbilityData.cs:                j = (short)Strings.InStr(buf, "Lv");
SRC.NET/AbilityData.cs:                k = (short)Strings.InStr(buf, "=");
SRC.NET/AbilityData.cs:                    dat.Name = Strings.Left(buf, j - 1);
SRC.NET/AbilityData.cs:                        dat.Level = Conversions.ToDouble(Strings.Mid(buf, j + 2, k - (j + 2)));
SRC.NET/AbilityData.cs:                        buf = Strings.Mid(buf, k + 1);
SRC.NET/AbilityData.cs:                        if (Strings.Left(buf, 1) == "\"")
SRC.NET/AbilityData.cs:                            buf = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/AbilityData.cs:                        j = (short)Strings.InStr(buf, "Lv");
SRC.NET/AbilityData.cs:                        k = (short)Strings.InStr(buf, "=");
SRC.NET/AbilityData.cs:                            etype = Strings.Left(buf, j - 1);
SRC.NET/AbilityData.cs:                                elevel = Strings.Mid(buf, j + 2, k - (j + 2));
SRC.NET/AbilityData.cs:                                edata = Strings.Mid(buf, k + 1);
SRC.NET/AbilityData.cs:                                elevel = Strings.Mid(buf, j + 2);
SRC.NET/AbilityData.cs:                            etype = Strings.Left(buf, k - 1);
SRC.NET/AbilityData.cs:                            edata = Strings.Mid(buf, k + 1);
SRC.NET/AbilityData.cs:                        dat.Data = Strings.Trim(etype + " " + elevel + " " + edata);
SRC.NET/AbilityData.cs:                        dat.Level = Conversions.ToDouble(Strings.Mid(buf, j + 2));
SRC.NET/AbilityData.cs:                    dat.Name = Strings.Left(buf, k - 1);
SRC.NET/AbilityData.cs:                    buf = Strings.Mid(buf, k + 1);
SRC.NET/AbilityData.cs:                    if (Strings.Asc(buf) == 34) // "
SRC.NET/AbilityData.cs:                        buf = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/AbilityData.cs:                    j = (short)Strings.InStr(buf, "Lv");
SRC.NET/AbilityData.cs:                    k = (short)Strings.InStr(buf, "=");
SRC.NET/AbilityData.cs:                        etype = Strings.Left(buf, j - 1);
SRC.NET/AbilityData.cs:                            elevel = Strings.Mid(buf, j + 2, k - (j + 2));
SRC.NET/AbilityData.cs:                            edata = Strings.Mid(buf, k + 1);
SRC.NET/AbilityData.cs:                            elevel = Strings.Mid(buf, j + 2);
SRC.NET/AbilityData.cs:                        etype = Strings.Left(buf, k - 1);
SRC.NET/AbilityData.cs:                        edata = Strings.Mid(buf, k + 1);
SRC.NET/AbilityData.cs:                    dat.Data = Strings.Trim(etype + " " + elevel + " " + edata);
SRC.NET/AbilityData.cs:                        var loopTo = (short)Strings.Len(buf);
SRC.NET/AbilityData.cs:                        var loopTo1 = (short)Strings.Len(buf);
SRC.NET/AbilityData.cs:                        if (Strings.Len(ae.Data) == 0)
SRC.NET/AbilityData.cs:                        EffectNameRet = Strings.Trim(EffectNameRet);
SRC.NET/AbilityData.cs:                        if (Strings.Len(EffectNameRet) > 0)
SRC.NET/AbilityData.cs:                                        if (Strings.InStr(GeneralLib.LIndex(ref ae.Data, i), "!") == 0)
SRC.NET/AbilityData.cs:                                        if (Strings.InStr(GeneralLib.LIndex(ref ae.Data, i), "!") == 0)
SRC.NET/AbilityData.cs:                                        if (Strings.InStr(GeneralLib.LIndex(ref ae.Data, i), "!") == 0)
SRC.NET/AbilityData.cs:                                        if (Strings.InStr(GeneralLib.LIndex(ref ae.Data, i), "!") == 0)
SRC.NET/AbilityData.cs:                                        if (Strings.InStr(GeneralLib.LIndex(ref ae.Data, i), "!") == 0)
SRC.NET/AbilityData.cs:                                    if (Strings.Left(EffectNameRet, 1) == "\"")
SRC.NET/AbilityData.cs:                                        string arglist = Strings.Mid(EffectNameRet, 2, Strings.Len(EffectNameRet) - 2);
SRC.NET/AbilityData.cs:                            EffectNameRet = localItem().Nickname + "を" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((int)elevel2), VbStrConv.Wide) + "体召喚";
SRC.NET/AbilityData.cs:            else if (Strings.Len(wclass) == 1)
SRC.NET/AbilityData.cs:            else if (Strings.Right(wclass, 2) == "装備")
SRC.NET/AbilityData.cs:                WeaponTypeRet = Strings.Left(wclass, Strings.Len(wclass) - 2);
SRC.NET/AliasData.cs:            if (Strings.Right(adef, 1) == ")")
SRC.NET/AliasData.cs:                i = (short)Strings.InStr(adef, " (");
SRC.NET/AliasData.cs:                    strAliasNecessarySkill[n] = Strings.Trim(Strings.Mid(adef, i + 2, Strings.Len(adef) - i - 2));
SRC.NET/AliasData.cs:                    buf = Strings.Trim(Strings.Left(adef, i));
SRC.NET/AliasData.cs:                else if (Strings.Left(adef, 1) == "(")
SRC.NET/AliasData.cs:                    strAliasNecessarySkill[n] = Strings.Trim(Strings.Mid(adef, 2, Strings.Len(adef) - 2));
SRC.NET/AliasData.cs:            if (Strings.Right(buf, 1) == ">")
SRC.NET/AliasData.cs:                i = (short)Strings.InStr(adef, " <");
SRC.NET/AliasData.cs:                    strAliasNecessaryCondition[n] = Strings.Trim(Strings.Mid(buf, i + 2, Strings.Len(buf) - i - 2));
SRC.NET/AliasData.cs:                    buf = Strings.Trim(Strings.Left(buf, i));
SRC.NET/AliasData.cs:                else if (Strings.Left(buf, 1) == "<")
SRC.NET/AliasData.cs:                    strAliasNecessaryCondition[n] = Strings.Trim(Strings.Mid(buf, 2, Strings.Len(buf) - 2));
SRC.NET/AliasData.cs:            i = (short)Strings.InStr(buf, "Lv");
SRC.NET/AliasData.cs:            j = (short)Strings.InStr(buf, "=");
SRC.NET/AliasData.cs:                atype = Strings.Left(buf, i - 1);
SRC.NET/AliasData.cs:                    alevel = Conversions.ToDouble(Strings.Mid(buf, i + 2, j - (i + 2)));
SRC.NET/AliasData.cs:                    adata = Strings.Mid(buf, j + 1);
SRC.NET/AliasData.cs:                    alevel = Conversions.ToDouble(Strings.Mid(buf, i + 2));
SRC.NET/AliasData.cs:                atype = Strings.Left(buf, j - 1);
SRC.NET/AliasData.cs:                adata = Strings.Mid(buf, j + 1);
SRC.NET/AliasDataList.cs:                while (Strings.Len(line_buf) == 0);
SRC.NET/AliasDataList.cs:                if (Strings.InStr(line_buf, ",") > 0)
SRC.NET/AliasDataList.cs:                if (Strings.InStr(data_name, " ") > 0)
SRC.NET/AliasDataList.cs:                if (Strings.InStr(data_name, "（") > 0 | Strings.InStr(data_name, "）") > 0)
SRC.NET/AliasDataList.cs:                if (Strings.InStr(data_name, "\"") > 0)
SRC.NET/AliasDataList.cs:                    if (Strings.Len(line_buf) == 0)
SRC.NET/BattleConfigDataList.cs:                while (Strings.Len(line_buf) == 0);
SRC.NET/BattleConfigDataList.cs:                    if (Strings.Len(line_buf) == 0)
SRC.NET/CmdData.cs:            if (Strings.Len(edata) == 0)
SRC.NET/CmdData.cs:            if (Strings.Right(edata, 1) == ":")
SRC.NET/CmdData.cs:                    switch (Strings.Asc(buf))
SRC.NET/CmdData.cs:                                if (Strings.Right(buf, 1) == "\"")
SRC.NET/CmdData.cs:                                    if (Strings.InStr(buf, "$(") == 0)
SRC.NET/CmdData.cs:                                        strArgs[i] = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/CmdData.cs:                                if (Strings.Right(buf, 1) == "`")
SRC.NET/CmdData.cs:                                    strArgs[i] = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/CmdData.cs:            switch (Strings.LCase(list[1]) ?? "")
SRC.NET/CmdData.cs:                            strArgs[2] = Strings.LCase(strArgs[2]);
SRC.NET/CmdData.cs:                            strArgs[2] = Strings.LCase(strArgs[2]);
SRC.NET/CmdData.cs:                            if (Strings.LCase(list[2]) == "else")
SRC.NET/CmdData.cs:                    switch (Strings.LCase(buf) ?? "")
SRC.NET/CmdData.cs:                                strArgs[4] = Strings.LCase(buf);
SRC.NET/CmdData.cs:                            switch (Strings.Asc(expr))
SRC.NET/CmdData.cs:                                        strArgs[2] = Strings.Mid(expr, 2, Strings.Len(expr) - 2);
SRC.NET/CmdData.cs:                            if (Strings.LCase(GeneralLib.LIndex(ref expr, 1)) == "not")
SRC.NET/CmdData.cs:                                switch (Strings.Asc(GeneralLib.ListIndex(ref expr, 2)))
SRC.NET/CmdData.cs:                if (Strings.Right(buf, 1) == ";")
SRC.NET/CmdData.cs:                    buf = Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/CmdData.cs:                    if (Strings.Right(buf, 1) == " ")
SRC.NET/CmdData.cs:                            if (Strings.Left(buf, 1) == "\"" & Strings.Right(buf, 1) == "\"")
SRC.NET/CmdData.cs:                                if (Strings.InStr(buf, "$(") > 0)
SRC.NET/CmdData.cs:                                    strArgs[2] = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/CmdData.cs:                            else if (Strings.Left(buf, 1) == "`" & Strings.Right(buf, 1) == "`")
SRC.NET/CmdData.cs:                                strArgs[2] = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/CmdData.cs:                            else if (Strings.InStr(buf, "$(") > 0)
SRC.NET/CmdData.cs:                            if (Strings.InStr(buf, "$(") > 0)
SRC.NET/CmdData.cs:                                if (Strings.InStr(buf, "$(") > 0)
SRC.NET/CmdData.cs:                            if (Strings.Left(buf, 1) == "\"" & Strings.Right(buf, 1) == "\"")
SRC.NET/CmdData.cs:                                if (Strings.InStr(buf, "$(") > 0)
SRC.NET/CmdData.cs:                                    strArgs[4] = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/CmdData.cs:                            else if (Strings.Left(buf, 1) == "`" & Strings.Right(buf, 1) == "`")
SRC.NET/CmdData.cs:                                strArgs[4] = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/CmdData.cs:                            else if (Strings.InStr(buf, "$(") > 0)
SRC.NET/CmdData.cs:                                if (Strings.InStr(buf, "$(") > 0)
SRC.NET/CmdData.cs:                            if (Strings.InStr(buf, "$(") > 0)
SRC.NET/CmdData.cs:                fname = Strings.Mid(fname, idx + 1);
SRC.NET/CmdData.cs:            if (Strings.Len(Event_Renamed.EventErrorMessage) > 0)
SRC.NET/CmdData.cs:            else if (Strings.LCase(GeneralLib.ListIndex(ref Event_Renamed.EventData[LineNum], 1)) == "talk")
SRC.NET/CmdData.cs:            else if (Strings.LCase(GeneralLib.ListIndex(ref Event_Renamed.EventData[LineNum], 1)) == "autotalk")
SRC.NET/CmdData.cs:                if (Strings.Asc(opt) == 35) // #
SRC.NET/CmdData.cs:                    if (Strings.Len(opt) != 7)
SRC.NET/CmdData.cs:                    var midTmp = Strings.Mid(opt, 6, 2);
SRC.NET/CmdData.cs:                    var midTmp1 = Strings.Mid(opt, 4, 2);
SRC.NET/CmdData.cs:                    var midTmp2 = Strings.Mid(opt, 2, 2);
SRC.NET/CmdData.cs:            if (Strings.Left(var_name, 1) == "$")
SRC.NET/CmdData.cs:                var_name = Strings.Mid(var_name, 2);
SRC.NET/CmdData.cs:            if (Strings.LCase(Strings.Left(var_name, 5)) == "eval(")
SRC.NET/CmdData.cs:                if (Strings.Right(var_name, 1) == ")")
SRC.NET/CmdData.cs:                    var_name = Strings.Mid(var_name, 6, Strings.Len(var_name) - 6);
SRC.NET/CmdData.cs:                i = Strings.InStr(buf, sep);
SRC.NET/CmdData.cs:                    array_buf((object)Information.UBound((Array)array_buf)) = Strings.Left(buf, i - 1);
SRC.NET/CmdData.cs:                    buf = Strings.Mid(buf, i + Strings.Len(sep));
SRC.NET/CmdData.cs:                    i = Strings.InStr(buf, sep);
SRC.NET/CmdData.cs:                            if (Strings.Len(buf) > 0)
SRC.NET/CmdData.cs:                            if (Strings.Left(vname, 1) == "$")
SRC.NET/CmdData.cs:                                vname = Strings.Mid(vname, 2) + "[";
SRC.NET/CmdData.cs:                                    if (Strings.InStr(withBlock.Name, vname) == 1)
SRC.NET/CmdData.cs:                                        if (Strings.Len(buf) > 0)
SRC.NET/CmdData.cs:                                            GUI.ListItemID[Information.UBound(list)] = Strings.Mid(withBlock.Name, Strings.Len(vname) + 1, Strings.Len(withBlock.Name) - Strings.Len(vname) - 1);
SRC.NET/CmdData.cs:                            if (Strings.Left(vname, 1) == "$")
SRC.NET/CmdData.cs:                                vname = Strings.Mid(vname, 2) + "[";
SRC.NET/CmdData.cs:                                if (Strings.InStr(var.Name, vname) == 1)
SRC.NET/CmdData.cs:                                    if (Strings.Len(buf) > 0)
SRC.NET/CmdData.cs:                                        GUI.ListItemID[Information.UBound(list)] = Strings.Mid(var.Name, Strings.Len(vname) + 1, Strings.Len(var.Name) - Strings.Len(vname) - 1);
SRC.NET/CmdData.cs:                            if (Strings.Left(vname, 1) == "$")
SRC.NET/CmdData.cs:                                vname = Strings.Mid(vname, 2) + "[";
SRC.NET/CmdData.cs:                                if (Strings.InStr(var.Name, vname) == 1)
SRC.NET/CmdData.cs:                                    if (Strings.Len(buf) > 0)
SRC.NET/CmdData.cs:                                        GUI.ListItemID[Information.UBound(list)] = Strings.Mid(var.Name, Strings.Len(vname) + 1, Strings.Len(var.Name) - Strings.Len(vname) - 1);
SRC.NET/CmdData.cs:                                if (Strings.Left(pname, 1) == "@")
SRC.NET/CmdData.cs:                                    pname = Strings.Mid(pname, 2);
SRC.NET/CmdData.cs:                                                    var midTmp = Strings.Mid(buf, 6, 2);
SRC.NET/CmdData.cs:                                                    var midTmp1 = Strings.Mid(buf, 4, 2);
SRC.NET/CmdData.cs:                                                    var midTmp2 = Strings.Mid(buf, 2, 2);
SRC.NET/CmdData.cs:            if (!localIsDefined() & Strings.InStr(pname, "(") > 0)
SRC.NET/CmdData.cs:                object argIndex1 = Strings.Left(pname, Strings.InStr(pname, "(") - 1);
SRC.NET/CmdData.cs:                    pname = Strings.Left(pname, Strings.InStr(pname, "(") - 1);
SRC.NET/CmdData.cs:                        if (Strings.InStr(fname, @"\") > 0)
SRC.NET/CmdData.cs:                            save_path = Strings.Left(fname, GeneralLib.InStr2(ref fname, ref argstr2));
SRC.NET/CmdData.cs:            if (Strings.Right(lname, 6) == "(ローカル)")
SRC.NET/CmdData.cs:                lname = Strings.Left(lname, Strings.Len(lname) - 6);
SRC.NET/CmdData.cs:            if (Strings.Len(fname) > 0)
SRC.NET/CmdData.cs:            if (Strings.Right(tname, 6) != "(ローカル)")
SRC.NET/CmdData.cs:                tname = Strings.Left(tname, Strings.Len(tname) - 6);
SRC.NET/CmdData.cs:                if (Strings.LCase(Strings.Right(new_bmp, 4)) == ".bmp")
SRC.NET/CmdData.cs:                if (Strings.Asc(opt) == 35) // #
SRC.NET/CmdData.cs:                    if (Strings.Len(opt) != 7)
SRC.NET/CmdData.cs:                    var midTmp = Strings.Mid(opt, 6, 2);
SRC.NET/CmdData.cs:                    var midTmp1 = Strings.Mid(opt, 4, 2);
SRC.NET/CmdData.cs:                    var midTmp2 = Strings.Mid(opt, 2, 2);
SRC.NET/CmdData.cs:                        slist = Strings.Trim(slist);
SRC.NET/CmdData.cs:                        if (Strings.Asc(buf) != 35 | Strings.Len(buf) != 7)
SRC.NET/CmdData.cs:                        var midTmp = Strings.Mid(buf, 6, 2);
SRC.NET/CmdData.cs:                        var midTmp1 = Strings.Mid(buf, 4, 2);
SRC.NET/CmdData.cs:                        var midTmp2 = Strings.Mid(buf, 2, 2);
SRC.NET/CmdData.cs:            if (Strings.Asc(opt) != 35 | Strings.Len(opt) != 7)
SRC.NET/CmdData.cs:            var midTmp = Strings.Mid(opt, 6, 2);
SRC.NET/CmdData.cs:            var midTmp1 = Strings.Mid(opt, 4, 2);
SRC.NET/CmdData.cs:            var midTmp2 = Strings.Mid(opt, 2, 2);
SRC.NET/CmdData.cs:                            if (Strings.Right(buf, 1) == "%" & Information.IsNumeric(Strings.Left(buf, Strings.Len(buf) - 1)))
SRC.NET/CmdData.cs:                                trans_par = GeneralLib.MaxDbl(0d, GeneralLib.MinDbl(1d, Conversions.ToDouble(Strings.Left(buf, Strings.Len(buf) - 1)) / 100d));
SRC.NET/CmdData.cs:            buf = "&H" + Strings.Mid(buf, 6, 2) + Strings.Mid(buf, 4, 2) + Strings.Mid(buf, 2, 2);
SRC.NET/CmdData.cs:                        GUI.DisplayMessage(ref argpname, Strings.Mid(msg, 2));
SRC.NET/CmdData.cs:                    GUI.DisplayMessage(ref argpname1, Strings.Mid(msg, 2));
SRC.NET/CmdData.cs:            if (Strings.Left(name1, 1) == "$")
SRC.NET/CmdData.cs:                name1 = Strings.Mid(name1, 2);
SRC.NET/CmdData.cs:            if (Strings.LCase(Strings.Left(name1, 5)) == "eval(")
SRC.NET/CmdData.cs:                if (Strings.Right(name1, 1) == ")")
SRC.NET/CmdData.cs:                    name1 = Strings.Mid(name1, 6, Strings.Len(name1) - 6);
SRC.NET/CmdData.cs:            if (Strings.Left(name2, 1) == "$")
SRC.NET/CmdData.cs:                name1 = Strings.Mid(name2, 2);
SRC.NET/CmdData.cs:            if (Strings.LCase(Strings.Left(name2, 5)) == "eval(")
SRC.NET/CmdData.cs:                if (Strings.Right(name2, 1) == ")")
SRC.NET/CmdData.cs:                    name2 = Strings.Mid(name2, 6, Strings.Len(name2) - 6);
SRC.NET/CmdData.cs:                        if (Strings.InStr(withBlock1.Name, name1 + "[") == 1)
SRC.NET/CmdData.cs:                            buf = name2 + Strings.Mid(withBlock1.Name, Strings.InStr(withBlock1.Name, "["));
SRC.NET/CmdData.cs:                        if (Strings.InStr(withBlock3.Name, name1 + "[") == 1)
SRC.NET/CmdData.cs:                            buf = name2 + Strings.Mid(withBlock3.Name, Strings.InStr(withBlock3.Name, "["));
SRC.NET/CmdData.cs:                        if (Strings.InStr(withBlock5.Name, name1 + "[") == 1)
SRC.NET/CmdData.cs:                            buf = name2 + Strings.Mid(withBlock5.Name, Strings.InStr(withBlock5.Name, "["));
SRC.NET/CmdData.cs:            if (Strings.InStr(fname1, @"..\") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname1, "../") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname2, @"..\") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname2, "../") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname, @"..\") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname, "../") > 0)
SRC.NET/CmdData.cs:            if (Strings.Right(fname, 1) == @"\")
SRC.NET/CmdData.cs:                fname = Strings.Left(fname, Strings.Len(fname) - 1);
SRC.NET/CmdData.cs:                        GUI.DisplayMessage(ref argpname, Strings.Mid(msg, 2));
SRC.NET/CmdData.cs:                    GUI.DisplayMessage(ref argpname1, Strings.Mid(msg, 2));
SRC.NET/CmdData.cs:            if (Strings.Asc(opt) != 35 | Strings.Len(opt) != 7)
SRC.NET/CmdData.cs:            var midTmp = Strings.Mid(opt, 6, 2);
SRC.NET/CmdData.cs:            var midTmp1 = Strings.Mid(opt, 4, 2);
SRC.NET/CmdData.cs:            var midTmp2 = Strings.Mid(opt, 2, 2);
SRC.NET/CmdData.cs:                                    if (Strings.Right(opt, 2) == "pt")
SRC.NET/CmdData.cs:                                        opt = Strings.Left(opt, Strings.Len(opt) - 2);
SRC.NET/CmdData.cs:                                    else if (Strings.Asc(opt) == 35 & Strings.Len(opt) == 7)
SRC.NET/CmdData.cs:                                        var midTmp = Strings.Mid(opt, 6, 2);
SRC.NET/CmdData.cs:                                        var midTmp1 = Strings.Mid(opt, 4, 2);
SRC.NET/CmdData.cs:                                        var midTmp2 = Strings.Mid(opt, 2, 2);
SRC.NET/CmdData.cs:                                            if (Strings.InStr(ustatus, u.Status_Renamed) > 0)
SRC.NET/CmdData.cs:                                                if (Strings.InStr(ustatus, u.Status_Renamed) > 0)
SRC.NET/CmdData.cs:                                            if ((u.MainPilot().ID ?? "") == (ugroup ?? "") | Strings.InStr(u.MainPilot().ID, ugroup + ":") == 1)
SRC.NET/CmdData.cs:                                                else if (Strings.InStr(ustatus, u.Status_Renamed) > 0)
SRC.NET/CmdData.cs:                        if (Strings.Left(vname, 1) == "$")
SRC.NET/CmdData.cs:                            vname = Strings.Mid(vname, 2);
SRC.NET/CmdData.cs:                        if (Strings.Left(aname, 1) == "$")
SRC.NET/CmdData.cs:                            aname = Strings.Mid(aname, 2);
SRC.NET/CmdData.cs:                        if (Strings.LCase(Strings.Left(aname, 5)) == "eval(")
SRC.NET/CmdData.cs:                            if (Strings.Right(aname, 1) == ")")
SRC.NET/CmdData.cs:                                aname = Strings.Mid(aname, 6, Strings.Len(aname) - 6);
SRC.NET/CmdData.cs:                            key_type = Strings.Mid(aname, (int)GeneralLib.InStrNotNest(ref aname, ref argstring2) + 1, Strings.Len(aname) - (int)GeneralLib.InStrNotNest(ref aname, ref argstring21) - 1);
SRC.NET/CmdData.cs:                                        if (Strings.StrComp(strkey_list[(int)j], max_str, (CompareMethod)1) == -1)
SRC.NET/CmdData.cs:                            key_type = Strings.Mid(aname, (int)GeneralLib.InStrNotNest(ref aname, ref argstring22) + 1, Strings.Len(aname) - (int)GeneralLib.InStrNotNest(ref aname, ref argstring23) - 1);
SRC.NET/CmdData.cs:                                        if (Strings.StrComp(strkey_list[(int)j], max_str, (CompareMethod)1) == -1)
SRC.NET/CmdData.cs:                                    if (Strings.InStr(withBlock2.Name, aname + "[") == 1)
SRC.NET/CmdData.cs:                                        var loopTo11 = (short)Strings.Len(buf);
SRC.NET/CmdData.cs:                                            if (Strings.Mid(buf, Strings.Len(buf) - (int)j + 1, 1) == "]")
SRC.NET/CmdData.cs:                                        buf = Strings.Mid(buf, Strings.InStr(buf, "[") + 1);
SRC.NET/CmdData.cs:                                        buf = Strings.Left(buf, Strings.Len(buf) - (int)j);
SRC.NET/CmdData.cs:                                if (Strings.InStr(var.Name, aname + "[") == 1)
SRC.NET/CmdData.cs:                                    var loopTo13 = Strings.Len(buf);
SRC.NET/CmdData.cs:                                        if (Strings.Mid(buf, Strings.Len(buf) - i + 1, 1) == "]")
SRC.NET/CmdData.cs:                                    buf = Strings.Mid(buf, Strings.InStr(buf, "[") + 1);
SRC.NET/CmdData.cs:                                    buf = Strings.Left(buf, Strings.Len(buf) - i);
SRC.NET/CmdData.cs:                                if (Strings.InStr(var.Name, aname + "[") == 1)
SRC.NET/CmdData.cs:                                    var loopTo15 = Strings.Len(buf);
SRC.NET/CmdData.cs:                                        if (Strings.Mid(buf, Strings.Len(buf) - i + 1, 1) == "]")
SRC.NET/CmdData.cs:                                    buf = Strings.Mid(buf, Strings.InStr(buf, "[") + 1);
SRC.NET/CmdData.cs:                                    buf = Strings.Left(buf, Strings.Len(buf) - i);
SRC.NET/CmdData.cs:                        else if (Strings.Left(aname, 1) == "(" & Strings.Right(aname, 1) == ")" | Strings.Left(aname, 1) == "\"" & Strings.Right(aname, 1) == "\"" | Strings.Left(aname, 1) == "`" & Strings.Right(aname, 1) == "`" | Strings.InStr(Strings.LCase(aname), "list(") == 1 & Strings.Right(aname, 1) == ")")
SRC.NET/CmdData.cs:                if (Strings.InStr(vname, "\"") > 0)
SRC.NET/CmdData.cs:                if (Strings.Asc(vname) == 36) // $
SRC.NET/CmdData.cs:                    vname = Strings.Mid(vname, 2);
SRC.NET/CmdData.cs:                if (Strings.Asc(opt) == 35) // #
SRC.NET/CmdData.cs:                    if (Strings.Len(opt) != 7)
SRC.NET/CmdData.cs:                    var midTmp = Strings.Mid(opt, 6, 2);
SRC.NET/CmdData.cs:                    var midTmp1 = Strings.Mid(opt, 4, 2);
SRC.NET/CmdData.cs:                    var midTmp2 = Strings.Mid(opt, 2, 2);
SRC.NET/CmdData.cs:                if (Strings.Right(Event_Renamed.EventData[i], 1) == "_")
SRC.NET/CmdData.cs:                        Event_Renamed.EventData[i + 1] = Strings.Left(Event_Renamed.EventData[i], Strings.Len(Event_Renamed.EventData[i]) - 1) + Event_Renamed.EventData[i + 1];
SRC.NET/CmdData.cs:                if (Strings.Right(Event_Renamed.EventData[i], 1) == ":")
SRC.NET/CmdData.cs:                    string arglname = Strings.Left(Event_Renamed.EventData[i], Strings.Len(Event_Renamed.EventData[i]) - 1);
SRC.NET/CmdData.cs:                    if (Strings.InStr(vname, "\"") > 0)
SRC.NET/CmdData.cs:                    if (Strings.Asc(vname) == 36) // $
SRC.NET/CmdData.cs:                        vname = Strings.Mid(vname, 2);
SRC.NET/CmdData.cs:                    if (Strings.InStr(vname, "\"") > 0)
SRC.NET/CmdData.cs:                    if (Strings.Asc(vname) == 36) // $
SRC.NET/CmdData.cs:                        vname = Strings.Mid(vname, 2);
SRC.NET/CmdData.cs:                        if (Strings.InStr(withBlock.Name, "ステータス表示用") == 0)
SRC.NET/CmdData.cs:                        if (Strings.StrComp(strkey_list[j], max_str, (CompareMethod)1) == -1)
SRC.NET/CmdData.cs:                            string argmsg3 = Strings.Left(Expression.Term(ref argtname1, ref u), 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(key_list[i]);
SRC.NET/CmdData.cs:                                string argmsg4 = Strings.Left(Expression.Term(ref argtname2, ref u), 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(key_list[i]);
SRC.NET/CmdData.cs:                                string argmsg5 = Strings.Left(Expression.Term(ref argtname3, ref u), 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(key_list[i]);
SRC.NET/CmdData.cs:                            string argmsg6 = Strings.Left(Expression.Term(ref argtname4, ref u), 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(key_list[i]);
SRC.NET/CmdData.cs:                            string argmsg7 = Strings.Left(Expression.Term(ref argtname5, ref u), 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(key_list[i]);
SRC.NET/CmdData.cs:                            string argmsg8 = Strings.Left(Expression.Term(ref argtname6, ref u), 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(key_list[i]);
SRC.NET/CmdData.cs:                            string argmsg9 = Strings.Left(Expression.Term(ref argtname7, ref u), 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(key_list[i]);
SRC.NET/CmdData.cs:                            if (Strings.InStr(opt, "アニメ表示") == 1)
SRC.NET/CmdData.cs:            if (string.IsNullOrEmpty(opt) | Strings.InStr(opt, "アニメ表示") == 1)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname, @"..\") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname, "../") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(opt, "出撃") <= 0)
SRC.NET/CmdData.cs:                uclass = Strings.Trim(uclass);
SRC.NET/CmdData.cs:                    list[Information.UBound(list)] = u.Nickname0 + Strings.Space(GeneralLib.MaxLng(52 - LenB(Strings.StrConv(u.Nickname0, vbFromUnicode)), 1)) + localLeftPaddedString();
SRC.NET/CmdData.cs:                    list[Information.UBound(list)] = u.Nickname0 + Strings.Space(GeneralLib.MaxLng(36 - LenB(Strings.StrConv(u.Nickname0, vbFromUnicode)), 1)) + u.MainPilot().get_Nickname(false) + Strings.Space(GeneralLib.MaxLng(17 - LenB(Strings.StrConv(u.MainPilot().get_Nickname(false), vbFromUnicode)), 1)) + localLeftPaddedString1();
SRC.NET/CmdData.cs:                if (Strings.InStr(opt, "非同期") > 0)
SRC.NET/CmdData.cs:                if (Strings.Asc(opt) == 35) // #
SRC.NET/CmdData.cs:                    if (Strings.Len(opt) != 7)
SRC.NET/CmdData.cs:                    var midTmp = Strings.Mid(opt, 6, 2);
SRC.NET/CmdData.cs:                    var midTmp1 = Strings.Mid(opt, 4, 2);
SRC.NET/CmdData.cs:                    var midTmp2 = Strings.Mid(opt, 2, 2);
SRC.NET/CmdData.cs:                            if (Strings.Asc(buf) == 35 & Strings.Len(buf) == 7)
SRC.NET/CmdData.cs:                                var midTmp = Strings.Mid(buf, 6, 2);
SRC.NET/CmdData.cs:                                var midTmp1 = Strings.Mid(buf, 4, 2);
SRC.NET/CmdData.cs:                                var midTmp2 = Strings.Mid(buf, 2, 2);
SRC.NET/CmdData.cs:                            else if (Strings.InStr(buf, " ") > 0)
SRC.NET/CmdData.cs:                            else if (Strings.Right(buf, 1) == "%" & Information.IsNumeric(Strings.Left(buf, Strings.Len(buf) - 1)))
SRC.NET/CmdData.cs:            switch (Strings.Right(Strings.LCase(fname), 4) ?? "")
SRC.NET/CmdData.cs:                    if (Strings.Left(fname, 2) == "$(")
SRC.NET/CmdData.cs:            if (Strings.Right(msg, 1) != ";")
SRC.NET/CmdData.cs:                if (Strings.Left(msg, 1) != "`" | Strings.Right(msg, 1) != "`")
SRC.NET/CmdData.cs:                    if (Strings.Left(msg, 2) == "$(")
SRC.NET/CmdData.cs:                        if (Strings.Right(msg, 1) == ")")
SRC.NET/CmdData.cs:                            string argexpr = Strings.Mid(msg, 3, Strings.Len(msg) - 3);
SRC.NET/CmdData.cs:                    msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/CmdData.cs:                msg = Strings.Left(msg, Strings.Len(msg) - 1);
SRC.NET/CmdData.cs:                if (Strings.Left(msg, 1) != "`" | Strings.Right(msg, 1) != "`")
SRC.NET/CmdData.cs:                    if (Strings.Left(msg, 2) == "$(")
SRC.NET/CmdData.cs:                        if (Strings.Right(msg, 1) == ")")
SRC.NET/CmdData.cs:                            string argexpr1 = Strings.Mid(msg, 3, Strings.Len(msg) - 3);
SRC.NET/CmdData.cs:                    msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/CmdData.cs:                if (Strings.Asc(opt) != 35 | Strings.Len(opt) != 7)
SRC.NET/CmdData.cs:                var midTmp = Strings.Mid(opt, 6, 2);
SRC.NET/CmdData.cs:                var midTmp1 = Strings.Mid(opt, 4, 2);
SRC.NET/CmdData.cs:                var midTmp2 = Strings.Mid(opt, 2, 2);
SRC.NET/CmdData.cs:                if (Strings.Len(buf) > 0)
SRC.NET/CmdData.cs:                    if (Strings.LCase(buf) == "end")
SRC.NET/CmdData.cs:            if (Strings.InStr(fname, @"..\") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname, "../") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname, @"..\") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname, "../") > 0)
SRC.NET/CmdData.cs:            if (Strings.Right(fname, 1) == @"\")
SRC.NET/CmdData.cs:                fname = Strings.Left(fname, Strings.Len(fname) - 1);
SRC.NET/CmdData.cs:            if (Strings.InStr(fname1, @"..\") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname1, "../") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname2, @"..\") > 0)
SRC.NET/CmdData.cs:            if (Strings.InStr(fname2, "../") > 0)
SRC.NET/CmdData.cs:                if (Strings.Right(Event_Renamed.EventData[i], 1) == "_")
SRC.NET/CmdData.cs:                    Event_Renamed.EventData[i + 1] = Strings.Left(Event_Renamed.EventData[i], Strings.Len(Event_Renamed.EventData[i]) - 1) + Event_Renamed.EventData[i + 1];
SRC.NET/CmdData.cs:                if (Strings.Right(buf, 1) == ":")
SRC.NET/CmdData.cs:                    string arglname = Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/CmdData.cs:                if (Strings.InStr(fname, @"\") > 0)
SRC.NET/CmdData.cs:                    save_path = Strings.Left(fname, (int)GeneralLib.InStr2(ref fname, ref argstr2));
SRC.NET/CmdData.cs:                if (Strings.Left(GetArg((short)4), 1) == "#")
SRC.NET/CmdData.cs:                                    if (Strings.InStr(pname0, "(") > 0)
SRC.NET/CmdData.cs:                                        pname0 = Strings.Left(pname0, (int)GeneralLib.InStr2(ref pname0, ref argstr2) - 1);
SRC.NET/CmdData.cs:                                sdata_array[i] = Strings.Trim(sdata + " " + localListTail());
SRC.NET/CmdData.cs:                                sdata_array[i] = Strings.Trim(sdata_array[i]);
SRC.NET/CmdData.cs:            if (Strings.Asc(opt) != 35 | Strings.Len(opt) != 7)
SRC.NET/CmdData.cs:            var midTmp = Strings.Mid(opt, 6, 2);
SRC.NET/CmdData.cs:            var midTmp1 = Strings.Mid(opt, 4, 2);
SRC.NET/CmdData.cs:            var midTmp2 = Strings.Mid(opt, 2, 2);
SRC.NET/CmdData.cs:            if (Strings.Asc(opt) != 35 | Strings.Len(opt) != 7)
SRC.NET/CmdData.cs:            var midTmp = Strings.Mid(opt, 6, 2);
SRC.NET/CmdData.cs:            var midTmp1 = Strings.Mid(opt, 4, 2);
SRC.NET/CmdData.cs:            var midTmp2 = Strings.Mid(opt, 2, 2);
SRC.NET/CmdData.cs:            switch (Strings.Right(Strings.LCase(fname), 4) ?? "")
SRC.NET/CmdData.cs:            if (Strings.Left(vname, 1) == "$")
SRC.NET/CmdData.cs:                vname = Strings.Mid(vname, 2);
SRC.NET/CmdData.cs:            if (Strings.LCase(Strings.Left(vname, 5)) == "eval(")
SRC.NET/CmdData.cs:                if (Strings.Right(vname, 1) == ")")
SRC.NET/CmdData.cs:                    vname = Strings.Mid(vname, 6, Strings.Len(vname) - 6);
SRC.NET/CmdData.cs:                        if (Strings.InStr(withBlock.Name, vname + "[") == 1)
SRC.NET/CmdData.cs:                            buf = Strings.Mid(withBlock.Name, Strings.InStr(withBlock.Name, "[") + 1, GeneralLib.InStr2(ref withBlock.Name, ref argstr2) - Strings.InStr(withBlock.Name, "[") - 1);
SRC.NET/CmdData.cs:                    if (Strings.InStr(var.Name, vname + "[") == 1)
SRC.NET/CmdData.cs:                        buf = Strings.Mid(var.Name, Strings.InStr(var.Name, "[") + 1, GeneralLib.InStr2(ref var.Name, ref argstr21) - Strings.InStr(var.Name, "[") - 1);
SRC.NET/CmdData.cs:                    if (Strings.InStr(var.Name, vname + "[") == 1)
SRC.NET/CmdData.cs:                        buf = Strings.Mid(var.Name, Strings.InStr(var.Name, "[") + 1, GeneralLib.InStr2(ref var.Name, ref argstr22) - Strings.InStr(var.Name, "[") - 1);
SRC.NET/CmdData.cs:                                isSwap = Conversions.ToBoolean(Interaction.IIf(Strings.StrComp(array_buf[0, i], array_buf[0, j], CompareMethod.Text) == 1, true, false));
SRC.NET/CmdData.cs:                                isSwap = Conversions.ToBoolean(Interaction.IIf(Strings.StrComp(array_buf[0, i], array_buf[0, j], CompareMethod.Text) == -1, true, false));
SRC.NET/CmdData.cs:                                isSwap = Conversions.ToBoolean(Interaction.IIf(Strings.StrComp(array_buf[2, i], array_buf[2, j], CompareMethod.Text) == 1, true, false));
SRC.NET/CmdData.cs:                                isSwap = Conversions.ToBoolean(Interaction.IIf(Strings.StrComp(array_buf[2, i], array_buf[2, j], CompareMethod.Text) == -1, true, false));
SRC.NET/CmdData.cs:                    if (Strings.Left(fname, 2) == "$(")
SRC.NET/CmdData.cs:                                if (Strings.Left(pname, 1) == "@")
SRC.NET/CmdData.cs:                                    pname = Strings.Mid(pname, 2);
SRC.NET/CmdData.cs:                                                    var midTmp = Strings.Mid(buf, 6, 2);
SRC.NET/CmdData.cs:                                                    var midTmp1 = Strings.Mid(buf, 4, 2);
SRC.NET/CmdData.cs:                                                    var midTmp2 = Strings.Mid(buf, 2, 2);
SRC.NET/CmdData.cs:            if (Strings.Len(BGM) > 0)
SRC.NET/CmdData.cs:                        switch (Strings.LCase(GetArg((short)2)) ?? "")
SRC.NET/CmdData.cs:            opt = Strings.Trim(opt);
SRC.NET/COM.cs:                    if (withBlock7.IsFeatureAvailable(ref argfname7) & Strings.InStr(withBlock7.MainPilot().Name, "(ザコ)") == 0)
SRC.NET/COM.cs:                    if (Strings.Len(BGM) > 0)
SRC.NET/COM.cs:                            if (Strings.Len(BGM) == 0)
SRC.NET/COM.cs:                            if (Strings.Len(BGM) == 0)
SRC.NET/COM.cs:                        if (Strings.Len(BGM) == 0)
SRC.NET/COM.cs:                                string argmidi_name5 = Strings.Mid(localFeatureData(), Strings.InStr(localFeatureData1(), " ") + 1);
SRC.NET/COM.cs:                                if (Strings.Len(BGM) > 0)
SRC.NET/COM.cs:                if (withBlock.MainPilot().Morale < 100 + (short)(10d * flevel) & (Strings.InStr(fdata, "気力発動") > 0 | withBlock.HP > withBlock.MaxHP / 4))
SRC.NET/COM.cs:                                    if (Strings.InStr(withBlock1.Data.Transportation, "水") > 0)
SRC.NET/COM.cs:                                        if (Strings.InStr(u.Data.Transportation, "水") == 0)
SRC.NET/COM.cs:                                    if (Strings.InStr(u.Data.Transportation, "水") > 0)
SRC.NET/COM.cs:                                        if (Strings.InStr(withBlock1.Data.Transportation, "水") == 0)
SRC.NET/COM.cs:                                    if (Strings.InStr(withBlock1.Data.Transportation, "空") > 0)
SRC.NET/COM.cs:                                        if (Strings.InStr(u.Data.Transportation, "空") == 0)
SRC.NET/COM.cs:                                    if (Strings.InStr(u.Data.Transportation, "空") > 0)
SRC.NET/COM.cs:                                        if (Strings.InStr(withBlock1.Data.Transportation, "空") == 0)
SRC.NET/COM.cs:                                    if (Strings.InStr(withBlock1.Data.Transportation, "水") > 0 | Strings.InStr(withBlock1.Data.Transportation, "空") > 0)
SRC.NET/COM.cs:                                    if (Strings.InStr(withBlock1.Data.Transportation, "空") > 0)
SRC.NET/COM.cs:                                    if (Strings.InStr(u.Data.Transportation, "水") > 0 | Strings.InStr(u.Data.Transportation, "空") > 0)
SRC.NET/COM.cs:                                    if (Strings.InStr(u.Data.Transportation, "空") > 0)
SRC.NET/COM.cs:                                if (Strings.Left(fname, 1) == "!")
SRC.NET/COM.cs:                                    fname = Strings.Mid(fname, 2);
SRC.NET/COM.cs:            if (Strings.InStr(p.Name, "(ザコ)") > 0)
SRC.NET/COM.cs:            if (Strings.InStr(amode, "反撃") == 0 & Strings.InStr(amode, "サポート") == 0)
SRC.NET/COM.cs:                    if (Strings.InStr(amode, "反撃") > 0 | Strings.InStr(amode, "サポート") > 0)
SRC.NET/COM.cs:                if (u.Party == "味方" & u.Party0 == "味方" & Strings.InStr(amode, "イベント") == 0)
SRC.NET/COM.cs:                if (u.BossRank >= 0 & Strings.InStr(amode, "イベント") == 0)
SRC.NET/COM.cs:                if (Strings.InStr(amode, "サポート") > 0)
SRC.NET/COM.cs:                if (Strings.InStr(amode, "可否判定") > 0)
SRC.NET/COM.cs:                if (Strings.InStr(amode, "サポート") == 0)
SRC.NET/COM.cs:                    var loopTo2 = (short)Strings.Len(wclass);
SRC.NET/COM.cs:                                        if (withBlock1.IsFeatureAvailable(ref argfname5) & Strings.InStr(t.FeatureData(ref argIndex33), "バリア無効化無効") == 0)
SRC.NET/COM.cs:                                        else if (withBlock1.IsFeatureAvailable(ref argfname7) & Strings.InStr(t.FeatureData(ref argIndex34), "バリア無効化無効") == 0)
SRC.NET/COM.cs:                                        else if (withBlock1.IsFeatureAvailable(ref argfname8) & Strings.InStr(t.FeatureData(ref argIndex35), "バリア無効化無効") == 0)
SRC.NET/COM.cs:                                        else if (withBlock1.IsFeatureAvailable(ref argfname10) & Strings.InStr(t.FeatureData(ref argIndex36), "バリア無効化無効") == 0)
SRC.NET/COM.cs:                                        if ((Strings.InStr(localCondition(), "付加") > 0 | Strings.InStr(localCondition1(), "強化") > 0 | Strings.InStr(localCondition2(), "ＵＰ") > 0) & localConditionLifetime() > 0)
SRC.NET/COM.cs:                                    if (Strings.Left(wattr, 1) == "弱")
SRC.NET/COM.cs:                                        checkwc = Strings.Mid(wattr, 2);
SRC.NET/COM.cs:                                    else if (Strings.Left(wattr, 1) == "効")
SRC.NET/COM.cs:                                        checkwc = Strings.Mid(wattr, 2);
SRC.NET/COM.cs:                                    else if (Strings.Left(wattr, 1) == "剋")
SRC.NET/COM.cs:                                        checkwc = Strings.Mid(wattr, 2);
SRC.NET/COM.cs:                if (Strings.InStr(amode, "反撃") > 0)
SRC.NET/COM.cs:                if (Strings.InStr(amode, "反撃") > 0)
SRC.NET/COM.cs:                        if (Strings.InStr(withBlock1.Name, "(ザコ)") > 0 | withBlock1.TacticalTechnique() < 160)
SRC.NET/Command.cs:                                    if (Strings.InStr(localAllFeatureData1(), "非表示") == 0)
SRC.NET/Command.cs:                                        if (Strings.InStr(withBlock4.FeatureData(ref argIndex29), "手動解除") > 0)
SRC.NET/Command.cs:                                if (Strings.Len(withBlock4.FeatureData(ref argIndex38)) > 0)
SRC.NET/Command.cs:                                if (Strings.Len(withBlock4.FeatureData(ref argIndex43)) > 0)
SRC.NET/Command.cs:                                if (Strings.Len(withBlock4.FeatureData(ref argIndex51)) > 0)
SRC.NET/Command.cs:                                if (Strings.Len(withBlock4.FeatureData(ref argIndex54)) > 0)
SRC.NET/Command.cs:                                if (withBlock4.IsFeatureAvailable(ref argfname26) & (withBlock4.MainPilot().Morale >= (short)(10d * withBlock4.FeatureLevel(ref argIndex80)) + 100 | withBlock4.HP <= withBlock4.MaxHP / 4 & Strings.InStr(withBlock4.FeatureData(ref argIndex81), "気力発動") == 0) & Strings.InStr(withBlock4.FeatureData(ref argIndex82), "自動発動") == 0 & !string.IsNullOrEmpty(withBlock4.FeatureName(ref argIndex83)) & !withBlock4.IsConditionSatisfied(ref argIndex84) & !withBlock4.IsConditionSatisfied(ref argIndex85))
SRC.NET/Command.cs:                                if (Strings.InStr(withBlock4.FeatureData(ref argIndex87), "手動解除") > 0)
SRC.NET/Command.cs:                                if (Map.TerrainClass(withBlock4.x, withBlock4.y) == "深水" & (withBlock4.IsTransAvailable(ref argarea_name6) | withBlock4.IsFeatureAvailable(ref argfname28)) & Strings.Mid(withBlock4.Data.Adaption, 3, 1) != "-")
SRC.NET/Command.cs:                                else if (Map.TerrainClass(withBlock4.x, withBlock4.y) == "水" & Strings.Mid(withBlock4.Data.Adaption, 3, 1) != "-")
SRC.NET/Command.cs:                                if (Strings.Len(withBlock14.FeatureData(ref argIndex94)) > 0)
SRC.NET/Command.cs:                                if (Strings.Len(withBlock14.FeatureData(ref argIndex96)) > 0)
SRC.NET/Command.cs:                            if (Strings.InStr(withBlock.FeatureData(ref argIndex1), "手動解除") > 0)
SRC.NET/Command.cs:                if (Strings.Len(BGM) == 0)
SRC.NET/Command.cs:                if (Strings.Len(BGM) == 0)
SRC.NET/Command.cs:                            string argmidi_name2 = Strings.Mid(localFeatureData(), Strings.InStr(localFeatureData1(), " ") + 1);
SRC.NET/Command.cs:                            if (Strings.Len(BGM) > 0)
SRC.NET/Command.cs:                if (withBlock1.IsFeatureAvailable(ref argfname) & Strings.InStr(withBlock1.MainPilot().Name, "(ザコ)") == 0)
SRC.NET/Command.cs:                    if (Strings.Len(BGM) > 0)
SRC.NET/Command.cs:            if (Strings.Len(BGM) == 0 & Sound.BossBGM)
SRC.NET/Command.cs:                                string argmidi_name1 = Strings.Mid(localFeatureData(), Strings.InStr(localFeatureData1(), " ") + 1);
SRC.NET/Command.cs:                    if (Strings.Len(BGM) == 0)
SRC.NET/Command.cs:                    if (Strings.Len(BGM) == 0)
SRC.NET/Command.cs:                    if (Strings.Len(BGM) == 0)
SRC.NET/Command.cs:                            string argmidi_name = Strings.Mid(localFeatureData(), Strings.InStr(localFeatureData1(), " ") + 1);
SRC.NET/Command.cs:                            if (Strings.Len(BGM) > 0)
SRC.NET/Command.cs:                        if (Strings.StrComp(strkey_list[j], max_str, (CompareMethod)1) == -1)
SRC.NET/Command.cs:                                        if (Strings.Left(fname, 1) == "!")
SRC.NET/Command.cs:                                            fname = Strings.Mid(fname, 2);
SRC.NET/Command.cs:                            string argmidi_name = Strings.Mid(localFeatureData(), Strings.InStr(localFeatureData1(), " ") + 1);
SRC.NET/Command.cs:                            if (Strings.Len(BGM) > 0)
SRC.NET/Command.cs:                            string argmidi_name = Strings.Mid(localFeatureData(), Strings.InStr(localFeatureData1(), " ") + 1);
SRC.NET/Command.cs:                            if (Strings.Len(BGM) > 0)
SRC.NET/Command.cs:                        if (Strings.Len(BGM) > 0)
SRC.NET/Command.cs:                        if (Strings.Len(BGM) > 0)
SRC.NET/Command.cs:                    if (Strings.InStr(fname, "非表示") > 0)
SRC.NET/Command.cs:                    if (Strings.Right(localCondition(), 3) != "付加２" & Strings.Right(localCondition1(), 3) != "強化２")
SRC.NET/Command.cs:                    ftype = Strings.Left(localCondition2(), Strings.Len(localCondition3()) - 3);
SRC.NET/Command.cs:                    if (Strings.InStr(fname, "非表示") > 0)
SRC.NET/Command.cs:                    if (Strings.Right(localCondition4(), 2) != "付加" & Strings.Right(localCondition5(), 2) != "強化")
SRC.NET/Command.cs:                    ftype = Strings.Left(localCondition6(), Strings.Len(localCondition7()) - 2);
SRC.NET/Command.cs:                    if (Strings.InStr(fname, "非表示") > 0)
SRC.NET/Command.cs:                    if (Strings.InStr(fname, "Lv") > 0)
SRC.NET/Command.cs:                        fname0 = Strings.Left(fname, Strings.InStr(fname, "Lv") - 1);
SRC.NET/Command.cs:                    while (i <= Strings.Len(wclass))
SRC.NET/Command.cs:                        if (Strings.Mid(wclass, i, 1) == "Ｍ")
SRC.NET/Command.cs:                            buf = buf + Strings.Mid(wclass, i, 1);
SRC.NET/Command.cs:                        if (Strings.Mid(wclass, i + 1, 1) == "L")
SRC.NET/Command.cs:                            c = Strings.Mid(wclass, i, 1);
SRC.NET/Command.cs:                                c = Strings.Mid(wclass, i, 1);
SRC.NET/Command.cs:                        if (Strings.Len(atype) > 0)
SRC.NET/Command.cs:                            if (Strings.Len(alevel) > 0)
SRC.NET/Command.cs:                                list[Information.UBound(list)] = localRightPaddedString() + atype + "レベル" + Strings.StrConv(alevel, VbStrConv.Wide);
SRC.NET/Command.cs:                    while (i <= Strings.Len(aclass))
SRC.NET/Command.cs:                        if (Strings.Mid(aclass, i, 1) == "Ｍ")
SRC.NET/Command.cs:                            buf = buf + Strings.Mid(aclass, i, 1);
SRC.NET/Command.cs:                        if (Strings.Mid(aclass, i + 1, 1) == "L")
SRC.NET/Command.cs:                            c = Strings.Mid(aclass, i, 1);
SRC.NET/Command.cs:                                c = Strings.Mid(aclass, i, 1);
SRC.NET/Command.cs:                        if (Strings.Len(atype) > 0)
SRC.NET/Command.cs:                            if (Strings.Len(alevel) > 0)
SRC.NET/Command.cs:                                list[Information.UBound(list)] = localRightPaddedString() + atype + "レベル" + Strings.StrConv(alevel, VbStrConv.Wide);
SRC.NET/Command.cs:                if (Strings.InStr(CommandState, "移動後") > 0)
SRC.NET/Command.cs:            if (Strings.InStr(sort_mode, "名称") == 0)
SRC.NET/Command.cs:                        if (Strings.StrComp(strkey_list[j], max_str, (CompareMethod)1) == -1)
SRC.NET/Command.cs:                            if (Strings.Right(mode_list[ret], 2) == "一覧")
SRC.NET/Command.cs:                                uparty = Strings.Left(mode_list[ret], Strings.Len(mode_list[ret]) - 2);
SRC.NET/Command.cs:                            else if (Strings.Right(mode_list[ret], 5) == "で並べ替え")
SRC.NET/Command.cs:                                sort_mode = Strings.Left(mode_list[ret], Strings.Len(mode_list[ret]) - 5);
SRC.NET/Command.cs:                    if (Strings.StrComp(strkey_list[j], max_str, (CompareMethod)1) == -1)
SRC.NET/Command.cs:            var loopTo = (short)Strings.Len(SRC.ScenarioFileName);
SRC.NET/Command.cs:                if (Strings.Mid(SRC.ScenarioFileName, Strings.Len(SRC.ScenarioFileName) - i + 1, 1) == @"\")
SRC.NET/Command.cs:            fname = Strings.Mid(SRC.ScenarioFileName, Strings.Len(SRC.ScenarioFileName) - i + 2, i - 5);
SRC.NET/Command.cs:            if (Strings.InStr(fname, @"\") > 0)
SRC.NET/Command.cs:                save_path = Strings.Left(fname, GeneralLib.InStr2(ref fname, ref argstr2));
SRC.NET/Configuration.cs:            if (Strings.LCase(GeneralLib.ReadIni(ref argini_section, ref argini_entry)) == "on")
SRC.NET/Configuration.cs:            if (Strings.LCase(GeneralLib.ReadIni(ref argini_section1, ref argini_entry1)) == "on")
SRC.NET/Dialog.cs:                if (Strings.Left(pname, 1) == "@")
SRC.NET/Dialog.cs:                    pname = Strings.Mid(pname, 2);
SRC.NET/Dialog.cs:                                    if ((pname ?? "") != (withBlock2.Name ?? "") & Strings.InStr(pname, withBlock2.Name + "(") != 1 & (pname ?? "") != (withBlock2.get_Nickname(false) ?? "") & Strings.InStr(pname, withBlock2.get_Nickname(false) + "(") != 1)
SRC.NET/Dialog.cs:                if (Strings.InStr(pname, "(") > 0)
SRC.NET/Dialog.cs:                        var loopTo2 = (short)Strings.Len(pname);
SRC.NET/Dialog.cs:                            if (Strings.Mid(pname, Strings.Len(pname) - j, 1) == "(")
SRC.NET/Dialog.cs:                                pname2 = Strings.Left(pname, Strings.Len(pname) - j - 1);
SRC.NET/DialogData.cs:                    if ((Strings.Left(strSituation[i], Strings.Len(situations[j])) ?? "") == (situations[j] ?? ""))
SRC.NET/DialogData.cs:                if (Strings.InStr(strSituation[list0[i]], "(対") > 0)
SRC.NET/DialogData.cs:                if (Strings.Len(withBlock.strWeakness) > 0)
SRC.NET/DialogData.cs:                    var loopTo7 = (short)Strings.Len(withBlock.strWeakness);
SRC.NET/DialogData.cs:                        sub_situations[Information.UBound(sub_situations)] = "(対弱点=" + Strings.Mid(withBlock.strWeakness, i, 1) + ")";
SRC.NET/DialogData.cs:                if (Strings.Len(withBlock.strEffective) > 0)
SRC.NET/DialogData.cs:                    var loopTo8 = (short)Strings.Len(withBlock.strEffective);
SRC.NET/DialogData.cs:                        sub_situations[Information.UBound(sub_situations)] = "(対弱点=" + Strings.Mid(withBlock.strEffective, i, 1) + ")";
SRC.NET/DialogData.cs:                if (Strings.InStr(withBlock.MainPilot().Name, "(ザコ)") > 0 & (u.MainPilot().Technique > withBlock.MainPilot().Technique | u.HP > withBlock.HP / 2))
SRC.NET/DialogData.cs:                if (withBlock.BossRank >= 0 | Strings.InStr(withBlock.MainPilot().Name, "(ザコ)") == 0 & u.MainPilot().Technique <= withBlock.MainPilot().Technique)
SRC.NET/DialogData.cs:                    var loopTo9 = (short)Strings.Len(wclass);
SRC.NET/DialogData.cs:                        ch = Strings.Mid(wclass, i, 1);
SRC.NET/DialogData.cs:                if (GeneralLib.Dice(2) == 1 | Strings.InStr(msg_situation, "(とどめ)") > 0 | msg_situation == "挑発" | msg_situation == "脱力" | msg_situation == "魅惑" | msg_situation == "威圧" | (u.Party ?? "") == (t.Party ?? ""))
SRC.NET/DialogDataList.cs:                while (Strings.Len(line_buf) == 0);
SRC.NET/DialogDataList.cs:                pilot_list = Strings.Trim(pilot_list);
SRC.NET/DialogDataList.cs:                while (Strings.Len(line_buf) > 0)
SRC.NET/DialogDataList.cs:                        ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/DialogDataList.cs:                        pname = Strings.Left(line_buf, (int)ret - 1);
SRC.NET/DialogDataList.cs:                        if (Strings.Left(pname, 1) != "@")
SRC.NET/DialogDataList.cs:                        if (Strings.Len(line_buf) == (int)ret)
SRC.NET/DialogDataList.cs:                        msg = Strings.Trim(Strings.Mid(line_buf, (int)ret + 1));
SRC.NET/Effect.cs:            if (Strings.InStr(expr, "戦闘アニメ_") != 1)
SRC.NET/Effect.cs:            if (GUI.IsPictureDrawn & Strings.LCase(buf) != "keep")
SRC.NET/Effect.cs:            if (Strings.Len(Event_Renamed.EventErrorMessage) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ダブル") > 0 | Strings.InStr(wname, "ツイン") > 0 | Strings.InStr(wname, "双") > 0 | Strings.InStr(wname, "二刀") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "高周波") > 0 | Strings.InStr(wname, "電磁") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ライフル") > 0 | Strings.InStr(wname, "バズーカ") > 0 | Strings.Right(wname, 2) == "ガン" | Strings.Right(wname, 1) == "銃" & Strings.Right(wname, 2) != "機銃")
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ハイメガ") > 0 | Strings.InStr(wname, "バスター") > 0 | Strings.InStr(wname, "大") > 0 | Strings.Left(wname, 2) == "ギガ")
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "メガ") > 0 | Strings.InStr(wname, "ハイ") > 0 | Strings.InStr(wname, "バズーカ") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(wname, "ライフル") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ピストル") > 0 | Strings.InStr(wname, "ミニ") > 0 | Strings.InStr(wname, "小") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "弓") > 0 | Strings.InStr(wname, "ショートボウ") > 0 | Strings.InStr(wname, "ロングボウ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "クロスボウ") > 0 | Strings.InStr(wname, "ボウガン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "バズーカ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "サブマシンガン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "マシンガン") > 0 | Strings.InStr(wname, "機関銃") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ヘビー") > 0 | Strings.InStr(wname, "重") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ガトリング") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ピストル") > 0 | Strings.InStr(wname, "拳銃") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "リボルバー") > 0 | Strings.InStr(wname, "リボルヴァー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ショットガン") > 0 | Strings.InStr(wname, "ライアットガン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スーパーガン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スーパーキャノン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ライフル") > 0 | Strings.Right(wname, 1) == "銃" & Strings.Right(wname, 2) != "機銃" | Strings.Right(wname, 2) == "ガン")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "対戦車ライフル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "対物ライフル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "消火器") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "放水") > 0 | Strings.InStr(wname, "放射器") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wtype, "ビームサーベル") > 0 | Strings.InStr(wtype, "ビームカッター") > 0 | wtype == "ビームナイフ" | wtype == "ライトセイバー")
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ビーム") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "プラズマ") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "レーザー") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ライト") > 0)
SRC.NET/Effect.cs:            if (Strings.Len(sname) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ビーム") > 0 | Strings.InStr(wname, "プラズマ") > 0 | Strings.InStr(wname, "レーザー") > 0 | Strings.InStr(wname, "ブラスター") > 0 | Strings.InStr(wname, "ライト") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "サーベル") > 0 | Strings.InStr(wname, "セイバー") > 0 | Strings.InStr(wname, "ブレード") > 0 | Strings.InStr(wname, "ソード") > 0 | Strings.InStr(wname, "剣") > 0 | Strings.InStr(wname, "刀") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(wname, "ハイパー") > 0 | Strings.InStr(wname, "ロング") > 0 | Strings.InStr(wname, "大") > 0 | Strings.InStr(wname, "高") > 0)
SRC.NET/Effect.cs:                    else if (Strings.InStr(wname, "セイバー") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "カッター") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(wname, "ハイパー") > 0 | Strings.InStr(wname, "ロング") > 0 | Strings.InStr(wname, "大") > 0 | Strings.InStr(wname, "高") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ナイフ") > 0 | Strings.InStr(wname, "ダガー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ナイフ") > 0 | Strings.InStr(wname, "ダガー") > 0 | Strings.InStr(wname, "短刀") > 0 | Strings.InStr(wname, "小刀") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "投") > 0 | Strings.InStr(wname, "飛び") > 0 | Strings.Right(wname, 3) == "スロー" | Strings.Right(wname, 3) == "スロウ" | GeneralLib.InStrNotNest(ref wclass, ref argstring2) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ショートソード") > 0 | Strings.InStr(wname, "短剣") > 0 | Strings.InStr(wname, "スモールソード") > 0 | Strings.InStr(wname, "小剣") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "グレートソード") > 0 | Strings.InStr(wname, "大剣") > 0 | Strings.InStr(wname, "ハンデッドソード") > 0 | Strings.InStr(wname, "両手剣") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ロングソード") > 0 | Strings.InStr(wname, "長剣") > 0 | Strings.InStr(wname, "バスタードソード") > 0 | wname == "ソード")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "手裏剣") > 0)
SRC.NET/Effect.cs:            if (Strings.Right(wname, 1) == "剣" & (Strings.Len(wname) <= 3 | Strings.Right(wname, 2) == "の剣"))
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ブラック") > 0 | Strings.InStr(wname, "黒") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ソードブレイカー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "レイピア") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "シミター") > 0 | Strings.InStr(wname, "サーベル") > 0 | Strings.InStr(wname, "カットラス") > 0 | Strings.InStr(wname, "三日月刀") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ショーテル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ナギナタ") > 0 | Strings.InStr(wname, "薙刀") > 0 | Strings.InStr(wname, "グレイブ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "竹刀") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "脇差") > 0 | Strings.InStr(wname, "小太刀") > 0)
SRC.NET/Effect.cs:            if (wname == "刀" | wname == "日本刀" | Strings.InStr(wname, "太刀") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "忍者刀") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "十手") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "青龍刀") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "トマホーク") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "アックス") > 0 | Strings.InStr(wname, "斧") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "グレート") > 0 | Strings.InStr(wname, "両") > 0 | Strings.InStr(wname, "バトル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "サイズ") > 0 | Strings.InStr(wname, "大鎌") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "鎌") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スタッフ") > 0 | Strings.InStr(wname, "杖") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "棍棒") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "警棒") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "鉄パイプ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スタンロッド") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スパナ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "メイス") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "パンチ") > 0 | Strings.InStr(wname, "ナックル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ウォーハンマー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "木槌") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ピコピコハンマー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ハンマー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "槌") > 0)
SRC.NET/Effect.cs:            if (Strings.Right(wname, 3) == "モール")
SRC.NET/Effect.cs:            if (Strings.Right(wname, 2) == "ムチ" | Strings.InStr(wname, "鞭") > 0 | Strings.InStr(wname, "ウィップ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "トンファー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "鉄の爪") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ハルバード") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "モーニングスター") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "フレイル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "鎖鉄球") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "分銅") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ヌンチャク") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "三節棍") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "チェーン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ブーメラン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "チャクラム") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ソーサー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "クナイ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "石") > 0 | Strings.InStr(wname, "礫") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "岩") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "鉄球") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "手榴弾") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ポテトスマッシャー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ダイナマイト") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "爆弾") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "投げ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "火炎瓶") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ネット") > 0 | Strings.InStr(wname, "網") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "手錠") > 0)
SRC.NET/Effect.cs:            if (Strings.Right(wname, 2) == "コマ")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "札") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "リボン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "フープ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "カタログ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "フライパン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "トンボ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "モップ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "唐傘") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "金属バット") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "釘バット") > 0)
SRC.NET/Effect.cs:            if (Strings.Right(wname, 3) == "バット")
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ヘッドバット") == 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "扇子") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ギター") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ハリセン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "トライデント") > 0 | Strings.InStr(wname, "三叉槍") > 0 | Strings.InStr(wname, "ジャベリン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スピア") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "槍") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ランス") > 0 | Strings.InStr(wname, "ランサー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "パイク") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "エストック") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ドリル") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ビーム") > 0 | Strings.InStr(wname, "プラズマ") > 0 | Strings.InStr(wname, "レーザー") > 0 | Strings.InStr(wname, "ブラスター") > 0 | Strings.InStr(wname, "高周波") > 0 | Strings.InStr(wname, "電磁") > 0 | wname == "セイバー" | wname == "ライトセイバー" | wname == "ランサー")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ダブル") > 0 | Strings.InStr(wname, "ツイン") > 0 | Strings.InStr(wname, "デュアル") > 0 | Strings.InStr(wname, "双") > 0 | Strings.InStr(wname, "二刀") > 0 | Strings.InStr(wname, "２連") > 0 | Strings.InStr(wname, "二連") > 0 | Strings.InStr(wname, "連装") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ダブル") > 0 | Strings.InStr(wname, "ツイン") > 0 | Strings.InStr(wname, "コンビネーション") > 0 | Strings.InStr(wname, "コンボ") > 0 | Strings.InStr(wname, "連") > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring2) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "乱打") > 0 | Strings.InStr(wname, "乱舞") > 0 | Strings.InStr(wname, "乱れ") > 0 | Strings.InStr(wname, "百烈") > 0 | Strings.Right(wname, 4) == "ラッシュ" & Strings.InStr(wname, "クラッシュ") == 0 & Strings.InStr(wname, "スラッシュ") == 0 & Strings.InStr(wname, "スプラッシュ") == 0 & Strings.InStr(wname, "フラッシュ") == 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "投") > 0 | Strings.InStr(wname, "飛び") > 0 | Strings.Right(wname, 3) == "スロー" | Strings.Right(wname, 3) == "スロウ" | GeneralLib.InStrNotNest(ref wclass, ref argstring25) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "突撃") > 0 | Strings.InStr(wname, "突進") > 0 | Strings.InStr(wname, "チャージ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "拳法") > 0 | Strings.Right(wname, 2) == "アーツ" | Strings.Right(wname, 5) == "ストライク")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "触手") > 0 | Strings.InStr(wname, "触腕") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "パンチ") > 0 | Strings.InStr(wname, "チョップ") > 0 | Strings.InStr(wname, "ナックル") > 0 | Strings.InStr(wname, "ブロー") > 0 | Strings.InStr(wname, "拳") > 0 | Strings.InStr(wname, "掌") > 0 | Strings.InStr(wname, "打") > 0 | Strings.InStr(wname, "勁") > 0 | Strings.InStr(wname, "殴") > 0 | Strings.Right(wname, 1) == "手" | Strings.Right(wname, 1) == "腕")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "格闘") > 0 | Strings.InStr(wname, "怪力") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "タックル") > 0 | Strings.InStr(wname, "体当") > 0 | Strings.InStr(wname, "チャージ") > 0 | Strings.InStr(wname, "ぶちかまし") > 0 | Strings.InStr(wname, "かみつき") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "キック") > 0 | Strings.InStr(wname, "蹴") > 0 | Strings.InStr(wname, "脚") > 0 | Strings.Right(wname, 1) == "足")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ヘッドバット") > 0 | Strings.InStr(wname, "頭突") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "アッパー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ソード") > 0 | Strings.InStr(wname, "剣") > 0 | Strings.InStr(wname, "ナイフ") > 0 | Strings.InStr(wname, "ダガー") > 0 | Strings.InStr(wname, "シミター") > 0 | Strings.InStr(wname, "サーベル") > 0 | Strings.InStr(wname, "カットラス") > 0 | Strings.InStr(wname, "カッター") > 0 | Strings.Right(wname, 2) == "ムチ" | Strings.InStr(wname, "鞭") > 0 | Strings.InStr(wname, "ウィップ") > 0 | Strings.InStr(wname, "ハンマー") > 0 | Strings.InStr(wname, "ロッド") > 0 | Strings.InStr(wname, "クロー") > 0 | Strings.InStr(wname, "爪") > 0 | Strings.InStr(wname, "ひっかき") > 0 | Strings.InStr(wname, "アーム") > 0 | Strings.Right(wname, 1) == "尾")
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "回転") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "刀") > 0 | Strings.InStr(wname, "斬") > 0 | Strings.InStr(wname, "ブレード") > 0 | Strings.InStr(wname, "刃") > 0 | Strings.InStr(wname, "アックス") > 0 | Strings.InStr(wname, "斧") > 0 | Strings.InStr(wname, "カット") > 0 | Strings.InStr(wname, "カッター") > 0 | Strings.InStr(wname, "スラッシュ") > 0 | Strings.InStr(wname, "居合") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "回転") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ブラック") > 0 | Strings.InStr(wname, "黒") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "サイズ") > 0 | Strings.InStr(wname, "鎌") > 0 | Strings.InStr(wname, "グレイブ") > 0 | Strings.InStr(wname, "ナギナタ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ショーテル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "円月殺法") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "鎖鉄球") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "モーニングスター") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "フレイル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "分銅") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "チェーン") > 0 & Strings.InStr(wname, "チェーンソー") == 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ヌンチャク") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "三節棍") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スピア") > 0 | Strings.InStr(wname, "槍") > 0 | Strings.InStr(wname, "ランス") > 0 | Strings.InStr(wname, "ランサー") > 0 | Strings.InStr(wname, "トライデント") > 0 | Strings.InStr(wname, "ジャベリン") > 0 | Strings.InStr(wname, "レイピア") > 0 | wname == "ロッド")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ドリル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "チェーンソー") > 0)
SRC.NET/Effect.cs:                            else if (Strings.InStr(wname, "回転") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "槍") > 0 | Strings.InStr(wname, "スピア") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ナイフ") > 0 | Strings.InStr(wname, "ダガー") > 0 | Strings.InStr(wname, "クナイ") > 0 | Strings.InStr(wname, "苦無") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "石") > 0 | Strings.InStr(wname, "礫") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "岩") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "鉄球") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ダイナマイト") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "爆弾") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "投げ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ハンドグレネード") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "トマホーク") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "アックス") > 0 | Strings.InStr(wname, "斧") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "グレート") > 0 | Strings.InStr(wname, "両") > 0 | Strings.InStr(wname, "バトル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "サイズ") > 0 | Strings.InStr(wname, "大鎌") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "鎌") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ブーメラン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "チャクラム") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "手裏剣") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "手榴弾") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ポテトマッシャー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "火炎瓶") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "手錠") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "フープ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "扇子") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "札") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "弓") > 0 | Strings.InStr(wname, "ショートボウ") > 0 | Strings.InStr(wname, "ロングボウ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "矢") > 0 | Strings.InStr(wname, "アロー") > 0)
SRC.NET/Effect.cs:            if (Strings.Right(wname, 2) == "ムチ" | Strings.InStr(wname, "鞭") > 0 | Strings.InStr(wname, "ウィップ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "触手") > 0 | Strings.InStr(wname, "触腕") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "鎖鉄球") > 0 | Strings.InStr(wname, "ハンマー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "分銅") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "チェーン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "パンチ") > 0 | Strings.InStr(wname, "ナックル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "クロスボウ") > 0 | Strings.InStr(wname, "ボウガン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "バズーカ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "対戦車ライフル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "対物ライフル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ピストル") > 0 | Strings.InStr(wname, "拳銃") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "リボルバー") > 0 | Strings.InStr(wname, "リボルヴァー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ライフル") > 0 | Strings.Right(wname, 1) == "銃" & Strings.Right(wname, 2) != "機銃")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "サブマシンガン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "マシンガン") > 0 | Strings.InStr(wname, "機関銃") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ヘビー") > 0 | Strings.InStr(wname, "重") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ガトリング") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ショットガン") > 0 | Strings.InStr(wname, "ライアットガン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "レールガン") > 0 | Strings.InStr(wname, "リニアガン") > 0)
SRC.NET/Effect.cs:            if (Strings.Right(wname, 2) == "ガン")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ライフル") > 0 | Strings.InStr(wname, "ガン") > 0 | Strings.InStr(wname, "ピストル") > 0 | Strings.InStr(wname, "バズーカ") > 0 | Strings.Right(wname, 1) == "銃" & Strings.Right(wname, 2) != "機銃")
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ハイメガ") > 0 | Strings.InStr(wname, "バスター") > 0 | Strings.InStr(wname, "大") > 0 | Strings.Left(wname, 2) == "ギガ")
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "メガ") > 0 | Strings.InStr(wname, "ハイ") > 0 | Strings.InStr(wname, "バズーカ") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(wname, "ライフル") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ピストル") > 0 | Strings.InStr(wname, "ミニ") > 0 | Strings.InStr(wname, "小") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ミサイル") > 0 | Strings.InStr(wname, "ロケット") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ドリル") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "大型") > 0 | Strings.InStr(wname, "ビッグ") > 0 | Strings.InStr(wname, "対艦") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "小型") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ランチャー") > 0 | Strings.InStr(wname, "ポッド") > 0 | Strings.InStr(wname, "マイクロ") > 0 | Strings.InStr(wname, "スプレー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "グレネード") > 0 | Strings.InStr(wname, "ディスチャージャー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "シュツルムファウスト") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "爆弾") > 0 | Strings.InStr(wname, "爆撃") > 0 | Strings.InStr(wname, "爆雷") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "光子魚雷") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "怪光線") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "破壊光線") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "消火") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "放水") > 0 | Strings.InStr(wname, "水流") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "水鉄砲") > 0 | Strings.Right(wname, 1) == "液")
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "毒") > 0 | Strings.InStr(wname, "毒") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "重力") > 0 | Strings.InStr(wname, "グラビ") > 0 | Strings.InStr(wname, "ブラックホール") > 0 | Strings.InStr(wname, "縮退") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "落雷") > 0 | Strings.Right(wname, 2) == "稲妻")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "雷") > 0 | Strings.InStr(wname, "ライトニング") > 0 | Strings.InStr(wname, "サンダー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "電撃") > 0 | Strings.InStr(wname, "電流") > 0 | Strings.InStr(wname, "エレクト") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "エネルギー弾") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "泡") > 0 | Strings.InStr(wname, "バブル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "音波") > 0 | Strings.InStr(wname, "サウンド") > 0 | Strings.InStr(wname, "ソニック") > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring217) > 0 & Strings.InStr(wname, "ショック") > 0 | Strings.InStr(wname, "ウェーブ") > 0 | Strings.InStr(wname, "叫び") > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring218) > 0 & Strings.InStr(wname, "咆哮") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "歌") > 0 | Strings.InStr(wname, "ソング") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "針") > 0 | Strings.InStr(wname, "ニードル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "津波") > 0 | Strings.InStr(wname, "ダイダル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "コメット") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "メテオ") > 0 | Strings.InStr(wname, "隕石") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "竜巻") > 0 | Strings.InStr(wname, "渦巻") > 0 | Strings.InStr(wname, "トルネード") > 0 | Strings.InStr(wname, "サイクロン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "つらら") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "つぶて") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "吹雪") > 0 | Strings.InStr(wname, "ブリザード") > 0 | Strings.InStr(wname, "アイスストーム") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ストーム") > 0 | Strings.InStr(wname, "ハリケーン") > 0 | Strings.InStr(wname, "タイフーン") > 0 | Strings.InStr(wname, "台風") > 0 | Strings.InStr(wname, "嵐") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ウィンド") > 0 | Strings.InStr(wname, "ウインド") > 0 | Strings.InStr(wname, "風") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "煙") > 0 | Strings.InStr(wname, "スモーク") > 0 | Strings.Right(wname, 2) == "ガス" | Strings.Right(wname, 1) == "霧" | Strings.InStr(wname, "胞子") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "毒") > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring219) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "火炎弾") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "火炎放射") > 0 | Strings.Right(wname, 2) == "火炎")
SRC.NET/Effect.cs:            if (Strings.Right(wname, 5) == "ファイアー" | Strings.Right(wname, 5) == "ファイヤー" | Strings.Right(wname, 4) == "ファイア" | Strings.Right(wname, 4) == "ファイヤ")
SRC.NET/Effect.cs:                if (GeneralLib.InStrNotNest(ref wclass, ref argstring221) == 0 & Strings.Left(wname, 2) != "フル")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "息") > 0 | Strings.Right(wname, 3) == "ブレス")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "エネルギー波") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "衝撃") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "気弾") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ソニックブレード") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ハイメガ") > 0 | Strings.InStr(wname, "バスター") > 0 | Strings.InStr(wname, "大") > 0 | Strings.Left(wname, 2) == "ギガ")
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "メガ") > 0 | Strings.InStr(wname, "ハイ") > 0)
SRC.NET/Effect.cs:                else if (CountAttack0(ref u, w) >= 4 | Strings.InStr(wname, "対空") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ミニ") > 0 | Strings.InStr(wname, "小") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ランチャー") > 0 | Strings.InStr(wname, "キャノン") > 0 | Strings.InStr(wname, "カノン") > 0 | Strings.InStr(wname, "砲") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "拡散") > 0 | Strings.InStr(wname, "放射") > 0 | Strings.InStr(wname, "ホーミング") > 0 | Strings.InStr(wname, "誘導") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "光線") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "バルカン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "機銃") > 0 | Strings.InStr(wname, "機関砲") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "チェーンガン") > 0 | Strings.InStr(wname, "ガンランチャー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "マシンキャノン") > 0 | Strings.InStr(wname, "オートキャノン") > 0 | Strings.InStr(wname, "速射砲") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ベアリング") > 0 | Strings.InStr(wname, "クレイモア") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "有線") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "砲") > 0 | Strings.InStr(wname, "キャノン") > 0 | Strings.InStr(wname, "カノン") > 0 | Strings.InStr(wname, "弾") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "リニア") > 0 | Strings.InStr(wname, "レール") > 0 | Strings.InStr(wname, "電磁") > 0)
SRC.NET/Effect.cs:                            if (Strings.InStr(wname, "フラッシュ") > 0 | Strings.InStr(wname, "閃光") > 0)
SRC.NET/Effect.cs:                            else if (Strings.InStr(wname, "ダーク") > 0 | Strings.InStr(wname, "闇") > 0)
SRC.NET/Effect.cs:                            else if (Strings.InStr(wname, "地震") > 0 | Strings.InStr(wname, "クウェイク") > 0 | Strings.InStr(wname, "クエイク") > 0)
SRC.NET/Effect.cs:                            else if (Strings.InStr(wname, "核") > 0 | Strings.InStr(wname, "アトミック") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "レッド") > 0 | Strings.InStr(wname, "赤") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ブルー") > 0 | Strings.InStr(wname, "青") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "イエロー") > 0 | Strings.InStr(wname, "黄") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "グリーン") > 0 | Strings.InStr(wname, "緑") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ピンク") > 0 | Strings.InStr(wname, "桃") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ブラウン") > 0 | Strings.InStr(wname, "橙") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ブラック") > 0 | Strings.InStr(wname, "黒") > 0 | Strings.InStr(wname, "ダーク") > 0 | Strings.InStr(wname, "闇") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ホワイト") > 0 | Strings.InStr(wname, "白") > 0 | Strings.InStr(wname, "ホーリー") > 0 | Strings.InStr(wname, "聖") > 0)
SRC.NET/Effect.cs:            if (Strings.Len(wtype0) > 0)
SRC.NET/Effect.cs:                if (Strings.Len(cname0) > 0)
SRC.NET/Effect.cs:                else if (Strings.Len(cname) > 0)
SRC.NET/Effect.cs:                if (Strings.Len(sname0) > 0)
SRC.NET/Effect.cs:            if (Strings.Len(bmpname) > 0)
SRC.NET/Effect.cs:            if (Strings.Len(cname) > 0)
SRC.NET/Effect.cs:            if (Strings.Len(sname) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ビームサーベル") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "銃剣") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "主砲") > 0 | Strings.InStr(wname, "副砲") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "対空砲") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "レーザー") > 0 | Strings.InStr(wname, "光線") > 0 | Strings.InStr(wname, "凝集光") > 0 | Strings.InStr(wname, "熱線") > 0 | Strings.InStr(wname, "冷線") > 0 | Strings.InStr(wname, "衝撃波") > 0 | Strings.InStr(wname, "電磁波") > 0 | Strings.InStr(wname, "電波") > 0 | Strings.InStr(wname, "音波") > 0 | Strings.InStr(wname, "磁力") > 0 | Strings.InStr(wname, "ブラックホール") > 0 | Strings.InStr(wname, "縮退") > 0 | Strings.InStr(wname, "ウェーブ") > 0 | Strings.InStr(wname, "波動") > 0 | Strings.InStr(wname, "ソニック") > 0 | Strings.InStr(wname, "スパーク") > 0 | Strings.InStr(wname, "エネルギー") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "粒子") > 0 | Strings.InStr(wname, "陽電子") > 0 | Strings.InStr(wname, "陽子") > 0 | Strings.InStr(wname, "ブラスター") > 0 | Strings.InStr(wname, "ブラスト") > 0 | Strings.InStr(wname, "フェイザー") > 0 | Strings.InStr(wname, "ディスラプター") > 0 | Strings.InStr(wname, "スマッシャー") > 0 | Strings.InStr(wname, "スラッシャー") > 0 | Strings.InStr(wname, "フラッシャー") > 0 | Strings.InStr(wname, "ディバイダー") > 0 | Strings.InStr(wname, "ドライバー") > 0 | Strings.InStr(wname, "シュトラール") > 0 | Strings.InStr(wname, "ニュートロン") > 0 | Strings.InStr(wname, "プラズマ") > 0 | Strings.InStr(wname, "イオン") > 0 | Strings.InStr(wname, "プロミネンス") > 0 | Strings.InStr(wname, "ハイドロ") > 0 | Strings.InStr(wname, "インパルス") > 0 | Strings.InStr(wname, "フレイム") > 0 | Strings.InStr(wname, "サンシャイン") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "シューター") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ビーム") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "バルカン") > 0 | Strings.InStr(wname, "マシンガン") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "機関銃") > 0 | Strings.InStr(wname, "機銃") > 0 | Strings.InStr(wname, "マシンガン") > 0 | Strings.InStr(wname, "アサルトライフル") > 0 | Strings.InStr(wname, "チェーンライフル") > 0 | Strings.InStr(wname, "パレットライフル") > 0 | Strings.InStr(wname, "マウラー砲") > 0 | Strings.InStr(wname, "ＳＭＧ") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "機関砲") > 0 | Strings.InStr(wname, "速射砲") > 0 | Strings.InStr(wname, "マシンキャノン") > 0 | Strings.InStr(wname, "モーターカノン") > 0 | Strings.InStr(wname, "ガンクラスター") > 0 | Strings.InStr(wname, "チェーンガン") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ガンポッド") > 0 | Strings.InStr(wname, "バルカン") > 0 | Strings.InStr(wname, "ガトリング") > 0 | Strings.InStr(wname, "ハンドレールガン") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "リニアキャノン") > 0 | Strings.InStr(wname, "レールキャノン") > 0 | Strings.InStr(wname, "リニアカノン") > 0 | Strings.InStr(wname, "レールカノン") > 0 | Strings.InStr(wname, "リニアガン") > 0 | Strings.InStr(wname, "レールガン") > 0 | Strings.InStr(wname, "電磁") > 0 & Strings.InStr(wname, "砲") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ライフル") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "バズーカ") > 0 | Strings.InStr(wname, "ジャイアントバズ") > 0 | Strings.InStr(wname, "シュツルムファウスト") > 0 | Strings.InStr(wname, "グレネード") > 0 | Strings.InStr(wname, "グレネイド") > 0 | Strings.InStr(wname, "ナパーム") > 0 | Strings.InStr(wname, "クレイモア") > 0 | Strings.InStr(wname, "ロケット砲") > 0 | Strings.InStr(wname, "迫撃砲") > 0 | Strings.InStr(wname, "無反動砲") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "自動砲") > 0 | Strings.InStr(wname, "オートキャノン") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "弓") > 0 | Strings.InStr(wname, "アロー") > 0 | Strings.InStr(wname, "ボーガン") > 0 | Strings.InStr(wname, "ボウガン") > 0 | Strings.InStr(wname, "ロングボウ") > 0 | Strings.InStr(wname, "ショートボウ") > 0 | Strings.InStr(wname, "針") > 0 | Strings.InStr(wname, "髪") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "マイン") > 0 | Strings.InStr(wname, "クラッカー") > 0 | Strings.InStr(wname, "手投弾") > 0 | Strings.InStr(wname, "手榴弾") > 0 | Strings.InStr(wname, "投げ") > 0 | Strings.InStr(wname, "スリング") > 0 | Strings.InStr(wname, "手裏剣") > 0 | Strings.InStr(wname, "苦無") > 0 | Strings.InStr(wname, "クナイ") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "爆弾") > 0 | Strings.InStr(wname, "爆雷") > 0 | Strings.InStr(wname, "爆撃") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "機雷") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "マイクロミサイル") > 0 & GeneralLib.InStrNotNest(ref wclass, ref argstring217) > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "全方位ミサイル") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ミサイル") > 0 | Strings.InStr(wname, "ロケット") > 0 | Strings.InStr(wname, "魚雷") > 0 | Strings.InStr(wname, "反応弾") > 0 | Strings.InStr(wname, "マルチポッド") > 0 | Strings.InStr(wname, "マルチランチャー") > 0 | Strings.InStr(wname, "ショット") > 0 | Strings.InStr(wname, "フルファイア") > 0 | Strings.InStr(wname, "ストリーム") > 0 | Strings.InStr(wname, "ナックル") > 0 | Strings.InStr(wname, "パンチ") > 0 | Strings.InStr(wname, "鉄腕") > 0 | Strings.InStr(wname, "発射") > 0 | Strings.InStr(wname, "射出") > 0 | Strings.InStr(wname, "ランチャー") > 0 | Strings.InStr(wname, "ＡＴＭ") > 0 | Strings.InStr(wname, "ＡＡＭ") > 0 | Strings.InStr(wname, "ＡＧＭ") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "砲") > 0 | Strings.InStr(wname, "弾") > 0 | Strings.InStr(wname, "キャノン") > 0 | Strings.InStr(wname, "カノン") > 0 | Strings.InStr(wname, "ボム") > 0 | Strings.InStr(wname, "火球") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ガン") > 0 | Strings.InStr(wname, "ピストル") > 0 | Strings.InStr(wname, "リボルヴァー") > 0 | Strings.InStr(wname, "マグナム") > 0 | Strings.InStr(wname, "ライアット") > 0 | Strings.InStr(wname, "銃") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ソニックブレード") > 0 | Strings.InStr(wname, "ビームカッター") > 0 | Strings.InStr(wname, "スライサー") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "重力") > 0 | Strings.InStr(wname, "グラビ") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ストーム") > 0 | Strings.InStr(wname, "トルネード") > 0 | Strings.InStr(wname, "ハリケーン") > 0 | Strings.InStr(wname, "タイフーン") > 0 | Strings.InStr(wname, "サイクロン") > 0 | Strings.InStr(wname, "ブリザード") > 0 | Strings.InStr(wname, "竜巻") > 0 | Strings.InStr(wname, "渦巻") > 0 | Strings.InStr(wname, "台風") > 0 | Strings.InStr(wname, "嵐") > 0 | Strings.InStr(wname, "吹雪") > 0 | Strings.InStr(wname, "フリーザー") > 0 | Strings.InStr(wname, "テレキネシス") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ブーメラン") > 0 | Strings.InStr(wname, "ウェッブ") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "サンダー") > 0 | Strings.InStr(wname, "ライトニング") > 0 | Strings.InStr(wname, "ボルト") > 0 | Strings.InStr(wname, "稲妻") > 0 | Strings.InStr(wname, "放電") > 0 | Strings.InStr(wname, "電撃") > 0 | Strings.InStr(wname, "電流") > 0 | Strings.InStr(wname, "雷") > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring218) > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "火炎放射") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "火炎") > 0 | Strings.InStr(wname, "焔") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "魔法") > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring219) > 0 | Strings.InStr(wname, "サイコキネシス") > 0 | Strings.InStr(wname, "糸") > 0 | Strings.InStr(wname, "アンカー") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "泡") > 0 | Strings.InStr(wname, "バブル") > 0)
SRC.NET/Effect.cs:            else if (Strings.Right(wname, 1) == "液")
SRC.NET/Effect.cs:            else if (Strings.Right(wname, 3) == "ブレス" | Strings.Right(wname, 3) == "の息")
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "一斉射撃") > 0)
SRC.NET/Effect.cs:                if (IsBeamWeapon(ref wname, wclass, ref cname) | Strings.InStr(wname, "ミサイル") > 0 | Strings.InStr(wname, "ロケット") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ダブル") > 0 | Strings.InStr(wname, "ツイン") > 0 | Strings.InStr(wname, "デュアル") > 0 | Strings.InStr(wname, "双") > 0 | Strings.InStr(wname, "二刀") > 0 | Strings.InStr(wname, "２連") > 0 | Strings.InStr(wname, "二連") > 0 | Strings.InStr(wname, "連装") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ダブル") > 0 | Strings.InStr(wname, "ツイン") > 0 | Strings.InStr(wname, "コンビネーション") > 0 | Strings.InStr(wname, "連") > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring21) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "乱打") > 0 | Strings.InStr(wname, "乱舞") > 0 | Strings.InStr(wname, "乱れ") > 0 | Strings.InStr(wname, "百烈") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "突撃") > 0 | Strings.InStr(wname, "突進") > 0 | Strings.InStr(wname, "チャージ") > 0)
SRC.NET/Effect.cs:            if (GeneralLib.InStrNotNest(ref wclass, ref argstring27) > 0 & (Strings.InStr(wname, "パンチ") > 0 | Strings.InStr(wname, "ナックル") > 0))
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "拳法") > 0 | Strings.Right(wname, 2) == "アーツ" | Strings.Right(wname, 5) == "ストライク")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "パンチ") > 0 | Strings.InStr(wname, "ナックル") > 0 | Strings.InStr(wname, "ブロー") > 0 | Strings.InStr(wname, "チョップ") > 0 | Strings.InStr(wname, "ビンタ") > 0 | Strings.InStr(wname, "殴") > 0 | Strings.Right(wname, 1) == "手" | Strings.Right(wname, 1) == "腕" | Strings.InStr(wname, "格闘") > 0 | Strings.InStr(wname, "トンファー") > 0 | Strings.InStr(wname, "棒") > 0 | Strings.InStr(wname, "杖") > 0 | Strings.InStr(wname, "スタッフ") > 0 | Strings.InStr(wname, "メイス") > 0 | Strings.Right(wname, 2) == "ムチ" | Strings.InStr(wname, "鞭") > 0 | Strings.InStr(wname, "ウィップ") > 0 | Strings.InStr(wname, "チェーン") > 0 | Strings.InStr(wname, "ロッド") > 0 | Strings.InStr(wname, "モーニングスター") > 0 | Strings.InStr(wname, "フレイル") > 0 | Strings.InStr(wname, "ヌンチャク") > 0 | Strings.InStr(wname, "三節根") > 0 | Strings.InStr(wname, "チェーン") > 0 & Strings.InStr(wname, "チェーンソー") == 0 | Strings.InStr(wname, "バット") > 0 | Strings.InStr(wname, "ギター") > 0 | Strings.InStr(wname, "竹刀") > 0 | Strings.InStr(wname, "ハリセン") > 0)
SRC.NET/Effect.cs:                else if (double_attack | Strings.InStr(wname, "触手") > 0 | Strings.InStr(wname, "触腕") > 0)
SRC.NET/Effect.cs:                if (Strings.Right(wname, 2) == "ムチ" | Strings.InStr(wname, "鞭") > 0 | Strings.InStr(wname, "ウィップ") > 0 | Strings.InStr(wname, "チェーン") > 0 | Strings.InStr(wname, "触手") > 0 | Strings.InStr(wname, "触腕") > 0 | Strings.InStr(wname, "ロッド") > 0 & wname != "ロッド" | Strings.InStr(wname, "竹刀") > 0 | Strings.InStr(wname, "ハリセン") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "張り手") > 0 | Strings.InStr(wname, "平手") > 0 | Strings.InStr(wname, "ビンタ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "拳") > 0 | Strings.InStr(wname, "掌") > 0 | Strings.InStr(wname, "打") > 0 | Strings.InStr(wname, "勁") > 0 | Strings.InStr(wname, "ラリアート") > 0 | Strings.InStr(wname, "キック") > 0 | Strings.InStr(wname, "蹴") > 0 | Strings.InStr(wname, "脚") > 0 | Strings.Right(wname, 1) == "足" | Strings.InStr(wname, "ヘッドバッド") > 0 | Strings.InStr(wname, "頭突") > 0 | Strings.InStr(wname, "ハンマー") > 0 | Strings.InStr(wname, "槌") > 0 | Strings.InStr(wname, "モール") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "拳") > 0 | Strings.InStr(wname, "掌") > 0 | Strings.InStr(wname, "打") > 0 | Strings.InStr(wname, "勁") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "アッパー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "タックル") > 0 | Strings.InStr(wname, "体当") > 0 | Strings.InStr(wname, "チャージ") > 0 | Strings.InStr(wname, "ぶちかまし") > 0 | Strings.InStr(wname, "バンカー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "バンカー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "怪力") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "格闘") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ビーム") > 0 | Strings.InStr(wname, "プラズマ") > 0 | Strings.InStr(wname, "レーザー") > 0 | Strings.InStr(wname, "ブラスター") > 0 | Strings.InStr(wname, "ライト") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "プラズマ") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "レーザー") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ライト") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "サーベル") > 0 | Strings.InStr(wname, "セイバー") > 0 | Strings.InStr(wname, "ブレード") > 0 | Strings.InStr(wname, "ソード") > 0 | Strings.InStr(wname, "剣") > 0 | Strings.InStr(wname, "刀") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(wname, "ハイパー") > 0 | Strings.InStr(wname, "ロング") > 0 | Strings.InStr(wname, "大") > 0 | Strings.InStr(wname, "高") > 0)
SRC.NET/Effect.cs:                    else if (Strings.InStr(wname, "回転") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "カッター") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(wname, "ハイパー") > 0 | Strings.InStr(wname, "ロング") > 0 | Strings.InStr(wname, "大") > 0 | Strings.InStr(wname, "高") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ナイフ") > 0 | Strings.InStr(wname, "ダガー") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ナギナタ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ソード") > 0 | Strings.InStr(wname, "剣") > 0 | Strings.InStr(wname, "ナイフ") > 0 | Strings.InStr(wname, "ダガー") > 0 | Strings.InStr(wname, "シミター") > 0 | Strings.InStr(wname, "サーベル") > 0 | Strings.InStr(wname, "カットラス") > 0 | Strings.InStr(wname, "刀") > 0 | Strings.InStr(wname, "斬") > 0 | Strings.InStr(wname, "ブレード") > 0 | Strings.InStr(wname, "刃") > 0 | Strings.InStr(wname, "アックス") > 0 | Strings.InStr(wname, "斧") > 0 | Strings.InStr(wname, "グレイブ") > 0 | Strings.InStr(wname, "ナギナタ") > 0 | Strings.InStr(wname, "切") > 0 | Strings.InStr(wname, "裂") > 0 | Strings.InStr(wname, "カット") > 0 | Strings.InStr(wname, "カッター") > 0 | Strings.InStr(wname, "スラッシュ") > 0 | Strings.InStr(wname, "居合") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "唐竹割") > 0 | Strings.InStr(wname, "縦") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "居合") > 0 | Strings.InStr(wname, "横") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "斬") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "黒") > 0 | Strings.InStr(wname, "闇") > 0 | Strings.InStr(wname, "死") > 0 | Strings.InStr(wname, "ダーク") > 0 | Strings.InStr(wname, "デス") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ショーテル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スピア") > 0 | Strings.InStr(wname, "槍") > 0 | Strings.InStr(wname, "ランス") > 0 | Strings.InStr(wname, "ランサー") > 0 | Strings.InStr(wname, "トライデント") > 0 | Strings.InStr(wname, "ジャベリン") > 0 | Strings.InStr(wname, "レイピア") > 0 | wname == "ロッド")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "爪") > 0 | Strings.InStr(wname, "クロー") > 0 | Strings.InStr(wname, "ひっかき") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "アーム") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "噛") > 0 | Strings.InStr(wname, "牙") > 0 | Strings.InStr(wname, "かみつき") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ドリル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "リボン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スープレックス") > 0 | Strings.InStr(wname, "投げ") > 0 | wname == "返し")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ヒールホールド") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ブリーカー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "固め") > 0 | Strings.InStr(wname, "ホールド") > 0 | Strings.InStr(wname, "ツイスト") > 0 | Strings.InStr(wname, "絞め") > 0 | Strings.InStr(wname, "締め") > 0 | Strings.InStr(wname, "折り") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ジャイアントスイング") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "地獄車") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ブレーンバスター") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スクリューバックドライバー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スクリュードライバー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "バックドライバー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ドライバー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "踏み") > 0 | Strings.InStr(wname, "押し") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "斧") > 0 | Strings.InStr(wname, "アックス") > 0 | Strings.InStr(wname, "トマホーク") > 0 | Strings.InStr(wname, "ソーサー") > 0 | Strings.InStr(wname, "チャクラム") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "パンチ") > 0 | Strings.InStr(wname, "ハンマー") > 0 | Strings.InStr(wname, "岩") > 0 | Strings.InStr(wname, "鉄球") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "石") > 0 | Strings.InStr(wname, "礫") > 0 | Strings.InStr(wname, "分銅") > 0 | Strings.InStr(wname, "ブーメラン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ナイフ") > 0 | Strings.InStr(wname, "ダガー") > 0 | Strings.InStr(wname, "手裏剣") > 0 | Strings.InStr(wname, "クナイ") > 0 | Strings.InStr(wname, "苦無") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "弓") > 0 | Strings.InStr(wname, "ショートボウ") > 0 | Strings.InStr(wname, "ロングボウ") > 0 | Strings.InStr(wname, "ボウガン") > 0 | Strings.InStr(wname, "矢") > 0 | Strings.InStr(wname, "アロー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "バルカン") > 0)
SRC.NET/Effect.cs:            if (Conversions.ToBoolean(Conversions.ToInteger(Strings.InStr(wname, "ガトリング") > 0) | Strings.InStr(wname, "チェーンガン") | Strings.InStr(wname, "ガンランチャー")))
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "マシンガン") > 0 | Strings.InStr(wname, "機関銃") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ヘビー") > 0 | Strings.InStr(wname, "重") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "機銃") > 0 | Strings.InStr(wname, "機関砲") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "マシンキャノン") > 0 | Strings.InStr(wname, "オートキャノン") > 0 | Strings.InStr(wname, "速射砲") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ショットガン") > 0 | Strings.InStr(wname, "散弾") > 0 | Strings.InStr(wname, "拡散バズーカ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ベアリング") > 0 | Strings.InStr(wname, "クレイモア") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "怪光線") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "破壊光線") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(CurrentWeaponType, "ビーム") > 0 | Strings.InStr(CurrentWeaponType, "レーザー") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(wname, "ハイメガ") > 0 | Strings.InStr(wname, "バスター") > 0 | Strings.InStr(wname, "大") > 0 | Strings.Left(wname, 2) == "ギガ")
SRC.NET/Effect.cs:                    else if (Strings.InStr(wname, "メガ") > 0 | Strings.InStr(wname, "ハイ") > 0 | Strings.InStr(wname, "バズーカ") > 0)
SRC.NET/Effect.cs:                    else if (CountAttack0(ref u, w) >= 4 | Strings.InStr(wname, "対空") > 0)
SRC.NET/Effect.cs:                    else if (Strings.InStr(wname, "ピストル") > 0 | Strings.InStr(wname, "ミニ") > 0 | Strings.InStr(wname, "小") > 0)
SRC.NET/Effect.cs:                    else if (Strings.InStr(wname, "ランチャー") > 0 | Strings.InStr(wname, "キャノン") > 0 | Strings.InStr(wname, "カノン") > 0 | Strings.InStr(wname, "砲") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(wname, "拡散") > 0 | Strings.InStr(wname, "放射") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(wname, "ホーミング") > 0 | Strings.InStr(wname, "誘導") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "光線") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ピストル") > 0 | Strings.InStr(wname, "拳銃") > 0 | Strings.InStr(wname, "リボルバー") > 0 | Strings.InStr(wname, "リボルヴァー") > 0 | Strings.InStr(wname, "銃") > 0 | Strings.Right(wname, 2) == "ガン" | Strings.InStr(wname, "ライフル") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "爆雷") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "爆撃") > 0 | CurrentWeaponType == "投下爆弾")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ミサイル") > 0 | Strings.InStr(wname, "ロケット") > 0 | Strings.InStr(wname, "爆弾") > 0 | Strings.InStr(wname, "ダイナマイト") > 0 | Strings.InStr(wname, "榴弾") > 0 | Strings.InStr(wname, "反応弾") > 0 | Strings.InStr(wname, "グレネード") > 0 | Strings.InStr(wname, "手榴弾") > 0 | Strings.InStr(wname, "クラッカー") > 0 | Strings.InStr(wname, "ディスチャージャー") > 0 | Strings.InStr(wname, "マイン") > 0 | Strings.InStr(wname, "ボム") > 0 | Strings.InStr(wname, "魚雷") > 0 | Strings.InStr(wname, "機雷") > 0 | Strings.InStr(wname, "バズーカ") > 0 | Strings.InStr(wname, "シュツルムファウスト") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "核") > 0 | Strings.InStr(wname, "反応") > 0 | Strings.InStr(wname, "アトミック") > 0 | Strings.InStr(wname, "超") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "大") > 0 | Strings.InStr(wname, "ビック") > 0 | Strings.InStr(wname, "ジャイアント") > 0 | Strings.InStr(wname, "メガ") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "小") > 0 | Strings.InStr(wname, "ミニ") > 0 | Strings.InStr(wname, "マイクロ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "電撃") > 0 | Strings.InStr(wname, "電流") > 0 | Strings.InStr(wname, "エレクト") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "雷") > 0 | Strings.InStr(wname, "ライトニング") > 0 | Strings.InStr(wname, "サンダー") > 0 | Strings.Right(wname, 2) == "稲妻" | GeneralLib.InStrNotNest(ref wclass, ref argstring221) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "吹雪") > 0 | Strings.InStr(wname, "ブリザード") > 0 | Strings.InStr(wname, "アイスストーム") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ストーム") > 0 | Strings.InStr(wname, "ハリケーン") > 0 | Strings.InStr(wname, "タイフーン") > 0 | Strings.InStr(wname, "台風") > 0 | Strings.InStr(wname, "嵐") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ウィンド") > 0 | Strings.InStr(wname, "ウインド") > 0 | Strings.InStr(wname, "風") > 0)
SRC.NET/Effect.cs:            if (Conversions.ToBoolean(Conversions.ToInteger(Strings.InStr(wname, "トルネード") > 0) | Strings.InStr(wname, "サイクロン") | Conversions.ToInteger(Strings.InStr(wname, "竜巻") > 0) | Conversions.ToInteger(Strings.InStr(wname, "渦巻") > 0)))
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "泡") > 0 | Strings.InStr(wname, "バブル") > 0 | Strings.InStr(wname, "消火") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "重力") > 0 | Strings.InStr(wname, "グラビ") > 0 | Strings.InStr(wname, "ブラックホール") > 0 | Strings.InStr(wname, "縮退") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "スロウ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "煙") > 0 | Strings.InStr(wname, "スモーク") > 0 | Strings.Right(wname, 2) == "ガス" | Strings.Right(wname, 1) == "霧" | Strings.InStr(wname, "胞子") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "毒") > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring222) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "火炎弾") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "火炎放射") > 0 | Strings.Right(wname, 2) == "火炎")
SRC.NET/Effect.cs:            if (Strings.Right(wname, 5) == "ファイアー" | Strings.Right(wname, 5) == "ファイヤー" | Strings.Right(wname, 4) == "ファイア" | Strings.Right(wname, 4) == "ファイヤ")
SRC.NET/Effect.cs:                if (GeneralLib.InStrNotNest(ref wclass, ref argstring224) == 0 & Strings.Left(wname, 2) != "フル")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "息") > 0 | Strings.Right(wname, 3) == "ブレス")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "火") > 0 | Strings.InStr(wname, "炎") > 0 | Strings.InStr(wname, "焔") > 0 | Strings.InStr(wname, "ファイヤー") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "水鉄砲") > 0 | Strings.InStr(wname, "放水") > 0 | Strings.InStr(wname, "水流") > 0 | Strings.InStr(wname, "酸かけ") > 0 | Strings.Right(wname, 1) == "液" | Strings.Right(wname, 1) == "酸")
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "毒") > 0 | Strings.InStr(wname, "毒") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "酸") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "吸収") > 0 | Strings.InStr(wname, "ドレイン") > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring226) > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring227) > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "レッド") > 0 | Strings.InStr(wname, "赤") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ブルー") > 0 | Strings.InStr(wname, "青") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "イエロー") > 0 | Strings.InStr(wname, "黄") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "グリーン") > 0 | Strings.InStr(wname, "緑") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ピンク") > 0 | Strings.InStr(wname, "桃") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ブラウン") > 0 | Strings.InStr(wname, "橙") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ブラック") > 0 | Strings.InStr(wname, "黒") > 0 | Strings.InStr(wname, "ダーク") > 0 | Strings.InStr(wname, "闇") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "ホワイト") > 0 | Strings.InStr(wname, "白") > 0 | Strings.InStr(wname, "ホーリー") > 0 | Strings.InStr(wname, "聖") > 0)
SRC.NET/Effect.cs:            if (Strings.Len(wtype0) > 0)
SRC.NET/Effect.cs:                if (Strings.Len(cname) > 0)
SRC.NET/Effect.cs:            if (Strings.Len(cname) > 0)
SRC.NET/Effect.cs:            if (Strings.Len(sname) > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ディスカッター") > 0 | Strings.InStr(wname, "リッパー") > 0 | Strings.InStr(wname, "スパイド") > 0 | Strings.InStr(wname, "居合") > 0 | Strings.InStr(wname, "閃") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "プログレッシブナイフ") > 0 | Strings.InStr(wname, "ドリル") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "サーベル") > 0 | Strings.InStr(wname, "セイバー") > 0 | Strings.InStr(wname, "ソード") > 0 | Strings.InStr(wname, "ブレード") > 0 | Strings.InStr(wname, "スパッド") > 0 | Strings.InStr(wname, "セーバー") > 0 | Strings.InStr(wname, "ダガー") > 0 | Strings.InStr(wname, "ナイフ") > 0 | Strings.InStr(wname, "トマホーク") > 0 | Strings.InStr(wname, "メイス") > 0 | Strings.InStr(wname, "アックス") > 0 | Strings.InStr(wname, "グレイブ") > 0 | Strings.InStr(wname, "ナギナタ") > 0 | Strings.InStr(wname, "ビアンキ") > 0 | Strings.InStr(wname, "ウェッブ") > 0 | Strings.InStr(wname, "ザンバー") > 0 | Strings.InStr(wname, "マーカー") > 0 | Strings.InStr(wname, "バスター") > 0 | Strings.InStr(wname, "ブラスター") > 0 | Strings.InStr(wname, "クロー") > 0 | Strings.InStr(wname, "ジザース") > 0 | Strings.InStr(wname, "ブーメラン") > 0 | Strings.InStr(wname, "ソーサー") > 0 | Strings.InStr(wname, "レザー") > 0 | Strings.InStr(wname, "レイバー") > 0 | Strings.InStr(wname, "サイズ") > 0 | Strings.InStr(wname, "ショーテル") > 0 | Strings.InStr(wname, "カッター") > 0 | Strings.InStr(wname, "スパイク") > 0 | Strings.InStr(wname, "カトラス") > 0 | Strings.InStr(wname, "エッジ") > 0 | Strings.InStr(wname, "剣") > 0 & Strings.InStr(wname, "手裏剣") == 0 | Strings.InStr(wname, "切") > 0 | Strings.InStr(wname, "斬") > 0 | Strings.InStr(wname, "刀") > 0 | Strings.InStr(wname, "刃") > 0 | Strings.InStr(wname, "斧") > 0 | Strings.InStr(wname, "鎌") > 0 | Strings.InStr(wname, "かま") > 0 | Strings.InStr(wname, "カマ") > 0 | Strings.InStr(wname, "爪") > 0 | Strings.InStr(wname, "かぎづめ") > 0 | Strings.InStr(wname, "ハサミ") > 0 | Strings.InStr(wname, "バサミ") > 0 | Strings.InStr(wname, "羽") > 0)
SRC.NET/Effect.cs:                    if (!t.IsHero() | Strings.InStr(wname, "ビーム") > 0 | Strings.InStr(wname, "プラズマ") > 0 | Strings.InStr(wname, "レーザー") > 0 | Strings.InStr(wname, "セイバー") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ランサー") > 0 | Strings.InStr(wname, "ランス") > 0 | Strings.InStr(wname, "スピア") > 0 | Strings.InStr(wname, "トライデント") > 0 | Strings.InStr(wname, "ハーケン") > 0 | Strings.InStr(wname, "槍") > 0 | Strings.InStr(wname, "もり") > 0 | Strings.InStr(wname, "手裏剣") > 0 | Strings.InStr(wname, "苦無") > 0 | Strings.InStr(wname, "クナイ") > 0 | Strings.InStr(wname, "突き") > 0 & Strings.InStr(wname, "拳") == 0 & Strings.InStr(wname, "頭") == 0)
SRC.NET/Effect.cs:                    if (!t.IsHero() | Strings.InStr(wname, "ビーム") > 0 | Strings.InStr(wname, "プラズマ") > 0 | Strings.InStr(wname, "レーザー") > 0 | Strings.InStr(wname, "ランサー") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "牙") > 0 | Strings.InStr(wname, "ファング") > 0 | Strings.InStr(wname, "噛") > 0 | Strings.InStr(wname, "かみつき") > 0 | Strings.InStr(wname, "顎") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ストライク") > 0 | Strings.InStr(wname, "アーツ") > 0 | Strings.InStr(wname, "拳法") > 0 | Strings.InStr(wname, "振動拳") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "格闘") > 0 | Strings.InStr(wname, "パンチ") > 0 | Strings.InStr(wname, "キック") > 0 | Strings.InStr(wname, "チョップ") > 0 | Strings.InStr(wname, "ナックル") > 0 | Strings.InStr(wname, "ブロー") > 0 | Strings.InStr(wname, "ハンマー") > 0 | Strings.InStr(wname, "トンファー") > 0 | Strings.InStr(wname, "ヌンチャク") > 0 | Strings.InStr(wname, "パイプ") > 0 | Strings.InStr(wname, "ラリアット") > 0 | Strings.InStr(wname, "アーム") > 0 | Strings.InStr(wname, "ヘッドバット") > 0 | Strings.InStr(wname, "スリング") > 0 | Strings.InStr(wname, "頭突き") > 0 | Strings.InStr(wname, "脚") > 0 | Strings.InStr(wname, "蹴") > 0 | Strings.InStr(wname, "棒") > 0 | Strings.InStr(wname, "石") > 0 | Strings.InStr(wname, "角") > 0 | Strings.InStr(wname, "尻尾") > 0 | Strings.InStr(wname, "鉄腕") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "体当たり") > 0 | Strings.InStr(wname, "タックル") > 0 | Strings.InStr(wname, "ぶちかまし") > 0 | Strings.InStr(wname, "突進") > 0 | Strings.InStr(wname, "突撃") > 0 | Strings.InStr(wname, "怪力") > 0 | Strings.InStr(wname, "鉄拳") > 0 | Strings.InStr(wname, "メガトンパンチ") > 0 | Strings.InStr(wname, "鉄球") > 0 | Strings.InStr(wname, "ボール") > 0 | Strings.InStr(wname, "車輪") > 0 | Strings.InStr(wname, "キャタピラ") > 0 | Strings.InStr(wname, "シールド") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "拳") > 0 | Strings.InStr(wname, "掌") > 0 | Strings.InStr(wname, "打") > 0 | Strings.InStr(wname, "勁") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "踏み") > 0 | Strings.InStr(wname, "押し") > 0 | Strings.InStr(wname, "ドロップ") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "張り手") > 0 | Strings.InStr(wname, "ビンタ") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "弓") > 0 | Strings.InStr(wname, "矢") > 0 | Strings.InStr(wname, "アロー") > 0 | Strings.InStr(wname, "ボーガン") > 0 | Strings.InStr(wname, "ボウガン") > 0 | Strings.InStr(wname, "ショートボウ") > 0 | Strings.InStr(wname, "ロングボウ") > 0 | Strings.InStr(wname, "針") > 0 | Strings.InStr(wname, "ニードル") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "鞭") > 0 | Strings.InStr(wname, "ムチ") > 0 | Strings.InStr(wname, "ウイップ") > 0 | Strings.InStr(wname, "チェーン") > 0 | Strings.InStr(wname, "ロッド") > 0 | Strings.InStr(wname, "テンタク") > 0 | Strings.InStr(wname, "テイル") > 0 | Strings.InStr(wname, "尾") > 0 | Strings.InStr(wname, "触手") > 0 | Strings.InStr(wname, "触腕") > 0 | Strings.InStr(wname, "舌") > 0 | Strings.InStr(wname, "巻き") > 0 | Strings.InStr(wname, "糸") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "投げ") > 0 | Strings.InStr(wname, "スープレック") > 0 | Strings.InStr(wname, "返し") > 0 & GeneralLib.InStrNotNest(ref wclass, ref argstring2) > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "大雪山おろし") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "関節") > 0 | Strings.InStr(wname, "固め") > 0 | Strings.InStr(wname, "折り") > 0 | Strings.InStr(wname, "締め") > 0 | Strings.InStr(wname, "絞め") > 0 | Strings.InStr(wname, "アームロック") > 0 | Strings.InStr(wname, "ホールド") > 0)
SRC.NET/Effect.cs:                else if (GeneralLib.InStrNotNest(ref wclass, ref argstring21) > 0 | Strings.InStr(wname, "核") > 0 | Strings.InStr(wname, "反応弾") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "ミサイル") > 0 | Strings.InStr(wname, "ロケット") > 0 | Strings.InStr(wname, "魚雷") > 0 | Strings.InStr(wname, "マルチポッド") > 0 | Strings.InStr(wname, "マルチランチャー") > 0 | Strings.InStr(wname, "爆弾") > 0 | Strings.InStr(wname, "爆雷") > 0 | Strings.InStr(wname, "爆撃") > 0 | Strings.Right(wname, 3) == "マイン" | Strings.Right(wname, 2) == "ボム")
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "アンカー") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "ストーム") > 0 | Strings.InStr(wname, "トルネード") > 0 | Strings.InStr(wname, "ハリケーン") > 0 | Strings.InStr(wname, "タイフーン") > 0 | Strings.InStr(wname, "サイクロン") > 0 | Strings.InStr(wname, "ブリザード") > 0 | Strings.InStr(wname, "竜巻") > 0 | Strings.InStr(wname, "渦巻") > 0 | Strings.InStr(wname, "台風") > 0 | Strings.InStr(wname, "嵐") > 0)
SRC.NET/Effect.cs:                else if (Strings.Right(wname, 1) == "液")
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "発火") > 0 | Strings.InStr(wname, "パイロキネシス") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "吸収") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(sname, ";") > 0)
SRC.NET/Effect.cs:                sname = Strings.Mid(sname, Strings.InStr(sname, ";"));
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "鞭") > 0 | Strings.InStr(wname, "ムチ") > 0 | Strings.InStr(wname, "ウイップ") > 0 | Strings.InStr(wname, "チェーン") > 0 | Strings.InStr(wname, "ロッド") > 0 | Strings.InStr(wname, "テンタク") > 0 | Strings.InStr(wname, "テイル") > 0 | Strings.InStr(wname, "尾") > 0 | Strings.InStr(wname, "触手") > 0 | Strings.InStr(wname, "触腕") > 0 | Strings.InStr(wname, "舌") > 0 | Strings.InStr(wname, "巻き") > 0 | Strings.InStr(wname, "糸") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "マシンガン") > 0 | Strings.InStr(wname, "機関銃") > 0 | Strings.InStr(wname, "アサルトライフル") > 0 | Strings.InStr(wname, "バルカン") > 0)
SRC.NET/Effect.cs:            if (Conversions.ToBoolean(GeneralLib.InStrNotNest(ref wclass, ref argstring2) | GeneralLib.InStrNotNest(ref wclass, ref argstring21) | GeneralLib.InStrNotNest(ref wclass, ref argstring22) | GeneralLib.InStrNotNest(ref wclass, ref argstring23) | Conversions.ToShort(Strings.InStr(wname, "弓") > 0) | Conversions.ToShort(Strings.InStr(wname, "アロー") > 0) | Conversions.ToShort(Strings.InStr(wname, "ロングボウ") > 0) | Conversions.ToShort(Strings.InStr(wname, "ショートボウ") > 0) | Conversions.ToShort(Strings.InStr(wname, "ボーガン") > 0) | Conversions.ToShort(Strings.InStr(wname, "ボウガン") > 0) | Conversions.ToShort(Strings.InStr(wname, "針") > 0) | Conversions.ToShort(Strings.InStr(wname, "ニードル") > 0) | Conversions.ToShort(Strings.InStr(wname, "ランサー") > 0) | Conversions.ToShort(Strings.InStr(wname, "ダガー") > 0) | Conversions.ToShort(Strings.InStr(wname, "剣") > 0)))
SRC.NET/Effect.cs:            if (Strings.Len(ctype_Renamed) == 0)
SRC.NET/Effect.cs:            if (hit_count > 0 & Strings.InStr(u.Weapon(w).Class_Renamed, "連") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "２４連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "２２連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "２０連") > 0 | Strings.InStr(wname, "二十連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "１８連") > 0 | Strings.InStr(wname, "十八連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "１６連") > 0 | Strings.InStr(wname, "十六連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "１４連") > 0 | Strings.InStr(wname, "十四連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "１２連") > 0 | Strings.InStr(wname, "十二連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "１連") > 0 | Strings.InStr(wname, "一連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "１０連") > 0 | Strings.InStr(wname, "十連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "９連") > 0 | Strings.InStr(wname, "九連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "８連") > 0 | Strings.InStr(wname, "八連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "７連") > 0 | Strings.InStr(wname, "七連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "６連") > 0 | Strings.InStr(wname, "六連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "５連") > 0 | Strings.InStr(wname, "五連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "４連") > 0 | Strings.InStr(wname, "四連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "３連") > 0 | Strings.InStr(wname, "三連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "２連") > 0 | Strings.InStr(wname, "二連") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "連打") > 0 | Strings.InStr(wname, "連射") > 0 | Strings.InStr(wname, "多連") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "全弾") > 0 | Strings.InStr(wname, "斉") > 0 | Strings.InStr(wname, "乱射") > 0 | Strings.InStr(wname, "フルファイア") > 0 | Strings.InStr(wname, "スプリット") > 0 | Strings.InStr(wname, "マルチ") > 0 | Strings.InStr(wname, "パラレル") > 0 | Strings.InStr(wname, "分身") > 0 | Strings.InStr(wname, "乱打") > 0 | Strings.InStr(wname, "乱舞") > 0 | Strings.InStr(wname, "乱れ") > 0 | Strings.InStr(wname, "百烈") > 0 | Strings.InStr(wname, "千本") > 0 | Strings.InStr(wname, "千手") > 0 | Strings.InStr(wname, "ファンネル") > 0 | Strings.InStr(wname, "ビット") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "マシンガン") > 0 | Strings.InStr(wname, "機銃") > 0 | Strings.InStr(wname, "機関銃") > 0 | Strings.InStr(wname, "バルカン") > 0 | Strings.InStr(wname, "ガトリング") > 0 | Strings.InStr(wname, "パルス") > 0 & Strings.InStr(wname, "インパルス") == 0 | Strings.InStr(wname, "速射") > 0 | Strings.InStr(wname, "ロケットランチャー") > 0 | Strings.InStr(wname, "ミサイルランチャー") > 0 | Strings.InStr(wname, "ミサイルポッド") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "トリプル") > 0 | Strings.InStr(wname, "インコム") > 0 | Strings.InStr(wname, "ファミリア") > 0 | Strings.InStr(wname, "爆撃") > 0 | Strings.InStr(wname, "爆弾") > 0 | Strings.InStr(wname, "爆雷") > 0 | Strings.InStr(wname, "艦載機") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ツイン") > 0 | Strings.InStr(wname, "ダブル") > 0 | Strings.InStr(wname, "デュアル") > 0 | Strings.InStr(wname, "マイクロ") > 0 | Strings.InStr(wname, "双") > 0 | Strings.InStr(wname, "二丁") > 0 | Strings.InStr(wname, "二刀") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ビーム") > 0 | GeneralLib.InStrNotNest(ref wclass, ref argstring21) > 0)
SRC.NET/Effect.cs:            else if (Strings.Right(wname, 2) == "ガス")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "反物質") > 0 | Strings.InStr(wname, "熱線") > 0 | Strings.InStr(wname, "ブラスター") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "フェイザー") > 0 | Strings.InStr(wname, "粒子") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "メガ粒子") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "冷凍") > 0 | Strings.InStr(wname, "冷線") > 0 | Strings.InStr(wname, "フリーザー") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "中間子") > 0 | Strings.InStr(wname, "中性子") > 0 | Strings.InStr(wname, "ニュートロン") > 0 | Strings.InStr(wname, "ニュートリノ") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "プラズマ") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "レーザー") > 0 | Strings.InStr(wname, "光子") > 0)
SRC.NET/Effect.cs:            else if (Strings.InStr(wname, "陽子") > 0)
SRC.NET/Effect.cs:                if (Strings.InStr(wname, "粒子") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(wname, "メガ粒子") > 0)
SRC.NET/Effect.cs:                else if (Strings.InStr(wname, "イオン") > 0 | Strings.InStr(wname, "冷凍") > 0 | Strings.InStr(wname, "電子") > 0)
SRC.NET/Effect.cs:                if (Strings.Right(wname, 2) == "光線" | Strings.Right(wname, 1) == "砲" | Strings.Right(wname, 1) == "銃")
SRC.NET/Effect.cs:            var loopTo = (short)Strings.Len(sclass);
SRC.NET/Effect.cs:                switch (Strings.Mid(sclass, i, 1) ?? "")
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ファイヤー") > 0 | Strings.InStr(wname, "フレア") > 0 | Strings.InStr(wname, "ヒート") > 0 | Strings.InStr(wname, "ブラッド") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ウォーター") > 0 | Strings.InStr(wname, "アクア") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ウッド") > 0 | Strings.InStr(wname, "フォレスト") > 0 | Strings.InStr(wname, "ポイズン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "イビル") > 0 | Strings.InStr(wname, "エビル") > 0 | Strings.InStr(wname, "ダーク") > 0 | Strings.InStr(wname, "デス") > 0 | Strings.InStr(wname, "ナイト") > 0 | Strings.InStr(wname, "シャドウ") > 0 | Strings.InStr(wname, "カース") > 0 | Strings.InStr(wname, "カーズ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "アース") > 0 | Strings.InStr(wname, "サンド") > 0 | Strings.InStr(wname, "ロック") > 0 | Strings.InStr(wname, "ストーン") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ライフ") > 0)
SRC.NET/Effect.cs:            if (Strings.InStr(wname, "ホーリー") > 0 | Strings.InStr(wname, "スター") > 0 | Strings.InStr(wname, "ムーン") > 0 | Strings.InStr(wname, "コールド") > 0 | Strings.InStr(wname, "アイス") > 0 | Strings.InStr(wname, "フリーズ") > 0)
SRC.NET/Effect.cs:            if (Conversions.ToBoolean(Strings.InStr(wname, "サン")))
SRC.NET/Effect.cs:            if (Strings.InStr(explode_image_path, @"\Anime\") > 0)
SRC.NET/Effect.cs:                    if (Strings.InStr(fdata, "バリア無効化無効") == 0 | ecost > 0)
SRC.NET/Event.cs:            if (Strings.LCase(GeneralLib.ReadIni(ref argini_section, ref argini_entry)) == "on")
SRC.NET/Event.cs:                if (Strings.LCase(GeneralLib.ReadIni(ref argini_section1, ref argini_entry1)) != "off")
SRC.NET/Event.cs:                    if (Strings.LCase(GeneralLib.ReadIni(ref argini_section2, ref argini_entry2)) != "off")
SRC.NET/Event.cs:                if (Strings.Left(EventData[i], 1) == "@")
SRC.NET/Event.cs:                    tname = Strings.Mid(EventData[i], 2);
SRC.NET/Event.cs:                        if (Strings.Len(tfolder) == 0)
SRC.NET/Event.cs:                if (Strings.Right(EventData[i], 1) == "_")
SRC.NET/Event.cs:                    EventData[i + 1] = Strings.Left(EventData[i], Strings.Len(EventData[i]) - 1) + EventData[i + 1];
SRC.NET/Event.cs:                    if (Strings.Right(buf, 1) == ":")
SRC.NET/Event.cs:                        string arglname = Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/Event.cs:                    switch (Strings.Right(buf, 1) ?? "")
SRC.NET/Event.cs:                                string arglname2 = Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/Event.cs:                    switch (Strings.Right(buf, 1) ?? "")
SRC.NET/Event.cs:                                string arglname3 = Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/Event.cs:                    switch (Strings.Right(buf, 1) ?? "")
SRC.NET/Event.cs:                                string arglname1 = Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/Event.cs:                                                        buf = Strings.LCase(GeneralLib.ListIndex(ref EventData[CurrentLineNum + 1], 1));
SRC.NET/Event.cs:                                                        if ((buf ?? "") != (buf2 ?? "") & buf != "end" & buf != "suspend" & Strings.Len(buf) == LenB(Strings.StrConv(buf, vbFromUnicode)))
SRC.NET/Event.cs:            string argfname34 = Strings.Left(fname, Strings.Len(fname) - 4) + ".map";
SRC.NET/Event.cs:            string argfname61 = Strings.Left(fname, Strings.Len(fname) - 4) + ".map";
SRC.NET/Event.cs:                string argfname60 = Strings.Left(fname, Strings.Len(fname) - 4) + ".map";
SRC.NET/Event.cs:                if (Strings.Left(buf, 1) == "#")
SRC.NET/Event.cs:                else if (Strings.InStr(buf, "//") > 0)
SRC.NET/Event.cs:                    var loopTo = (short)Strings.Len(buf);
SRC.NET/Event.cs:                        switch (Strings.Mid(buf, i, 1) ?? "")
SRC.NET/Event.cs:                                            if (Strings.Mid(buf, i - 1, 1) == "/")
SRC.NET/Event.cs:                                                buf = Strings.Left(buf, i - 2);
SRC.NET/Event.cs:                if (Strings.Left(buf, 1) == "<")
SRC.NET/Event.cs:                    if (Strings.InStr(buf, ">") == Strings.Len(buf) & buf != "<>")
SRC.NET/Event.cs:                        fname2 = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/Event.cs:                            if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + fname2)) > 0)
SRC.NET/Event.cs:                            else if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + fname2)) > 0)
SRC.NET/Event.cs:                            else if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + fname2)) > 0)
SRC.NET/Event.cs:                            else if (Strings.Len(FileSystem.Dir(SRC.AppPath + fname2)) > 0)
SRC.NET/Event.cs:            if (Strings.Len(buf) == 0)
SRC.NET/Event.cs:                        if (Strings.Asc(EventData[ret]) != 42) // *
SRC.NET/Event.cs:                    if (Strings.Left(EventData[ret], 1) != "*")
SRC.NET/Event.cs:                                    if (Strings.InStr(str1, ":") > 0)
SRC.NET/Event.cs:                                        str1 = Strings.Left(str1, Strings.InStr(str1, ":") - 1);
SRC.NET/Event.cs:                            if (Strings.InStr(str1, ":") > 0)
SRC.NET/Event.cs:                                str1 = Strings.Left(str1, Strings.InStr(str1, ":") - 1);
SRC.NET/Event.cs:                            if (Strings.InStr(str2, ":") > 0)
SRC.NET/Event.cs:                                str2 = Strings.Left(str2, Strings.InStr(str2, ":") - 1);
SRC.NET/Event.cs:                    if (Strings.Asc(EventData[ret]) != 42) // *
SRC.NET/Event.cs:                        if (Strings.InStr(fname, ":") == 0)
SRC.NET/Event.cs:                        if (Strings.Right(EventData[i], 1) == "_")
SRC.NET/Event.cs:                            EventData[i + 1] = Strings.Left(EventData[i], Strings.Len(EventData[i]) - 1) + EventData[i + 1];
SRC.NET/Event.cs:                        if (Strings.Right(buf, 1) == ":")
SRC.NET/Event.cs:                            string arglname = Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/Event.cs:                if (Strings.Left(buf, 1) == "\"")
SRC.NET/Event.cs:                    vvalue = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/Event.cs:                    if (Strings.Left(vname, 8) == "Ability(")
SRC.NET/Event.cs:                        idx = (short)Strings.InStr(vname, ",");
SRC.NET/Event.cs:                            aname = Strings.Mid(vname, idx + 1, Strings.Len(vname) - idx - 1);
SRC.NET/Event.cs:                                vname = Strings.Left(vname, idx) + localItem().get_AliasType(1) + ")";
SRC.NET/Event.cs:                            vvalue = Strings.Trim(buf);
SRC.NET/Event.cs:                    if (Strings.Left(vname, 8) == "Ability(")
SRC.NET/Event.cs:                        idx = (short)Strings.InStr(vname, ",");
SRC.NET/Event.cs:                            vname2 = Strings.Left(vname, idx - 1) + ")";
SRC.NET/Event.cs:                            aname = Strings.Mid(vname, idx + 1, Strings.Len(vname) - idx - 1);
SRC.NET/Event.cs:                    if (Strings.Left(vname, 8) == "Ability(")
SRC.NET/Event.cs:                        if (Strings.Right(vname, 5) == ",非表示)")
SRC.NET/Event.cs:                    if (Strings.Left(vname, 8) == "Ability(")
SRC.NET/Event.cs:                        if (Strings.InStr(vname, ",") == 0)
SRC.NET/Event.cs:                            vvalue = Strings.Trim(buf);
SRC.NET/Event.cs:                    if (Strings.Left(vname, 8) == "Ability(")
SRC.NET/Event.cs:                if (Strings.InStr(var.Name, "\"") > 0)
SRC.NET/Event.cs:                if (Strings.Left(buf, 1) == "\"")
SRC.NET/Event.cs:                    vvalue = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/Event.cs:                    if (Strings.Left(vname, 8) == "Ability(")
SRC.NET/Event.cs:                        if (Strings.StrComp(Conversions.ToString(strkey_list[j]), max_str, (CompareMethod)1) == -1)
SRC.NET/Expression.cs:                ret = (short)Strings.Asc(terms[i]);
SRC.NET/Expression.cs:                switch (Strings.Len(terms[i]))
SRC.NET/Expression.cs:                                            if (Strings.Right(terms[i], 1) == "=")
SRC.NET/Expression.cs:                                            switch (Strings.Right(terms[i], 1) ?? "")
SRC.NET/Expression.cs:                                            if (Strings.Right(terms[i], 1) == "=")
SRC.NET/Expression.cs:                                            if (Strings.LCase(terms[i]) == "or")
SRC.NET/Expression.cs:                                            if (Strings.LCase(terms[i]) == "mod")
SRC.NET/Expression.cs:                                            if (Strings.LCase(terms[i]) == "not")
SRC.NET/Expression.cs:                                            if (Strings.LCase(terms[i]) == "and")
SRC.NET/Expression.cs:                                            if (Strings.LCase(terms[i]) == "like")
SRC.NET/Expression.cs:                        buf = new string(Conversions.ToChar(Constants.vbNullChar), Strings.Len(expr));
SRC.NET/Expression.cs:                        tsize = (short)Strings.Len(terms[1]);
SRC.NET/Expression.cs:                            tsize = (short)Strings.Len(terms[i]);
SRC.NET/Expression.cs:                        lop = Strings.Left(buf, osize);
SRC.NET/Expression.cs:                buf = new string(Conversions.ToChar(Constants.vbNullChar), Strings.Len(expr));
SRC.NET/Expression.cs:                tsize = (short)Strings.Len(terms[op_idx + 1]);
SRC.NET/Expression.cs:                    tsize = (short)Strings.Len(terms[i]);
SRC.NET/Expression.cs:                rop = Strings.Left(buf, osize);
SRC.NET/Expression.cs:            if (Strings.Len(expr) == 0)
SRC.NET/Expression.cs:            switch (Strings.Asc(expr))
SRC.NET/Expression.cs:                        string argexpr = Strings.Trim(expr);
SRC.NET/Expression.cs:                        if (Strings.Right(expr, 1) == "\"")
SRC.NET/Expression.cs:                            str_result = Strings.Mid(expr, 2, Strings.Len(expr) - 2);
SRC.NET/Expression.cs:                        if (Strings.Right(expr, 1) == ")")
SRC.NET/Expression.cs:                            string argexpr1 = Strings.Mid(expr, 2, Strings.Len(expr) - 2);
SRC.NET/Expression.cs:                        if (Strings.Right(expr, 1) == "`")
SRC.NET/Expression.cs:                            str_result = Strings.Mid(expr, 2, Strings.Len(expr) - 2);
SRC.NET/Expression.cs:            if (Strings.Right(expr, 1) != ")")
SRC.NET/Expression.cs:            i = (short)Strings.InStr(expr, " ");
SRC.NET/Expression.cs:            j = (short)Strings.InStr(expr, "(");
SRC.NET/Expression.cs:            num = (short)Strings.Len(expr);
SRC.NET/Expression.cs:                    if (Strings.Asc(Strings.Mid(expr, i, 1)) == 96) // `
SRC.NET/Expression.cs:                    if (Strings.Asc(Strings.Mid(expr, i, 1)) == 34) // "
SRC.NET/Expression.cs:                    switch (Strings.Asc(Strings.Mid(expr, i, 1)))
SRC.NET/Expression.cs:                                    @params[pcount] = Strings.Mid(expr, start_idx, i - start_idx);
SRC.NET/Expression.cs:                @params[pcount] = Strings.Mid(expr, start_idx, num - start_idx);
SRC.NET/Expression.cs:            switch (Strings.Asc(expr))
SRC.NET/Expression.cs:                        fname = Strings.Left(expr, j - 1);
SRC.NET/Expression.cs:                        fname = Strings.Left(expr, j - 1);
SRC.NET/Expression.cs:                        fname = Strings.Left(expr, j - 1);
SRC.NET/Expression.cs:            switch (Strings.LCase(fname) ?? "")
SRC.NET/Expression.cs:                            i = (short)Strings.InStr(GetValueAsString(ref @params[1], is_term[1]), GetValueAsString(ref @params[2], is_term[2]));
SRC.NET/Expression.cs:                            i = (short)Strings.InStr(GetValueAsLong(ref @params[3], is_term[3]), GetValueAsString(ref @params[1], is_term[1]), GetValueAsString(ref @params[2], is_term[2]));
SRC.NET/Expression.cs:                            i = InStrB(Strings.StrConv(GetValueAsString(ref @params[1], is_term[1]), vbFromUnicode), Strings.StrConv(GetValueAsString(ref @params[2], is_term[2]), vbFromUnicode));
SRC.NET/Expression.cs:                            i = InStrB(GetValueAsLong(ref @params[3], is_term[3]), Strings.StrConv(GetValueAsString(ref @params[1], is_term[1]), vbFromUnicode), Strings.StrConv(GetValueAsString(ref @params[2], is_term[2]), vbFromUnicode));
SRC.NET/Expression.cs:                        if (Strings.Left(str_result, 1) == "(" & Strings.Right(str_result, 1) == ")")
SRC.NET/Expression.cs:                            str_result = Strings.Mid(str_result, 2, Strings.Len(str_result) - 2);
SRC.NET/Expression.cs:                        num_result = (double)Strings.Asc(GetValueAsString(ref @params[1], is_term[1]));
SRC.NET/Expression.cs:                        expr = Strings.Trim(expr);
SRC.NET/Expression.cs:                        buf = Strings.Mid(expr, 7, Strings.Len(expr) - 7) + "[";
SRC.NET/Expression.cs:                                if (Strings.InStr(Event_Renamed.VarStack[(int)i].Name, buf) == 1)
SRC.NET/Expression.cs:                            if (Strings.InStr(var.Name, buf) == 1)
SRC.NET/Expression.cs:                            if (Strings.InStr(var.Name, buf) == 1)
SRC.NET/Expression.cs:                                    if (Strings.Mid(fname, 2, 1) != ":")
SRC.NET/Expression.cs:                                    if (Strings.Len(str_result) == 0)
SRC.NET/Expression.cs:                                            dir_path = Strings.Left(fname, (int)i);
SRC.NET/Expression.cs:                                    if (Strings.InStr(fname, "*") == 0)
SRC.NET/Expression.cs:                                        while (Strings.Len(str_result) > 0)
SRC.NET/Expression.cs:                                        while (Strings.Len(str_result) > 0)
SRC.NET/Expression.cs:                                    if (Strings.Mid(fname, 2, 1) != ":")
SRC.NET/Expression.cs:                                    if (Strings.Len(str_result) == 0)
SRC.NET/Expression.cs:                                    if (Strings.InStr(fname, "*") == 0)
SRC.NET/Expression.cs:                                    while (Strings.Len(str_result) > 0)
SRC.NET/Expression.cs:                        buf = Strings.Trim(GetValueAsString(ref @params[1], is_term[1]));
SRC.NET/Expression.cs:                                    var loopTo6 = (short)(6 - Strings.Len(str_result));
SRC.NET/Expression.cs:                        if (Strings.Len(buf2) > 0 & Strings.Len(buf) >= Strings.Len(buf2))
SRC.NET/Expression.cs:                                num = (short)Strings.Len(buf);
SRC.NET/Expression.cs:                            i = (short)((int)num - Strings.Len(buf2) + 1);
SRC.NET/Expression.cs:                                j = (short)Strings.InStr((int)i, buf, buf2);
SRC.NET/Expression.cs:                        string argvar_name = Strings.Trim(Strings.Mid(expr, 14, Strings.Len(expr) - 14));
SRC.NET/Expression.cs:                        str_result = Strings.Left(GetValueAsString(ref @params[1], is_term[1]), GetValueAsLong(ref @params[2], is_term[2]));
SRC.NET/Expression.cs:                        str_result = LeftB(Strings.StrConv(buf, vbFromUnicode), GetValueAsLong(ref @params[2], is_term[2]));
SRC.NET/Expression.cs:                        str_result = Strings.StrConv(str_result, vbUnicode);
SRC.NET/Expression.cs:                        num_result = (double)Strings.Len(GetValueAsString(ref @params[1], is_term[1]));
SRC.NET/Expression.cs:                        num_result = LenB(Strings.StrConv(buf, vbFromUnicode));
SRC.NET/Expression.cs:                        str_result = Strings.LCase(GetValueAsString(ref @params[1], is_term[1]));
SRC.NET/Expression.cs:                        if (LenB(Strings.StrConv(buf, vbFromUnicode)) < i)
SRC.NET/Expression.cs:                            str_result = buf + Strings.Space(i - LenB(Strings.StrConv(buf, vbFromUnicode)));
SRC.NET/Expression.cs:                                    str_result = Strings.Mid(buf, (int)i, (int)j);
SRC.NET/Expression.cs:                                    str_result = Strings.Mid(buf, (int)i);
SRC.NET/Expression.cs:                                    str_result = MidB(Strings.StrConv(buf, vbFromUnicode), i, j);
SRC.NET/Expression.cs:                                    str_result = MidB(Strings.StrConv(buf, vbFromUnicode), i);
SRC.NET/Expression.cs:                        str_result = Strings.StrConv(str_result, vbUnicode);
SRC.NET/Expression.cs:                                    buf2 = Strings.Right(buf, Strings.Len(buf) - (int)num + 1);
SRC.NET/Expression.cs:                                    str_result = Strings.Left(buf, (int)num - 1) + buf2;
SRC.NET/Expression.cs:                                    buf2 = Strings.Mid(buf, (int)num, (int)num2);
SRC.NET/Expression.cs:                                    str_result = Strings.Left(buf, (int)num - 1) + buf2 + Strings.Right(buf, Strings.Len(buf) - (num + num2 - 1) - 1);
SRC.NET/Expression.cs:                        var loopTo11 = (short)(6 - Strings.Len(buf));
SRC.NET/Expression.cs:                        var midTmp = Strings.Mid(buf, 5, 2);
SRC.NET/Expression.cs:                        var midTmp1 = Strings.Mid(buf, 3, 2);
SRC.NET/Expression.cs:                        var midTmp2 = Strings.Mid(buf, 1, 2);
SRC.NET/Expression.cs:                        str_result = Strings.Right(GetValueAsString(ref @params[1], is_term[1]), GetValueAsLong(ref @params[2], is_term[2]));
SRC.NET/Expression.cs:                        str_result = RightB(Strings.StrConv(buf, vbFromUnicode), GetValueAsLong(ref @params[2], is_term[2]));
SRC.NET/Expression.cs:                        str_result = Strings.StrConv(str_result, vbUnicode);
SRC.NET/Expression.cs:                        switch (Strings.LCase(fname) ?? "")
SRC.NET/Expression.cs:                        if (LenB(Strings.StrConv(buf, vbFromUnicode)) < i)
SRC.NET/Expression.cs:                            str_result = Strings.Space(i - LenB(Strings.StrConv(buf, vbFromUnicode))) + buf;
SRC.NET/Expression.cs:                        num_result = (double)Strings.StrComp(GetValueAsString(ref @params[1], is_term[1]), GetValueAsString(ref @params[2], is_term[2]));
SRC.NET/Expression.cs:                        if (Strings.Len(buf) <= 1)
SRC.NET/Expression.cs:                        str_result = Strings.Trim(GetValueAsString(ref @params[1], is_term[1]));
SRC.NET/Expression.cs:                        str_result = Strings.StrConv(GetValueAsString(ref @params[1], is_term[1]), VbStrConv.Wide);
SRC.NET/Expression.cs:                        if (Strings.InStr(str_result, SRC.ScenarioPath) > 0)
SRC.NET/Expression.cs:                            str_result = Strings.Mid(str_result, Strings.Len(SRC.ScenarioPath) + 1);
SRC.NET/Expression.cs:                        if (Strings.Right(Strings.Left(str_result, 3), 2) == @":\")
SRC.NET/Expression.cs:                            if (Strings.InStr(str_result, @"\") == 0)
SRC.NET/Expression.cs:                            str_result = Strings.Mid(str_result, Strings.InStr(str_result, @"\") + 1);
SRC.NET/Expression.cs:                        if (Strings.InStr(str_result, SRC.ScenarioPath) > 0)
SRC.NET/Expression.cs:                            str_result = Strings.Mid(str_result, Strings.Len(SRC.ScenarioPath) + 1);
SRC.NET/Expression.cs:                        if (Strings.InStr(str_result, @"\") == 0)
SRC.NET/Expression.cs:                        var loopTo13 = (short)Strings.Len(str_result);
SRC.NET/Expression.cs:                            if (Strings.Mid(str_result, Strings.Len(str_result) - (int)i + 1, 1) == @"\")
SRC.NET/Expression.cs:                        buf = Strings.Left(str_result, Strings.Len(str_result) - (int)i);
SRC.NET/Expression.cs:                        str_result = Strings.Mid(str_result, Strings.Len(str_result) - (int)i + 2);
SRC.NET/Expression.cs:                        while (Strings.InStr(buf, @"\") > 0)
SRC.NET/Expression.cs:                            buf = Strings.Mid(buf, Strings.InStr(buf, @"\") + 1);
SRC.NET/Expression.cs:                            EvalInfoFuncRet = Strings.Trim(EvalInfoFuncRet);
SRC.NET/Expression.cs:                            EvalInfoFuncRet = Strings.Trim(EvalInfoFuncRet);
SRC.NET/Expression.cs:                                            j = (short)(j + Strings.Len(@params[idx + 1]) + 1);
SRC.NET/Expression.cs:                                            string argstr_Renamed = Strings.Mid(withBlock8.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                EvalInfoFuncRet = EvalInfoFuncRet + Strings.Mid(withBlock8.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                j = (short)(j + Strings.Len(@params[idx + 1]) + 1);
SRC.NET/Expression.cs:                                                string argstr_Renamed1 = Strings.Mid(withBlock10.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                    EvalInfoFuncRet = EvalInfoFuncRet + Strings.Mid(withBlock10.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                            j = (short)(j + Strings.Len(@params[idx + 1]) + 1);
SRC.NET/Expression.cs:                                            string argstr_Renamed2 = Strings.Mid(withBlock11.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                EvalInfoFuncRet = EvalInfoFuncRet + Strings.Mid(withBlock11.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                            j = (short)(j + Strings.Len(@params[idx + 1]) + 1);
SRC.NET/Expression.cs:                                            string argstr_Renamed3 = Strings.Mid(withBlock12.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                EvalInfoFuncRet = EvalInfoFuncRet + Strings.Mid(withBlock12.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                            j = (short)(j + Strings.Len(@params[idx + 1]) + 1);
SRC.NET/Expression.cs:                                            string argstr_Renamed4 = Strings.Mid(withBlock13.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                EvalInfoFuncRet = EvalInfoFuncRet + Strings.Mid(withBlock13.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                            j = (short)(j + Strings.Len(@params[idx + 1]) + 1);
SRC.NET/Expression.cs:                                            string argstr_Renamed5 = Strings.Mid(withBlock15.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                EvalInfoFuncRet = EvalInfoFuncRet + Strings.Mid(withBlock15.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                j = (short)(j + Strings.Len(@params[idx + 1]) + 1);
SRC.NET/Expression.cs:                                                string argstr_Renamed6 = Strings.Mid(withBlock17.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                    EvalInfoFuncRet = EvalInfoFuncRet + Strings.Mid(withBlock17.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                            j = (short)(j + Strings.Len(@params[idx + 1]) + 1);
SRC.NET/Expression.cs:                                            string argstr_Renamed7 = Strings.Mid(withBlock18.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                EvalInfoFuncRet = EvalInfoFuncRet + Strings.Mid(withBlock18.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                            j = (short)(j + Strings.Len(@params[idx + 1]) + 1);
SRC.NET/Expression.cs:                                            string argstr_Renamed8 = Strings.Mid(withBlock19.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                EvalInfoFuncRet = EvalInfoFuncRet + Strings.Mid(withBlock19.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                            j = (short)(j + Strings.Len(@params[idx + 1]) + 1);
SRC.NET/Expression.cs:                                            string argstr_Renamed9 = Strings.Mid(withBlock20.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                                EvalInfoFuncRet = EvalInfoFuncRet + Strings.Mid(withBlock20.Class_Renamed, j, 1);
SRC.NET/Expression.cs:                                if (Strings.InStr(localWeapon7().Class_Renamed, "合") == 0)
SRC.NET/Expression.cs:                                if (Strings.InStr(localWeapon10().Class_Renamed, "合") == 0)
SRC.NET/Expression.cs:                                    if (Strings.Len(EvalInfoFuncRet) > Strings.Len(SRC.ScenarioPath))
SRC.NET/Expression.cs:                                        if ((Strings.Left(EvalInfoFuncRet, Strings.Len(SRC.ScenarioPath)) ?? "") == (SRC.ScenarioPath ?? ""))
SRC.NET/Expression.cs:                                            EvalInfoFuncRet = Strings.Mid(EvalInfoFuncRet, Strings.Len(SRC.ScenarioPath) + 1);
SRC.NET/Expression.cs:                                            var loopTo24 = (short)(6 - Strings.Len(buf));
SRC.NET/Expression.cs:                                            buf = "#" + Strings.Mid(buf, 5, 2) + Strings.Mid(buf, 3, 2) + Strings.Mid(buf, 1, 2) + " " + (Map.MapDrawFilterTransPercent * 100d).ToString() + "%";
SRC.NET/Expression.cs:            ret = Strings.InStr(vname, "[");
SRC.NET/Expression.cs:            if (Strings.Right(vname, 1) != "]")
SRC.NET/Expression.cs:            idx = Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1);
SRC.NET/Expression.cs:            if (Strings.InStr(idx, ",") > 0)
SRC.NET/Expression.cs:                var loopTo = (short)Strings.Len(idx);
SRC.NET/Expression.cs:                        if (Strings.Asc(Strings.Mid(idx, i, 1)) == 96) // `
SRC.NET/Expression.cs:                        if (Strings.Asc(Strings.Mid(idx, i, 1)) == 34) // "
SRC.NET/Expression.cs:                        switch (Strings.Asc(Strings.Mid(idx, i, 1)))
SRC.NET/Expression.cs:                                        if (Strings.Len(buf) > 0)
SRC.NET/Expression.cs:                                        ipara = Strings.Trim(Strings.Mid(idx, start_idx, i - start_idx));
SRC.NET/Expression.cs:                ipara = Strings.Trim(Strings.Mid(idx, start_idx, i - start_idx));
SRC.NET/Expression.cs:                if (Strings.Len(buf) > 0)
SRC.NET/Expression.cs:            vname = Strings.Left(vname, ret) + idx + "]";
SRC.NET/Expression.cs:                        switch (Strings.LCase(vname) ?? "")
SRC.NET/Expression.cs:            switch (Strings.Asc(var_name))
SRC.NET/Expression.cs:                        vname = Strings.Mid(var_name, 2);
SRC.NET/Expression.cs:            ret = (short)Strings.InStr(vname, "[");
SRC.NET/Expression.cs:            if (Strings.Right(vname, 1) != "]")
SRC.NET/Expression.cs:            idx = Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1);
SRC.NET/Expression.cs:            if (Strings.InStr(idx, ",") > 0)
SRC.NET/Expression.cs:                var loopTo = (short)Strings.Len(idx);
SRC.NET/Expression.cs:                        if (Strings.Asc(Strings.Mid(idx, i, 1)) == 96) // `
SRC.NET/Expression.cs:                        if (Strings.Asc(Strings.Mid(idx, i, 1)) == 34) // "
SRC.NET/Expression.cs:                        switch (Strings.Asc(Strings.Mid(idx, i, 1)))
SRC.NET/Expression.cs:                                        if (Strings.Len(buf) > 0)
SRC.NET/Expression.cs:                                        ipara = Strings.Trim(Strings.Mid(idx, start_idx, i - start_idx));
SRC.NET/Expression.cs:                ipara = Strings.Trim(Strings.Mid(idx, start_idx, i - start_idx));
SRC.NET/Expression.cs:                if (Strings.Len(buf) > 0)
SRC.NET/Expression.cs:                string argexpr = Strings.Trim(idx);
SRC.NET/Expression.cs:            vname = Strings.Left(vname, ret) + idx + "]";
SRC.NET/Expression.cs:            ret = (short)Strings.InStr(vname, "(");
SRC.NET/Expression.cs:            if (ret > 1 & Strings.Right(vname, 1) == ")")
SRC.NET/Expression.cs:                switch (Strings.LCase(Strings.Left(vname, ret - 1)) ?? "")
SRC.NET/Expression.cs:                            idx = Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1);
SRC.NET/Expression.cs:                            idx = Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1);
SRC.NET/Expression.cs:                            idx = Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1);
SRC.NET/Expression.cs:                            idx = Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1);
SRC.NET/Expression.cs:                            idx = Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1);
SRC.NET/Expression.cs:                            vname = Strings.Trim(Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1));
SRC.NET/Expression.cs:            ret = (short)Strings.InStr(vname, "[");
SRC.NET/Expression.cs:            if (Strings.Right(vname, 1) != "]")
SRC.NET/Expression.cs:            idx = Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1);
SRC.NET/Expression.cs:            if (Strings.InStr(idx, ",") > 0)
SRC.NET/Expression.cs:                var loopTo = (short)Strings.Len(idx);
SRC.NET/Expression.cs:                        if (Strings.Asc(Strings.Mid(idx, i, 1)) == 96) // `
SRC.NET/Expression.cs:                        if (Strings.Asc(Strings.Mid(idx, i, 1)) == 34) // "
SRC.NET/Expression.cs:                        switch (Strings.Asc(Strings.Mid(idx, i, 1)))
SRC.NET/Expression.cs:                                        if (Strings.Len(buf) > 0)
SRC.NET/Expression.cs:                                        ipara = Strings.Trim(Strings.Mid(idx, start_idx, i - start_idx));
SRC.NET/Expression.cs:                ipara = Strings.Trim(Strings.Mid(idx, start_idx, i - start_idx));
SRC.NET/Expression.cs:                if (Strings.Len(buf) > 0)
SRC.NET/Expression.cs:                string argexpr = Strings.Trim(idx);
SRC.NET/Expression.cs:            vname = Strings.Left(vname, ret) + idx + "]";
SRC.NET/Expression.cs:            vname0 = Strings.Left(vname, ret - 1);
SRC.NET/Expression.cs:            switch (Strings.LCase(vname) ?? "")
SRC.NET/Expression.cs:            if (Strings.Len(vname0) != 0)
SRC.NET/Expression.cs:                    if (Strings.InStr(new_var2.Name, "\"") > 0)
SRC.NET/Expression.cs:            if (Strings.InStr(new_var.Name, "\"") > 0)
SRC.NET/Expression.cs:            if (Strings.Asc(var_name) == 36) // $
SRC.NET/Expression.cs:                vname = Strings.Mid(var_name, 2);
SRC.NET/Expression.cs:            if (Strings.LCase(Strings.Left(vname, 5)) == "eval(")
SRC.NET/Expression.cs:                if (Strings.Right(vname, 1) == ")")
SRC.NET/Expression.cs:                    vname = Strings.Mid(vname, 6, Strings.Len(vname) - 6);
SRC.NET/Expression.cs:            ret = (short)Strings.InStr(vname, "[");
SRC.NET/Expression.cs:            if (Strings.Right(vname, 1) != "]")
SRC.NET/Expression.cs:            idx = Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1);
SRC.NET/Expression.cs:            if (Strings.InStr(idx, ",") > 0)
SRC.NET/Expression.cs:                var loopTo = (short)Strings.Len(idx);
SRC.NET/Expression.cs:                        if (Strings.Asc(Strings.Mid(idx, i, 1)) == 96) // `
SRC.NET/Expression.cs:                        if (Strings.Asc(Strings.Mid(idx, i, 1)) == 34) // "
SRC.NET/Expression.cs:                        switch (Strings.Asc(Strings.Mid(idx, i, 1)))
SRC.NET/Expression.cs:                                        if (Strings.Len(buf) > 0)
SRC.NET/Expression.cs:                                        string localGetValueAsString() { string argexpr = Strings.Mid(idx, start_idx, i - start_idx); var ret = GetValueAsString(ref argexpr, is_term); return ret; }
SRC.NET/Expression.cs:                if (Strings.Len(buf) > 0)
SRC.NET/Expression.cs:                    string localGetValueAsString1() { string argexpr = Strings.Mid(idx, start_idx, i - start_idx); var ret = GetValueAsString(ref argexpr, is_term); return ret; }
SRC.NET/Expression.cs:                    string argexpr = Strings.Mid(idx, start_idx, i - start_idx);
SRC.NET/Expression.cs:            vname = Strings.Left(vname, ret) + idx + "]";
SRC.NET/Expression.cs:                        if ((vname ?? "") == (withBlock1.Name ?? "") | Strings.InStr(withBlock1.Name, vname2) == 1)
SRC.NET/Expression.cs:                    if (Strings.InStr(var.Name, vname2) == 1)
SRC.NET/Expression.cs:                    if (Strings.InStr(var.Name, vname2) == 1)
SRC.NET/Expression.cs:            switch (Strings.Asc(str_Renamed))
SRC.NET/Expression.cs:                start_idx = (short)Strings.InStr(str_Renamed, "$(");
SRC.NET/Expression.cs:                str_len = (short)Strings.Len(str_Renamed);
SRC.NET/Expression.cs:                    switch (Strings.Mid(str_Renamed, i, 1) ?? "")
SRC.NET/Expression.cs:                string localGetValueAsString() { string argexpr = Strings.Mid(str_Renamed, start_idx + 2, end_idx - start_idx - 2); var ret = GetValueAsString(ref argexpr); return ret; }
SRC.NET/Expression.cs:                str_Renamed = Strings.Left(str_Renamed, start_idx - 1) + localGetValueAsString() + Strings.Right(str_Renamed, str_len - end_idx);
SRC.NET/Expression.cs:            if (Strings.Len(TermRet) == 0)
SRC.NET/Expression.cs:                if (LenB(Strings.StrConv(TermRet, vbFromUnicode)) < tlen)
SRC.NET/Expression.cs:            ret = Strings.InStr(vname, "[");
SRC.NET/Expression.cs:            if (Strings.Right(vname, 1) != "]")
SRC.NET/Expression.cs:            idx = Strings.Mid(vname, ret + 1, Strings.Len(vname) - ret - 1);
SRC.NET/Expression.cs:            if (Strings.InStr(idx, ",") > 0)
SRC.NET/Expression.cs:                var loopTo = (short)Strings.Len(idx);
SRC.NET/Expression.cs:                        if (Strings.Asc(Strings.Mid(idx, i, 1)) == 96) // `
SRC.NET/Expression.cs:                        if (Strings.Asc(Strings.Mid(idx, i, 1)) == 34) // "
SRC.NET/Expression.cs:                        switch (Strings.Asc(Strings.Mid(idx, i, 1)))
SRC.NET/Expression.cs:                                        if (Strings.Len(buf) > 0)
SRC.NET/Expression.cs:                                        ipara = Strings.Trim(Strings.Mid(idx, start_idx, i - start_idx));
SRC.NET/Expression.cs:                ipara = Strings.Trim(Strings.Mid(idx, start_idx, i - start_idx));
SRC.NET/Expression.cs:                if (Strings.Len(buf) > 0)
SRC.NET/Expression.cs:            vname = Strings.Left(vname, ret) + idx + "]";
SRC.NET/Expression.cs:                            if ((u.Party0 ?? "") == (Strings.Left(vname, Strings.Len(vname) - 1) ?? "") & (u.Status_Renamed == "出撃" | u.Status_Renamed == "格納"))
SRC.NET/Expression.cs:                        switch (Strings.LCase(vname) ?? "")
SRC.NET/FileDialog.cs:            fname = default_file + new string(Conversions.ToChar(Constants.vbNullChar), 1024 - Strings.Len(default_file));
SRC.NET/FileDialog.cs:            ftitle = Strings.Space(1024);
SRC.NET/FileDialog.cs:                withBlock.lStructSize = Strings.Len(f);
SRC.NET/FileDialog.cs:                        LoadFileDialogRet = Strings.Left(LoadFileDialogRet, Strings.InStr(LoadFileDialogRet, Constants.vbNullChar) - 1);
SRC.NET/FileDialog.cs:            fname = default_file + new string(Conversions.ToChar(Constants.vbNullChar), 1024 - Strings.Len(default_file));
SRC.NET/FileDialog.cs:            ftitle = Strings.Space(1024);
SRC.NET/FileDialog.cs:                withBlock.lStructSize = Strings.Len(f);
SRC.NET/FileDialog.cs:                        SaveFileDialogRet = Strings.Left(SaveFileDialogRet, Strings.InStr(SaveFileDialogRet, Constants.vbNullChar) - 1);
SRC.NET/GeneralLib.cs:            list_len = (short)Strings.Len(list);
SRC.NET/GeneralLib.cs:                while (Strings.Mid(list, i, 1) == " ");
SRC.NET/GeneralLib.cs:                while (Strings.Mid(list, i, 1) != " ");
SRC.NET/GeneralLib.cs:                    LIndexRet = Strings.Mid(list, begin);
SRC.NET/GeneralLib.cs:            while (Strings.Mid(list, i, 1) != " ");
SRC.NET/GeneralLib.cs:            LIndexRet = Strings.Mid(list, begin, i - begin);
SRC.NET/GeneralLib.cs:            list_len = (short)Strings.Len(list);
SRC.NET/GeneralLib.cs:                while (Strings.Mid(list, i, 1) == " ");
SRC.NET/GeneralLib.cs:                while (Strings.Mid(list, i, 1) != " ");
SRC.NET/GeneralLib.cs:            list_len = (short)Strings.Len(list);
SRC.NET/GeneralLib.cs:                while (Strings.Mid(list, i, 1) == " ");
SRC.NET/GeneralLib.cs:                        larray[LSplitRet] = Strings.Mid(list, begin);
SRC.NET/GeneralLib.cs:                while (Strings.Mid(list, i, 1) != " ");
SRC.NET/GeneralLib.cs:                larray[LSplitRet] = Strings.Mid(list, begin, i - begin);
SRC.NET/GeneralLib.cs:            if (Strings.Len(ch) == 0)
SRC.NET/GeneralLib.cs:            switch (Strings.Asc(ch))
SRC.NET/GeneralLib.cs:            list = Strings.Trim(list);
SRC.NET/GeneralLib.cs:            str_Renamed = Strings.Trim(str_Renamed);
SRC.NET/GeneralLib.cs:            list_len = (short)Strings.Len(list);
SRC.NET/GeneralLib.cs:                    ch = (short)Strings.Asc(Strings.Mid(list, i, 1));
SRC.NET/GeneralLib.cs:                    ch = (short)Strings.Asc(Strings.Mid(list, i, 1));
SRC.NET/GeneralLib.cs:                    ListIndexRet = Strings.Mid(list, begin);
SRC.NET/GeneralLib.cs:                ch = (short)Strings.Asc(Strings.Mid(list, i, 1));
SRC.NET/GeneralLib.cs:            ListIndexRet = Strings.Mid(list, begin, i - begin);
SRC.NET/GeneralLib.cs:            list_len = (short)Strings.Len(list);
SRC.NET/GeneralLib.cs:                    ch = (short)Strings.Asc(Strings.Mid(list, i, 1));
SRC.NET/GeneralLib.cs:                    ch = (short)Strings.Asc(Strings.Mid(list, i, 1));
SRC.NET/GeneralLib.cs:            list_len = (short)Strings.Len(list);
SRC.NET/GeneralLib.cs:                    ch = (short)Strings.Asc(Strings.Mid(list, i, 1));
SRC.NET/GeneralLib.cs:                                        larray[n] = Strings.Mid(list, begin);
SRC.NET/GeneralLib.cs:                        larray[n] = Strings.Mid(list, begin);
SRC.NET/GeneralLib.cs:                    ch = (short)Strings.Asc(Strings.Mid(list, i, 1));
SRC.NET/GeneralLib.cs:                larray[n] = Strings.Mid(list, begin, i - begin);
SRC.NET/GeneralLib.cs:            list_len = (short)Strings.Len(list);
SRC.NET/GeneralLib.cs:                    ch = (short)Strings.Asc(Strings.Mid(list, i, 1));
SRC.NET/GeneralLib.cs:                    ch = (short)Strings.Asc(Strings.Mid(list, i, 1));
SRC.NET/GeneralLib.cs:            ListTailRet = Strings.Mid(list, i);
SRC.NET/GeneralLib.cs:            lstr = (short)Strings.Len(str_Renamed);
SRC.NET/GeneralLib.cs:                switch (Strings.Asc(Strings.Mid(str_Renamed, i)))
SRC.NET/GeneralLib.cs:                switch (Strings.Asc(Strings.Mid(str_Renamed, j)))
SRC.NET/GeneralLib.cs:                str_Renamed = Strings.Mid(str_Renamed, i, j - i + 1);
SRC.NET/GeneralLib.cs:            slen = (short)Strings.Len(str2);
SRC.NET/GeneralLib.cs:            i = (short)(Strings.Len(str_Renamed) - slen + 1);
SRC.NET/GeneralLib.cs:                if ((Strings.Mid(str_Renamed, i, slen) ?? "") == (str2 ?? ""))
SRC.NET/GeneralLib.cs:            StrToHiraganaRet = Strings.StrConv(str_Renamed, VbStrConv.Hiragana);
SRC.NET/GeneralLib.cs:            LeftPaddedStringRet = Strings.Space(MaxLng(length - LenB(Strings.StrConv(buf, vbFromUnicode)), 0)) + buf;
SRC.NET/GeneralLib.cs:            RightPaddedStringRet = buf + Strings.Space(MaxLng(length - LenB(Strings.StrConv(buf, vbFromUnicode)), 0));
SRC.NET/GeneralLib.cs:            ReadIniRet = Strings.Left(s.Value, Strings.InStr(s.Value, Constants.vbNullChar) - 1);
SRC.NET/GeneralLib.cs:            if (Strings.Len(SRC.ScenarioPath) > 0 & localFileExists())
SRC.NET/GeneralLib.cs:            idx = (short)Strings.InStr(s1, s2);
SRC.NET/GeneralLib.cs:            len2 = (short)Strings.Len(s2);
SRC.NET/GeneralLib.cs:            len3 = (short)Strings.Len(s3);
SRC.NET/GeneralLib.cs:                    idx = (short)Strings.InStr(s1, s2);
SRC.NET/GeneralLib.cs:                    s1 = s1 + Strings.Left(buf, idx - 1) + s3;
SRC.NET/GeneralLib.cs:                    buf = Strings.Mid(buf, idx + len2);
SRC.NET/GeneralLib.cs:                    idx = (short)Strings.InStr(buf, s2);
SRC.NET/GeneralLib.cs:                if (Strings.Left(buf, 1) == "#")
SRC.NET/GeneralLib.cs:                idx = (short)Strings.InStr(buf, "//");
SRC.NET/GeneralLib.cs:                    buf = Strings.Left(buf, idx - 1);
SRC.NET/GeneralLib.cs:                if (Strings.Right(buf, 1) != "_")
SRC.NET/GeneralLib.cs:                line_buf = line_buf + Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/GeneralLib.cs:                withBlock.dwOSVersionInfoSize = Strings.Len(vinfo);
SRC.NET/GeneralLib.cs:            if (Strings.Asc(str_Renamed) == 40)
SRC.NET/GeneralLib.cs:            ch = Strings.Mid(aname, i, 1);
SRC.NET/GeneralLib.cs:                if (i >= Strings.Len(aname))
SRC.NET/GeneralLib.cs:                ch = Strings.Mid(aname, i, 1);
SRC.NET/GeneralLib.cs:                if (i > Strings.Len(aname))
SRC.NET/GeneralLib.cs:                ch = Strings.Mid(aname, i, 1);
SRC.NET/GeneralLib.cs:                GetClassBundleRet = Strings.Mid(aname, idx, i - idx + 1);
SRC.NET/GeneralLib.cs:                GetClassBundleRet = Strings.Mid(aname, idx, length);
SRC.NET/GeneralLib.cs:            i = (short)Strings.InStr(start, string1, string2);
SRC.NET/GeneralLib.cs:                    c = Strings.Mid(string1, i - 1, 1);
SRC.NET/GeneralLib.cs:                    if (i < Strings.Len(string1))
SRC.NET/GeneralLib.cs:                        i = (short)Strings.InStr(i + 1, string1, string2);
SRC.NET/Graphics.cs:                    withBlock4.biSize = Strings.Len(BmpInfo[i].bmiHeader);
SRC.NET/GUI.cs:            switch (Strings.LCase(GeneralLib.ReadIni(ref argini_section1, ref argini_entry1)) ?? "")
SRC.NET/GUI.cs:                            buf = GeneralLib.LeftPaddedString(ref argbuf, (short)GeneralLib.MinLng(Strings.Len(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(lu.MaxHP)), 5));
SRC.NET/GUI.cs:                            buf = GeneralLib.LeftPaddedString(ref argbuf1, (short)GeneralLib.MinLng(Strings.Len(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(lu.MaxEN)), 3));
SRC.NET/GUI.cs:                            buf = GeneralLib.LeftPaddedString(ref argbuf2, (short)GeneralLib.MinLng(Strings.Len(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(ru.MaxHP)), 5));
SRC.NET/GUI.cs:                            buf = GeneralLib.LeftPaddedString(ref argbuf3, (short)GeneralLib.MinLng(Strings.Len(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(ru.MaxEN)), 3));
SRC.NET/GUI.cs:                                    buf = GeneralLib.LeftPaddedString(ref argbuf4, (short)GeneralLib.MinLng(Strings.Len(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(lu.MaxHP)), 5));
SRC.NET/GUI.cs:                                    buf = GeneralLib.LeftPaddedString(ref argbuf5, (short)GeneralLib.MinLng(Strings.Len(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(lu.MaxEN)), 3));
SRC.NET/GUI.cs:                                    buf = GeneralLib.LeftPaddedString(ref argbuf6, (short)GeneralLib.MinLng(Strings.Len(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(ru.MaxHP)), 5));
SRC.NET/GUI.cs:                                    buf = GeneralLib.LeftPaddedString(ref argbuf7, (short)GeneralLib.MinLng(Strings.Len(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(ru.MaxEN)), 3));
SRC.NET/GUI.cs:            msg = Strings.Trim(msg);
SRC.NET/GUI.cs:            while (Strings.Right(msg, 1) == ";")
SRC.NET/GUI.cs:                msg = Strings.Left(msg, Strings.Len(msg) - 1);
SRC.NET/GUI.cs:                        if (Strings.InStr(msg, "「") > 0 & Strings.Right(msg, 1) == "」")
SRC.NET/GUI.cs:                            i = (short)Strings.InStr(msg, "「");
SRC.NET/GUI.cs:                        else if (Strings.InStr(msg, "『") > 0 & Strings.Right(msg, 1) == "』")
SRC.NET/GUI.cs:                            i = (short)Strings.InStr(msg, "『");
SRC.NET/GUI.cs:                        else if (Strings.InStr(msg, "(") > 0 & Strings.Right(msg, 1) == ")")
SRC.NET/GUI.cs:                            i = (short)Strings.InStr(msg, "(");
SRC.NET/GUI.cs:                        else if (Strings.InStr(msg, "（") > 0 & Strings.Right(msg, 1) == "）")
SRC.NET/GUI.cs:                            i = (short)Strings.InStr(msg, "（");
SRC.NET/GUI.cs:                            bool localIsDefined4() { object argIndex1 = Strings.Trim(Strings.Left(msg, i - 1)); var ret = SRC.PDList.IsDefined(ref argIndex1); return ret; }
SRC.NET/GUI.cs:                            bool localIsDefined5() { object argIndex1 = Strings.Trim(Strings.Left(msg, i - 1)); var ret = SRC.NPDList.IsDefined(ref argIndex1); return ret; }
SRC.NET/GUI.cs:                                bool localIsSpace() { string argch = Strings.Mid(msg, i - 1, 1); var ret = GeneralLib.IsSpace(ref argch); return ret; }
SRC.NET/GUI.cs:                                    msg = Strings.Left(msg, i - 1) + " " + Strings.Mid(msg, i);
SRC.NET/GUI.cs:                        if ((Strings.Left(msg, 1) == "(" | Strings.Left(msg, 1) == "（") & (Strings.Right(msg, 1) == ")" | Strings.Right(msg, 1) == "）"))
SRC.NET/GUI.cs:                            msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/GUI.cs:                        else if (Strings.Left(msg, 1) == "『" & Strings.Right(msg, 1) == "』")
SRC.NET/GUI.cs:                            msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/GUI.cs:            var loopTo = (short)Strings.Len(msg);
SRC.NET/GUI.cs:                if (Strings.Mid(msg, i, 1) == ":")
SRC.NET/GUI.cs:                    buf = buf + Strings.Mid(msg, msg_head, i - msg_head);
SRC.NET/GUI.cs:            messages[Information.UBound(messages)] = buf + Strings.Mid(msg, msg_head);
SRC.NET/GUI.cs:                var loopTo2 = (short)Strings.Len(buf);
SRC.NET/GUI.cs:                    ch = Strings.Mid(buf, j, 1);
SRC.NET/GUI.cs:                            string argmsg = Strings.Mid(buf, line_head, j - line_head);
SRC.NET/GUI.cs:                    if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > 0.95d * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                        string argmsg1 = Strings.Mid(buf, line_head, j - line_head + 1);
SRC.NET/GUI.cs:                    switch (Strings.Mid(buf, j + 1, 1) ?? "")
SRC.NET/GUI.cs:                    switch (Strings.Mid(buf, j + 2, 1) ?? "")
SRC.NET/GUI.cs:                    if (Strings.Mid(buf, j + 3, 1) == ";")
SRC.NET/GUI.cs:                    if (MessageLen(Strings.Mid(messages[i], line_head)) < 0.95d * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > cl_margin[1] * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                    string argmsg2 = Strings.Mid(buf, line_head, j - line_head + 1);
SRC.NET/GUI.cs:                                if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > cl_margin[2] * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                    string argmsg3 = Strings.Mid(buf, line_head, j - line_head + 1);
SRC.NET/GUI.cs:                                ch = Strings.Mid(buf, j - 1, 1);
SRC.NET/GUI.cs:                                    if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > cl_margin[1] * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                        string argmsg4 = Strings.Mid(buf, line_head, j - line_head + 1);
SRC.NET/GUI.cs:                                else if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > cl_margin[0] * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                    string argmsg5 = Strings.Mid(buf, line_head, j - line_head + 1);
SRC.NET/GUI.cs:                                if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > cl_margin[0] * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                    string argmsg6 = Strings.Mid(buf, line_head, j - line_head + 1);
SRC.NET/GUI.cs:                        if (j < Strings.Len(buf))
SRC.NET/GUI.cs:                    if (Strings.Len(buf) >= line_head)
SRC.NET/GUI.cs:                        string argmsg7 = Strings.Mid(buf, line_head);
SRC.NET/GUI.cs:            var loopTo = (short)Strings.Len(msg);
SRC.NET/GUI.cs:                ch = Strings.Mid(msg, i, 1);
SRC.NET/GUI.cs:                                    p.Print(Strings.Mid(msg, head, i - head));
SRC.NET/GUI.cs:                                    p.Print(Strings.Mid(msg, head, i - head));
SRC.NET/GUI.cs:                                p.Print(Strings.Mid(msg, head, i - head));
SRC.NET/GUI.cs:                                tag = Strings.LCase(Strings.Mid(msg, head, i - head));
SRC.NET/GUI.cs:                                            if (Strings.InStr(tag, "color=") == 1)
SRC.NET/GUI.cs:                                                string argexpr = Strings.Mid(tag, 7);
SRC.NET/GUI.cs:                                                            if (Strings.Asc(cname) == 35) // #
SRC.NET/GUI.cs:                                                                var midTmp = Strings.Mid(cname, 6, 2);
SRC.NET/GUI.cs:                                                                var midTmp1 = Strings.Mid(cname, 4, 2);
SRC.NET/GUI.cs:                                                                var midTmp2 = Strings.Mid(cname, 2, 2);
SRC.NET/GUI.cs:                                            else if (Strings.InStr(tag, "size=") == 1)
SRC.NET/GUI.cs:                                                if (Information.IsNumeric(Strings.Mid(tag, 6)))
SRC.NET/GUI.cs:                                                    p.Font = Microsoft.VisualBasic.Compatibility.VB6.Support.FontChangeSize(p.Font, Conversions.ToInteger(Strings.Mid(tag, 6)));
SRC.NET/GUI.cs:                                                p.Print(Strings.Mid(msg, head - 1, i - head + 2));
SRC.NET/GUI.cs:            if (head <= Strings.Len(msg))
SRC.NET/GUI.cs:                if (Strings.Right(msg, 1) == "」")
SRC.NET/GUI.cs:                    p.Print(Strings.Mid(msg, head, Strings.Len(msg) - head));
SRC.NET/GUI.cs:                    p.Print(Strings.Right(msg, 1));
SRC.NET/GUI.cs:                    p.Print(Strings.Mid(msg, head));
SRC.NET/GUI.cs:            ret = (short)Strings.InStr(msg, "<");
SRC.NET/GUI.cs:                buf = buf + Strings.Left(msg, ret - 1);
SRC.NET/GUI.cs:                msg = Strings.Mid(msg, ret + 1);
SRC.NET/GUI.cs:                ret = (short)Strings.InStr(msg, ">");
SRC.NET/GUI.cs:                    msg = Strings.Mid(msg, ret + 1);
SRC.NET/GUI.cs:                ret = (short)Strings.InStr(msg, "<");
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + "Bitmap", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + "Bitmap", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:            var loopTo = (short)Strings.Len(msg);
SRC.NET/GUI.cs:                switch (Strings.Mid(msg, i, 1) ?? "")
SRC.NET/GUI.cs:                            buf = buf + Strings.Mid(msg, line_head, i - line_head);
SRC.NET/GUI.cs:                            buf = buf + Strings.Mid(msg, line_head, i - line_head);
SRC.NET/GUI.cs:            messages[Information.UBound(messages)] = buf + Strings.Mid(msg, line_head);
SRC.NET/GUI.cs:                switch (Strings.LCase(Strings.Right(GeneralLib.LIndex(ref buf, 1), 4)) ?? "")
SRC.NET/GUI.cs:                            j = (short)Strings.InStr(fname, "[");
SRC.NET/GUI.cs:                            if (j > 0 & Strings.InStr(fname, "].") == Strings.Len(fname) - 4)
SRC.NET/GUI.cs:                                fname0 = Strings.Left(fname, j - 1);
SRC.NET/GUI.cs:                                fsuffix = Strings.Right(fname, 4);
SRC.NET/GUI.cs:                                buf2 = Strings.Mid(fname, j + 1, Strings.Len(fname) - j - 5);
SRC.NET/GUI.cs:                                j = (short)Strings.InStr(buf2, "-");
SRC.NET/GUI.cs:                                first_id = Conversions.ToShort(Strings.Left(buf2, j - 1));
SRC.NET/GUI.cs:                                last_id = Conversions.ToShort(Strings.Mid(buf2, j + 1));
SRC.NET/GUI.cs:                                            if (Strings.Asc(buf2) == 35 & Strings.Len(buf2) == 7)
SRC.NET/GUI.cs:                                                var midTmp = Strings.Mid(buf2, 6, 2);
SRC.NET/GUI.cs:                                                var midTmp1 = Strings.Mid(buf2, 4, 2);
SRC.NET/GUI.cs:                                                var midTmp2 = Strings.Mid(buf2, 2, 2);
SRC.NET/GUI.cs:                            if (Strings.Asc(fname) == 64) // @
SRC.NET/GUI.cs:                                    fname = Strings.Mid(fname, 2);
SRC.NET/GUI.cs:                                    fname0 = Strings.Mid(fname0, 2);
SRC.NET/GUI.cs:                if (Strings.Left(buf, 1) == "@")
SRC.NET/GUI.cs:                    string arganame = Strings.Mid(buf, 2);
SRC.NET/GUI.cs:                switch (Strings.LCase(GeneralLib.LIndex(ref buf, 1)) ?? "")
SRC.NET/GUI.cs:                if (pname != "システム" & (!string.IsNullOrEmpty(pname) & pname != "-" | Strings.Left(buf, 1) == "「" & Strings.Right(buf, 1) == "」" | Strings.Left(buf, 1) == "『" & Strings.Right(buf, 1) == "』"))
SRC.NET/GUI.cs:                    if (Strings.Right(buf, 1) != ":")
SRC.NET/GUI.cs:                        buf = Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/GUI.cs:                    if ((Strings.Left(buf, 1) == "(" | Strings.Left(buf, 1) == "（") & (!with_footer | Strings.Right(buf, 1) == ")" | Strings.Right(buf, 1) == "）"))
SRC.NET/GUI.cs:                            buf = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/GUI.cs:                            buf = Strings.Mid(buf, 2);
SRC.NET/GUI.cs:                    else if (Strings.Left(buf, 1) == "「" & (!with_footer | Strings.Right(buf, 1) == "」"))
SRC.NET/GUI.cs:                    else if (Strings.Left(buf, 1) == "『" & (!with_footer | Strings.Right(buf, 1) == "』"))
SRC.NET/GUI.cs:                else if (Strings.Right(buf, 1) == ":")
SRC.NET/GUI.cs:                    buf = Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/GUI.cs:                var loopTo4 = (short)Strings.Len(buf);
SRC.NET/GUI.cs:                    ch = Strings.Mid(buf, j, 1);
SRC.NET/GUI.cs:                            string argmsg = Strings.Mid(buf, line_head, j - line_head);
SRC.NET/GUI.cs:                    if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > 0.95d * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                        string argmsg1 = Strings.Mid(buf, line_head, j - line_head + 1);
SRC.NET/GUI.cs:                    switch (Strings.Mid(buf, j + 1, 1) ?? "")
SRC.NET/GUI.cs:                    switch (Strings.Mid(buf, j + 2, 1) ?? "")
SRC.NET/GUI.cs:                    if (Strings.Mid(buf, j + 3, 1) == ".")
SRC.NET/GUI.cs:                    if (MessageLen(Strings.Mid(messages[i], line_head)) < 0.95d * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > cl_margin[1] * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                    string argmsg2 = Strings.Mid(buf, line_head, j - line_head + 1);
SRC.NET/GUI.cs:                                if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > cl_margin[1] * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                    string argmsg3 = Strings.Mid(buf, line_head, j - line_head);
SRC.NET/GUI.cs:                                if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > cl_margin[2] * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                    string argmsg4 = Strings.Mid(buf, line_head, j - line_head + 1);
SRC.NET/GUI.cs:                                if (MessageLen(Strings.Mid(buf, line_head, j - line_head)) > cl_margin[0] * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                                    string argmsg5 = Strings.Mid(buf, line_head, j - line_head);
SRC.NET/GUI.cs:                if (Strings.Len(buf) >= line_head)
SRC.NET/GUI.cs:                    string argmsg6 = Strings.Mid(buf, line_head);
SRC.NET/GUI.cs:            var loopTo = (short)Strings.Len(msg);
SRC.NET/GUI.cs:                ch = Strings.Mid(msg, i, 1);
SRC.NET/GUI.cs:                        buf = Strings.Mid(msg, line_head, i - line_head);
SRC.NET/GUI.cs:                if (i < Strings.Len(msg))
SRC.NET/GUI.cs:                    if (Strings.Mid(msg, i + 1, 1) == "。" | Strings.Mid(msg, i + 1, 1) == "、")
SRC.NET/GUI.cs:                if (MessageLen(Strings.Mid(msg, line_head)) < Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                if (GeneralLib.IsSpace(ref ch) & MessageLen(Strings.Mid(msg, line_head, i - line_head)) > 0.5d * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                    buf = Strings.Mid(msg, line_head, i - line_head);
SRC.NET/GUI.cs:                else if (MessageLen(Strings.Mid(msg, line_head, i - line_head + 1)) > 0.95d * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                    buf = Strings.Mid(msg, line_head, i - line_head + 1);
SRC.NET/GUI.cs:                    var loopTo1 = (short)Strings.Len(msg);
SRC.NET/GUI.cs:                        if (Strings.Mid(msg, j, 1) == "]")
SRC.NET/GUI.cs:                    if (MessageLen(Strings.Mid(msg, line_head, j - line_head)) > 0.95d * Microsoft.VisualBasic.Compatibility.VB6.Support.PixelsToTwipsX(p.Width))
SRC.NET/GUI.cs:                        buf = Strings.Mid(msg, line_head, i - line_head);
SRC.NET/GUI.cs:            buf = Strings.Mid(msg, line_head);
SRC.NET/GUI.cs:            if (u.IsFeatureAvailable(ref argfname) & Strings.InStr(u.Name, "ステータス表示用ユニット") == 0)
SRC.NET/GUI.cs:                if (Strings.InStr(fname, @"\-.bmp") > 0)
SRC.NET/GUI.cs:                    i = (short)(Strings.Len(fname) - 5);
SRC.NET/GUI.cs:                        if (LikeOperator.LikeString(Strings.Mid(fname, i, 1), "[!-0-9]", CompareMethod.Binary))
SRC.NET/GUI.cs:                        tdir = Strings.Left(fname, i);
SRC.NET/GUI.cs:                                    tnum = Strings.Mid(fname, i + 1, Strings.Len(fname) - i - 4);
SRC.NET/GUI.cs:                                    tname = Strings.Left(fname, i) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(GeneralLib.StrToLng(ref tnum), "0000") + ".bmp";
SRC.NET/GUI.cs:                    else if (Strings.InStr(fname, @"\") > 0)
SRC.NET/GUI.cs:                if (Strings.InStr(fname, ":") == 2)
SRC.NET/GUI.cs:                else if (Strings.InStr(fname, @"\") > 0)
SRC.NET/GUI.cs:            if (Strings.InStr(fname, @"\-.bmp") > 0)
SRC.NET/GUI.cs:                if (Strings.InStr(fname, @"\Pilot\") > 0 | u.FeatureData(ref argIndex1) == "ユニット画像使用")
SRC.NET/GUI.cs:                if (Strings.InStr(lb_mode, "コメント") > 0)
SRC.NET/GUI.cs:                if (MainForm.Visible & !((int)MainForm.WindowState == 1) & withBlock.VerticalSize == "M" & Strings.InStr(lb_mode, "中央表示") == 0)
SRC.NET/GUI.cs:                if (Strings.InStr(lb_mode, "表示のみ") > 0)
SRC.NET/GUI.cs:                else if (Strings.InStr(lb_mode, "連続表示") > 0)
SRC.NET/GUI.cs:                    if (Strings.InStr(lb_mode, "カーソル移動") > 0)
SRC.NET/GUI.cs:                    if (Strings.InStr(lb_mode, "カーソル移動") > 0)
SRC.NET/GUI.cs:                    if (Strings.InStr(lb_mode, "カーソル移動") > 0 & Strings.InStr(lb_mode, "カーソル移動(行きのみ)") == 0)
SRC.NET/GUI.cs:                            wclass = Strings.Left(wclass, GeneralLib.InStrNotNest(ref wclass, ref argstring2) - 1);
SRC.NET/GUI.cs:                            wclass = Strings.Left(wclass, GeneralLib.InStrNotNest(ref wclass, ref argstring22) - 1);
SRC.NET/GUI.cs:                            else if (Strings.InStr(localEffectName6(), "ターン)") > 0)
SRC.NET/GUI.cs:                                k = (short)Strings.InStr(msg, Strings.Mid(localEffectName(), Strings.InStr(localEffectName1(), "(")));
SRC.NET/GUI.cs:                                    msg = Strings.Left(msg, k - 1) + "、" + Strings.Left(localEffectName2(), Strings.InStr(localEffectName3(), "(") - 1) + Strings.Mid(msg, k);
SRC.NET/GUI.cs:                        msg = Strings.Trim(msg);
SRC.NET/GUI.cs:                        buf = Strings.StrConv(msg, vbFromUnicode);
SRC.NET/GUI.cs:                                buf = Strings.StrConv(buf, vbUnicode);
SRC.NET/GUI.cs:                                buf = Strings.Left(buf, Strings.Len(buf) - 1);
SRC.NET/GUI.cs:                                buf = Strings.StrConv(buf, vbFromUnicode);
SRC.NET/GUI.cs:                            buf = Strings.StrConv(buf, vbUnicode);
SRC.NET/GUI.cs:                            rest_msg = Strings.Mid(msg, Strings.Len(buf) + 1);
SRC.NET/GUI.cs:                            if (LenB(Strings.StrConv(buf, vbFromUnicode)) < 32)
SRC.NET/GUI.cs:                                buf = buf + Strings.Space(32 - LenB(Strings.StrConv(buf, vbFromUnicode)));
SRC.NET/GUI.cs:                            list[Information.UBound(list)] = list[Information.UBound(list)] + " " + Strings.Left(withBlock3.Class_Renamed, GeneralLib.InStrNotNest(ref withBlock3.Class_Renamed, ref argstring2) - 1);
SRC.NET/GUI.cs:                            list[Information.UBound(list)] = Strings.Space(21) + rest_msg;
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + "Bitmap", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + "Bitmap", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + "Bitmap", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + @"Bitmap\Anime", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + @"Bitmap\Anime", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + @"Bitmap\Anime", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + @"Bitmap\Event", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + @"Bitmap\Event", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + @"Bitmap\Event", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + @"Bitmap\Cutin", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + @"Bitmap\Cutin", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + @"Bitmap\Cutin", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.AppPath + @"Bitmap\Cutin", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + @"Bitmap\Pilot", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + @"Bitmap\Pilot", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + @"Bitmap\Pilot", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.AppPath + @"Bitmap\Pilot", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + @"Bitmap\Unit", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + @"Bitmap\Unit", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + @"Bitmap\Unit", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.AppPath + @"Bitmap\Unit", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + @"Bitmap\Map", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + @"Bitmap\Map", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + @"Bitmap\Map", FileAttribute.Directory)) > 0)
SRC.NET/GUI.cs:                            if (Strings.Right(opt, 1) == "%" & Information.IsNumeric(Strings.Left(opt, Strings.Len(opt) - 1)))
SRC.NET/GUI.cs:                                trans_par = GeneralLib.MaxDbl(0d, GeneralLib.MinDbl(1d, Conversions.ToDouble(Strings.Left(opt, Strings.Len(opt) - 1)) / 100d));
SRC.NET/GUI.cs:            pic_option = Strings.Trim(pic_option);
SRC.NET/GUI.cs:            pic_option2 = Strings.Trim(pic_option2);
SRC.NET/GUI.cs:            switch (Strings.LCase(fname) ?? "")
SRC.NET/GUI.cs:            if (Strings.InStr(fname, ":") == 2)
SRC.NET/GUI.cs:            if (Strings.InStr(fname, @"\EFFECT_") > 0)
SRC.NET/GUI.cs:            if (Strings.Len(last_path) > 0)
SRC.NET/GUI.cs:            if (Strings.InStr(fname, @"Bitmap\") > 0)
SRC.NET/GUI.cs:                if (Strings.Mid(fname, 2, 1) == ":")
SRC.NET/GUI.cs:            if (Strings.InStr(fname, @"\") > 0)
SRC.NET/GUI.cs:                if (Strings.LCase(Strings.Left(fname, 4)) == @"map\")
SRC.NET/GUI.cs:                    tname = Strings.Mid(fname, 5);
SRC.NET/GUI.cs:                    if (Strings.InStr(tname, @"\") == 0)
SRC.NET/GUI.cs:                        i = (short)(Strings.Len(tname) - 5);
SRC.NET/GUI.cs:                            if (LikeOperator.LikeString(Strings.Mid(tname, i, 1), "[!-0-9]", CompareMethod.Binary))
SRC.NET/GUI.cs:                            tdir = Strings.Left(tname, i) + @"\";
SRC.NET/GUI.cs:                            tnum = Strings.Mid(tname, i + 1, Strings.Len(tname) - i - 4);
SRC.NET/GUI.cs:                            tname = Strings.Left(tname, i) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(GeneralLib.StrToLng(ref tnum), "0000") + ".bmp";
SRC.NET/GUI.cs:            else if (LikeOperator.LikeString(fname, "*#.bmp", CompareMethod.Binary) & LikeOperator.LikeString(Strings.Left(fname, 1), "[a-z]", CompareMethod.Binary))
SRC.NET/GUI.cs:                i = (short)(Strings.Len(fname) - 5);
SRC.NET/GUI.cs:                    if (LikeOperator.LikeString(Strings.Mid(fname, i, 1), "[!-0-9]", CompareMethod.Binary))
SRC.NET/GUI.cs:                    tdir = Strings.Left(fname, i);
SRC.NET/GUI.cs:                                tnum = Strings.Mid(fname, i + 1, Strings.Len(fname) - i - 4);
SRC.NET/GUI.cs:                                tname = Strings.Left(fname, i) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(GeneralLib.StrToLng(ref tnum), "0000") + ".bmp";
SRC.NET/GUI.cs:            else if (Strings.InStr(fname, "EFFECT_") > 0 | Strings.InStr(fname, @"スペシャルパワー\") > 0 | Strings.InStr(fname, @"精神コマンド\") > 0)
SRC.NET/GUI.cs:                                if (!ListItemFlag[i] & Strings.InStr(Microsoft.VisualBasic.Compatibility.VB6.Support.GetItemString(withBlock1.lstItems, i), "援護攻撃：") == 0)
SRC.NET/GUI.cs:            dm.dmSize = (short)Strings.Len(dm);
SRC.NET/GUI.cs:            if (Strings.Len(dname) > 0)
SRC.NET/GUI.cs:            if (Strings.Len(msg) > 0)
SRC.NET/GUI.cs:                if (Strings.InStr(msg, ".") > 0)
SRC.NET/GUI.cs:                    StringType.MidStmtStr(ref msg, Strings.InStr(msg, "."), Constants.vbCr.Length, Constants.vbCr);
SRC.NET/GUI.cs:                if (Strings.InStr(msg, ".") > 0)
SRC.NET/GUI.cs:                    StringType.MidStmtStr(ref msg, Strings.InStr(msg, "."), Constants.vbCr.Length, Constants.vbCr);
SRC.NET/Help.cs:                if (Strings.InStr(sindex, "Lv") > 0)
SRC.NET/Help.cs:                    stype = Strings.Left(sindex, Strings.InStr(sindex, "Lv") - 1);
SRC.NET/Help.cs:            if (Strings.Len(msg) > 0)
SRC.NET/Help.cs:                if (Strings.InStr(sindex, "Lv") > 0)
SRC.NET/Help.cs:                    stype = Strings.Left(sindex, Strings.InStr(sindex, "Lv") - 1);
SRC.NET/Help.cs:                        msg = "半径" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(p.CommandRange()), VbStrConv.Wide) + "マス以内にいる味方ザコ・汎用及び階級所有パイロットの" + Expression.Term(ref argtname53, ref u) + "・" + Expression.Term(ref argtname54, ref u);
SRC.NET/Help.cs:                        if (Strings.InStr(sname, "階級Lv") == 0)
SRC.NET/Help.cs:                            msg = "階級レベル" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((int)slevel), VbStrConv.Wide) + "に相当する。;";
SRC.NET/Help.cs:                        msg = msg + "半径" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(p.CommandRange()), VbStrConv.Wide) + "マス以内にいるザコ及び階級所有パイロットに指揮効果を与える。";
SRC.NET/Help.cs:                            if (Strings.Left(msg, 1) == "\"")
SRC.NET/Help.cs:                                msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/Help.cs:                        if (Strings.Left(msg, 1) == "\"")
SRC.NET/Help.cs:                            msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/Help.cs:                if (Strings.Left(msg, 1) == "\"")
SRC.NET/Help.cs:                    msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/Help.cs:                        if (Strings.Left(msg, 1) == "\"")
SRC.NET/Help.cs:                            msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/Help.cs:                            if (Strings.Left(msg, 1) == "\"")
SRC.NET/Help.cs:                                msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/Help.cs:            if (Strings.Len(msg) > 0)
SRC.NET/Help.cs:                if (Strings.InStr(fname, "Lv") > 0)
SRC.NET/Help.cs:                    fname0 = Strings.Left(fname, Strings.InStr(fname, "Lv") - 1);
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                                msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + Expression.Term(ref argtname1, ref u) + "増加。";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr2 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = msg + "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                                msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + Expression.Term(ref argtname4, ref u) + "増加。";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr5 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            msg = "半径" + Strings.StrConv(GeneralLib.LIndex(ref fdata, 2), VbStrConv.Wide) + "マス以内の味方ユニットに対する";
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 3), 1) == "!")
SRC.NET/Help.cs:                                msg = msg + "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + "」属性を持たない";
SRC.NET/Help.cs:                                msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 4), 2) + Expression.Term(ref argtname8, ref u) + "増加。";
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                            msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + Expression.Term(ref argtname12, ref u) + "増加。";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr10 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = msg + "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                            msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + Expression.Term(ref argtname15, ref u) + "増加。";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr13 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            msg = "半径" + Strings.StrConv(GeneralLib.LIndex(ref fdata, 2), VbStrConv.Wide) + "マス以内の味方ユニットに対する";
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 3), 1) == "!")
SRC.NET/Help.cs:                                msg = msg + "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + "」属性を持たない";
SRC.NET/Help.cs:                                msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 4), 2) + Expression.Term(ref argtname18, ref u) + "増加。";
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                            msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + Expression.Term(ref argtname23, ref u) + "増加。";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr17 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = msg + "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                            msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + Expression.Term(ref argtname27, ref u) + "増加。";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr19 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            msg = "半径" + Strings.StrConv(GeneralLib.LIndex(ref fdata, 2), VbStrConv.Wide) + "マス以内の味方ユニットに対する";
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 3), 1) == "!")
SRC.NET/Help.cs:                                msg = msg + "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + "」属性を持たない";
SRC.NET/Help.cs:                                msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 4), 2) + Expression.Term(ref argtname30, ref u) + "増加。";
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr23 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr25 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 3), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + "」属性を持たない";
SRC.NET/Help.cs:                        else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Help.cs:                            i = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Help.cs:                            sname = u.SkillName0(Strings.Left(buf, i - 1));
SRC.NET/Help.cs:                            prob = (short)((long)((u.SkillLevel(Strings.Left(buf, i - 1)) + Conversions.ToShort(Strings.Mid(buf, i))) * 100d) / 16L);
SRC.NET/Help.cs:                            msg = msg + "(" + sname + "Lv" + Strings.Mid(buf, i) + ")/16の確率(" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prob) + "%)で受け止め、";
SRC.NET/Help.cs:                        if (Strings.InStr(buf, "(") > 0)
SRC.NET/Help.cs:                            buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Help.cs:                            msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 5), 2) + Expression.Term(ref argtname36, ref u) + "増加。";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr28 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                        else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Help.cs:                            i = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Help.cs:                            sname = u.SkillName0(Strings.Left(buf, i - 1));
SRC.NET/Help.cs:                            prob = (short)((long)((u.SkillLevel(Strings.Left(buf, i - 1)) + Conversions.ToShort(Strings.Mid(buf, i))) * 100d) / 16L);
SRC.NET/Help.cs:                            msg = msg + "(" + sname + "Lv" + Strings.Mid(buf, i) + ")/16の確率(" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prob) + "%)で反射。";
SRC.NET/Help.cs:                            msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 4), 2) + Expression.Term(ref argtname39, ref u) + "増加。";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr31 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                        else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Help.cs:                            i = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Help.cs:                            sname = u.SkillName0(Strings.Left(buf, i - 1));
SRC.NET/Help.cs:                            prob = (short)((long)((u.SkillLevel(Strings.Left(buf, i - 1)) + Conversions.ToShort(Strings.Mid(buf, i))) * 100d) / 16L);
SRC.NET/Help.cs:                            msg = msg + "(" + sname + "Lv" + Strings.Mid(buf, i) + ")/16の確率(" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prob) + "%)で阻止。";
SRC.NET/Help.cs:                            msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 4), 2) + Expression.Term(ref argtname42, ref u) + "増加。";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr34 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                            msg = "半径" + Strings.StrConv(GeneralLib.LIndex(ref fdata, 2), VbStrConv.Wide) + "マス以内の味方ユニットに対する";
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 3), 1) == "!")
SRC.NET/Help.cs:                                msg = msg + "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + "」属性を持たない";
SRC.NET/Help.cs:                        else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Help.cs:                            i = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Help.cs:                            sname = u.SkillName0(Strings.Left(buf, i - 1));
SRC.NET/Help.cs:                            prob = (short)((long)((u.SkillLevel(Strings.Left(buf, i - 1)) + Conversions.ToShort(Strings.Mid(buf, i))) * 100d) / 16L);
SRC.NET/Help.cs:                            msg = msg + "(" + sname + "Lv" + Strings.Mid(buf, i) + ")/16の確率(" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prob) + "%)で阻止。";
SRC.NET/Help.cs:                            msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 5), 2) + Expression.Term(ref argtname45, ref u) + "増加。";
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 3), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + "」属性を持たない";
SRC.NET/Help.cs:                        else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Help.cs:                            i = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Help.cs:                            sname = u.SkillName0(Strings.Left(buf, i - 1));
SRC.NET/Help.cs:                            prob = (short)((long)((u.SkillLevel(Strings.Left(buf, i - 1)) + Conversions.ToShort(Strings.Mid(buf, i))) * 100d) / 16L);
SRC.NET/Help.cs:                            msg = msg + "(" + sname + "Lv" + Strings.Mid(buf, i) + ")/16の確率(" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prob) + "%)で、";
SRC.NET/Help.cs:                        if (Strings.InStr(buf, "(") > 0)
SRC.NET/Help.cs:                            buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Help.cs:                            msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 5), 2) + Expression.Term(ref argtname51, ref u) + "増加。";
SRC.NET/Help.cs:                            idx = (short)Strings.InStr(opt, "*");
SRC.NET/Help.cs:                                string argexpr39 = Strings.Mid(opt, idx + 1);
SRC.NET/Help.cs:                                opt = Strings.Left(opt, idx - 1);
SRC.NET/Help.cs:                                msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + Expression.Term(ref argtname63, ref u) + "増加。";
SRC.NET/Help.cs:                                msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 3), 2) + Expression.Term(ref argtname66, ref u) + "増加。";
SRC.NET/Help.cs:                        if (Conversions.ToBoolean(Strings.InStr(buf, "Lv")))
SRC.NET/Help.cs:                            buf = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
SRC.NET/Help.cs:                            if (Strings.Left(GeneralLib.LIndex(ref fdata, 2), 1) == "!")
SRC.NET/Help.cs:                                msg = "「" + Strings.Mid(GeneralLib.LIndex(ref fdata, 2), 2) + "」属性を持たない";
SRC.NET/Help.cs:                            if (Strings.Left(buf, 1) == "!")
SRC.NET/Help.cs:                                buf = Strings.Mid(buf, 2);
SRC.NET/Help.cs:                            msg = "敵から" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(flevel), VbStrConv.Wide) + "マス以内にいない限り発見されない。" + "ただし自分から攻撃すると１ターン無効。";
SRC.NET/Help.cs:                                        if (Strings.Right(uname, 5) == "(前期型)")
SRC.NET/Help.cs:                                            uname = Strings.Left(uname, Strings.Len(uname) - 5);
SRC.NET/Help.cs:                                        else if (Strings.Right(uname, 5) == "・前期型)")
SRC.NET/Help.cs:                                            uname = Strings.Left(uname, Strings.Len(uname) - 5) + ")";
SRC.NET/Help.cs:                                        else if (Strings.Right(uname, 5) == "(後期型)")
SRC.NET/Help.cs:                                            uname = Strings.Left(uname, Strings.Len(uname) - 5);
SRC.NET/Help.cs:                            if (Strings.Right(uname, 5) == "(前期型)")
SRC.NET/Help.cs:                                uname = Strings.Left(uname, Strings.Len(uname) - 5);
SRC.NET/Help.cs:                            else if (Strings.Right(uname, 5) == "・前期型)")
SRC.NET/Help.cs:                                uname = Strings.Left(uname, Strings.Len(uname) - 5) + ")";
SRC.NET/Help.cs:                            else if (Strings.Right(uname, 5) == "(後期型)")
SRC.NET/Help.cs:                                uname = Strings.Left(uname, Strings.Len(uname) - 5);
SRC.NET/Help.cs:                        if (Strings.Right(uname, 5) == "(前期型)")
SRC.NET/Help.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 5);
SRC.NET/Help.cs:                        else if (Strings.Right(uname, 5) == "・前期型)")
SRC.NET/Help.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 5) + ")";
SRC.NET/Help.cs:                        else if (Strings.Right(uname, 5) == "(後期型)")
SRC.NET/Help.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 5);
SRC.NET/Help.cs:                        if (Strings.Right(uname, 5) == "(前期型)")
SRC.NET/Help.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 5);
SRC.NET/Help.cs:                        else if (Strings.Right(uname, 5) == "・前期型)")
SRC.NET/Help.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 5) + ")";
SRC.NET/Help.cs:                        else if (Strings.Right(uname, 5) == "(後期型)")
SRC.NET/Help.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 5);
SRC.NET/Help.cs:                        if (Strings.Right(uname, 5) == "(前期型)")
SRC.NET/Help.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 5);
SRC.NET/Help.cs:                        else if (Strings.Right(uname, 5) == "・前期型)")
SRC.NET/Help.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 5) + ")";
SRC.NET/Help.cs:                        else if (Strings.Right(uname, 5) == "(後期型)")
SRC.NET/Help.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 5);
SRC.NET/Help.cs:                        if (Strings.InStr(fdata, "気力発動") > 0)
SRC.NET/Help.cs:                        if (Strings.InStr(fdata, "自動発動") > 0)
SRC.NET/Help.cs:                        if (Conversions.ToBoolean(Strings.InStr(buf, "Lv")))
SRC.NET/Help.cs:                            buf = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
SRC.NET/Help.cs:                        fdata = Strings.Trim(u.WeaponProficiency());
SRC.NET/Help.cs:                        fdata = Strings.Trim(u.ArmorProficiency());
SRC.NET/Help.cs:                            if (Strings.Left(buf, 1) == "@")
SRC.NET/Help.cs:                                msg = Strings.Mid(buf, 2) + "による";
SRC.NET/Help.cs:                        else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Help.cs:                            i = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Help.cs:                            sname = u.SkillName0(Strings.Left(buf, i - 1));
SRC.NET/Help.cs:                            prob = (short)((long)((u.SkillLevel(Strings.Left(buf, i - 1)) + Conversions.ToShort(Strings.Mid(buf, i))) * 100d) / 16L);
SRC.NET/Help.cs:                            msg = msg + "(" + sname + "Lv" + Strings.Mid(buf, i) + ")/16の確率(" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prob) + "%)で";
SRC.NET/Help.cs:                        if (Strings.InStr(buf, "(") > 0)
SRC.NET/Help.cs:                            buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Help.cs:                            msg = msg + ";発動時に" + Strings.Mid(GeneralLib.LIndex(ref fdata, 5), 2) + "ＥＮ増加。";
SRC.NET/Help.cs:                        if (Strings.InStr(fdata, "連鎖不可") > 0)
SRC.NET/Help.cs:                            if (Strings.InStr(opt, "直線") > 0)
SRC.NET/Help.cs:                            else if (Strings.InStr(opt, " 水平") > 0)
SRC.NET/Help.cs:                            else if (Strings.InStr(opt, " 垂直") > 0)
SRC.NET/Help.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Help.cs:                            if (Strings.Len(fdata) > 0)
SRC.NET/Help.cs:                                if (Strings.Left(msg, 1) == "\"")
SRC.NET/Help.cs:                                    msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/Help.cs:                            if (Strings.Len(msg) == 0)
SRC.NET/Help.cs:                        else if (Strings.Len(fdata) > 0)
SRC.NET/Help.cs:                            if (Strings.Left(msg, 1) == "\"")
SRC.NET/Help.cs:                                msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/Help.cs:                if (Strings.Left(msg, 1) == "\"")
SRC.NET/Help.cs:                    msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/Help.cs:                        if (Strings.Left(atr, 1) == "弱")
SRC.NET/Help.cs:                            AttributeNameRet = Strings.Mid(atr, 2) + "属性弱点付加攻撃";
SRC.NET/Help.cs:                        else if (Strings.Left(atr, 1) == "効")
SRC.NET/Help.cs:                            AttributeNameRet = Strings.Mid(atr, 2) + "属性有効付加攻撃";
SRC.NET/Help.cs:                        else if (Strings.Left(atr, 1) == "剋")
SRC.NET/Help.cs:                            AttributeNameRet = Strings.Mid(atr, 2) + "属性使用妨害攻撃";
SRC.NET/Help.cs:                if (Strings.Right(AttributeNameRet, 2) == "攻撃" | Strings.Right(AttributeNameRet, 2) == "武器")
SRC.NET/Help.cs:                    AttributeNameRet = Strings.Left(AttributeNameRet, Strings.Len(AttributeNameRet) - 2) + Expression.Term(ref argtname17, ref u);
SRC.NET/Help.cs:            if (Strings.Len(msg) > 0)
SRC.NET/Help.cs:                if (Strings.InStr(atr, "L") > 0)
SRC.NET/Help.cs:                    string localAttributeName() { string argatr = Strings.Left(atr, Strings.InStr(atr, "L") - 1); var ret = AttributeName(ref u, ref argatr, is_ability); return ret; }
SRC.NET/Help.cs:                    aname = localAttributeName() + "レベル" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Strings.Mid(atr, Strings.InStr(atr, "L") + 1)), VbStrConv.Wide);
SRC.NET/Help.cs:            if (Strings.InStr(atr, "L") > 0)
SRC.NET/Help.cs:                atype = Strings.Left(atr, Strings.InStr(atr, "L") - 1);
SRC.NET/Help.cs:                alevel = Conversions.ToDouble(Strings.Mid(atr, Strings.InStr(atr, "L") + 1));
SRC.NET/Help.cs:                                msg = "全" + Expression.Term(ref argtname29, ref u) + "を使って攻撃し、使用後に" + Expression.Term(ref argtname30, ref u) + "が0になる。;" + "(残り" + Expression.Term(ref argtname31, ref u) + "－必要" + Expression.Term(ref argtname32, ref u) + ")×" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(alevel), VbStrConv.Wide) + "だけ攻撃力が上昇。";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                                msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                                msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                                msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = "クリティカル発生時に相手を「死の宣告」状態にし、" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン後に" + Expression.Term(ref argtname39, ref u) + "を１にする。";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = "相手ユニットを" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "マス吹き飛ばす。;" + "クリティカル発生時は吹き飛ばし距離＋１。";
SRC.NET/Help.cs:                            msg = "相手ユニットを" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "マス吹き飛ばす。;" + "クリティカル発生時は吹き飛ばし距離＋１。" + Expression.Term(ref argtname50, ref u) + "制限あり。";
SRC.NET/Help.cs:                        msg = "クリティカル発生時に相手ユニットを" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "マス強制テレポートさせる。テレポート先はランダムに選ばれる。";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                            msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                                msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                                msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                        msg = "相手のメインパイロットのレベルが" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "の倍数の場合にのみ有効な" + whatsthis + "。";
SRC.NET/Help.cs:                        msg = "最小射程が" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "になる。";
SRC.NET/Help.cs:                        switch (Strings.Left(atype, 1) ?? "")
SRC.NET/Help.cs:                                    msg = "クリティカル発生時に相手に" + Strings.Mid(atype, 2) + "属性に対する弱点を";
SRC.NET/Help.cs:                                        msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                                    msg = "クリティカル発生時に相手に" + Strings.Mid(atype, 2) + "属性に対する有効を";
SRC.NET/Help.cs:                                        msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                                    switch (Strings.Mid(atype, 2) ?? "")
SRC.NET/Help.cs:                                                msg = msg + Strings.Mid(atype, 2) + "属性の武器、アビリティ";
SRC.NET/Help.cs:                                        msg = msg + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format((short)alevel), VbStrConv.Wide) + "ターン";
SRC.NET/Help.cs:                if (Strings.Left(msg, 1) == "\"")
SRC.NET/Help.cs:                    msg = Strings.Mid(msg, 2, Strings.Len(msg) - 2);
SRC.NET/Intermission.cs:            if (Strings.InStr(Sound.BGMFileName, @"\" + Sound.BGMName(ref argbgm_name2)) == 0)
SRC.NET/Intermission.cs:                                if (Strings.Left(u.Class_Renamed, 1) == "(")
SRC.NET/Intermission.cs:                    if (Strings.InStr(var.Name, "IntermissionCommand(") == 1)
SRC.NET/Intermission.cs:                        ret = (short)Strings.Len("IntermissionCommand(");
SRC.NET/Intermission.cs:                        buf = Strings.Mid(var.Name, ret + 1, Strings.Len(var.Name) - ret - 1);
SRC.NET/Intermission.cs:                            if (Strings.InStr(fname, @"\") > 0)
SRC.NET/Intermission.cs:                                save_path = Strings.Left(fname, GeneralLib.InStr2(ref fname, ref argstr2));
SRC.NET/Intermission.cs:                        list[Information.UBound(list)] = localRightPaddedString1() + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock.Rank), VbStrConv.Wide);
SRC.NET/Intermission.cs:            if (Strings.InStr(sort_mode, "名称") == 0)
SRC.NET/Intermission.cs:                        if (Strings.StrComp(strkey_list[j], max_str, (CompareMethod)1) == -1)
SRC.NET/Intermission.cs:                                    list[j] = localRightPaddedString4() + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock8.Rank), VbStrConv.Wide);
SRC.NET/Intermission.cs:                    list[ret] = localRightPaddedString7() + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock7.Rank), VbStrConv.Wide);
SRC.NET/Intermission.cs:                        string localLeftPaddedString() { string argbuf = Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock.Level), VbStrConv.Wide); var ret = GeneralLib.LeftPaddedString(ref argbuf, 4); return ret; }
SRC.NET/Intermission.cs:                        string localLeftPaddedString1() { string argbuf = Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock.Level), VbStrConv.Wide); var ret = GeneralLib.LeftPaddedString(ref argbuf, 4); return ret; }
SRC.NET/Intermission.cs:                        string localLeftPaddedString2() { string argbuf = Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock.Level), VbStrConv.Wide); var ret = GeneralLib.LeftPaddedString(ref argbuf, 4); return ret; }
SRC.NET/Intermission.cs:                        if (Strings.StrComp(strkey_list[j], max_str, (CompareMethod)1) == -1)
SRC.NET/Intermission.cs:                        if (Strings.InStr(p.Class_Renamed, "専属サポート") == 0)
SRC.NET/Intermission.cs:                            list[Information.UBound(list)] = list[Information.UBound(list)] + " " + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock8.Rank), VbStrConv.Wide);
SRC.NET/Intermission.cs:                        list[Information.UBound(list)] = " " + localRightPaddedString4() + Strings.Space(21);
SRC.NET/Intermission.cs:                            list[Information.UBound(list)] = list[Information.UBound(list)] + " " + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock8.Rank), VbStrConv.Wide);
SRC.NET/Intermission.cs:            if (Strings.InStr(sort_mode2, "名称") == 0)
SRC.NET/Intermission.cs:                        if (Strings.StrComp(strkey_list[j], max_str, (CompareMethod)1) == -1)
SRC.NET/Intermission.cs:                        list[Information.UBound(list)] = list[Information.UBound(list)] + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock.Rank), VbStrConv.Wide);
SRC.NET/Intermission.cs:            if (Strings.InStr(sort_mode, "名称") == 0)
SRC.NET/Intermission.cs:                        if (Strings.StrComp(strkey_list[j], max_str, (CompareMethod)1) == -1)
SRC.NET/Intermission.cs:                        if (Strings.InStr(buf, "腕") > 0)
SRC.NET/Intermission.cs:                        if (Strings.InStr(buf, "肩") > 0)
SRC.NET/Intermission.cs:                        if (Strings.InStr(buf, "体") > 0)
SRC.NET/Intermission.cs:                        if (Strings.InStr(buf, "頭") > 0)
SRC.NET/Intermission.cs:                                if (Strings.StrComp(strkey_list[j], max_str, (CompareMethod)1) == -1)
SRC.NET/Intermission.cs:                            list[Information.UBound(list)] = localRightPaddedString() + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock.Rank), VbStrConv.Wide);
SRC.NET/Intermission.cs:                        list[Information.UBound(list)] = localRightPaddedString2() + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock.Rank), VbStrConv.Wide);
SRC.NET/Intermission.cs:                if (Strings.InStr(SRC.ScenarioFileName, @"\ユニットステータス表示.eve") > 0 | Strings.InStr(SRC.ScenarioFileName, @"\パイロットステータス表示.eve") > 0 | SRC.IsSubStage)
SRC.NET/Item.cs:            if (Strings.Right(Class0Ret, 3) == "専用)")
SRC.NET/Item.cs:                i = (short)(Strings.Len(Class0Ret) - 2);
SRC.NET/Item.cs:                    switch (Strings.Mid(Class0Ret, i, 1) ?? "")
SRC.NET/Item.cs:                                    Class0Ret = Strings.Left(Class0Ret, i - 1);
SRC.NET/Item.cs:                        if (Strings.InStr(u.FeatureData(ref argIndex1), "腕") == 0)
SRC.NET/Item.cs:                        if (Strings.InStr(u.FeatureData(ref argIndex2), "肩") == 0)
SRC.NET/Item.cs:                        if (Strings.InStr(u.FeatureData(ref argIndex3), "体") == 0)
SRC.NET/Item.cs:                        if (Strings.InStr(u.FeatureData(ref argIndex4), "頭") == 0)
SRC.NET/Item.cs:                                if (Strings.Right(sname, 2) == "装備")
SRC.NET/Item.cs:                                    if ((Strings.Left(sname, Strings.Len(sname) - 2) ?? "") == (Name ?? "") | (Strings.Left(sname, Strings.Len(sname) - 2) ?? "") == (Class0() ?? ""))
SRC.NET/Item.cs:                                    if (Strings.Left(fdata, 1) == "\"")
SRC.NET/Item.cs:                                        fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/Item.cs:                                    if (Strings.InStr(fdata, "=") > 0)
SRC.NET/Item.cs:                                        fdata = Strings.Left(fdata, Strings.InStr(fdata, "=") - 1);
SRC.NET/Item.cs:                                if (Strings.Right(sname, 2) == "装備")
SRC.NET/Item.cs:                                    if ((Strings.Left(sname, Strings.Len(sname) - 2) ?? "") == (Name ?? "") | (Strings.Left(sname, Strings.Len(sname) - 2) ?? "") == (Class0() ?? ""))
SRC.NET/Item.cs:                                    if (Strings.Left(fdata, 1) == "\"")
SRC.NET/Item.cs:                                        fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/Item.cs:                                    if (Strings.InStr(fdata, "=") > 0)
SRC.NET/Item.cs:                                        fdata = Strings.Left(fdata, Strings.InStr(fdata, "=") - 1);
SRC.NET/ItemData.cs:                if (Strings.InStr(NicknameRet, "主人公") == 1 | Strings.InStr(NicknameRet, "ヒロイン") == 1)
SRC.NET/ItemData.cs:                if (Strings.InStr(KanaNameRet, "主人公") == 1 | Strings.InStr(KanaNameRet, "ヒロイン") == 1 | Strings.InStr(KanaNameRet, "ひろいん") == 1)
SRC.NET/ItemData.cs:            if (Strings.Right(fdef, 1) == ")")
SRC.NET/ItemData.cs:                i = (short)Strings.InStr(fdef, " (");
SRC.NET/ItemData.cs:                    nskill = Strings.Trim(Strings.Mid(fdef, i + 2, Strings.Len(fdef) - i - 2));
SRC.NET/ItemData.cs:                    buf = Strings.Trim(Strings.Left(fdef, i));
SRC.NET/ItemData.cs:                else if (Strings.Left(fdef, 1) == "(")
SRC.NET/ItemData.cs:                    nskill = Strings.Trim(Strings.Mid(fdef, 2, Strings.Len(fdef) - 2));
SRC.NET/ItemData.cs:            if (Strings.Right(buf, 1) == ">")
SRC.NET/ItemData.cs:                i = (short)Strings.InStr(buf, " <");
SRC.NET/ItemData.cs:                    ncondition = Strings.Trim(Strings.Mid(buf, i + 2, Strings.Len(buf) - i - 2));
SRC.NET/ItemData.cs:                    buf = Strings.Trim(Strings.Left(buf, i));
SRC.NET/ItemData.cs:                else if (Strings.Left(buf, 1) == "<")
SRC.NET/ItemData.cs:                    ncondition = Strings.Trim(Strings.Mid(buf, 2, Strings.Len(buf) - 2));
SRC.NET/ItemData.cs:            i = (short)Strings.InStr(buf, "Lv");
SRC.NET/ItemData.cs:            j = (short)Strings.InStr(buf, "=");
SRC.NET/ItemData.cs:                ftype = Strings.Left(buf, i - 1);
SRC.NET/ItemData.cs:                    flevel = Conversions.ToDouble(Strings.Mid(buf, i + 2, j - (i + 2)));
SRC.NET/ItemData.cs:                    fdata = Strings.Mid(buf, j + 1);
SRC.NET/ItemData.cs:                    flevel = Conversions.ToDouble(Strings.Mid(buf, i + 2));
SRC.NET/ItemData.cs:                ftype = Strings.Left(buf, j - 1);
SRC.NET/ItemData.cs:                fdata = Strings.Mid(buf, j + 1);
SRC.NET/ItemData.cs:            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/ItemData.cs:                if (Strings.Right(fdata, 1) == "\"")
SRC.NET/ItemData.cs:                    fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/ItemData.cs:                                if (!string.IsNullOrEmpty(fdata) & Strings.InStr(withBlock.get_AliasData(i), "非表示") != 1)
SRC.NET/ItemData.cs:            if (Strings.Len(fd.StrData) > 0)
SRC.NET/ItemDataList.cs:                while (Strings.Len(line_buf) == 0);
SRC.NET/ItemDataList.cs:                if (Strings.InStr(line_buf, ",") > 0)
SRC.NET/ItemDataList.cs:                if (Strings.InStr(data_name, " ") > 0)
SRC.NET/ItemDataList.cs:                if (Strings.InStr(data_name, "（") > 0 | Strings.InStr(data_name, "）") > 0)
SRC.NET/ItemDataList.cs:                if (Strings.InStr(data_name, "\"") > 0)
SRC.NET/ItemDataList.cs:                var loopTo = (short)Strings.Len(line_buf);
SRC.NET/ItemDataList.cs:                    if (Strings.Mid(line_buf, (int)i, 1) == ",")
SRC.NET/ItemDataList.cs:                if (Strings.Len(line_buf) == 0)
SRC.NET/ItemDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/ItemDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                buf2 = Strings.Trim(buf);
SRC.NET/ItemDataList.cs:                if (Strings.Len(buf2) == 0)
SRC.NET/ItemDataList.cs:                        var loopTo1 = (short)Strings.Len(buf);
SRC.NET/ItemDataList.cs:                            switch (Strings.Mid(buf, (int)j, 1) ?? "")
SRC.NET/ItemDataList.cs:                            buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                            buf = Strings.Trim(Strings.Mid(buf, (int)ret + 1));
SRC.NET/ItemDataList.cs:                else if (Strings.InStr(line_buf, "特殊能力,") == 1)
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(line_buf, 6);
SRC.NET/ItemDataList.cs:                    var loopTo2 = (short)Strings.Len(buf);
SRC.NET/ItemDataList.cs:                        switch (Strings.Mid(buf, (int)j, 1) ?? "")
SRC.NET/ItemDataList.cs:                        buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                        buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                        ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(buf);
SRC.NET/ItemDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/ItemDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                buf2 = Strings.Trim(buf);
SRC.NET/ItemDataList.cs:                if (Strings.Len(buf2) == 0)
SRC.NET/ItemDataList.cs:                while (Strings.Len(line_buf) > 0 & Strings.Left(line_buf, 1) != "*" & line_buf != "===")
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/ItemDataList.cs:                    wname = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    if (Strings.Len(buf2) == 4)
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    buf = Strings.Trim(buf);
SRC.NET/ItemDataList.cs:                    if (Strings.Len(buf) == 0)
SRC.NET/ItemDataList.cs:                    if (Strings.Right(buf, 1) == ")")
SRC.NET/ItemDataList.cs:                        ret = (short)Strings.InStr(buf, "> ");
SRC.NET/ItemDataList.cs:                                wd.NecessarySkill = Strings.Mid(buf, (int)ret + 2);
SRC.NET/ItemDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, (int)ret + 1));
SRC.NET/ItemDataList.cs:                                ret = (short)Strings.InStr(wd.NecessarySkill, "(");
SRC.NET/ItemDataList.cs:                                wd.NecessarySkill = Strings.Mid(wd.NecessarySkill, (int)ret + 1, Strings.Len(wd.NecessarySkill) - (int)ret - 1);
SRC.NET/ItemDataList.cs:                            ret = (short)Strings.InStr(buf, "(");
SRC.NET/ItemDataList.cs:                                wd.NecessarySkill = Strings.Trim(Strings.Mid(buf, (int)ret + 1, Strings.Len(buf) - (int)ret - 1));
SRC.NET/ItemDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    if (Strings.Right(buf, 1) == ">")
SRC.NET/ItemDataList.cs:                        ret = (short)Strings.InStr(buf, "<");
SRC.NET/ItemDataList.cs:                            wd.NecessaryCondition = Strings.Trim(Strings.Mid(buf, (int)ret + 1, Strings.Len(buf) - (int)ret - 1));
SRC.NET/ItemDataList.cs:                            buf = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    if (Strings.InStr(wd.Class_Renamed, "Lv") > 0)
SRC.NET/ItemDataList.cs:                while (Strings.Len(line_buf) > 0 & Strings.Left(line_buf, 1) != "*")
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/ItemDataList.cs:                    sname = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/ItemDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/ItemDataList.cs:                    buf = Strings.Trim(buf);
SRC.NET/ItemDataList.cs:                    if (Strings.Len(buf) == 0)
SRC.NET/ItemDataList.cs:                    if (Strings.Right(buf, 1) == ")")
SRC.NET/ItemDataList.cs:                        ret = (short)Strings.InStr(buf, "> ");
SRC.NET/ItemDataList.cs:                                sd.NecessarySkill = Strings.Mid(buf, (int)ret + 2);
SRC.NET/ItemDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, (int)ret + 1));
SRC.NET/ItemDataList.cs:                                ret = (short)Strings.InStr(sd.NecessarySkill, "(");
SRC.NET/ItemDataList.cs:                                sd.NecessarySkill = Strings.Mid(sd.NecessarySkill, (int)ret + 1, Strings.Len(sd.NecessarySkill) - (int)ret - 1);
SRC.NET/ItemDataList.cs:                            ret = (short)Strings.InStr(buf, "(");
SRC.NET/ItemDataList.cs:                                sd.NecessarySkill = Strings.Trim(Strings.Mid(buf, (int)ret + 1, Strings.Len(buf) - (int)ret - 1));
SRC.NET/ItemDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    if (Strings.Right(buf, 1) == ">")
SRC.NET/ItemDataList.cs:                        ret = (short)Strings.InStr(buf, "<");
SRC.NET/ItemDataList.cs:                            sd.NecessaryCondition = Strings.Trim(Strings.Mid(buf, (int)ret + 1, Strings.Len(buf) - (int)ret - 1));
SRC.NET/ItemDataList.cs:                            buf = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/ItemDataList.cs:                    if (Strings.InStr(sd.Class_Renamed, "Lv") > 0)
SRC.NET/ItemDataList.cs:                while (Strings.Left(line_buf, 1) == "*")
SRC.NET/ItemDataList.cs:                    if (Strings.Len(nd.Comment) > 0)
SRC.NET/ItemDataList.cs:                    nd.Comment = nd.Comment + Strings.Mid(line_buf, 2);
SRC.NET/LabelData.cs:                switch (Strings.Asc(lname))
SRC.NET/LabelData.cs:                            lname = Strings.Mid(lname, 2);
SRC.NET/LabelData.cs:                            switch (Strings.Asc(lname))
SRC.NET/LabelData.cs:                                        lname = Strings.Mid(lname, 2);
SRC.NET/LabelData.cs:                                        lname = Strings.Mid(lname, 2);
SRC.NET/LabelData.cs:                            lname = Strings.Mid(lname, 2);
SRC.NET/LabelData.cs:                            switch (Strings.Asc(lname))
SRC.NET/LabelData.cs:                                        lname = Strings.Mid(lname, 2);
SRC.NET/LabelData.cs:                                        lname = Strings.Mid(lname, 2);
SRC.NET/LabelData.cs:                        if (Strings.InStr(strParas[i], "主人公") != 1 & Strings.InStr(strParas[i], "ヒロイン") != 1)
SRC.NET/LabelData.cs:                                    if (Strings.Left(strParas[i], 1) == "\"" & Strings.Right(strParas[i], 1) == "\"")
SRC.NET/LabelData.cs:                                        if (Strings.InStr(strParas[i], "$(") == 0)
SRC.NET/LabelData.cs:                                            strParas[i] = Strings.Mid(strParas[i], 2, Strings.Len(strParas[i]) - 2);
SRC.NET/Map.cs:                if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + @"Bitmap\Map", FileAttribute.Directory)) > 0)
SRC.NET/Map.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + @"Bitmap\Map", FileAttribute.Directory)) > 0)
SRC.NET/Map.cs:                if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + @"Bitmap\Map", FileAttribute.Directory)) > 0)
SRC.NET/Map.cs:                if (Strings.InStr(SRC.ScenarioFileName, "ステータス表示.") > 0 | Strings.InStr(SRC.ScenarioFileName, "ランキング.") > 0)
SRC.NET/Map.cs:            if (Strings.InStr(MapFileName, SRC.ScenarioPath) == 1)
SRC.NET/Map.cs:                fname = Strings.Right(MapFileName, Strings.Len(MapFileName) - Strings.Len(SRC.ScenarioPath));
SRC.NET/Map.cs:            if (Strings.InStr(sbuf1, ":") == 0)
SRC.NET/Map.cs:                    if (Strings.Right(sbuf2, 7) == "(マップ限定)")
SRC.NET/Map.cs:                        MapDrawMode = Strings.Left(sbuf2, Strings.Len(sbuf2) - 7);
SRC.NET/Map.cs:                if (Strings.Right(sbuf2, 7) == "(マップ限定)")
SRC.NET/Map.cs:                    MapDrawMode = Strings.Left(sbuf2, Strings.Len(sbuf2) - 7);
SRC.NET/Map.cs:                if (Strings.Mid(withBlock.Data.Adaption, 3, 1) != "-" | withBlock.IsFeatureAvailable(ref argfname))
SRC.NET/Map.cs:                if (Strings.Mid(withBlock.Data.Adaption, 4, 1) != "-" | withBlock.IsFeatureAvailable(ref argfname1))
SRC.NET/Map.cs:                                            if (Conversions.ToBoolean(Strings.InStr(withBlock1.FeatureData(ref argIndex16), "直線")))
SRC.NET/Map.cs:                                                if (Conversions.ToBoolean(Strings.InStr(withBlock1.FeatureData(ref argIndex14), "水平")))
SRC.NET/Map.cs:                                                if (Conversions.ToBoolean(Strings.InStr(withBlock1.FeatureData(ref argIndex15), "垂直")))
SRC.NET/Map.cs:            if (Strings.Mid(u.Data.Adaption, 3, 1) != "-" | u.IsFeatureAvailable(ref argfname))
SRC.NET/Map.cs:            if (Strings.Mid(u.Data.Adaption, 4, 1) != "-" | u.IsFeatureAvailable(ref argfname1))
SRC.NET/Map.cs:            if (Strings.Mid(u.Data.Adaption, 3, 1) != "-" | u.IsFeatureAvailable(ref argfname))
SRC.NET/Map.cs:            if (Strings.Mid(u.Data.Adaption, 4, 1) != "-" | u.IsFeatureAvailable(ref argfname1))
SRC.NET/Map.cs:            if (Strings.Mid(u.Data.Adaption, 3, 1) != "-" | u.IsFeatureAvailable(ref argfname))
SRC.NET/MessageData.cs:                    if ((Strings.Left(strSituation[i], Strings.Len(situations[j])) ?? "") == (situations[j] ?? ""))
SRC.NET/MessageData.cs:                if (Strings.InStr(strSituation[list0[i]], "(対") > 0)
SRC.NET/MessageData.cs:                if (Strings.Len(withBlock.strWeakness) > 0)
SRC.NET/MessageData.cs:                    var loopTo7 = (short)Strings.Len(withBlock.strWeakness);
SRC.NET/MessageData.cs:                if (Strings.Len(withBlock.strEffective) > 0)
SRC.NET/MessageData.cs:                    var loopTo8 = (short)Strings.Len(withBlock.strEffective);
SRC.NET/MessageData.cs:                if (Strings.InStr(withBlock.MainPilot().Name, "(ザコ)") > 0 & (u.MainPilot().Technique > withBlock.MainPilot().Technique | u.HP > withBlock.HP / 2))
SRC.NET/MessageData.cs:                if (withBlock.BossRank >= 0 | Strings.InStr(withBlock.MainPilot().Name, "(ザコ)") == 0 & u.MainPilot().Technique <= withBlock.MainPilot().Technique)
SRC.NET/MessageData.cs:                    var loopTo9 = (short)Strings.Len(wclass);
SRC.NET/MessageData.cs:                if (GeneralLib.Dice(2) == 1 | Strings.InStr(msg_situation, "(とどめ)") > 0 | msg_situation == "挑発" | msg_situation == "脱力" | msg_situation == "魅惑" | msg_situation == "威圧" | (u.Party ?? "") == (t.Party ?? ""))
SRC.NET/MessageDataList.cs:            if (Strings.InStr(Strings.LCase(fname), "effect.txt") > 0 | Strings.InStr(Strings.LCase(fname), "animation.txt") > 0)
SRC.NET/MessageDataList.cs:                while (Strings.Len(line_buf) == 0);
SRC.NET/MessageDataList.cs:                if (Strings.InStr(line_buf, ",") > 0)
SRC.NET/MessageDataList.cs:                if (Strings.InStr(data_name, " ") > 0)
SRC.NET/MessageDataList.cs:                if (Strings.InStr(data_name, "（") > 0 | Strings.InStr(data_name, "）") > 0)
SRC.NET/MessageDataList.cs:                if (Strings.InStr(data_name, "\"") > 0)
SRC.NET/MessageDataList.cs:                while (Strings.Len(line_buf) > 0)
SRC.NET/MessageDataList.cs:                    ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/MessageDataList.cs:                    sname = Strings.Left(line_buf, (int)ret - 1);
SRC.NET/MessageDataList.cs:                    msg = Strings.Trim(Strings.Mid(line_buf, (int)ret + 1));
SRC.NET/MessageDataList.cs:                    if (Strings.Len(sname) == 0)
SRC.NET/MultiSelectListBox.cs:                Microsoft.VisualBasic.Compatibility.VB6.Support.SetItemString(lstItems, i - 1, "　" + Strings.Mid(Microsoft.VisualBasic.Compatibility.VB6.Support.GetItemString(lstItems, i - 1), 2));
SRC.NET/MultiSelectListBox.cs:                    Microsoft.VisualBasic.Compatibility.VB6.Support.SetItemString(lstItems, i - 1, "○" + Strings.Mid(Microsoft.VisualBasic.Compatibility.VB6.Support.GetItemString(lstItems, i - 1), 2));
SRC.NET/MultiSelectListBox.cs:                Microsoft.VisualBasic.Compatibility.VB6.Support.SetItemString(lstItems, i - 1, "　" + Strings.Mid(Microsoft.VisualBasic.Compatibility.VB6.Support.GetItemString(lstItems, i - 1), 2));
SRC.NET/MultiSelectListBox.cs:                    Microsoft.VisualBasic.Compatibility.VB6.Support.SetItemString(lstItems, lstItems.Items.Count - i, "○" + Strings.Mid(Microsoft.VisualBasic.Compatibility.VB6.Support.GetItemString(lstItems, lstItems.Items.Count - i), 2));
SRC.NET/MultiSelectListBox.cs:                        if (Strings.StrComp(strkey_list[j], max_str, (CompareMethod)1) == -1)
SRC.NET/MultiSelectListBox.cs:                    Microsoft.VisualBasic.Compatibility.VB6.Support.SetItemString(lstItems, i, "　" + Strings.Mid(Microsoft.VisualBasic.Compatibility.VB6.Support.GetItemString(lstItems, i), 2));
SRC.NET/MultiSelectListBox.cs:                    Microsoft.VisualBasic.Compatibility.VB6.Support.SetItemString(lstItems, i, "○" + Strings.Mid(Microsoft.VisualBasic.Compatibility.VB6.Support.GetItemString(lstItems, i), 2));
SRC.NET/MultiSelectListBox.cs:                    Microsoft.VisualBasic.Compatibility.VB6.Support.SetItemString(lstItems, i, "　" + Strings.Mid(Microsoft.VisualBasic.Compatibility.VB6.Support.GetItemString(lstItems, i), 2));
SRC.NET/MultiSelectListBox.cs:                    Microsoft.VisualBasic.Compatibility.VB6.Support.SetItemString(lstItems, i, "○" + Strings.Mid(Microsoft.VisualBasic.Compatibility.VB6.Support.GetItemString(lstItems, i), 2));
SRC.NET/NonPilotData.cs:                if (Strings.InStr(NicknameRet, "主人公") == 1 | Strings.InStr(NicknameRet, "ヒロイン") == 1)
SRC.NET/NonPilotData.cs:                idx = (short)Strings.InStr(Name, "(");
SRC.NET/NonPilotData.cs:                    pname = Strings.Left(Name, idx - 1);
SRC.NET/NonPilotData.cs:                                idx = (short)Strings.InStr(pname, "$(愛称)");
SRC.NET/NonPilotData.cs:                                    pname = Strings.Left(pname, idx - 1) + NicknameRet + Strings.Mid(pname, idx + 5);
SRC.NET/NonPilotDataList.cs:                while (Strings.Len(line_buf) == 0);
SRC.NET/NonPilotDataList.cs:                if (Strings.InStr(line_buf, ",") > 0)
SRC.NET/NonPilotDataList.cs:                if (Strings.InStr(data_name, " ") > 0)
SRC.NET/NonPilotDataList.cs:                if (Strings.InStr(data_name, "（") > 0 | Strings.InStr(data_name, "）") > 0)
SRC.NET/NonPilotDataList.cs:                if (Strings.InStr(data_name, "\"") > 0)
SRC.NET/NonPilotDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/NonPilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/NonPilotDataList.cs:                buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/NonPilotDataList.cs:                buf2 = Strings.Trim(buf);
SRC.NET/NonPilotDataList.cs:                if (Strings.LCase(Strings.Right(buf2, 4)) == ".bmp")
SRC.NET/Pilot.cs:                        idx = (short)Strings.InStr(NicknameRet, "$(愛称)");
SRC.NET/Pilot.cs:                            NicknameRet = Strings.Left(NicknameRet, idx - 1) + Data.Nickname + Strings.Mid(NicknameRet, idx + 5);
SRC.NET/Pilot.cs:                            idx = (short)Strings.InStr(KanaNameRet, "$(読み仮名)");
SRC.NET/Pilot.cs:                                KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + Data.KanaName + Strings.Mid(KanaNameRet, idx + 5);
SRC.NET/Pilot.cs:                            idx = (short)Strings.InStr(KanaNameRet, "$(愛称)");
SRC.NET/Pilot.cs:                                KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + Data.Nickname + Strings.Mid(KanaNameRet, idx + 5);
SRC.NET/Pilot.cs:                        switch (Strings.Mid(Adaption, i, 1) ?? "")
SRC.NET/Pilot.cs:                    if (Strings.InStr(Name, "(ザコ)") == 0 & Strings.InStr(Name, "(汎用)") == 0)
SRC.NET/Pilot.cs:                if (Strings.InStr(Name, "(ザコ)") > 0)
SRC.NET/Pilot.cs:                    if (Strings.Len(localConditionData()) > 0)
SRC.NET/Pilot.cs:                    if (Strings.Len(localConditionData1()) > 0)
SRC.NET/Pilot.cs:            if (Strings.Right(sname, 2) == "ＵＰ" | Strings.Right(sname, 4) == "ＤＯＷＮ")
SRC.NET/Pilot.cs:            if (Strings.Len(sd.StrData) > 0)
SRC.NET/Pilot.cs:            if (sd.Level != SRC.DEFAULT_LEVEL & Strings.InStr(SkillNameRet, "Lv") == 0 & Strings.Left(SkillNameRet, 1) != "(")
SRC.NET/Pilot.cs:                    if (Strings.InStr(SkillNameRet, "非表示") > 0)
SRC.NET/Pilot.cs:                            if (Strings.Left(SkillNameRet, 1) == "(")
SRC.NET/Pilot.cs:                                SkillNameRet = Strings.Mid(SkillNameRet, 2);
SRC.NET/Pilot.cs:                                SkillNameRet = Strings.Left(SkillNameRet, GeneralLib.InStr2(ref SkillNameRet, ref argstr2) - 1);
SRC.NET/Pilot.cs:                            if (Strings.Left(SkillNameRet, 1) == "(")
SRC.NET/Pilot.cs:                                SkillNameRet = Strings.Mid(SkillNameRet, 2);
SRC.NET/Pilot.cs:                                SkillNameRet = Strings.Left(SkillNameRet, GeneralLib.InStr2(ref SkillNameRet, ref argstr21) - 1);
SRC.NET/Pilot.cs:                            i = (short)Strings.InStr(SkillNameRet, "Lv");
SRC.NET/Pilot.cs:                                SkillNameRet = Strings.Left(SkillNameRet, i - 1);
SRC.NET/Pilot.cs:                                if (Strings.InStr(SkillNameRet, "非表示") > 0)
SRC.NET/Pilot.cs:                                    if (Strings.InStr(SkillNameRet, "Lv") > 0)
SRC.NET/Pilot.cs:                                        SkillNameRet = Strings.Left(SkillNameRet, Strings.InStr(SkillNameRet, "Lv") - 1);
SRC.NET/Pilot.cs:                                if (Strings.InStr(SkillNameRet, "非表示") > 0)
SRC.NET/Pilot.cs:                                    if (Strings.InStr(SkillNameRet, "Lv") > 0)
SRC.NET/Pilot.cs:                                        SkillNameRet = Strings.Left(SkillNameRet, Strings.InStr(SkillNameRet, "Lv") - 1);
SRC.NET/Pilot.cs:                                    if (Strings.InStr(SkillNameRet, "非表示") > 0)
SRC.NET/Pilot.cs:                                    if (Strings.InStr(SkillNameRet, "非表示") > 0)
SRC.NET/Pilot.cs:            if (Strings.Right(sname, 2) == "ＵＰ" | Strings.Right(sname, 4) == "ＤＯＷＮ")
SRC.NET/Pilot.cs:                        i = (short)Strings.InStr(SkillNameRet, "Lv");
SRC.NET/Pilot.cs:                            SkillNameRet = Strings.Left(SkillNameRet, i - 1);
SRC.NET/Pilot.cs:            if (Strings.Left(SkillNameRet, 1) == "(")
SRC.NET/Pilot.cs:                SkillNameRet = Strings.Mid(SkillNameRet, 2);
SRC.NET/Pilot.cs:                SkillNameRet = Strings.Left(SkillNameRet, GeneralLib.InStr2(ref SkillNameRet, ref argstr22) - 1);
SRC.NET/Pilot.cs:            if (Strings.Right(sname, 2) == "ＵＰ" | Strings.Right(sname, 4) == "ＤＯＷＮ")
SRC.NET/Pilot.cs:            if (Strings.Len(sd.StrData) > 0)
SRC.NET/Pilot.cs:                    if (Strings.InStr(SkillName0Ret, "非表示") > 0)
SRC.NET/Pilot.cs:                                if (Strings.InStr(SkillName0Ret, "非表示") > 0)
SRC.NET/Pilot.cs:                                if (Strings.InStr(SkillName0Ret, "非表示") > 0)
SRC.NET/Pilot.cs:                                    if (Strings.InStr(SkillName0Ret, "非表示") > 0)
SRC.NET/Pilot.cs:                                    if (Strings.InStr(SkillName0Ret, "非表示") > 0)
SRC.NET/Pilot.cs:            if (Strings.Right(sname, 2) == "ＵＰ" | Strings.Right(sname, 4) == "ＤＯＷＮ")
SRC.NET/Pilot.cs:            if (Strings.Left(SkillName0Ret, 1) == "(")
SRC.NET/Pilot.cs:                SkillName0Ret = Strings.Mid(SkillName0Ret, 2);
SRC.NET/Pilot.cs:                SkillName0Ret = Strings.Left(SkillName0Ret, GeneralLib.InStr2(ref SkillName0Ret, ref argstr2) - 1);
SRC.NET/Pilot.cs:            i = (short)Strings.InStr(SkillName0Ret, "Lv");
SRC.NET/Pilot.cs:                SkillName0Ret = Strings.Left(SkillName0Ret, i - 1);
SRC.NET/Pilot.cs:            if (Strings.Right(stype, 2) == "ＵＰ" | Strings.Right(stype, 4) == "ＤＯＷＮ")
SRC.NET/Pilot.cs:            if (Strings.Len(sd.StrData) > 0)
SRC.NET/Pilot.cs:                    if (Strings.InStr(SkillNameForNSRet, "非表示") > 0)
SRC.NET/Pilot.cs:                                if (Strings.InStr(SkillNameForNSRet, "非表示") > 0)
SRC.NET/Pilot.cs:                                if (Strings.InStr(SkillNameForNSRet, "非表示") > 0)
SRC.NET/Pilot.cs:                                    if (Strings.InStr(SkillNameForNSRet, "非表示") > 0)
SRC.NET/Pilot.cs:                                    if (Strings.InStr(SkillNameForNSRet, "非表示") > 0)
SRC.NET/Pilot.cs:            if (Strings.Left(SkillNameForNSRet, 1) == "(")
SRC.NET/Pilot.cs:                SkillNameForNSRet = Strings.Mid(SkillNameForNSRet, 2);
SRC.NET/Pilot.cs:                SkillNameForNSRet = Strings.Left(SkillNameForNSRet, GeneralLib.InStr2(ref SkillNameForNSRet, ref argstr2) - 1);
SRC.NET/Pilot.cs:            i = (short)Strings.InStr(SkillNameForNSRet, "Lv");
SRC.NET/Pilot.cs:                SkillNameForNSRet = Strings.Left(SkillNameForNSRet, i - 1);
SRC.NET/Pilot.cs:            i = (short)Strings.InStr(sname, "Lv");
SRC.NET/Pilot.cs:                sname0 = Strings.Left(sname, i - 1);
SRC.NET/Pilot.cs:                if (Strings.Left(sname2, 1) == "(")
SRC.NET/Pilot.cs:                    if (Strings.Right(sname2, 1) == ")")
SRC.NET/Pilot.cs:                        sname2 = Strings.Mid(sname2, 2, Strings.Len(sname2) - 2);
SRC.NET/Pilot.cs:                                if (Strings.Right(localCondition(), 2) == "付加")
SRC.NET/Pilot.cs:                                        SkillTypeRet = Strings.Left(SkillTypeRet, Strings.Len(SkillTypeRet) - 2);
SRC.NET/Pilot.cs:                                else if (Strings.Right(localCondition1(), 3) == "付加２")
SRC.NET/Pilot.cs:                                        SkillTypeRet = Strings.Left(SkillTypeRet, Strings.Len(SkillTypeRet) - 3);
SRC.NET/Pilot.cs:                if (Strings.Left(withBlock.Class_Renamed, 1) == "(" & Strings.Right(withBlock.Class_Renamed, 1) == ")")
SRC.NET/Pilot.cs:                    uclass = Strings.Mid(withBlock.Class_Renamed, 2, Strings.Len(withBlock.Class_Renamed) - 2);
SRC.NET/PilotData.cs:                if (Strings.InStr(NicknameRet, "主人公") == 1 | Strings.InStr(NicknameRet, "ヒロイン") == 1)
SRC.NET/PilotData.cs:                if (Strings.InStr(KanaNameRet, "主人公") == 1 | Strings.InStr(KanaNameRet, "ヒロイン") == 1 | Strings.InStr(KanaNameRet, "ひろいん") == 1)
SRC.NET/PilotData.cs:            if ((last_sname ?? "") == (sname ?? "") & Strings.Len(sdata) == 0)
SRC.NET/PilotData.cs:                                    sd.StrData = Strings.Trim(sdata + " " + localListTail());
SRC.NET/PilotData.cs:                        if (Strings.Len(sd.StrData) > 0)
SRC.NET/PilotData.cs:                            if (sd.Level != SRC.DEFAULT_LEVEL & Strings.InStr(SkillNameRet, "Lv") == 0)
SRC.NET/PilotData.cs:            if (Strings.Left(SkillNameRet, 1) == "(")
SRC.NET/PilotData.cs:                SkillNameRet = Strings.Mid(SkillNameRet, 2, Strings.Len(SkillNameRet) - 2);
SRC.NET/PilotData.cs:            if (Strings.Right(fdef, 1) == ")")
SRC.NET/PilotData.cs:                i = (short)Strings.InStr(fdef, " (");
SRC.NET/PilotData.cs:                    nskill = Strings.Trim(Strings.Mid(fdef, i + 2, Strings.Len(fdef) - i - 2));
SRC.NET/PilotData.cs:                    buf = Strings.Trim(Strings.Left(fdef, i));
SRC.NET/PilotData.cs:                else if (Strings.Left(fdef, 1) == "(")
SRC.NET/PilotData.cs:                    nskill = Strings.Trim(Strings.Mid(fdef, 2, Strings.Len(fdef) - 2));
SRC.NET/PilotData.cs:            if (Strings.Right(buf, 1) == ">")
SRC.NET/PilotData.cs:                i = (short)Strings.InStr(buf, " <");
SRC.NET/PilotData.cs:                    ncondition = Strings.Trim(Strings.Mid(buf, i + 2, Strings.Len(buf) - i - 2));
SRC.NET/PilotData.cs:                    buf = Strings.Trim(Strings.Left(buf, i));
SRC.NET/PilotData.cs:                else if (Strings.Left(buf, 1) == "<")
SRC.NET/PilotData.cs:                    ncondition = Strings.Trim(Strings.Mid(buf, 2, Strings.Len(buf) - 2));
SRC.NET/PilotData.cs:            i = (short)Strings.InStr(buf, "Lv");
SRC.NET/PilotData.cs:            j = (short)Strings.InStr(buf, "=");
SRC.NET/PilotData.cs:                ftype = Strings.Left(buf, i - 1);
SRC.NET/PilotData.cs:                    flevel = Conversions.ToDouble(Strings.Mid(buf, i + 2, j - (i + 2)));
SRC.NET/PilotData.cs:                    fdata = Strings.Mid(buf, j + 1);
SRC.NET/PilotData.cs:                    flevel = Conversions.ToDouble(Strings.Mid(buf, i + 2));
SRC.NET/PilotData.cs:                ftype = Strings.Left(buf, j - 1);
SRC.NET/PilotData.cs:                fdata = Strings.Mid(buf, j + 1);
SRC.NET/PilotData.cs:            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/PilotData.cs:                if (Strings.Right(fdata, 1) == "\"")
SRC.NET/PilotData.cs:                    fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/PilotData.cs:                                if (!string.IsNullOrEmpty(fdata) & Strings.InStr(withBlock.get_AliasData(i), "非表示") != 1)
SRC.NET/PilotData.cs:            if (Strings.Len(fd.StrData) > 0)
SRC.NET/PilotDataList.cs:                while (Strings.Len(line_buf) == 0);
SRC.NET/PilotDataList.cs:                if (Strings.InStr(line_buf, ",") > 0)
SRC.NET/PilotDataList.cs:                if (Strings.InStr(data_name, " ") > 0)
SRC.NET/PilotDataList.cs:                if (Strings.InStr(data_name, "（") > 0 | Strings.InStr(data_name, "）") > 0)
SRC.NET/PilotDataList.cs:                if (Strings.InStr(data_name, "\"") > 0)
SRC.NET/PilotDataList.cs:                var loopTo = (short)Strings.Len(line_buf);
SRC.NET/PilotDataList.cs:                    if (Strings.Mid(line_buf, (int)i, 1) == ",")
SRC.NET/PilotDataList.cs:                ret = Strings.InStr(line_buf, ",");
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, ret - 1));
SRC.NET/PilotDataList.cs:                buf = Strings.Mid(line_buf, ret + 1);
SRC.NET/PilotDataList.cs:                if (Strings.Len(buf2) == 0)
SRC.NET/PilotDataList.cs:                            ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                            buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                            buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                            ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                            buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                            buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                            ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                            buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                            buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                if (Strings.Len(buf2) == 4)
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(buf);
SRC.NET/PilotDataList.cs:                        ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                        ret2 = Strings.InStr(buf, "\"");
SRC.NET/PilotDataList.cs:                            while ((int)j <= Strings.Len(buf))
SRC.NET/PilotDataList.cs:                                switch (Strings.Mid(buf, (int)j, 1) ?? "")
SRC.NET/PilotDataList.cs:                                                buf2 = Strings.Left(buf, (int)j - 1);
SRC.NET/PilotDataList.cs:                                                buf = Strings.Mid(buf, (int)j + 1);
SRC.NET/PilotDataList.cs:                            if ((int)j == Strings.Len(buf))
SRC.NET/PilotDataList.cs:                            buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                            buf = Strings.Trim(Strings.Mid(buf, ret + 1));
SRC.NET/PilotDataList.cs:                            if (Strings.InStr(buf2, " ") > 0)
SRC.NET/PilotDataList.cs:                                if (Strings.Left(buf2, 4) != "先手必勝" & Strings.Left(buf2, 6) != "ＳＰ消費減少" & Strings.Left(buf2, 12) != "スペシャルパワー自動発動" & Strings.Left(buf2, 4) != "ハンター" & Strings.InStr(buf2, "=解説 ") == 0)
SRC.NET/PilotDataList.cs:                                        err_msg = "行頭から" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format((object)(((int)i + 1) / 2)) + "番目の特殊能力「" + Strings.Trim(Strings.Left(buf2, Strings.InStr(buf2, " "))) + "」の指定の後に「,」が抜けています。";
SRC.NET/PilotDataList.cs:                            j = (short)Strings.InStr(buf2, "=");
SRC.NET/PilotDataList.cs:                                adata = Strings.Mid(buf2, (int)j + 1);
SRC.NET/PilotDataList.cs:                                buf2 = Strings.Left(buf2, (int)j - 1);
SRC.NET/PilotDataList.cs:                            j = (short)Strings.InStr(buf2, "Lv");
SRC.NET/PilotDataList.cs:                                        if (!Information.IsNumeric(Strings.Mid(buf2, (int)j + 2)))
SRC.NET/PilotDataList.cs:                                        alevel = (double)Conversions.ToShort(Strings.Mid(buf2, (int)j + 2));
SRC.NET/PilotDataList.cs:                                        aname = Strings.Left(buf2, (int)j - 1);
SRC.NET/PilotDataList.cs:                                        alevel = Conversions.ToDouble(Strings.Mid(buf2, (int)j + 2));
SRC.NET/PilotDataList.cs:                else if (Strings.InStr(line_buf, "特殊能力,") == 1)
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(line_buf, 6);
SRC.NET/PilotDataList.cs:                        ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                        ret2 = Strings.InStr(buf, "\"");
SRC.NET/PilotDataList.cs:                            while ((int)j <= Strings.Len(buf))
SRC.NET/PilotDataList.cs:                                switch (Strings.Mid(buf, (int)j, 1) ?? "")
SRC.NET/PilotDataList.cs:                                                buf2 = Strings.Left(buf, (int)j - 1);
SRC.NET/PilotDataList.cs:                                                buf = Strings.Mid(buf, (int)j + 1);
SRC.NET/PilotDataList.cs:                            if ((int)j == Strings.Len(buf))
SRC.NET/PilotDataList.cs:                            buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                            buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                            if (Strings.InStr(buf2, " ") > 0)
SRC.NET/PilotDataList.cs:                            j = (short)Strings.InStr(buf2, "=");
SRC.NET/PilotDataList.cs:                                adata = Strings.Mid(buf2, (int)j + 1);
SRC.NET/PilotDataList.cs:                                buf2 = Strings.Left(buf2, (int)j - 1);
SRC.NET/PilotDataList.cs:                            j = (short)Strings.InStr(buf2, "Lv");
SRC.NET/PilotDataList.cs:                                        if (!Information.IsNumeric(Strings.Mid(buf2, (int)j + 2)))
SRC.NET/PilotDataList.cs:                                        alevel = Conversions.ToDouble(Strings.Mid(buf2, (int)j + 2));
SRC.NET/PilotDataList.cs:                                        aname = Strings.Left(buf2, (int)j - 1);
SRC.NET/PilotDataList.cs:                                        alevel = Conversions.ToDouble(Strings.Mid(buf2, (int)j + 2));
SRC.NET/PilotDataList.cs:                if (Strings.Len(line_buf) == 0)
SRC.NET/PilotDataList.cs:                ret = Strings.InStr(line_buf, ",");
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, ret - 1));
SRC.NET/PilotDataList.cs:                buf = Strings.Mid(line_buf, ret + 1);
SRC.NET/PilotDataList.cs:                ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(buf);
SRC.NET/PilotDataList.cs:                if (Strings.Len(buf2) == 0)
SRC.NET/PilotDataList.cs:                if (Strings.InStr(buf2, ",") > 0)
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf2, Strings.InStr(buf2, ",") - 1));
SRC.NET/PilotDataList.cs:                            ret = Strings.InStr(line_buf, ",");
SRC.NET/PilotDataList.cs:                            buf2 = Strings.Trim(Strings.Left(line_buf, ret - 1));
SRC.NET/PilotDataList.cs:                            buf = Strings.Mid(line_buf, ret + 1);
SRC.NET/PilotDataList.cs:                            ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                                buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                                buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                                buf2 = Strings.Trim(buf);
SRC.NET/PilotDataList.cs:                            ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                                sname = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                                buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                                if (Strings.InStr(sname, "=") > 0)
SRC.NET/PilotDataList.cs:                                    string argexpr = Strings.Mid(sname, Strings.InStr(sname, "=") + 1);
SRC.NET/PilotDataList.cs:                                    sname = Strings.Left(sname, Strings.InStr(sname, "=") - 1);
SRC.NET/PilotDataList.cs:                                ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                                    buf2 = Strings.Trim(buf);
SRC.NET/PilotDataList.cs:                                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                                ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                                string argmsg28 = "スペシャルパワー「" + Strings.Trim(sname) + "」の獲得レベル指定が抜けています。";
SRC.NET/PilotDataList.cs:                if (Strings.Len(line_buf) == 0)
SRC.NET/PilotDataList.cs:                ret = Strings.InStr(line_buf, ",");
SRC.NET/PilotDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, ret - 1));
SRC.NET/PilotDataList.cs:                buf = Strings.Mid(line_buf, ret + 1);
SRC.NET/PilotDataList.cs:                if (Strings.LCase(Strings.Right(buf2, 4)) == ".bmp")
SRC.NET/PilotDataList.cs:                buf = Strings.Trim(buf);
SRC.NET/PilotDataList.cs:                while (Strings.Right(buf2, 1) == ")")
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Left(buf2, Strings.Len(buf2) - 1);
SRC.NET/PilotDataList.cs:                switch (Strings.LCase(Strings.Right(buf2, 4)) ?? "")
SRC.NET/PilotDataList.cs:                    var loopTo1 = (short)Strings.Len(buf);
SRC.NET/PilotDataList.cs:                        switch (Strings.Mid(buf, (int)j, 1) ?? "")
SRC.NET/PilotDataList.cs:                        buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                        buf = Strings.Trim(Strings.Mid(buf, ret + 1));
SRC.NET/PilotDataList.cs:                while (Strings.Len(line_buf) > 0 & line_buf != "===")
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(line_buf, ",");
SRC.NET/PilotDataList.cs:                    wname = Strings.Trim(Strings.Left(line_buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(line_buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    if (Strings.Len(buf2) == 4)
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    buf = Strings.Trim(buf);
SRC.NET/PilotDataList.cs:                    if (Strings.Len(buf) == 0)
SRC.NET/PilotDataList.cs:                    if (Strings.Right(buf, 1) == ")")
SRC.NET/PilotDataList.cs:                        ret = Strings.InStr(buf, "> ");
SRC.NET/PilotDataList.cs:                                wd.NecessarySkill = Strings.Mid(buf, ret + 2);
SRC.NET/PilotDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, ret + 1));
SRC.NET/PilotDataList.cs:                                ret = Strings.InStr(wd.NecessarySkill, "(");
SRC.NET/PilotDataList.cs:                                wd.NecessarySkill = Strings.Mid(wd.NecessarySkill, ret + 1, Strings.Len(wd.NecessarySkill) - ret - 1);
SRC.NET/PilotDataList.cs:                            ret = Strings.InStr(buf, "(");
SRC.NET/PilotDataList.cs:                                wd.NecessarySkill = Strings.Trim(Strings.Mid(buf, ret + 1, Strings.Len(buf) - ret - 1));
SRC.NET/PilotDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    if (Strings.Right(buf, 1) == ">")
SRC.NET/PilotDataList.cs:                        ret = Strings.InStr(buf, "<");
SRC.NET/PilotDataList.cs:                            wd.NecessaryCondition = Strings.Trim(Strings.Mid(buf, ret + 1, Strings.Len(buf) - ret - 1));
SRC.NET/PilotDataList.cs:                            buf = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    if (Strings.InStr(wd.Class_Renamed, "Lv") > 0)
SRC.NET/PilotDataList.cs:                while (Strings.Len(line_buf) > 0)
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(line_buf, ",");
SRC.NET/PilotDataList.cs:                    sname = Strings.Trim(Strings.Left(line_buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(line_buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    ret = Strings.InStr(buf, ",");
SRC.NET/PilotDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    buf = Strings.Mid(buf, ret + 1);
SRC.NET/PilotDataList.cs:                    buf = Strings.Trim(buf);
SRC.NET/PilotDataList.cs:                    if (Strings.Len(buf) == 0)
SRC.NET/PilotDataList.cs:                    if (Strings.Right(buf, 1) == ")")
SRC.NET/PilotDataList.cs:                        ret = Strings.InStr(buf, "> ");
SRC.NET/PilotDataList.cs:                                sd.NecessarySkill = Strings.Mid(buf, ret + 2);
SRC.NET/PilotDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, ret + 1));
SRC.NET/PilotDataList.cs:                                ret = Strings.InStr(sd.NecessarySkill, "(");
SRC.NET/PilotDataList.cs:                                sd.NecessarySkill = Strings.Mid(sd.NecessarySkill, ret + 1, Strings.Len(sd.NecessarySkill) - ret - 1);
SRC.NET/PilotDataList.cs:                            ret = Strings.InStr(buf, "(");
SRC.NET/PilotDataList.cs:                                sd.NecessarySkill = Strings.Trim(Strings.Mid(buf, ret + 1, Strings.Len(buf) - ret - 1));
SRC.NET/PilotDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    if (Strings.Right(buf, 1) == ">")
SRC.NET/PilotDataList.cs:                        ret = Strings.InStr(buf, "<");
SRC.NET/PilotDataList.cs:                            sd.NecessaryCondition = Strings.Trim(Strings.Mid(buf, ret + 1, Strings.Len(buf) - ret - 1));
SRC.NET/PilotDataList.cs:                            buf = Strings.Trim(Strings.Left(buf, ret - 1));
SRC.NET/PilotDataList.cs:                    if (Strings.InStr(sd.Class_Renamed, "Lv") > 0)
SRC.NET/Pilots.cs:                if (Strings.InStr(new_pilot.Name, "(ザコ)") == 0 & Strings.InStr(new_pilot.Name, "(汎用)") == 0)
SRC.NET/Pilots.cs:                        if (Strings.InStr(pname, "(") > 0)
SRC.NET/Pilots.cs:                            pname = Strings.Left(pname, Strings.InStr(pname, "(") - 1);
SRC.NET/Pilots.cs:                        pname = Strings.Left(pname, Strings.InStr(pname, "(") - 1);
SRC.NET/Pilots.cs:                    ret = (short)Strings.InStr(uid, ":");
SRC.NET/Pilots.cs:                    uid = Strings.Left(uid, ret - 1);
SRC.NET/Pilots.cs:                if (Expression.IsOptionDefined(ref argoname1) & Strings.InStr(withBlock.Name, "(ザコ)") == 0)
SRC.NET/Sound.cs:            if (Strings.Len(bgm_name) < 5)
SRC.NET/Sound.cs:            fname0 = Strings.Left(bgm_name, Strings.Len(bgm_name) - 4);
SRC.NET/Sound.cs:                fname0 = Strings.Mid(fname0, GeneralLib.InStr2(ref fname0, ref argstr2) + 1);
SRC.NET/Sound.cs:            if (Strings.Len(BGMFileName) > 0)
SRC.NET/Sound.cs:                if (Strings.InStr(BGMFileName, @"\" + fname0 + ".") > 0)
SRC.NET/Sound.cs:            if (Strings.Len(fname) == 0)
SRC.NET/Sound.cs:            if (Strings.InStr(fname, SRC.ScenarioPath) > 0)
SRC.NET/Sound.cs:                    string argmidi_name = "(" + fname0 + "(" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(i) + ")" + Strings.Right(fname, 4) + ")";
SRC.NET/Sound.cs:                while (Strings.InStr(fname2, SRC.ScenarioPath) > 0);
SRC.NET/Sound.cs:                    string argmidi_name1 = "(" + fname0 + "(" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(i) + ")" + Strings.Right(fname, 4) + ")";
SRC.NET/Sound.cs:                string argmidi_name2 = "(" + fname0 + "(" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(i) + ")" + Strings.Right(fname, 4) + ")";
SRC.NET/Sound.cs:            switch (Strings.LCase(Strings.Right(fname, 4)) ?? "")
SRC.NET/Sound.cs:            switch (Strings.LCase(Strings.Right(BGMFileName, 4)) ?? "")
SRC.NET/Sound.cs:            if (!by_force & Strings.Len(BGMFileName) == 0)
SRC.NET/Sound.cs:            switch (Strings.LCase(Strings.Right(BGMFileName, 4)) ?? "")
SRC.NET/Sound.cs:            if (Strings.Len(BGMFileName) == 0)
SRC.NET/Sound.cs:            switch (Strings.LCase(Strings.Right(BGMFileName, 4)) ?? "")
SRC.NET/Sound.cs:                            retstr = Strings.Space(120);
SRC.NET/Sound.cs:                            ret = Strings.InStr(retstr, Conversions.ToString('\0'));
SRC.NET/Sound.cs:                            BGMStatusRet = Strings.Left(retstr, ret - 1);
SRC.NET/Sound.cs:                        retstr = Strings.Space(120);
SRC.NET/Sound.cs:                        ret = Strings.InStr(retstr, Conversions.ToString('\0'));
SRC.NET/Sound.cs:                        BGMStatusRet = Strings.Left(retstr, ret - 1);
SRC.NET/Sound.cs:            if (Strings.Len(bgm_name) < 5)
SRC.NET/Sound.cs:            fname = Strings.Left(bgm_name, Strings.Len(bgm_name) - 4);
SRC.NET/Sound.cs:                fname = Strings.Mid(fname, GeneralLib.InStr2(ref fname, ref argstr2) + 1);
SRC.NET/Sound.cs:            if (Strings.Len(BGMFileName) > 0)
SRC.NET/Sound.cs:                if (Strings.InStr(BGMFileName, @"\" + fname + ".") > 0)
SRC.NET/Sound.cs:            if (Strings.Len(BGMFileName) > 5)
SRC.NET/Sound.cs:                fname2 = Strings.Left(BGMFileName, Strings.Len(BGMFileName) - 4);
SRC.NET/Sound.cs:                    fname2 = Strings.Mid(fname2, GeneralLib.InStr2(ref fname2, ref argstr22) + 1);
SRC.NET/Sound.cs:                if (Strings.Len(fname2) > 4)
SRC.NET/Sound.cs:                    switch (Strings.Right(fname2, 3) ?? "")
SRC.NET/Sound.cs:                                fname2 = Strings.Left(fname2, Strings.Len(fname2) - 3);
SRC.NET/Sound.cs:                if (Strings.InStr(DMPerformance.GetPortName(i), "MIDI マッパー") > 0 | Strings.InStr(DMPerformance.GetPortName(i), "MIDI Mapper") > 0)
SRC.NET/Sound.cs:                if (Strings.InStr(DMPerformance.GetPortName(i), "XG ") > 0)
SRC.NET/Sound.cs:                if (Strings.InStr(DMPerformance.GetPortName(i), "GS ") > 0)
SRC.NET/Sound.cs:                if (Strings.InStr(pname, "[") > 0)
SRC.NET/Sound.cs:                    pname = Strings.Left(pname, Strings.InStr(pname, "[") - 1);
SRC.NET/Sound.cs:                if (Strings.Len(SRC.ScenarioPath) > 0)
SRC.NET/Sound.cs:                    if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + "Midi", FileAttribute.Directory)) > 0)
SRC.NET/Sound.cs:                if (Strings.Len(SRC.ExtDataPath) > 0)
SRC.NET/Sound.cs:                    if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + "Midi", FileAttribute.Directory)) > 0)
SRC.NET/Sound.cs:                if (Strings.Len(SRC.ExtDataPath2) > 0)
SRC.NET/Sound.cs:                    if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + "Midi", FileAttribute.Directory)) > 0)
SRC.NET/Sound.cs:            if (Strings.Len(midi_name) < 5)
SRC.NET/Sound.cs:                    buf2 = Strings.LCase(GeneralLib.ListIndex(ref midi_name, j));
SRC.NET/Sound.cs:                    if (Strings.Left(buf2, 1) == "(" & Strings.Right(buf2, 1) == ")")
SRC.NET/Sound.cs:                        buf2 = Strings.Mid(buf2, 2, Strings.Len(buf2) - 2);
SRC.NET/Sound.cs:                    if (Strings.Right(buf, 4) == ".mid")
SRC.NET/Sound.cs:                buf = Strings.Trim(buf);
SRC.NET/Sound.cs:                    fname_mp3 = Strings.Left(buf, Strings.Len(buf) - 4) + ".mp3";
SRC.NET/Sound.cs:                if (Strings.InStr(buf, ":") == 2)
SRC.NET/Sound.cs:                if (Strings.InStr(buf, "_") > 0)
SRC.NET/Sound.cs:                    sub_folder = Strings.Left(buf, Strings.InStr(buf, "_") - 1) + @"\";
SRC.NET/Sound.cs:                if (Strings.Len(FileSystem.Dir(SRC.ScenarioPath + "Sound", FileAttribute.Directory)) > 0)
SRC.NET/Sound.cs:                if (Strings.Len(SRC.ExtDataPath) > 0)
SRC.NET/Sound.cs:                    if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath + "Sound", FileAttribute.Directory)) > 0)
SRC.NET/Sound.cs:                if (Strings.Len(SRC.ExtDataPath2) > 0)
SRC.NET/Sound.cs:                    if (Strings.Len(FileSystem.Dir(SRC.ExtDataPath2 + "Sound", FileAttribute.Directory)) > 0)
SRC.NET/Sound.cs:            switch (Strings.LCase(wave_name) ?? "")
SRC.NET/Sound.cs:                        if (Strings.LCase(Strings.Right(BGMFileName, 4)) == ".mp3")
SRC.NET/Sound.cs:            if (Strings.LCase(Strings.Right(fname, 4)) == ".mp3")
SRC.NET/Sound.cs:                if (Strings.LCase(Strings.Right(BGMFileName, 4)) == ".mp3")
SRC.NET/SpecialPowerData.cs:                j = (short)Strings.InStr(buf, "Lv");
SRC.NET/SpecialPowerData.cs:                k = (short)Strings.InStr(buf, "=");
SRC.NET/SpecialPowerData.cs:                    strEffectType[i] = Strings.Left(buf, j - 1);
SRC.NET/SpecialPowerData.cs:                        dblEffectLevel[i] = Conversions.ToDouble(Strings.Mid(buf, j + 2, k - (j + 2)));
SRC.NET/SpecialPowerData.cs:                        buf = Strings.Mid(buf, k + 1);
SRC.NET/SpecialPowerData.cs:                        if (Strings.Left(buf, 1) == "\"")
SRC.NET/SpecialPowerData.cs:                            buf = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/SpecialPowerData.cs:                        j = (short)Strings.InStr(buf, "Lv");
SRC.NET/SpecialPowerData.cs:                        k = (short)Strings.InStr(buf, "=");
SRC.NET/SpecialPowerData.cs:                            etype = Strings.Left(buf, j - 1);
SRC.NET/SpecialPowerData.cs:                                elevel = Strings.Mid(buf, j + 2, k - (j + 2));
SRC.NET/SpecialPowerData.cs:                                edata = Strings.Mid(buf, k + 1);
SRC.NET/SpecialPowerData.cs:                                elevel = Strings.Mid(buf, j + 2);
SRC.NET/SpecialPowerData.cs:                            etype = Strings.Left(buf, k - 1);
SRC.NET/SpecialPowerData.cs:                            edata = Strings.Mid(buf, k + 1);
SRC.NET/SpecialPowerData.cs:                        strEffectData[i] = Strings.Trim(etype + " " + elevel + " " + edata);
SRC.NET/SpecialPowerData.cs:                        dblEffectLevel[i] = Conversions.ToDouble(Strings.Mid(buf, j + 2));
SRC.NET/SpecialPowerData.cs:                    strEffectType[i] = Strings.Left(buf, k - 1);
SRC.NET/SpecialPowerData.cs:                    buf = Strings.Mid(buf, k + 1);
SRC.NET/SpecialPowerData.cs:                    if (Strings.Asc(buf) == 34) // "
SRC.NET/SpecialPowerData.cs:                        buf = Strings.Mid(buf, 2, Strings.Len(buf) - 2);
SRC.NET/SpecialPowerData.cs:                    j = (short)Strings.InStr(buf, "Lv");
SRC.NET/SpecialPowerData.cs:                    k = (short)Strings.InStr(buf, "=");
SRC.NET/SpecialPowerData.cs:                        etype = Strings.Left(buf, j - 1);
SRC.NET/SpecialPowerData.cs:                            elevel = Strings.Mid(buf, j + 2, k - (j + 2));
SRC.NET/SpecialPowerData.cs:                            edata = Strings.Mid(buf, k + 1);
SRC.NET/SpecialPowerData.cs:                            elevel = Strings.Mid(buf, j + 2);
SRC.NET/SpecialPowerData.cs:                        etype = Strings.Left(buf, k - 1);
SRC.NET/SpecialPowerData.cs:                        edata = Strings.Mid(buf, k + 1);
SRC.NET/SpecialPowerData.cs:                    strEffectData[i] = Strings.Trim(etype + " " + elevel + " " + edata);
SRC.NET/SpecialPowerData.cs:                            if (Strings.InStr(ncond, "射程Lv") == 1)
SRC.NET/SpecialPowerData.cs:                                int localStrToLng() { string argexpr = Strings.Mid(ncond, 5); var ret = GeneralLib.StrToLng(ref argexpr); return ret; }
SRC.NET/SpecialPowerData.cs:                                    if (Strings.Len(localCondition2()) > 6)
SRC.NET/SpecialPowerData.cs:                                        if (Strings.Right(localCondition1(), 6) == "属性使用不能")
SRC.NET/SpecialPowerData.cs:                                if (Strings.InStr(ncond, "射程Lv") == 1)
SRC.NET/SpecialPowerData.cs:                                    int localStrToLng() { string argexpr = Strings.Mid(ncond, 5); var ret = GeneralLib.StrToLng(ref argexpr); return ret; }
SRC.NET/SpecialPowerData.cs:                                        if (Strings.Len(localCondition2()) > 6)
SRC.NET/SpecialPowerData.cs:                                            if (Strings.Right(localCondition1(), 6) == "属性使用不能")
SRC.NET/SpecialPowerData.cs:                                    if (Strings.Len(localCondition6()) > 6)
SRC.NET/SpecialPowerData.cs:                                        if (Strings.Right(localCondition5(), 6) == "属性使用不能")
SRC.NET/SpecialPowerData.cs:                                    GUI.DisplaySysMessage(withBlock1.Nickname + "は" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock1.Action), VbStrConv.Wide) + "回行動可能になった。");
SRC.NET/SpecialPowerData.cs:                                        if (Strings.Len(msg) > 0)
SRC.NET/SpecialPowerData.cs:                                if (Strings.Len(msg) > 0)
SRC.NET/SpecialPowerData.cs:            var loopTo = (short)Strings.Len(Animation);
SRC.NET/SpecialPowerData.cs:                if (Strings.Mid(Animation, i, 1) == ";")
SRC.NET/SpecialPowerData.cs:                    animes[Information.UBound(animes)] = Strings.Mid(Animation, anime_head, i - anime_head);
SRC.NET/SpecialPowerData.cs:            animes[Information.UBound(animes)] = Strings.Mid(Animation, anime_head);
SRC.NET/SpecialPowerData.cs:                if (Strings.LCase(anime) == "clear")
SRC.NET/SpecialPowerData.cs:                switch (Strings.LCase(Strings.Right(GeneralLib.LIndex(ref anime, 1), 4)) ?? "")
SRC.NET/SpecialPowerData.cs:                switch (Strings.LCase(GeneralLib.LIndex(ref anime, 1)) ?? "")
SRC.NET/SpecialPowerData.cs:                if (Strings.Left(anime, 1) == "@")
SRC.NET/SpecialPowerData.cs:                    expr = Strings.Mid(GeneralLib.ListIndex(ref anime, 1), 2) + "(";
SRC.NET/SpecialPowerData.cs:                if (GUI.IsPictureDrawn & Strings.LCase(buf) != "keep")
SRC.NET/SpecialPowerData.cs:            if (Strings.Len(Event_Renamed.EventErrorMessage) > 0)
SRC.NET/SpecialPowerDataList.cs:                while (Strings.Len(line_buf) == 0);
SRC.NET/SpecialPowerDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/SpecialPowerDataList.cs:                    data_name = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/SpecialPowerDataList.cs:                    buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/SpecialPowerDataList.cs:                if (Strings.InStr(data_name, " ") > 0)
SRC.NET/SpecialPowerDataList.cs:                if (Strings.InStr(data_name, "（") > 0 | Strings.InStr(data_name, "）") > 0)
SRC.NET/SpecialPowerDataList.cs:                if (Strings.InStr(data_name, "\"") > 0)
SRC.NET/SpecialPowerDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/SpecialPowerDataList.cs:                sd.KanaName = Strings.Trim(buf);
SRC.NET/SpecialPowerDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/SpecialPowerDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/SpecialPowerDataList.cs:                buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/SpecialPowerDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/SpecialPowerDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/SpecialPowerDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/SpecialPowerDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/SpecialPowerDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/SpecialPowerDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/SpecialPowerDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/SpecialPowerDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/SpecialPowerDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/SpecialPowerDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/SpecialPowerDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/SpecialPowerDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/SpecialPowerDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/SpecialPowerDataList.cs:                    sd.Animation = Strings.Trim(Strings.Mid(buf, Strings.InStr(buf, ",") + 1));
SRC.NET/SpecialPowerDataList.cs:                if (Strings.Len(line_buf) == 0)
SRC.NET/SpecialPowerDataList.cs:                if (Strings.Len(line_buf) == 0)
SRC.NET/SRC.cs:            if (Strings.Right(AppPath, 1) != @"\")
SRC.NET/SRC.cs:            if (Strings.Len(FileSystem.Dir(AppPath + "Bitmap", FileAttribute.Directory)) == 0)
SRC.NET/SRC.cs:            if (Strings.Len(FileSystem.Dir(AppPath + "Ｂｉｔｍａｐ", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:            if (Strings.Len(FileSystem.Dir(AppPath + @"Bitmap\Bitmap", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:            if (Strings.Len(FileSystem.Dir(AppPath + @"Bitmap\Event", FileAttribute.Directory)) == 0)
SRC.NET/SRC.cs:            if (Strings.Len(FileSystem.Dir(AppPath + @"Bitmap\Map", FileAttribute.Directory)) == 0)
SRC.NET/SRC.cs:            if (Strings.Len(FileSystem.Dir(AppPath + @"Bitmap\Map\plain\plain0000.bmp")) == 0 & Strings.Len(FileSystem.Dir(AppPath + @"Bitmap\Map\plain0000.bmp")) == 0 & Strings.Len(FileSystem.Dir(AppPath + @"Bitmap\Map\plain0.bmp")) == 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(AppPath + @"Bitmap\Map\Map", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(AppPath + @"Bitmap\Map\*", FileAttribute.Normal)) == 0)
SRC.NET/SRC.cs:            if (Strings.Len(FileSystem.Dir(AppPath + "Sound", FileAttribute.Directory)) == 0)
SRC.NET/SRC.cs:            if (Strings.Len(FileSystem.Dir(AppPath + "Ｓｏｕｎｄ", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:            if (Strings.Len(FileSystem.Dir(AppPath + @"Sound\Sound", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:            if (Strings.Len(FileSystem.Dir(AppPath + @"Sound\*", FileAttribute.Normal)) == 0)
SRC.NET/SRC.cs:            if (Strings.LCase(GeneralLib.ReadIni(ref argini_section, ref argini_entry)) == "on")
SRC.NET/SRC.cs:            switch (Strings.LCase(GeneralLib.ReadIni(ref argini_section1, ref argini_entry1)) ?? "")
SRC.NET/SRC.cs:            switch (Strings.LCase(GeneralLib.ReadIni(ref argini_section5, ref argini_entry5)) ?? "")
SRC.NET/SRC.cs:            if (Strings.Left(Interaction.Command(), 1) == "\"")
SRC.NET/SRC.cs:                fname = Strings.Mid(Interaction.Command(), 2, Strings.Len(Interaction.Command()) - 2);
SRC.NET/SRC.cs:            if (Strings.LCase(Strings.Right(fname, 4)) != ".src" & Strings.LCase(Strings.Right(fname, 4)) != ".eve")
SRC.NET/SRC.cs:                    if (Strings.InStr(ScenarioPath, "テストデータ") > 0)
SRC.NET/SRC.cs:                    if (Strings.InStr(ScenarioPath, "戦闘アニメテスト") > 0)
SRC.NET/SRC.cs:                if (Strings.Right(ScenarioPath, 1) != @"\")
SRC.NET/SRC.cs:                if (Strings.Len(ExtDataPath) > 0)
SRC.NET/SRC.cs:                    if (Strings.Right(ExtDataPath, 1) != @"\")
SRC.NET/SRC.cs:                if (Strings.Len(ExtDataPath2) > 0)
SRC.NET/SRC.cs:                    if (Strings.Right(ExtDataPath2, 1) != @"\")
SRC.NET/SRC.cs:                if (Strings.InStr(fname, @"\") > 0)
SRC.NET/SRC.cs:                    var loopTo = (short)Strings.Len(fname);
SRC.NET/SRC.cs:                        if (Strings.Mid(fname, Strings.Len(fname) - (int)i + 1, 1) == @"\")
SRC.NET/SRC.cs:                    ScenarioPath = Strings.Left(fname, Strings.Len(fname) - (int)i);
SRC.NET/SRC.cs:                if (Strings.Right(ScenarioPath, 1) != @"\")
SRC.NET/SRC.cs:                if (Strings.Len(ExtDataPath) > 0)
SRC.NET/SRC.cs:                    if (Strings.Right(ExtDataPath, 1) != @"\")
SRC.NET/SRC.cs:                if (Strings.Len(ExtDataPath2) > 0)
SRC.NET/SRC.cs:                    if (Strings.Right(ExtDataPath2, 1) != @"\")
SRC.NET/SRC.cs:                if (Strings.InStr(fname, @"\") > 0)
SRC.NET/SRC.cs:                    var loopTo1 = (short)Strings.Len(fname);
SRC.NET/SRC.cs:                        if (Strings.Mid(fname, Strings.Len(fname) - (int)i + 1, 1) == @"\")
SRC.NET/SRC.cs:                    ScenarioPath = Strings.Left(fname, Strings.Len(fname) - (int)i);
SRC.NET/SRC.cs:                if (Strings.Right(ScenarioPath, 1) != @"\")
SRC.NET/SRC.cs:                if (Strings.Len(ExtDataPath) > 0)
SRC.NET/SRC.cs:                    if (Strings.Right(ExtDataPath, 1) != @"\")
SRC.NET/SRC.cs:                if (Strings.Len(ExtDataPath2) > 0)
SRC.NET/SRC.cs:                    if (Strings.Right(ExtDataPath2, 1) != @"\")
SRC.NET/SRC.cs:            if (Strings.InStr(fname, "不要ファイル削除") == 0 & Strings.InStr(fname, "必須修正") == 0)
SRC.NET/SRC.cs:                if (Strings.LCase(buf) == "on")
SRC.NET/SRC.cs:            buf = Strings.LCase(GeneralLib.ReadIni(ref argini_section53, ref argini_entry53));
SRC.NET/SRC.cs:            buf = Strings.LCase(GeneralLib.ReadIni(ref argini_section56, ref argini_entry56));
SRC.NET/SRC.cs:            buf = Strings.LCase(GeneralLib.ReadIni(ref argini_section58, ref argini_entry58));
SRC.NET/SRC.cs:            buf = Strings.LCase(GeneralLib.ReadIni(ref argini_section60, ref argini_entry60));
SRC.NET/SRC.cs:                if (Strings.LCase(buf) == "on")
SRC.NET/SRC.cs:                if (Strings.LCase(buf) == "on")
SRC.NET/SRC.cs:                if (Strings.LCase(buf) == "on")
SRC.NET/SRC.cs:                if (Strings.LCase(buf) == "on")
SRC.NET/SRC.cs:                if (Strings.LCase(buf) == "on")
SRC.NET/SRC.cs:                    if (Strings.LCase(buf) == "on")
SRC.NET/SRC.cs:            if (Strings.LCase(Strings.Right(fname, 4)) == ".src")
SRC.NET/SRC.cs:            else if (Strings.LCase(Strings.Right(fname, 4)) == ".eve")
SRC.NET/SRC.cs:            if (Strings.Len(fname) == 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(ScenarioPath + "Date", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(ScenarioPath + "Ｄａｔａ", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(ScenarioPath + "Ｂｉｔｍａｐ", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(ScenarioPath + "Ｌｉｂ", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(ScenarioPath + "Ｍｉｄｉ", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(ScenarioPath + "Ｓｏｕｎｄ", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                var loopTo = (short)Strings.Len(fname);
SRC.NET/SRC.cs:                    if (Strings.Mid(fname, Strings.Len(fname) - i + 1, 1) == @"\")
SRC.NET/SRC.cs:                string argnew_value1 = Strings.Mid(fname, Strings.Len(fname) - i + 2);
SRC.NET/SRC.cs:                string argnew_value2 = Strings.Mid(fname, Strings.Len(fname) - i + 2, i - 5) + "までクリア.src";
SRC.NET/SRC.cs:                GUI.MainForm.Text = GUI.MainForm.Text + " - " + Strings.Mid(fname, Strings.Len(fname) - i + 2, i - 5);
SRC.NET/SRC.cs:            if (Strings.InStr(fname, @"\Lib\ユニットステータス表示.eve") == 0 & Strings.InStr(fname, @"\Lib\パイロットステータス表示.eve") == 0)
SRC.NET/SRC.cs:            FileSystem.WriteLine(SaveDataFileNumber, Strings.Mid(ScenarioFileName, Strings.Len(ScenarioPath) + 1));
SRC.NET/SRC.cs:            if (Strings.InStr(Strings.LCase(Sound.BGMFileName), @"\midi\") > 0)
SRC.NET/SRC.cs:                FileSystem.WriteLine(SaveDataFileNumber, Strings.Mid(Sound.BGMFileName, Strings.InStr(Strings.LCase(Sound.BGMFileName), @"\midi\") + 6));
SRC.NET/SRC.cs:            else if (Strings.InStr(Sound.BGMFileName, @"\") > 0)
SRC.NET/SRC.cs:                FileSystem.WriteLine(SaveDataFileNumber, Strings.Mid(Sound.BGMFileName, Strings.InStr(Sound.BGMFileName, @"\") + 1));
SRC.NET/SRC.cs:            if (Strings.InStr(fname, @"\_リスタート.src") > 0)
SRC.NET/SRC.cs:            else if (Strings.InStr(fname, @"\_クイックセーブ.src") > 0)
SRC.NET/SRC.cs:                GUI.MainForm.Text = "SRC - " + Strings.Left(fname2, Strings.Len(fname2) - 4);
SRC.NET/SRC.cs:            if (Strings.InStr(fname, @"\_リスタート.src") > 0)
SRC.NET/SRC.cs:            else if (Strings.InStr(fname, @"\_クイックセーブ.src") > 0)
SRC.NET/SRC.cs:            if (Strings.InStr(ID, ":") > 0)
SRC.NET/SRC.cs:            i = (short)Strings.Len(ID);
SRC.NET/SRC.cs:                switch (Strings.Asc(Strings.Mid(ID, i, 1)))
SRC.NET/SRC.cs:            ID = Strings.Left(ID, i) + ":" + Strings.Mid(ID, i + 1);
SRC.NET/SRC.cs:            if (Strings.Len(fpath) == 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(ScenarioPath + "Data", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(ExtDataPath) > 0 & (ScenarioPath ?? "") != (ExtDataPath ?? ""))
SRC.NET/SRC.cs:                    if (Strings.Len(FileSystem.Dir(ExtDataPath + "Data", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(ExtDataPath2) > 0 & (ScenarioPath ?? "") != (ExtDataPath2 ?? ""))
SRC.NET/SRC.cs:                    if (Strings.Len(FileSystem.Dir(ExtDataPath2 + "Data", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                    if (Strings.Len(FileSystem.Dir(AppPath + "Data", FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(SearchDataFolderRet, FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(SearchDataFolderRet, FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(SearchDataFolderRet, FileAttribute.Directory)) > 0)
SRC.NET/SRC.cs:                if (Strings.Len(FileSystem.Dir(SearchDataFolderRet, FileAttribute.Directory)) > 0)
SRC.NET/Status.cs:            if (Strings.InStr(Map.TerrainName(X, Y), "(") > 0)
SRC.NET/Status.cs:                pic.Print("(" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(X) + "," + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Y) + ") " + Strings.Left(Map.TerrainName(X, Y), Strings.InStr(Map.TerrainName(X, Y), "(") - 1));
SRC.NET/Status.cs:                    if (Strings.InStr(p.Name, "(ザコ)") > 0 | Strings.InStr(p.Name, "(汎用)") > 0)
SRC.NET/Status.cs:                if (Strings.InStr(fname, @"\-.bmp") > 0)
SRC.NET/Status.cs:                    if (Strings.InStr(fname, @"\Pilot\") > 0)
SRC.NET/Status.cs:                    upic.Print(GeneralLib.LeftPaddedString(ref argbuf, 4) + Strings.Space(10));
SRC.NET/Status.cs:                                upic.Print(localLeftPaddedString2() + Strings.Space(9));
SRC.NET/Status.cs:                    upic.Print(GeneralLib.LeftPaddedString(ref argbuf1, 5) + Strings.Space(9));
SRC.NET/Status.cs:                                upic.Print(localLeftPaddedString5() + Strings.Space(5));
SRC.NET/Status.cs:                    upic.Print(GeneralLib.LeftPaddedString(ref argbuf3, 5) + Strings.Space(5));
SRC.NET/Status.cs:                    upic.Print(GeneralLib.LeftPaddedString(ref argbuf4, 4) + Strings.Space(10));
SRC.NET/Status.cs:                                upic.Print(localLeftPaddedString8() + Strings.Space(9));
SRC.NET/Status.cs:                    upic.Print(GeneralLib.LeftPaddedString(ref argbuf5, 5) + Strings.Space(9));
SRC.NET/Status.cs:                                upic.Print(localLeftPaddedString11() + Strings.Space(9));
SRC.NET/Status.cs:                    upic.Print(GeneralLib.LeftPaddedString(ref argbuf7, 5) + Strings.Space(9));
SRC.NET/Status.cs:                    upic.Print(GeneralLib.LeftPaddedString(ref argbuf8, 4) + Strings.Space(10));
SRC.NET/Status.cs:                                upic.Print(localLeftPaddedString14() + Strings.Space(9));
SRC.NET/Status.cs:                    upic.Print(GeneralLib.LeftPaddedString(ref argbuf9, 5) + Strings.Space(9));
SRC.NET/Status.cs:                                upic.Print(localLeftPaddedString17() + Strings.Space(9));
SRC.NET/Status.cs:                    upic.Print(GeneralLib.LeftPaddedString(ref argbuf11, 5) + Strings.Space(9));
SRC.NET/Status.cs:                    if (Strings.InStr(sname, "非表示") == 0)
SRC.NET/Status.cs:                    if (Strings.InStr(p.SkillName(ref argIndex12), "非表示") == 0)
SRC.NET/Status.cs:                        switch (Strings.Right(localCondition2(), 3) ?? "")
SRC.NET/Status.cs:                                                stype = Strings.Left(localCondition(), Strings.Len(localCondition1()) - 3);
SRC.NET/Status.cs:                    if (Strings.InStr(sname, "非表示") > 0)
SRC.NET/Status.cs:                                if (!u.IsFeatureAvailable(ref argfname2) & !u.IsFeatureAvailable(ref argfname3) & !u.IsFeatureAvailable(ref argfname4) & !u.IsFeatureAvailable(ref argfname5) & !u.IsFeatureAvailable(ref argfname6) & !u.IsFeatureAvailable(ref argfname7) & !u.IsFeatureAvailable(ref argfname8) & !u.IsFeatureAvailable(ref argfname9) & !u.IsFeatureAvailable(ref argfname10) & Strings.InStr(u.FeatureData(ref argIndex18), "Ｓ防御") == 0 & Strings.InStr(u.FeatureData(ref argIndex19), "Ｓ防御") == 0 & Strings.InStr(u.FeatureData(ref argIndex20), "Ｓ防御") == 0 & Strings.InStr(u.FeatureData(ref argIndex21), "Ｓ防御") == 0 & Strings.InStr(u.FeatureData(ref argIndex22), "Ｓ防御") == 0 & !string.IsNullOrEmpty(Map.MapFileName))
SRC.NET/Status.cs:                                if (j > u.CountWeapon() & Strings.InStr(u.FeatureData(ref argIndex23), "切り払い") == 0 & Strings.InStr(u.FeatureData(ref argIndex24), "切り払い") == 0 & Strings.InStr(u.FeatureData(ref argIndex25), "切り払い") == 0 & Strings.InStr(u.FeatureData(ref argIndex26), "切り払い") == 0 & Strings.InStr(u.FeatureData(ref argIndex27), "切り払い") == 0 & !string.IsNullOrEmpty(Map.MapFileName))
SRC.NET/Status.cs:                                if (j > u.CountWeapon() & Strings.InStr(u.FeatureData(ref argIndex28), "迎撃") == 0 & Strings.InStr(u.FeatureData(ref argIndex29), "迎撃") == 0 & Strings.InStr(u.FeatureData(ref argIndex30), "迎撃") == 0 & Strings.InStr(u.FeatureData(ref argIndex31), "迎撃") == 0 & Strings.InStr(u.FeatureData(ref argIndex32), "迎撃") == 0 & !string.IsNullOrEmpty(Map.MapFileName))
SRC.NET/Status.cs:                    if (LenB(Strings.StrConv(sname, vbFromUnicode)) > 19)
SRC.NET/Status.cs:                    if (Strings.InStr(Map.TerrainName(withBlock.x, withBlock.y), "(") > 0)
SRC.NET/Status.cs:                        upic.Print(withBlock.Area + " (" + Strings.Left(Map.TerrainName(withBlock.x, withBlock.y), Strings.InStr(Map.TerrainName(withBlock.x, withBlock.y), "(") - 1));
SRC.NET/Status.cs:                        upic.Print(" " + Strings.Left(Expression.Term(ref argtname28, u: ref argu), 1) + "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Map.TerrainEffectForHPRecover(withBlock.x, withBlock.y)) + "%");
SRC.NET/Status.cs:                        upic.Print(" " + Strings.Left(Expression.Term(ref argtname29, u: ref argu1), 1) + "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Map.TerrainEffectForENRecover(withBlock.x, withBlock.y)) + "%");
SRC.NET/Status.cs:                        upic.Print(" " + Strings.Left(Expression.Term(ref argtname30, u: ref argu2), 1) + "-" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(10d * td.FeatureLevel(ref argIndex33)) + "%");
SRC.NET/Status.cs:                        upic.Print(" " + Strings.Left(Expression.Term(ref argtname31, u: ref argu3), 1) + "-" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(10d * td.FeatureLevel(ref argIndex34)) + "%");
SRC.NET/Status.cs:                        upic.Print(" " + Strings.Left(Expression.Term(ref argtname32, u: ref argu4), 1) + "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(1000d * td.FeatureLevel(ref argIndex35)));
SRC.NET/Status.cs:                        upic.Print(" " + Strings.Left(Expression.Term(ref argtname33, u: ref argu5), 1) + "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(10d * td.FeatureLevel(ref argIndex36)));
SRC.NET/Status.cs:                        upic.Print(" " + Strings.Left(Expression.Term(ref argtname34, u: ref argu6), 1) + "-" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(1000d * td.FeatureLevel(ref argIndex37)));
SRC.NET/Status.cs:                        upic.Print(" " + Strings.Left(Expression.Term(ref argtname35, u: ref argu7), 1) + "-" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(10d * td.FeatureLevel(ref argIndex38)));
SRC.NET/Status.cs:                    if (Strings.InStr(localConditionData1(), "非表示") > 0)
SRC.NET/Status.cs:                                if (Strings.InStr(buf, "Lv") > 0)
SRC.NET/Status.cs:                                    buf = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
SRC.NET/Status.cs:                                upic.Print(buf + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(localConditionLevel5()), VbStrConv.Wide) + "体破壊");
SRC.NET/Status.cs:                                upic.Print(withBlock.FeatureName(ref argIndex56) + "残り" + Strings.StrConv(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(localConditionLevel6()), VbStrConv.Wide) + "体");
SRC.NET/Status.cs:                                if (Strings.Right(localCondition7(), 3) == "充填中")
SRC.NET/Status.cs:                                        upic.Print(Strings.Left(localCondition4(), Strings.Len(localCondition5()) - 3));
SRC.NET/Status.cs:                                if (Strings.Right(localCondition8(), 3) == "付加２" | Strings.Right(localCondition9(), 3) == "強化２")
SRC.NET/Status.cs:                                if (Strings.Right(localCondition12(), 2) == "付加" & !string.IsNullOrEmpty(localConditionData15()))
SRC.NET/Status.cs:                                else if (Strings.Right(localCondition13(), 2) == "強化" & !string.IsNullOrEmpty(localConditionData16()))
SRC.NET/Status.cs:                                    buf = Strings.Left(localCondition10(), Strings.Len(localCondition11()) - 2) + "Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(localConditionLevel8()) + "付加";
SRC.NET/Status.cs:                upic.Print(Strings.Space(8));
SRC.NET/Status.cs:                upic.Print(Strings.StrConv(withBlock.Size, VbStrConv.Wide));
SRC.NET/Status.cs:                if (Strings.Len(withBlock.strAbsorb) > 0 & Strings.InStr(withBlock.strAbsorb, "非表示") == 0)
SRC.NET/Status.cs:                    if (Strings.Len(withBlock.strAbsorb) > 5)
SRC.NET/Status.cs:                if (Strings.Len(withBlock.strImmune) > 0 & Strings.InStr(withBlock.strImmune, "非表示") == 0)
SRC.NET/Status.cs:                    if (Strings.Len(withBlock.strImmune) > 5)
SRC.NET/Status.cs:                if (Strings.Len(withBlock.strResist) > 0 & Strings.InStr(withBlock.strResist, "非表示") == 0)
SRC.NET/Status.cs:                    if (Strings.Len(withBlock.strResist) > 5)
SRC.NET/Status.cs:                if (Strings.Len(withBlock.strWeakness) > 0 & Strings.InStr(withBlock.strWeakness, "非表示") == 0)
SRC.NET/Status.cs:                    if (Strings.Len(withBlock.strWeakness) > 5)
SRC.NET/Status.cs:                if (Strings.Len(withBlock.strEffective) > 0 & Strings.InStr(withBlock.strEffective, "非表示") == 0)
SRC.NET/Status.cs:                    if (Strings.Len(withBlock.strEffective) > 5)
SRC.NET/Status.cs:                if (Strings.Len(withBlock.strSpecialEffectImmune) > 0 & Strings.InStr(withBlock.strSpecialEffectImmune, "非表示") == 0)
SRC.NET/Status.cs:                    if (Strings.Len(withBlock.strSpecialEffectImmune) > 5)
SRC.NET/Status.cs:                                if (withBlock.EN < ecost | pmorale < nmorale | withBlock.IsConditionSatisfied(ref argIndex70) & Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Status.cs:                                else if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Status.cs:                                        if (Strings.InStr(opt, "*") > 0)
SRC.NET/Status.cs:                                            opt = Strings.Left(opt, Strings.InStr(opt, "*") - 1);
SRC.NET/Status.cs:                                if (withBlock.EN < ecost | pmorale < nmorale | withBlock.IsConditionSatisfied(ref argIndex71) & Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Status.cs:                                else if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Status.cs:                                        if (Strings.InStr(opt, "*") > 0)
SRC.NET/Status.cs:                                            opt = Strings.Left(opt, Strings.InStr(opt, "*") - 1);
SRC.NET/Status.cs:                                if (withBlock.EN < ecost | pmorale < nmorale | withBlock.IsConditionSatisfied(ref argIndex72) & Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Status.cs:                                else if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Status.cs:                                        if (Strings.InStr(opt, "*") > 0)
SRC.NET/Status.cs:                                            opt = Strings.Left(opt, Strings.InStr(opt, "*") - 1);
SRC.NET/Status.cs:                                else if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Status.cs:                                        if (Strings.InStr(opt, "*") > 0)
SRC.NET/Status.cs:                                            opt = Strings.Left(opt, Strings.InStr(opt, "*") - 1);
SRC.NET/Status.cs:                                else if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Status.cs:                                        if (Strings.InStr(opt, "*") > 0)
SRC.NET/Status.cs:                                            opt = Strings.Left(opt, Strings.InStr(opt, "*") - 1);
SRC.NET/Status.cs:                                    if (Strings.InStr(fdata, " 直線") > 0 | Strings.InStr(fdata, " 垂直") > 0 & Strings.InStr(fdata, " 水平") > 0)
SRC.NET/Status.cs:                                    else if (Strings.InStr(fdata, " 垂直") > 0)
SRC.NET/Status.cs:                                    else if (Strings.InStr(fdata, " 水平") > 0)
SRC.NET/Status.cs:                    if (LenB(Strings.StrConv(fname, vbFromUnicode)) > 19)
SRC.NET/Status.cs:                            if (Strings.Len(withBlock6.Nickname()) > 9)
SRC.NET/Status.cs:                upic.Print(Strings.Space(25));
SRC.NET/Status.cs:                        string localLeftPaddedString21() { string argbuf = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock.Weapon(w).MinRange) + "-" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock.WeaponMaxRange(w)); var ret = GeneralLib.LeftPaddedString(ref argbuf, 34 - LenB(Strings.StrConv(buf, vbFromUnicode))); return ret; }
SRC.NET/Status.cs:                        buf = buf + GeneralLib.LeftPaddedString(ref argbuf20, 34 - LenB(Strings.StrConv(buf, vbFromUnicode)));
SRC.NET/Susie.cs:            switch (Strings.LCase(Strings.Right(fname, 4)) ?? "")
SRC.NET/Susie.cs:            MoveMemory(ref bmi, ref lpHBInfo, Strings.Len(bmi));
SRC.NET/Susie.cs:            switch (Strings.LCase(Strings.Right(fname, 4)) ?? "")
SRC.NET/TerrainData.cs:            i = (short)Strings.InStr(buf, "Lv");
SRC.NET/TerrainData.cs:            j = (short)Strings.InStr(buf, "=");
SRC.NET/TerrainData.cs:                ftype = Strings.Left(buf, i - 1);
SRC.NET/TerrainData.cs:                    flevel = Conversions.ToDouble(Strings.Mid(buf, i + 2, j - (i + 2)));
SRC.NET/TerrainData.cs:                    fdata = Strings.Mid(buf, j + 1);
SRC.NET/TerrainData.cs:                    flevel = Conversions.ToDouble(Strings.Mid(buf, i + 2));
SRC.NET/TerrainData.cs:                ftype = Strings.Left(buf, j - 1);
SRC.NET/TerrainData.cs:                fdata = Strings.Mid(buf, j + 1);
SRC.NET/TerrainData.cs:            if (Strings.Len(fd.StrData) > 0)
SRC.NET/TerrainDataList.cs:                while (Strings.Len(line_buf) == 0);
SRC.NET/TerrainDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/TerrainDataList.cs:                data_name = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/TerrainDataList.cs:                buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/TerrainDataList.cs:                td.Bitmap_Renamed = Strings.Trim(buf);
SRC.NET/TerrainDataList.cs:                if (Strings.Len(td.Bitmap_Renamed) == 0)
SRC.NET/TerrainDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/TerrainDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/TerrainDataList.cs:                buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/TerrainDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/TerrainDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/TerrainDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/TerrainDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/TerrainDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/TerrainDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/TerrainDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/TerrainDataList.cs:                buf2 = Strings.Trim(buf);
SRC.NET/TerrainDataList.cs:                while (Strings.Len(line_buf) > 0)
SRC.NET/TerrainDataList.cs:                    while (Strings.Len(buf) > 0)
SRC.NET/TerrainDataList.cs:                        var loopTo = (short)Strings.Len(buf);
SRC.NET/TerrainDataList.cs:                            switch (Strings.Mid(buf, (int)j, 1) ?? "")
SRC.NET/TerrainDataList.cs:                            buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/TerrainDataList.cs:                            buf = Strings.Trim(Strings.Mid(buf, (int)ret + 1));
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(Nickname0Ret, "$(愛称)");
SRC.NET/Unit.cs:                        Nickname0Ret = Strings.Left(Nickname0Ret, idx - 1) + Data.Nickname + Strings.Mid(Nickname0Ret, idx + 5);
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(Nickname0Ret, "$(パイロット愛称)");
SRC.NET/Unit.cs:                            Nickname0Ret = Strings.Left(Nickname0Ret, idx - 1) + MainPilot().get_Nickname(true) + Strings.Mid(Nickname0Ret, idx + 10);
SRC.NET/Unit.cs:                            Nickname0Ret = Strings.Left(Nickname0Ret, idx - 1) + "○○" + Strings.Mid(Nickname0Ret, idx + 10);
SRC.NET/Unit.cs:                            if (Strings.InStr(withBlock.Name, "(ザコ)") == 0 & Strings.InStr(withBlock.Name, "(汎用)") == 0)
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(KanaNameRet, "$(読み仮名)");
SRC.NET/Unit.cs:                        KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + Data.KanaName + Strings.Mid(KanaNameRet, idx + 5);
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(KanaNameRet, "$(パイロット読み仮名)");
SRC.NET/Unit.cs:                            KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + MainPilot().KanaName + Strings.Mid(KanaNameRet, idx + 10);
SRC.NET/Unit.cs:                            KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + "○○" + Strings.Mid(KanaNameRet, idx + 10);
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(KanaNameRet, "$(愛称)");
SRC.NET/Unit.cs:                        KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + Data.Nickname + Strings.Mid(KanaNameRet, idx + 5);
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(KanaNameRet, "$(パイロット愛称)");
SRC.NET/Unit.cs:                            KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + MainPilot().get_Nickname(false) + Strings.Mid(KanaNameRet, idx + 10);
SRC.NET/Unit.cs:                            KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + "○○" + Strings.Mid(KanaNameRet, idx + 10);
SRC.NET/Unit.cs:                if (Strings.Left(Class0Ret, 1) == "(")
SRC.NET/Unit.cs:                    Class0Ret = Strings.Mid(Class0Ret, 2, Strings.Len(Class0Ret) - 2);
SRC.NET/Unit.cs:                if (Strings.Right(Class0Ret, 3) == "専用)")
SRC.NET/Unit.cs:                    i = (short)(Strings.Len(Class0Ret) - 2);
SRC.NET/Unit.cs:                        switch (Strings.Mid(Class0Ret, i, 1) ?? "")
SRC.NET/Unit.cs:                                        Class0Ret = Strings.Left(Class0Ret, i - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(TransportationRet, "空") == 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(TransportationRet, "陸") == 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(TransportationRet, "水") == 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(TransportationRet, "地中") == 0)
SRC.NET/Unit.cs:            switch (Strings.Mid(strAdaption, idx, 1) ?? "")
SRC.NET/Unit.cs:                switch (Strings.Mid(MainPilot().Adaption, idx, 1) ?? "")
SRC.NET/Unit.cs:            if (Strings.InStr(Transportation, area_name) > 0)
SRC.NET/Unit.cs:            if (Strings.InStr(fd.Name, "拡大画像") == 1)
SRC.NET/Unit.cs:            if (Strings.Len(fd.StrData) > 0)
SRC.NET/Unit.cs:            if (Strings.InStr(FeatureName0Ret, "Lv") > 0)
SRC.NET/Unit.cs:                FeatureName0Ret = Strings.Left(FeatureName0Ret, Strings.InStr(FeatureName0Ret, "Lv") - 1);
SRC.NET/Unit.cs:                    if (Strings.Right(cnd.Name, 2) == "付加")
SRC.NET/Unit.cs:                        fd.Name = Strings.Left(cnd.Name, Strings.Len(cnd.Name) - 2);
SRC.NET/Unit.cs:                switch (Strings.Right(localCondition(), 3) ?? "")
SRC.NET/Unit.cs:                            if (Strings.Asc(fd.StrData) == 34) // "
SRC.NET/Unit.cs:                                buf = Strings.Mid(fd.StrData, 2, Strings.Len(fd.StrData) - 2);
SRC.NET/Unit.cs:                            if (Strings.InStr(buf, "=") > 0)
SRC.NET/Unit.cs:                                sdata = Strings.Mid(buf, Strings.InStr(buf, "=") + 1);
SRC.NET/Unit.cs:                                buf = Strings.Left(buf, Strings.InStr(buf, "=") - 1);
SRC.NET/Unit.cs:                                if (Strings.InStr(buf, "Lv") > 0)
SRC.NET/Unit.cs:                                    stype = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
SRC.NET/Unit.cs:                                    if (Information.IsNumeric(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2)))
SRC.NET/Unit.cs:                                        slevel = Conversions.ToDouble(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2));
SRC.NET/Unit.cs:                                if (Strings.InStr(buf, "Lv") > 0)
SRC.NET/Unit.cs:                                    stype = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
SRC.NET/Unit.cs:                                    if (Information.IsNumeric(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2)))
SRC.NET/Unit.cs:                                        slevel = Conversions.ToDouble(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2));
SRC.NET/Unit.cs:                                                if (Strings.InStr(sdata2, "非表示") != 1)
SRC.NET/Unit.cs:                                                sdata2 = Strings.Trim(sdata2);
SRC.NET/Unit.cs:                            if (Strings.Asc(fd.StrData) == 34) // "
SRC.NET/Unit.cs:                                buf = Strings.Mid(fd.StrData, 2, Strings.Len(fd.StrData) - 2);
SRC.NET/Unit.cs:                            if (Strings.InStr(buf, "=") > 0)
SRC.NET/Unit.cs:                                sdata = Strings.Mid(buf, Strings.InStr(buf, "=") + 1);
SRC.NET/Unit.cs:                                buf = Strings.Left(buf, Strings.InStr(buf, "=") - 1);
SRC.NET/Unit.cs:                                if (Strings.InStr(buf, "Lv") > 0)
SRC.NET/Unit.cs:                                    stype = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
SRC.NET/Unit.cs:                                    if (Information.IsNumeric(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2)))
SRC.NET/Unit.cs:                                        slevel = Conversions.ToDouble(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2));
SRC.NET/Unit.cs:                                if (Strings.InStr(buf, "Lv") > 0)
SRC.NET/Unit.cs:                                    stype = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
SRC.NET/Unit.cs:                                    if (Information.IsNumeric(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2)))
SRC.NET/Unit.cs:                                        slevel = Conversions.ToDouble(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2));
SRC.NET/Unit.cs:                                                if (Strings.InStr(sdata2, "非表示") != 1)
SRC.NET/Unit.cs:                switch (Strings.Mid(Data.Adaption, i, 1) ?? "")
SRC.NET/Unit.cs:                    switch (Strings.Right(ch, 6) ?? "")
SRC.NET/Unit.cs:                                strWeakness = strWeakness + Strings.Left(ch, Strings.Len(ch) - 6);
SRC.NET/Unit.cs:                                strEffective = strEffective + Strings.Left(ch, Strings.Len(ch) - 6);
SRC.NET/Unit.cs:            var loopTo9 = (short)Strings.Len(strAbsorb);
SRC.NET/Unit.cs:            var loopTo10 = (short)Strings.Len(strImmune);
SRC.NET/Unit.cs:            var loopTo11 = (short)Strings.Len(strResist);
SRC.NET/Unit.cs:            var loopTo12 = (short)Strings.Len(strWeakness);
SRC.NET/Unit.cs:            var loopTo13 = (short)Strings.Len(strEffective);
SRC.NET/Unit.cs:            var loopTo14 = (short)Strings.Len(strSpecialEffectImmune);
SRC.NET/Unit.cs:                        strWeaponClass[i] = Strings.Left(wclass, GeneralLib.InStrNotNest(ref wclass, ref argstring2) - 1);
SRC.NET/Unit.cs:                        hidden_attr = Strings.Mid(wclass, GeneralLib.InStrNotNest(ref wclass, ref argstring21) + 1);
SRC.NET/Unit.cs:                            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/Unit.cs:                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/Unit.cs:                                if (Strings.Left(wtype, 1) == "!")
SRC.NET/Unit.cs:                                    wtype = Strings.Mid(wtype, 2);
SRC.NET/Unit.cs:                                                    if (Strings.InStr(sname, "Lv") > 0)
SRC.NET/Unit.cs:                                                        sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
SRC.NET/Unit.cs:                                    var loopTo28 = (short)Strings.Len(buf);
SRC.NET/Unit.cs:                                                    strWeaponClass[i] = Strings.Left(strWeaponClass[i], l - 1) + ch + Strings.Mid(strWeaponClass[i], l);
SRC.NET/Unit.cs:                    if (Strings.Len(hidden_attr) > 0)
SRC.NET/Unit.cs:                            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/Unit.cs:                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/Unit.cs:                                if (Strings.Left(wtype, 1) == "!")
SRC.NET/Unit.cs:                                    wtype = Strings.Mid(wtype, 2);
SRC.NET/Unit.cs:                                                        if (Strings.InStr(sname, "Lv") > 0)
SRC.NET/Unit.cs:                                                            sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
SRC.NET/Unit.cs:                            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/Unit.cs:                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/Unit.cs:                                if (Strings.Left(wtype, 1) == "!")
SRC.NET/Unit.cs:                                    wtype = Strings.Mid(wtype, 2);
SRC.NET/Unit.cs:                                                        if (Strings.InStr(sname, "Lv") > 0)
SRC.NET/Unit.cs:                                                            sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
SRC.NET/Unit.cs:                            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/Unit.cs:                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/Unit.cs:                                if (Strings.Left(wtype, 1) == "!")
SRC.NET/Unit.cs:                                    wtype = Strings.Mid(wtype, 2);
SRC.NET/Unit.cs:                                                    if (Strings.InStr(sname, "Lv") > 0)
SRC.NET/Unit.cs:                                                        sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
SRC.NET/Unit.cs:                            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/Unit.cs:                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/Unit.cs:                                if (Strings.Left(wtype, 1) == "!")
SRC.NET/Unit.cs:                                    wtype = Strings.Mid(wtype, 2);
SRC.NET/Unit.cs:                                                    if (Strings.InStr(sname, "Lv") > 0)
SRC.NET/Unit.cs:                                                        sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
SRC.NET/Unit.cs:                            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/Unit.cs:                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/Unit.cs:                                if (Strings.Left(wtype, 1) == "!")
SRC.NET/Unit.cs:                                    wtype = Strings.Mid(wtype, 2);
SRC.NET/Unit.cs:                                                    if (Strings.InStr(sname, "Lv") > 0)
SRC.NET/Unit.cs:                                                        sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
SRC.NET/Unit.cs:                            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/Unit.cs:                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/Unit.cs:                                if (Strings.Left(wtype, 1) == "!")
SRC.NET/Unit.cs:                                    wtype = Strings.Mid(wtype, 2);
SRC.NET/Unit.cs:                                                    if (Strings.InStr(buf, "Lv") > 0)
SRC.NET/Unit.cs:                                                        buf = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
SRC.NET/Unit.cs:                            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/Unit.cs:                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/Unit.cs:                                if (Strings.Left(wtype, 1) == "!")
SRC.NET/Unit.cs:                                    wtype = Strings.Mid(wtype, 2);
SRC.NET/Unit.cs:                                                    if (Strings.InStr(sname, "Lv") > 0)
SRC.NET/Unit.cs:                                                        sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
SRC.NET/Unit.cs:                    if (!p.IsAdditionalPilot | Strings.InStr(pname, "(ザコ)") == 0 & Strings.InStr(pname, "(汎用)") == 0)
SRC.NET/Unit.cs:                if (!p.IsAdditionalSupport | Strings.InStr(pname, "(ザコ)") == 0 & Strings.InStr(pname, "(汎用)") == 0)
SRC.NET/Unit.cs:                if (Strings.Right(Conversions.ToString(withBlock.Name), 2) == "付加" & Strings.InStr(Conversions.ToString(withBlock.StrData), "パイロット能力付加") == 0)
SRC.NET/Unit.cs:                                if (Strings.Right(cnd.Name, 2) == "付加" | Strings.Right(cnd.Name, 2) == "強化")
SRC.NET/Unit.cs:                        if (Strings.Mid(Weapon(w).Adaption, 3, 1) == "A")
SRC.NET/Unit.cs:            switch (Strings.Mid(Weapon(w).Adaption, ind, 1) ?? "")
SRC.NET/Unit.cs:            if (Strings.Len(attr) <= 2)
SRC.NET/Unit.cs:            if (Strings.InStr("弱効剋", Strings.Left(attr, 1)) > 0)
SRC.NET/Unit.cs:            start_idx = (short)(start_idx + Strings.Len(attrlv));
SRC.NET/Unit.cs:                c = Strings.Mid(wclass, i, 1);
SRC.NET/Unit.cs:                switch (Strings.Asc(c))
SRC.NET/Unit.cs:            WeaponLevelRet = Conversions.ToDouble(Strings.Mid(wclass, start_idx, i - start_idx));
SRC.NET/Unit.cs:            if (Strings.InStr(strWeaponClass[w], attr + "L") > 0)
SRC.NET/Unit.cs:            var loopTo = (short)Strings.Len(wclass);
SRC.NET/Unit.cs:                ret = (short)Strings.InStr("Ｓ縛劣中石凍痺眠乱魅恐踊狂ゾ害憑盲毒撹不止黙除即告脱Ｄ低吹Ｋ引転衰滅盗習写化弱効剋", Strings.Mid(wclass, i, 1));
SRC.NET/Unit.cs:            var loopTo = (short)Strings.Len(wclass);
SRC.NET/Unit.cs:                ret = (short)Strings.InStr("Ｓ縛劣中石凍痺眠乱魅恐踊狂ゾ害憑盲毒撹不止黙除即告脱Ｄ低吹Ｋ引転衰滅盗習写化弱効剋", wattr);
SRC.NET/Unit.cs:                ret = (short)Strings.InStr("先再忍貫固殺無浸破間浄吸減奪", wattr);
SRC.NET/Unit.cs:                    if (Strings.InStr(nskill, "Lv") > 0)
SRC.NET/Unit.cs:                        nskill = Strings.Left(nskill, Strings.InStr(nskill, "Lv") - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(nskill, "Lv") > 0)
SRC.NET/Unit.cs:                        nskill = Strings.Left(nskill, Strings.InStr(nskill, "Lv") - 1);
SRC.NET/Unit.cs:                if (Strings.Len(localCondition3()) > 6)
SRC.NET/Unit.cs:                    if (Strings.Right(localCondition2(), 6) == "属性使用不能")
SRC.NET/Unit.cs:                        string argstring22 = Strings.Left(localCondition(), Strings.Len(localCondition1()) - 6);
SRC.NET/Unit.cs:                    var loopTo4 = (short)Strings.Len(wclass);
SRC.NET/Unit.cs:                        if (Strings.Mid(wclass, i, 1) == "攻")
SRC.NET/Unit.cs:                            if (Strings.Mid(wclass, i - 1, 1) != "低")
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                var loopTo2 = (short)Strings.Len(buf);
SRC.NET/Unit.cs:                if (i > Strings.Len(buf))
SRC.NET/Unit.cs:                var loopTo3 = (short)Strings.Len(buf);
SRC.NET/Unit.cs:                if (i > Strings.Len(buf))
SRC.NET/Unit.cs:                    var loopTo4 = (short)Strings.Len(sdata);
SRC.NET/Unit.cs:                        string argstring213 = Strings.Mid(sdata, i, 1);
SRC.NET/Unit.cs:                    var loopTo5 = (short)Strings.Len(sdata);
SRC.NET/Unit.cs:                        string argstring214 = Strings.Mid(sdata, i, 1);
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr1 = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(t.MainPilot().Name, "(ザコ)") > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(t.MainPilot().Name, "(ザコ)") > 0)
SRC.NET/Unit.cs:                    var loopTo = (short)Strings.Len(buf);
SRC.NET/Unit.cs:                    if (i > Strings.Len(buf))
SRC.NET/Unit.cs:                    var loopTo1 = (short)Strings.Len(buf);
SRC.NET/Unit.cs:                    if (i > Strings.Len(buf))
SRC.NET/Unit.cs:                    buf = buf + Strings.Mid(GeneralLib.GetClassBundle(ref wclass, ref i), 2);
SRC.NET/Unit.cs:                    buf = buf + Strings.Mid(GeneralLib.GetClassBundle(ref wclass, ref i), 2);
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr1 = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr2 = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Unit.cs:            if (Strings.InStr(w.ToString(), "殺") > 0)
SRC.NET/Unit.cs:            if (Strings.Len(aname) == 0)
SRC.NET/Unit.cs:            slen = (short)Strings.Len(strAbsorb);
SRC.NET/Unit.cs:            if (Strings.Len(aname) == 0)
SRC.NET/Unit.cs:            slen = (short)Strings.Len(strImmune);
SRC.NET/Unit.cs:            if (Strings.Len(aname) == 0)
SRC.NET/Unit.cs:            slen = (short)Strings.Len(strResist);
SRC.NET/Unit.cs:            if (Strings.Len(aname) == 0)
SRC.NET/Unit.cs:            slen = (short)Strings.Len(strWeakness);
SRC.NET/Unit.cs:            if (Strings.Len(aname) == 0)
SRC.NET/Unit.cs:            slen = (short)Strings.Len(strEffective);
SRC.NET/Unit.cs:            if (Strings.Len(aname) == 0)
SRC.NET/Unit.cs:            if (Strings.Left(aname, 1) == "弱" | Strings.Left(aname, 1) == "効")
SRC.NET/Unit.cs:            if (Strings.Len(aclass1) == 0)
SRC.NET/Unit.cs:            if (Strings.Len(aclass2) == 0)
SRC.NET/Unit.cs:            alen = (short)Strings.Len(aclass1);
SRC.NET/Unit.cs:            dmg = Damage(w, ref t, true, Strings.InStr(attack_mode, "援護攻撃") > 0);
SRC.NET/Unit.cs:                else if (!is_critical & dmg > 0 & Strings.InStr(attack_mode, "援護攻撃") == 0)
SRC.NET/Unit.cs:                else if (Strings.InStr(attack_mode, "援護攻撃") > 0)
SRC.NET/Unit.cs:                if (Strings.Right(wnickname, 2) == "攻撃" | Strings.Right(wnickname, 4) == "アタック" | wnickname == "突撃")
SRC.NET/Unit.cs:                    if (Strings.Right(wnickname, 2) == "呪文")
SRC.NET/Unit.cs:                    else if (Strings.Right(wnickname, 2) == "の杖")
SRC.NET/Unit.cs:                        msg = msg + "[" + Strings.Left(wnickname, Strings.Len(wnickname) - 2) + "]の呪文を唱えた。;";
SRC.NET/Unit.cs:                else if (IsWeaponClassifiedAs(w, ref argattr11) & (Strings.InStr(wnickname, "ミサイル") > 0 | Strings.InStr(wnickname, "ロケット") > 0))
SRC.NET/Unit.cs:                else if (Strings.Right(wnickname, 1) == "息" | Strings.Right(wnickname, 3) == "ブレス" | Strings.Right(wnickname, 2) == "光線" | Strings.Right(wnickname, 1) == "光" | Strings.Right(wnickname, 3) == "ビーム" | Strings.Right(wnickname, 4) == "レーザー")
SRC.NET/Unit.cs:                else if (Strings.Right(wnickname, 1) == "歌")
SRC.NET/Unit.cs:                else if (Strings.Right(wnickname, 2) == "踊り")
SRC.NET/Unit.cs:            if (IsUnderSpecialPowerEffect(ref argsptype8) & this.MainPilot().Technique > t.MainPilot().Technique & Strings.InStr(attack_mode, "援護攻撃") == 0 | t.IsConditionSatisfied(ref argIndex9))
SRC.NET/Unit.cs:            if (Strings.InStr(critical_type, "即死") > 0 & !use_support_guard & !use_protect_msg)
SRC.NET/Unit.cs:            if (is_critical | Strings.Len(critical_type) > 0)
SRC.NET/Unit.cs:            else if ((dmg <= 0.05d * t.MaxHP & t.HP >= 0.25d * t.MaxHP | dmg <= 10) & Strings.Len(critical_type) == 0)
SRC.NET/Unit.cs:            else if (t.HP > 0.8d * t.MaxHP & Strings.Len(critical_type) == 0)
SRC.NET/Unit.cs:                else if ((dmg <= 0.05d * t.MaxHP & t.HP >= 0.25d * t.MaxHP | dmg <= 10) & Strings.Len(critical_type) == 0)
SRC.NET/Unit.cs:                else if (t.HP >= 0.8d * t.MaxHP & Strings.Len(critical_type) == 0)
SRC.NET/Unit.cs:                    if (Strings.Len(critical_type) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(t.FeatureName(ref argIndex22)) > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(attack_mode, "援護攻撃") > 0)
SRC.NET/Unit.cs:            if (Status_Renamed == "出撃" & t.Status_Renamed == "出撃" & Strings.InStr(attack_mode, "援護攻撃") == 0 & attack_mode != "マップ攻撃" & attack_mode != "反射" & !IsWeaponClassifiedAs(w, ref argattr39) & HP > 0 & t.HP > 0)
SRC.NET/Unit.cs:            if (Strings.InStr(msg, "かばった") == 0)
SRC.NET/Unit.cs:                if (Strings.InStr(attack_mode, "援護攻撃") == 0)
SRC.NET/Unit.cs:                else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Unit.cs:                    i = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Unit.cs:                    prob = (int)(100d * (u.SkillLevel(Strings.Left(buf, i - 1)) + Conversions.ToShort(Strings.Mid(buf, i))) / 16d);
SRC.NET/Unit.cs:            if (IsWeaponClassifiedAs(w, ref argattr4) & (slevel > t.MainPilot().SkillLevel(ref argIndex3, ref_mode: ref argref_mode4) | slevel > 0d & Strings.Len(wname2) == 0))
SRC.NET/Unit.cs:                    else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Unit.cs:                        j = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Unit.cs:                        prob = (int)(100d * (t.SkillLevel(Strings.Left(buf, j - 1)) + Conversions.ToShort(Strings.Mid(buf, j))) / 16d);
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                    else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Unit.cs:                        j = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Unit.cs:                        prob = (int)(100d * (t.SkillLevel(Strings.Left(buf, j - 1)) + Conversions.ToShort(Strings.Mid(buf, j))) / 16d);
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr1 = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:            if (t.MainPilot().SkillLevel(ref argIndex26, ref_mode: ref argref_mode15) > 0d & Strings.Len(wname2) > 0)
SRC.NET/Unit.cs:                    else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Unit.cs:                        j = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Unit.cs:                        prob = (int)(100d * (t.SkillLevel(Strings.Left(buf, j - 1)) + Conversions.ToShort(Strings.Mid(buf, j))) / 16d);
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr2 = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                if (Strings.Len(fname) > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(fname, "Lv") > 0)
SRC.NET/Unit.cs:                        fname = Strings.Left(fname, Strings.InStr(fname, "Lv") - 1);
SRC.NET/Unit.cs:                    if (Strings.Len(fname) > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(fname, "Lv") > 0)
SRC.NET/Unit.cs:                            fname = Strings.Left(fname, Strings.InStr(fname, "Lv") - 1);
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                            if (Strings.InStr(msg, "[" + fname + "]を貫いた") == 0)
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr1 = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                            if (Strings.InStr(msg, "[" + fname + "]を貫いた") == 0)
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr2 = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                            if (Strings.InStr(msg, "[" + fname + "]") == 0)
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr3 = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                                if (Strings.InStr(msg, "[" + fname + "]を貫いた") == 0)
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr4 = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                                if (Strings.InStr(msg, "[" + fname + "]を貫いた") == 0)
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr5 = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                                if (Strings.InStr(msg, "[" + fname + "]") == 0)
SRC.NET/Unit.cs:                    else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Unit.cs:                        j = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Unit.cs:                        prob = (int)(100d * (t.SkillLevel(Strings.Left(buf, j - 1)) + Conversions.ToShort(Strings.Mid(buf, j))) / 16d);
SRC.NET/Unit.cs:                        if (Strings.InStr(fdata, "完全自動") == 0)
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(opt, "*");
SRC.NET/Unit.cs:                            string argexpr = Strings.Mid(opt, idx + 1);
SRC.NET/Unit.cs:                            opt = Strings.Left(opt, idx - 1);
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(fdata, "能力必要") > 0)
SRC.NET/Unit.cs:                    else if (Strings.InStr(buf, "+") > 0 | Strings.InStr(buf, "-") > 0)
SRC.NET/Unit.cs:                        j = (short)GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
SRC.NET/Unit.cs:                        prob = (int)(100d * (SkillLevel(Strings.Left(buf, j - 1)) + Conversions.ToShort(Strings.Mid(buf, j))) / 16d);
SRC.NET/Unit.cs:                    if (Strings.Left(wtype, 1) == "@")
SRC.NET/Unit.cs:                        wtype = Strings.Mid(wtype, 2);
SRC.NET/Unit.cs:                                if (Strings.InStr(sname, "Lv") > 0)
SRC.NET/Unit.cs:                                    sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(fdata, "連鎖不可") > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(fdata, "命中時限定") > 0)
SRC.NET/Unit.cs:            if (Strings.InStr(fc1, "Lv") > 0)
SRC.NET/Unit.cs:                fc1 = Strings.Left(fc1, Strings.InStr(fc1, "Lv") - 1);
SRC.NET/Unit.cs:            if (Strings.InStr(fc2, "Lv") > 0)
SRC.NET/Unit.cs:                fc2 = Strings.Left(fc2, Strings.InStr(fc2, "Lv") - 1);
SRC.NET/Unit.cs:                    if (t.IsFeatureAvailable(ref argfname) & Strings.InStr(t.FeatureData(ref argIndex10), "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                        if (Strings.Len(fname) == 0)
SRC.NET/Unit.cs:                    else if (t.IsFeatureAvailable(ref argfname1) & Strings.InStr(t.FeatureData(ref argIndex11), "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                        if (Strings.Len(fname) == 0)
SRC.NET/Unit.cs:                        if (Strings.Len(fname) == 0)
SRC.NET/Unit.cs:                    else if (t.IsFeatureAvailable(ref argfname3) & Strings.InStr(t.FeatureData(ref argIndex12), "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                        if (Strings.Len(fname) == 0)
SRC.NET/Unit.cs:                    else if (t.IsFeatureAvailable(ref argfname4) & Strings.InStr(t.FeatureData(ref argIndex13), "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                        if (Strings.Len(fname) == 0)
SRC.NET/Unit.cs:                        if (Strings.Len(fname) == 0)
SRC.NET/Unit.cs:                    else if (t.IsFeatureAvailable(ref argfname6) & Strings.InStr(t.FeatureData(ref argIndex14), "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                        if (Strings.Len(fname) == 0)
SRC.NET/Unit.cs:                    else if (t.IsFeatureAvailable(ref argfname7) & Strings.InStr(t.FeatureData(ref argIndex15), "バリア無効化無効") == 0)
SRC.NET/Unit.cs:                        if (Strings.Len(fname) == 0)
SRC.NET/Unit.cs:                        if (Strings.Len(fname) == 0)
SRC.NET/Unit.cs:                        if ((Strings.InStr(localCondition(), "付加") > 0 | Strings.InStr(localCondition1(), "強化") > 0 | Strings.InStr(localCondition2(), "ＵＰ") > 0) & localCondition3() != "ノーマルモード付加" & localConditionLifetime() > 0)
SRC.NET/Unit.cs:                            if ((Strings.InStr(localCondition4(), "付加") > 0 | Strings.InStr(localCondition5(), "強化") > 0 | Strings.InStr(localCondition6(), "ＵＰ") > 0) & localCondition7() != "ノーマルモード付加" & localConditionLifetime1() > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(WeaponClass(w), "告L") > 0)
SRC.NET/Unit.cs:                ch = Strings.Mid(GeneralLib.GetClassBundle(ref strWeaponClass[w], ref i), 2);
SRC.NET/Unit.cs:                ch = Strings.Mid(GeneralLib.GetClassBundle(ref strWeaponClass[w], ref i), 2);
SRC.NET/Unit.cs:                ch = Strings.Mid(GeneralLib.GetClassBundle(ref strWeaponClass[w], ref i), 2);
SRC.NET/Unit.cs:                            if (Strings.Len(Skill[j]) > 0)
SRC.NET/Unit.cs:                if (Strings.Right(wnickname, 2) == "攻撃" | Strings.Right(wnickname, 4) == "アタック" | wnickname == "突撃")
SRC.NET/Unit.cs:                    if (Strings.Right(wnickname, 2) == "呪文")
SRC.NET/Unit.cs:                    else if (Strings.Right(wnickname, 2) == "の杖")
SRC.NET/Unit.cs:                        msg = msg + "[" + Strings.Left(wnickname, Strings.Len(wnickname) - 2) + "]の呪文を唱えた。";
SRC.NET/Unit.cs:                else if (IsWeaponClassifiedAs(w, ref argattr16) & (Strings.InStr(wnickname, "ミサイル") > 0 | Strings.InStr(wnickname, "ロケット") > 0))
SRC.NET/Unit.cs:                else if (Strings.Right(wnickname, 1) == "息" | Strings.Right(wnickname, 3) == "ブレス" | Strings.Right(wnickname, 2) == "光線" | Strings.Right(wnickname, 1) == "光" | Strings.Right(wnickname, 3) == "ビーム" | Strings.Right(wnickname, 4) == "レーザー")
SRC.NET/Unit.cs:                else if (Strings.Right(wnickname, 1) == "歌")
SRC.NET/Unit.cs:                else if (Strings.Right(wnickname, 2) == "踊り")
SRC.NET/Unit.cs:                            if (Strings.InStr(localSkillName2(), "非表示") == 0)
SRC.NET/Unit.cs:            start_idx = (short)Strings.InStr(aclass, attrlv);
SRC.NET/Unit.cs:            start_idx = (short)(start_idx + Strings.Len(attrlv));
SRC.NET/Unit.cs:                c = Strings.Mid(aclass, i, 1);
SRC.NET/Unit.cs:                switch (Strings.Asc(c))
SRC.NET/Unit.cs:            AbilityLevelRet = Conversions.ToDouble(Strings.Mid(aclass, start_idx, i - start_idx));
SRC.NET/Unit.cs:                    if (Strings.InStr(nskill, "Lv") > 0)
SRC.NET/Unit.cs:                        nskill = Strings.Left(nskill, Strings.InStr(nskill, "Lv") - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(nskill, "Lv") > 0)
SRC.NET/Unit.cs:                        nskill = Strings.Left(nskill, Strings.InStr(nskill, "Lv") - 1);
SRC.NET/Unit.cs:                if (Strings.Len(localCondition3()) > 6)
SRC.NET/Unit.cs:                    if (Strings.Right(localCondition2(), 6) == "属性使用不能")
SRC.NET/Unit.cs:                        string argstring2 = Strings.Left(localCondition(), Strings.Len(localCondition1()) - 6);
SRC.NET/Unit.cs:                    if (Strings.InStr(pname, "(汎用)") == 0 & Strings.InStr(pname, "(ザコ)") == 0)
SRC.NET/Unit.cs:                                        if (Strings.Len(localCondition2()) > 6)
SRC.NET/Unit.cs:                                            if (Strings.Right(localCondition1(), 6) == "属性使用不能")
SRC.NET/Unit.cs:                                if (Strings.InStr(edata, "サイズ制限強") > 0)
SRC.NET/Unit.cs:                                else if (Strings.InStr(edata, "サイズ制限無し") == 0)
SRC.NET/Unit.cs:                bool localWeakness() { string argstring2 = "限"; string arganame = Strings.Mid(Ability(a).Class_Renamed, GeneralLib.InStrNotNest(ref Ability(a).Class_Renamed, ref argstring2) + 1); var ret = t.Weakness(ref arganame); return ret; }
SRC.NET/Unit.cs:                bool localEffective() { string argstring2 = "限"; string arganame = Strings.Mid(Ability(a).Class_Renamed, GeneralLib.InStrNotNest(ref Ability(a).Class_Renamed, ref argstring2) + 1); var ret = t.Effective(ref arganame); return ret; }
SRC.NET/Unit.cs:                        if (Strings.Left(fname, 1) == "!")
SRC.NET/Unit.cs:                            fname = Strings.Mid(fname, 2);
SRC.NET/Unit.cs:                    if (Strings.Right(anickname, 2) == "呪文")
SRC.NET/Unit.cs:                    else if (Strings.Right(anickname, 2) == "の杖")
SRC.NET/Unit.cs:                        msg = msg + "[" + Strings.Left(anickname, Strings.Len(anickname) - 2) + "]の呪文を唱えた。";
SRC.NET/Unit.cs:                else if (Strings.Right(anickname, 1) == "歌")
SRC.NET/Unit.cs:                else if (Strings.Right(anickname, 2) == "踊り")
SRC.NET/Unit.cs:                    if ((Strings.InStr(localCondition(), "付加") > 0 | Strings.InStr(localCondition1(), "強化") > 0 | Strings.InStr(localCondition2(), "ＵＰ") > 0) & localCondition3() != "ノーマルモード付加" & localConditionLifetime() != 0)
SRC.NET/Unit.cs:                    var loopTo5 = (short)Strings.Len(buf);
SRC.NET/Unit.cs:                        if (Strings.InStr(aclass, GeneralLib.GetClassBundle(ref buf, ref i)) > 0)
SRC.NET/Unit.cs:                    var loopTo6 = (short)Strings.Len(buf);
SRC.NET/Unit.cs:                        if (Strings.InStr(aclass, GeneralLib.GetClassBundle(ref buf, ref i)) > 0)
SRC.NET/Unit.cs:                                        if (Strings.Len(localCondition5()) > 6 & Strings.Right(localCondition6(), 6) == "属性使用不能" & localConditionLifetime1() > 0)
SRC.NET/Unit.cs:                                fdata = Strings.Trim(fdata);
SRC.NET/Unit.cs:                                if (Strings.Left(fdata, 1) == "\"" & Strings.Right(fdata, 1) == "\"")
SRC.NET/Unit.cs:                                    fdata = Strings.Trim(Strings.Mid(fdata, 2, Strings.Len(fdata) - 2));
SRC.NET/Unit.cs:                                                    if (Strings.InStr(fdata2, "非表示") != 1)
SRC.NET/Unit.cs:                                            GUI.DisplaySysMessage(withBlock28.Nickname + "の" + "サイズが" + Strings.StrConv(GeneralLib.LIndex(ref edata, 3), VbStrConv.Wide) + "サイズに変化した。");
SRC.NET/Unit.cs:                                fdata = Strings.Trim(fdata);
SRC.NET/Unit.cs:                                                    if (Strings.InStr(fdata2, "非表示") != 1)
SRC.NET/Unit.cs:                                if (Strings.InStr(localItem1().Name, "(ザコ)") > 0 | Strings.InStr(localItem2().Name, "(汎用)") > 0)
SRC.NET/Unit.cs:                if (Strings.Right(anickname, 2) == "呪文")
SRC.NET/Unit.cs:                else if (Strings.Right(anickname, 2) == "の杖")
SRC.NET/Unit.cs:                    msg = msg + "[" + Strings.Left(anickname, Strings.Len(anickname) - 2) + "]の呪文を唱えた。";
SRC.NET/Unit.cs:            else if (Strings.Right(anickname, 1) == "歌")
SRC.NET/Unit.cs:            else if (Strings.Right(anickname, 2) == "踊り")
SRC.NET/Unit.cs:                            else if (Strings.InStr(iclass, "専用)") > 0)
SRC.NET/Unit.cs:                                if (Strings.InStr(iclass, eclass0 + "(") == 1 & (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 | Strings.InStr(iclass, "(" + Name + "専用)") > 0 | Strings.InStr(iclass, "(" + Nickname + "専用)") > 0))
SRC.NET/Unit.cs:                                    else if (Strings.InStr(iclass, "専用)") > 0)
SRC.NET/Unit.cs:                                        if (Strings.InStr(iclass, eclass0 + "(") == 1 & (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 | Strings.InStr(iclass, "(" + withBlock.Name + "専用)") > 0 | Strings.InStr(iclass, "(" + withBlock.Nickname + "専用)") > 0))
SRC.NET/Unit.cs:                            else if (Strings.InStr(iclass, "専用)") > 0)
SRC.NET/Unit.cs:                                if (Strings.InStr(iclass, eclass0 + "(") == 1 & (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 | Strings.InStr(iclass, "(" + Name + "専用)") > 0 | Strings.InStr(iclass, "(" + Nickname + "専用)") > 0))
SRC.NET/Unit.cs:                                    else if (Strings.InStr(iclass, "専用)") > 0)
SRC.NET/Unit.cs:                                        if (Strings.InStr(iclass, eclass0 + "(") == 1 & (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 | Strings.InStr(iclass, "(" + withBlock1.Name + "専用)") > 0 | Strings.InStr(iclass, "(" + withBlock1.Nickname + "専用)") > 0))
SRC.NET/Unit.cs:                        if (Strings.InStr(it.Part(), "強化パーツ") == 1)
SRC.NET/Unit.cs:                        if (Strings.InStr(iclass, "専用)") == 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 | Strings.InStr(iclass, "(" + Name + "専用)") > 0 | Strings.InStr(iclass, "(" + Nickname + "専用)") > 0)
SRC.NET/Unit.cs:                            if (Strings.InStr(iclass, "(" + MainPilot().Sex + "専用)") > 0)
SRC.NET/Unit.cs:                                if (Strings.InStr(iclass, "(" + withBlock2.Class0 + "専用)") > 0 | Strings.InStr(iclass, "(" + withBlock2.Name + "専用)") > 0 | Strings.InStr(iclass, "(" + withBlock2.Nickname + "専用)") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(iclass, "専用)") == 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 | Strings.InStr(iclass, "(" + Name + "専用)") > 0 | Strings.InStr(iclass, "(" + Nickname + "専用)") > 0)
SRC.NET/Unit.cs:                            if (Strings.InStr(iclass, "(" + MainPilot().Sex + "専用)") > 0)
SRC.NET/Unit.cs:                                if (Strings.InStr(iclass, "(" + withBlock3.Class0 + "専用)") > 0 | Strings.InStr(iclass, "(" + withBlock3.Name + "専用)") > 0 | Strings.InStr(iclass, "(" + withBlock3.Nickname + "専用)") > 0)
SRC.NET/Unit.cs:                        else if (Strings.InStr(Situation, "(命中)") > 0 | Strings.InStr(Situation, "(回避)") > 0 | Strings.InStr(Situation, "(とどめ)") > 0 | Strings.InStr(Situation, "(クリティカル)") > 0)
SRC.NET/Unit.cs:                            wname = Strings.Left(Situation, GeneralLib.InStr2(ref Situation, ref argstr2) - 1);
SRC.NET/Unit.cs:                                    situations[2] = "格闘" + Strings.Mid(Situation, GeneralLib.InStr2(ref Situation, ref argstr21));
SRC.NET/Unit.cs:                                    situations[2] = "射撃" + Strings.Mid(Situation, GeneralLib.InStr2(ref Situation, ref argstr22));
SRC.NET/Unit.cs:                                    situations[3] = "格闘" + Strings.Mid(Situation, GeneralLib.InStr2(ref Situation, ref argstr27));
SRC.NET/Unit.cs:                                    situations[3] = "射撃" + Strings.Mid(Situation, GeneralLib.InStr2(ref Situation, ref argstr28));
SRC.NET/Unit.cs:                                    situations[3] = "格闘" + Strings.Mid(Situation, GeneralLib.InStr2(ref Situation, ref argstr23)) + "(反撃)";
SRC.NET/Unit.cs:                                    situations[4] = "格闘" + Strings.Mid(Situation, GeneralLib.InStr2(ref Situation, ref argstr24));
SRC.NET/Unit.cs:                                    situations[3] = "射撃" + Strings.Mid(Situation, GeneralLib.InStr2(ref Situation, ref argstr25)) + "(反撃)";
SRC.NET/Unit.cs:                                    situations[4] = "射撃" + Strings.Mid(Situation, GeneralLib.InStr2(ref Situation, ref argstr26));
SRC.NET/Unit.cs:            if (Strings.InStr(selected_msg, "::") > 0)
SRC.NET/Unit.cs:                selected_pilot = Strings.Left(selected_msg, Strings.InStr(selected_msg, "::") - 1);
SRC.NET/Unit.cs:                selected_msg = Strings.Mid(selected_msg, Strings.InStr(selected_msg, "::") + 2);
SRC.NET/Unit.cs:                if (Strings.InStr(Situation, "かけ声") == 1)
SRC.NET/Unit.cs:                    if (Strings.InStr(Situation, "(") == 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(Situation, "(") == 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(Situation, "(") == 0)
SRC.NET/Unit.cs:                        if (Strings.Len(md.SelectMessage(ref situations[j], ref argu1)) > 0)
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(ユニット)") > 0)
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(msg, "$(ユニット)");
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(機体)") > 0)
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(msg, "$(機体)");
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 5);
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(パイロット)") > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(msg, "$(パイロット)");
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 8);
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(武器)") > 0)
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(msg, "$(武器)");
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "<") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "<") - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "＜") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "＜") - 1);
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 5);
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(損傷率)") > 0)
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(msg, "$(損傷率)");
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, idx - 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (MaxHP - HP) / MaxHP) + Strings.Mid(msg, idx + 6);
SRC.NET/Unit.cs:                    while (Strings.InStr(msg, "$(相手ユニット)") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                            buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                        if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                            buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(msg, "$(相手ユニット)");
SRC.NET/Unit.cs:                        msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 9);
SRC.NET/Unit.cs:                    while (Strings.InStr(msg, "$(相手機体)") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                            buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                        if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                            buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(msg, "$(相手機体)");
SRC.NET/Unit.cs:                        msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
SRC.NET/Unit.cs:                    while (Strings.InStr(msg, "$(相手パイロット)") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                            buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(msg, "$(相手パイロット)");
SRC.NET/Unit.cs:                        msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 10);
SRC.NET/Unit.cs:                    while (Strings.InStr(msg, "$(相手武器)") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(buf, "<") > 0)
SRC.NET/Unit.cs:                            buf = Strings.Left(buf, Strings.InStr(buf, "<") - 1);
SRC.NET/Unit.cs:                        if (Strings.InStr(buf, "＜") > 0)
SRC.NET/Unit.cs:                            buf = Strings.Left(buf, Strings.InStr(buf, "＜") - 1);
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(msg, "$(相手武器)");
SRC.NET/Unit.cs:                        msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
SRC.NET/Unit.cs:                    while (Strings.InStr(msg, "$(相手損傷率)") > 0)
SRC.NET/Unit.cs:                        idx = (short)Strings.InStr(msg, "$(相手損傷率)");
SRC.NET/Unit.cs:                        msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 8);
SRC.NET/Unit.cs:                else if (Strings.Left(dd.Name(i), 1) == "@")
SRC.NET/Unit.cs:                    string argpname1 = Strings.Mid(dd.Name(i), 2);
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(ユニット)") > 0)
SRC.NET/Unit.cs:                idx = (short)Strings.InStr(msg, "$(ユニット)");
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(機体)") > 0)
SRC.NET/Unit.cs:                idx = (short)Strings.InStr(msg, "$(機体)");
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 5);
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(パイロット)") > 0)
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                idx = (short)Strings.InStr(msg, "$(パイロット)");
SRC.NET/Unit.cs:                msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 8);
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(武器)") > 0)
SRC.NET/Unit.cs:                idx = (short)Strings.InStr(msg, "$(武器)");
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "<") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "<") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "＜") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "＜") - 1);
SRC.NET/Unit.cs:                msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 5);
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(損傷率)") > 0)
SRC.NET/Unit.cs:                idx = (short)Strings.InStr(msg, "$(損傷率)");
SRC.NET/Unit.cs:                msg = Strings.Left(msg, idx - 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (MaxHP - HP) / MaxHP) + Strings.Mid(msg, idx + 6);
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(相手ユニット)") > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(msg, "$(相手ユニット)");
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 9);
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(相手機体)") > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(msg, "$(相手機体)");
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(相手パイロット)") > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(msg, "$(相手パイロット)");
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 10);
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(相手武器)") > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "<") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "<") - 1);
SRC.NET/Unit.cs:                    if (Strings.InStr(buf, "＜") > 0)
SRC.NET/Unit.cs:                        buf = Strings.Left(buf, Strings.InStr(buf, "＜") - 1);
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(msg, "$(相手武器)");
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(相手損傷率)") > 0)
SRC.NET/Unit.cs:                    idx = (short)Strings.InStr(msg, "$(相手損傷率)");
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 8);
SRC.NET/Unit.cs:                if (Strings.Len(msg) == 0)
SRC.NET/Unit.cs:            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                                if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        ret = (short)Strings.InStr(uname, "(");
SRC.NET/Unit.cs:                            uname = Strings.Left(uname, ret - 1);
SRC.NET/Unit.cs:                        ret = (short)Strings.InStr(uname, "用");
SRC.NET/Unit.cs:                            if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                                uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                        ret = (short)Strings.InStr(uname, "型");
SRC.NET/Unit.cs:                            if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                                uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                        if (Strings.Right(uname, 4) == "カスタム")
SRC.NET/Unit.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 4);
SRC.NET/Unit.cs:                        if (Strings.Right(uname, 1) == "改")
SRC.NET/Unit.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 1);
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "(");
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, ret - 1);
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "用");
SRC.NET/Unit.cs:                        if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                            uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "型");
SRC.NET/Unit.cs:                        if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                            uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                    if (Strings.Right(uname, 4) == "カスタム")
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, Strings.Len(uname) - 4);
SRC.NET/Unit.cs:                    if (Strings.Right(uname, 1) == "改")
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, Strings.Len(uname) - 1);
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "(");
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, ret - 1);
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "用");
SRC.NET/Unit.cs:                        if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                            uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "型");
SRC.NET/Unit.cs:                        if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                            uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                    if (Strings.Right(uname, 4) == "カスタム")
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, Strings.Len(uname) - 4);
SRC.NET/Unit.cs:                    if (Strings.Right(uname, 1) == "改")
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, Strings.Len(uname) - 1);
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(ユニット)") > 0)
SRC.NET/Unit.cs:                idx = Strings.InStr(msg, "$(ユニット)").ToString();
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                msg = Strings.Left(msg, (int)(Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (int)(Conversions.ToDouble(idx) + 7d));
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(機体)") > 0)
SRC.NET/Unit.cs:                idx = Strings.InStr(msg, "$(機体)").ToString();
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                msg = Strings.Left(msg, (int)(Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (int)(Conversions.ToDouble(idx) + 5d));
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(パイロット)") > 0)
SRC.NET/Unit.cs:                idx = Strings.InStr(msg, "$(パイロット)").ToString();
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                msg = Strings.Left(msg, (int)(Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (int)(Conversions.ToDouble(idx) + 8d));
SRC.NET/Unit.cs:            if (Strings.InStr(msg, "$(武器)") > 0)
SRC.NET/Unit.cs:                if (Strings.InStr(wname, "(") > 0)
SRC.NET/Unit.cs:                    wname = Strings.Left(wname, Strings.InStr(wname, "(") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(wname, "<") > 0)
SRC.NET/Unit.cs:                    wname = Strings.Left(wname, Strings.InStr(wname, "<") - 1);
SRC.NET/Unit.cs:                while (Strings.InStr(msg, "$(武器)") > 0)
SRC.NET/Unit.cs:                    idx = Strings.InStr(msg, "$(武器)").ToString();
SRC.NET/Unit.cs:                    msg = Strings.Left(msg, (int)(Conversions.ToDouble(idx) - 1d)) + wname + Strings.Mid(msg, (int)(Conversions.ToDouble(idx) + 5d));
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(損傷率)") > 0)
SRC.NET/Unit.cs:                idx = Strings.InStr(msg, "$(損傷率)").ToString();
SRC.NET/Unit.cs:                msg = Strings.Left(msg, (int)(Conversions.ToDouble(idx) - 1d)) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (MaxHP - HP) / MaxHP) + Strings.Mid(msg, (int)(Conversions.ToDouble(idx) + 6d));
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(相手ユニット)") > 0)
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                idx = Strings.InStr(msg, "$(相手ユニット)").ToString();
SRC.NET/Unit.cs:                msg = Strings.Left(msg, (int)(Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (int)(Conversions.ToDouble(idx) + 9d));
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(相手機体)") > 0)
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "専用") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "専用") + 2);
SRC.NET/Unit.cs:                idx = Strings.InStr(msg, "$(相手機体)").ToString();
SRC.NET/Unit.cs:                msg = Strings.Left(msg, (int)(Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (int)(Conversions.ToDouble(idx) + 7d));
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(相手パイロット)") > 0)
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                idx = Strings.InStr(msg, "$(相手パイロット)").ToString();
SRC.NET/Unit.cs:                msg = Strings.Left(msg, (int)(Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (int)(Conversions.ToDouble(idx) + 10d));
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(相手武器)") > 0)
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "(") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "<") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "<") - 1);
SRC.NET/Unit.cs:                if (Strings.InStr(buf, "＜") > 0)
SRC.NET/Unit.cs:                    buf = Strings.Left(buf, Strings.InStr(buf, "＜") - 1);
SRC.NET/Unit.cs:                idx = Strings.InStr(msg, "$(相手武器)").ToString();
SRC.NET/Unit.cs:                msg = Strings.Left(msg, (int)(Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (int)(Conversions.ToDouble(idx) + 7d));
SRC.NET/Unit.cs:            while (Strings.InStr(msg, "$(相手損傷率)") > 0)
SRC.NET/Unit.cs:                idx = Strings.InStr(msg, "$(相手損傷率)").ToString();
SRC.NET/Unit.cs:                msg = Strings.Left(msg, (int)(Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (int)(Conversions.ToDouble(idx) + 8d));
SRC.NET/Unit.cs:                                if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        ret = (short)Strings.InStr(uname, "(");
SRC.NET/Unit.cs:                            uname = Strings.Left(uname, ret - 1);
SRC.NET/Unit.cs:                        ret = (short)Strings.InStr(uname, "用");
SRC.NET/Unit.cs:                            if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                                uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                        ret = (short)Strings.InStr(uname, "型");
SRC.NET/Unit.cs:                            if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                                uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                        if (Strings.Right(uname, 4) == "カスタム")
SRC.NET/Unit.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 4);
SRC.NET/Unit.cs:                        if (Strings.Right(uname, 1) == "改")
SRC.NET/Unit.cs:                            uname = Strings.Left(uname, Strings.Len(uname) - 1);
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "(");
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, ret - 1);
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "用");
SRC.NET/Unit.cs:                        if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                            uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "型");
SRC.NET/Unit.cs:                        if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                            uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                    if (Strings.Right(uname, 4) == "カスタム")
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, Strings.Len(uname) - 4);
SRC.NET/Unit.cs:                    if (Strings.Right(uname, 1) == "改")
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, Strings.Len(uname) - 1);
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "(");
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, ret - 1);
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "用");
SRC.NET/Unit.cs:                        if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                            uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                    ret = (short)Strings.InStr(uname, "型");
SRC.NET/Unit.cs:                        if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                            uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                    if (Strings.Right(uname, 4) == "カスタム")
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, Strings.Len(uname) - 4);
SRC.NET/Unit.cs:                    if (Strings.Right(uname, 1) == "改")
SRC.NET/Unit.cs:                        uname = Strings.Left(uname, Strings.Len(uname) - 1);
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(SpecialEffectDataRet) > 0)
SRC.NET/Unit.cs:                    if (Strings.Len(SpecialEffectDataRet) > 0)
SRC.NET/Unit.cs:                ret = (short)Strings.InStr(uname, "(");
SRC.NET/Unit.cs:                    uname = Strings.Left(uname, ret - 1);
SRC.NET/Unit.cs:                ret = (short)Strings.InStr(uname, "用");
SRC.NET/Unit.cs:                    if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                        uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                ret = (short)Strings.InStr(uname, "型");
SRC.NET/Unit.cs:                    if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                        uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                if (Strings.Right(uname, 4) == "カスタム")
SRC.NET/Unit.cs:                    uname = Strings.Left(uname, Strings.Len(uname) - 4);
SRC.NET/Unit.cs:                if (Strings.Right(uname, 1) == "改")
SRC.NET/Unit.cs:                    uname = Strings.Left(uname, Strings.Len(uname) - 1);
SRC.NET/Unit.cs:                    if (Strings.Len(SpecialEffectDataRet) > 0)
SRC.NET/Unit.cs:                    if (Strings.Len(SpecialEffectDataRet) > 0)
SRC.NET/Unit.cs:                    if (Strings.Len(SpecialEffectDataRet) > 0)
SRC.NET/Unit.cs:                    switch (Strings.LCase(anime) ?? "")
SRC.NET/Unit.cs:                                if (Strings.InStr(main_situation, "槍") > 0 | Strings.InStr(main_situation, "スピア") > 0 | Strings.InStr(main_situation, "ランス") > 0 | Strings.InStr(main_situation, "ジャベリン") > 0)
SRC.NET/Unit.cs:                else if (Strings.InStr(main_situation, "(命中)") > 0)
SRC.NET/Unit.cs:                    switch (Strings.LCase(anime) ?? "")
SRC.NET/Unit.cs:            var loopTo3 = (short)Strings.Len(anime);
SRC.NET/Unit.cs:                if (Strings.Mid(anime, i, 1) == ";")
SRC.NET/Unit.cs:                    animes[Information.UBound(animes)] = Strings.Mid(anime, anime_head, i - anime_head);
SRC.NET/Unit.cs:            animes[Information.UBound(animes)] = Strings.Mid(anime, anime_head);
SRC.NET/Unit.cs:                if (Strings.LCase(anime) == "clear")
SRC.NET/Unit.cs:                switch (Strings.LCase(Strings.Right(GeneralLib.LIndex(ref anime, 1), 4)) ?? "")
SRC.NET/Unit.cs:                            else if (Strings.Left(anime, 1) == "@")
SRC.NET/Unit.cs:                switch (Strings.LCase(GeneralLib.LIndex(ref anime, 1)) ?? "")
SRC.NET/Unit.cs:                else if (Strings.InStr(main_situation, "(命中)") > 0)
SRC.NET/Unit.cs:            if (GUI.IsPictureDrawn & Strings.InStr(main_situation, "(準備)") == 0 & Strings.LCase(anime) != "keep")
SRC.NET/Unit.cs:            if (Strings.Len(Event_Renamed.EventErrorMessage) > 0)
SRC.NET/Unit.cs:            if (Strings.Len(msg) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(AnimationDataRet) > 0)
SRC.NET/Unit.cs:                            if (Strings.Len(AnimationDataRet) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(AnimationDataRet) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(AnimationDataRet) > 0)
SRC.NET/Unit.cs:                ret = (short)Strings.InStr(uname, "(");
SRC.NET/Unit.cs:                    uname = Strings.Left(uname, ret - 1);
SRC.NET/Unit.cs:                ret = (short)Strings.InStr(uname, "用");
SRC.NET/Unit.cs:                    if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                        uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                ret = (short)Strings.InStr(uname, "型");
SRC.NET/Unit.cs:                    if (ret < Strings.Len(uname))
SRC.NET/Unit.cs:                        uname = Strings.Mid(uname, ret + 1);
SRC.NET/Unit.cs:                if (Strings.Right(uname, 4) == "カスタム")
SRC.NET/Unit.cs:                    uname = Strings.Left(uname, Strings.Len(uname) - 4);
SRC.NET/Unit.cs:                if (Strings.Right(uname, 1) == "改")
SRC.NET/Unit.cs:                    uname = Strings.Left(uname, Strings.Len(uname) - 1);
SRC.NET/Unit.cs:                        if (Strings.Len(AnimationDataRet) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(AnimationDataRet) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(AnimationDataRet) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(AnimationDataRet) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(AnimationDataRet) > 0)
SRC.NET/Unit.cs:                        if (Strings.Len(AnimationDataRet) > 0)
SRC.NET/Unit.cs:                switch (Strings.Right(main_situation, 4) ?? "")
SRC.NET/Unit.cs:                            string argmain_situation = Strings.Left(main_situation, Strings.Len(main_situation) - 4);
SRC.NET/Unit.cs:                            string argmain_situation1 = Strings.Left(main_situation, Strings.Len(main_situation) - 4);
SRC.NET/Unit.cs:                if (main_situation != "終了" & Strings.Right(main_situation, 4) != "(終了)")
SRC.NET/Unit.cs:            var loopTo2 = (short)Strings.Len(anime);
SRC.NET/Unit.cs:                if (Strings.Mid(anime, i, 1) == ";")
SRC.NET/Unit.cs:                    animes[Information.UBound(animes)] = Strings.Mid(anime, anime_head, i - anime_head);
SRC.NET/Unit.cs:            animes[Information.UBound(animes)] = Strings.Mid(anime, anime_head);
SRC.NET/Unit.cs:                if (Strings.LCase(anime) == "clear")
SRC.NET/Unit.cs:                switch (Strings.LCase(Strings.Right(GeneralLib.LIndex(ref anime, 1), 4)) ?? "")
SRC.NET/Unit.cs:                            else if (Strings.Left(anime, 1) == "@")
SRC.NET/Unit.cs:                switch (Strings.LCase(GeneralLib.LIndex(ref anime, 1)) ?? "")
SRC.NET/Unit.cs:                if (Strings.Left(sname, 1) == "@")
SRC.NET/Unit.cs:                    sname = Strings.Mid(sname, 2);
SRC.NET/Unit.cs:                        switch (Strings.Left(main_situation, idx - 1) ?? "")
SRC.NET/Unit.cs:                        if (Strings.Mid(main_situation, idx) == "(攻撃無効化)")
SRC.NET/Unit.cs:                        sname = "戦闘アニメ_" + sname + Strings.Mid(main_situation, idx + 1, Strings.Len(main_situation) - idx - 1);
SRC.NET/Unit.cs:                        switch (Strings.Right(main_situation, 4) ?? "")
SRC.NET/Unit.cs:                if (GUI.IsPictureDrawn & Strings.LCase(buf) != "keep")
SRC.NET/Unit.cs:            if (GUI.IsPictureDrawn & string.IsNullOrEmpty(sname) & Strings.InStr(main_situation, "(準備)") == 0 & Strings.LCase(anime) != "keep")
SRC.NET/Unit.cs:            if (Strings.Len(Event_Renamed.EventErrorMessage) > 0)
SRC.NET/Unit.cs:            if (Strings.Len(anime) > 0)
SRC.NET/Unit.cs:                if (Strings.InStr(smode, "部隊配置") > 0)
SRC.NET/Unit.cs:            if ((Strings.InStr(smode, "出撃") > 0 | Strings.InStr(smode, "部隊配置") > 0) & GUI.MainForm.Visible & !GUI.IsPictureVisible & !GUI.IsRButtonPressed() & BitmapID > 0)
SRC.NET/Unit.cs:                if (Strings.InStr(smode, "非同期") > 0)
SRC.NET/Unit.cs:                                if (IsTransAvailable(ref argarea_name) & Strings.Mid(strAdaption, 1, 1) == "A")
SRC.NET/Unit.cs:                                if ((IsTransAvailable(ref argarea_name2) | IsTransAvailable(ref argarea_name3)) & Strings.Mid(strAdaption, 4, 1) == "A")
SRC.NET/Unit.cs:                    if (localConditionLifetime1() != 0 & Strings.InStr(localConditionData1(), "パイロット能力付加") == 0 & Strings.InStr(localConditionData2(), "パイロット能力強化") == 0)
SRC.NET/Unit.cs:                                    string argmidi_name = Strings.Mid(localFeatureData11(), Strings.InStr(localFeatureData12(), " ") + 1);
SRC.NET/Unit.cs:                                    if (Strings.Len(BGM) > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(withBlock4.MainPilot().Name, "(ザコ)") > 0 | Strings.InStr(withBlock4.MainPilot().Name, "(汎用)") > 0)
SRC.NET/Unit.cs:                                    if (Strings.InStr(localItem1().Name, "(ザコ)") > 0 | Strings.InStr(localItem2().Name, "(汎用)") > 0)
SRC.NET/Unit.cs:                        if (Strings.InStr(sname, "非表示") == 0)
SRC.NET/Unit.cs:                    if (localCondition() == "残り時間" | localCondition1() == "非操作" | Strings.Right(localCondition2(), 2) == "付加" | Strings.Right(localCondition3(), 2) == "強化" | Strings.Right(localCondition4(), 3) == "付加２" | Strings.Right(localCondition5(), 3) == "強化２" | Strings.Right(localCondition6(), 2) == "ＵＰ")
SRC.NET/Unit.cs:                                                    if (Strings.Len(cname) > 6)
SRC.NET/Unit.cs:                                                        if (Strings.Right(cname, 6) == "属性弱点付加")
SRC.NET/Unit.cs:                                                            bool localSpecialEffectImmune() { string arganame = "弱" + Strings.Left(cname, Strings.Len(cname) - 6); var ret = SpecialEffectImmune(ref arganame); return ret; }
SRC.NET/Unit.cs:                                                            bool localAbsorb4() { string arganame = Strings.Left(cname, Strings.Len(cname) - 6); var ret = Absorb(ref arganame); return ret; }
SRC.NET/Unit.cs:                                                            bool localImmune4() { string arganame = Strings.Left(cname, Strings.Len(cname) - 6); var ret = Immune(ref arganame); return ret; }
SRC.NET/Unit.cs:                                                        else if (Strings.Right(cname, 6) == "属性有効付加")
SRC.NET/Unit.cs:                                                            bool localSpecialEffectImmune1() { string arganame = "有" + Strings.Left(cname, Strings.Len(cname) - 6); var ret = SpecialEffectImmune(ref arganame); return ret; }
SRC.NET/Unit.cs:                                                            bool localAbsorb5() { string arganame = Strings.Left(cname, Strings.Len(cname) - 6); var ret = Absorb(ref arganame); return ret; }
SRC.NET/Unit.cs:                                                            bool localImmune5() { string arganame = Strings.Left(cname, Strings.Len(cname) - 6); var ret = Immune(ref arganame); return ret; }
SRC.NET/Unit.cs:                                                        else if (Strings.Right(cname, 6) == "属性使用不能")
SRC.NET/Unit.cs:                                                            string arganame31 = "剋" + Strings.Left(cname, Strings.Len(cname) - 6);
SRC.NET/Unit.cs:            if (Strings.InStr(fdata, "自動発動") == 0)
SRC.NET/Unit.cs:            if (this.MainPilot().Morale < (short)(10d * flevel) + 100 & (HP > MaxHP / 4 | Strings.InStr(fdata, "気力発動") > 0))
SRC.NET/Unit.cs:                        string argbgm_name = Strings.Mid(localFeatureData(), Strings.InStr(localFeatureData1(), " ") + 1);
SRC.NET/Unit.cs:                            string argbgm_name = Strings.Mid(localFeatureData(), Strings.InStr(localFeatureData1(), " ") + 1);
SRC.NET/Unit.cs:                ret = (short)Strings.InStr(sbuf, ",");
SRC.NET/Unit.cs:                ctype_Renamed = Strings.Left(sbuf, ret - 1);
SRC.NET/Unit.cs:                if (Strings.Left(ctype_Renamed, 1) == "\"")
SRC.NET/Unit.cs:                    ctype_Renamed = Strings.Mid(ctype_Renamed, 2, Strings.Len(ctype_Renamed) - 2);
SRC.NET/Unit.cs:                sbuf = Strings.Mid(sbuf, ret + 1);
SRC.NET/Unit.cs:                ret = (short)Strings.InStr(sbuf, ",");
SRC.NET/Unit.cs:                string argexpr = Strings.Left(sbuf, ret - 1);
SRC.NET/Unit.cs:                sbuf = Strings.Mid(sbuf, ret + 1);
SRC.NET/Unit.cs:                ret = (short)Strings.InStr(sbuf, ",");
SRC.NET/Unit.cs:                string argexpr1 = Strings.Left(sbuf, ret - 1);
SRC.NET/Unit.cs:                sbuf = Strings.Mid(sbuf, ret + 1);
SRC.NET/Unit.cs:                if (Strings.Left(cdata, 1) == "\"")
SRC.NET/Unit.cs:                    cdata = Strings.Mid(cdata, 2, Strings.Len(cdata) - 2);
SRC.NET/Unit.cs:                    if (Strings.InStr(cdata, " パイロット能力付加 ") > 0)
SRC.NET/Unit.cs:                    if (Strings.InStr(cdata, " パイロット能力強化 ") > 0)
SRC.NET/Unit.cs:                if (Strings.Left(withBlock.Class_Renamed, 1) == "(")
SRC.NET/Unit.cs:            if (Strings.Len(nabilities) == 0)
SRC.NET/Unit.cs:                        while (Strings.LCase(nskill_list[i + 1]) == "or")
SRC.NET/Unit.cs:                    if (Strings.LCase(nskill_list[i]) != "or")
SRC.NET/Unit.cs:            if (Strings.Left(ndata, 1) == "+")
SRC.NET/Unit.cs:                ndata = Strings.Mid(ndata, 2);
SRC.NET/Unit.cs:            if (Strings.Left(ndata, 1) == "*")
SRC.NET/Unit.cs:                string argndata = Strings.Mid(ndata, 2);
SRC.NET/Unit.cs:            i = (short)Strings.InStr(ndata, "Lv");
SRC.NET/Unit.cs:                sname = Strings.Left(ndata, i - 1);
SRC.NET/Unit.cs:                string argexpr = Strings.Mid(ndata, i + 2);
SRC.NET/Unit.cs:            if (Strings.Left(sname, 1) == "!")
SRC.NET/Unit.cs:                bool localIsNecessarySkillSatisfied2() { string argndata = Strings.Mid(ndata, 2); var ret = IsNecessarySkillSatisfied2(ref argndata, ref p); return ret; }
SRC.NET/Unit.cs:                            if (Strings.Left(sname, 1) == "@")
SRC.NET/Unit.cs:                                    if ((Strings.Mid(sname, 2) ?? "") == (Map.TerrainName(x, y) ?? ""))
SRC.NET/Unit.cs:                            else if (Strings.Right(sname, 2) == "装備")
SRC.NET/Unit.cs:                                iname = Strings.Left(sname, Strings.Len(sname) - 2);
SRC.NET/Unit.cs:                            else if (Strings.Right(sname, 2) == "隣接" | Strings.Right(sname, 4) == "マス以内")
SRC.NET/Unit.cs:                                    if (Strings.Right(sname, 2) == "隣接")
SRC.NET/Unit.cs:                                        uname = Strings.Left(sname, Strings.Len(sname) - 2);
SRC.NET/Unit.cs:                                        uname = Strings.Left(sname, Strings.Len(sname) - 5);
SRC.NET/Unit.cs:                                        string argexpr1 = Strings.Mid(sname, Strings.Len(sname) - 4, 1);
SRC.NET/Unit.cs:                            else if (Strings.Right(sname, 2) == "状態")
SRC.NET/Unit.cs:                                object argIndex22 = Strings.Left(sname, Strings.Len(sname) - 2);
SRC.NET/Unit.cs:            if (Strings.Len(fname) == 0)
SRC.NET/UnitData.cs:                if (Strings.InStr(NicknameRet, "主人公") == 1 | Strings.InStr(NicknameRet, "ヒロイン") == 1)
SRC.NET/UnitData.cs:                if (Strings.InStr(KanaNameRet, "主人公") == 1 | Strings.InStr(KanaNameRet, "ヒロイン") == 1 | Strings.InStr(KanaNameRet, "ひろいん") == 1)
SRC.NET/UnitData.cs:            if (Strings.Right(fdef, 1) == ")")
SRC.NET/UnitData.cs:                i = (short)Strings.InStr(fdef, " (");
SRC.NET/UnitData.cs:                    nskill = Strings.Trim(Strings.Mid(fdef, i + 2, Strings.Len(fdef) - i - 2));
SRC.NET/UnitData.cs:                    buf = Strings.Trim(Strings.Left(fdef, i));
SRC.NET/UnitData.cs:                else if (Strings.Left(fdef, 1) == "(")
SRC.NET/UnitData.cs:                    nskill = Strings.Trim(Strings.Mid(fdef, 2, Strings.Len(fdef) - 2));
SRC.NET/UnitData.cs:            if (Strings.Right(buf, 1) == ">")
SRC.NET/UnitData.cs:                i = (short)Strings.InStr(buf, " <");
SRC.NET/UnitData.cs:                    ncondition = Strings.Trim(Strings.Mid(buf, i + 2, Strings.Len(buf) - i - 2));
SRC.NET/UnitData.cs:                    buf = Strings.Trim(Strings.Left(buf, i));
SRC.NET/UnitData.cs:                else if (Strings.Left(buf, 1) == "<")
SRC.NET/UnitData.cs:                    ncondition = Strings.Trim(Strings.Mid(buf, 2, Strings.Len(buf) - 2));
SRC.NET/UnitData.cs:            i = (short)Strings.InStr(buf, "Lv");
SRC.NET/UnitData.cs:            j = (short)Strings.InStr(buf, "=");
SRC.NET/UnitData.cs:                ftype = Strings.Left(buf, i - 1);
SRC.NET/UnitData.cs:                    flevel = Conversions.ToDouble(Strings.Mid(buf, i + 2, j - (i + 2)));
SRC.NET/UnitData.cs:                    fdata = Strings.Mid(buf, j + 1);
SRC.NET/UnitData.cs:                    flevel = Conversions.ToDouble(Strings.Mid(buf, i + 2));
SRC.NET/UnitData.cs:                ftype = Strings.Left(buf, j - 1);
SRC.NET/UnitData.cs:                fdata = Strings.Mid(buf, j + 1);
SRC.NET/UnitData.cs:            if (Strings.Left(fdata, 1) == "\"")
SRC.NET/UnitData.cs:                if (Strings.Right(fdata, 1) == "\"")
SRC.NET/UnitData.cs:                    fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
SRC.NET/UnitData.cs:                                if (!string.IsNullOrEmpty(fdata) & Strings.InStr(withBlock.get_AliasData(i), "非表示") != 1)
SRC.NET/UnitData.cs:            if (Strings.Len(fd.StrData) > 0)
SRC.NET/UnitDataList.cs:                while (Strings.Len(line_buf) == 0);
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/UnitDataList.cs:                    data_name = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                if (Strings.InStr(data_name, " ") > 0)
SRC.NET/UnitDataList.cs:                if (Strings.InStr(data_name, "（") > 0 | Strings.InStr(data_name, "）") > 0)
SRC.NET/UnitDataList.cs:                if (Strings.InStr(data_name, "\"") > 0)
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                var loopTo = (short)Strings.Len(line_buf);
SRC.NET/UnitDataList.cs:                    if (Strings.Mid(line_buf, (int)i, 1) == ",")
SRC.NET/UnitDataList.cs:                if (Strings.Len(line_buf) == 0)
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                if (Strings.Left(buf2, 1) != "(")
SRC.NET/UnitDataList.cs:                    if (Strings.Right(buf2, 1) != ")")
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Mid(buf2, 2, Strings.Len(buf2) - 2);
SRC.NET/UnitDataList.cs:                buf = Strings.Trim(buf);
SRC.NET/UnitDataList.cs:                if (Strings.Len(buf) == 0)
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                buf = Strings.Trim(buf);
SRC.NET/UnitDataList.cs:                if (Strings.Len(buf) == 0)
SRC.NET/UnitDataList.cs:                        var loopTo1 = (short)Strings.Len(buf);
SRC.NET/UnitDataList.cs:                            switch (Strings.Mid(buf, (int)j, 1) ?? "")
SRC.NET/UnitDataList.cs:                            buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                            buf = Strings.Trim(Strings.Mid(buf, (int)ret + 1));
SRC.NET/UnitDataList.cs:                else if (Strings.InStr(line_buf, "特殊能力,") == 1)
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(line_buf, 6);
SRC.NET/UnitDataList.cs:                    var loopTo2 = (short)Strings.Len(buf);
SRC.NET/UnitDataList.cs:                        switch (Strings.Mid(buf, (int)k, 1) ?? "")
SRC.NET/UnitDataList.cs:                        buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                        buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                        ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(buf);
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(buf);
SRC.NET/UnitDataList.cs:                if (Strings.Len(buf2) == 0)
SRC.NET/UnitDataList.cs:                ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/UnitDataList.cs:                buf2 = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                if (Strings.Len(buf2) == 4)
SRC.NET/UnitDataList.cs:                buf = Strings.Trim(buf);
SRC.NET/UnitDataList.cs:                if (Strings.Len(buf) == 0)
SRC.NET/UnitDataList.cs:                if (Strings.LCase(Strings.Right(buf, 4)) == ".bmp")
SRC.NET/UnitDataList.cs:                while (Strings.Len(line_buf) > 0 & line_buf != "===")
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/UnitDataList.cs:                    wname = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    if (Strings.Len(buf2) == 4)
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    buf = Strings.Trim(buf);
SRC.NET/UnitDataList.cs:                    if (Strings.Len(buf) == 0)
SRC.NET/UnitDataList.cs:                    if (Strings.Right(buf, 1) == ")")
SRC.NET/UnitDataList.cs:                        ret = (short)Strings.InStr(buf, "> ");
SRC.NET/UnitDataList.cs:                                wd.NecessarySkill = Strings.Mid(buf, (int)ret + 2);
SRC.NET/UnitDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, (int)ret + 1));
SRC.NET/UnitDataList.cs:                                ret = (short)Strings.InStr(wd.NecessarySkill, "(");
SRC.NET/UnitDataList.cs:                                wd.NecessarySkill = Strings.Mid(wd.NecessarySkill, (int)ret + 1, Strings.Len(wd.NecessarySkill) - (int)ret - 1);
SRC.NET/UnitDataList.cs:                            ret = (short)Strings.InStr(buf, "(");
SRC.NET/UnitDataList.cs:                                wd.NecessarySkill = Strings.Trim(Strings.Mid(buf, (int)ret + 1, Strings.Len(buf) - (int)ret - 1));
SRC.NET/UnitDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    if (Strings.Right(buf, 1) == ">")
SRC.NET/UnitDataList.cs:                        ret = (short)Strings.InStr(buf, "<");
SRC.NET/UnitDataList.cs:                            wd.NecessaryCondition = Strings.Trim(Strings.Mid(buf, (int)ret + 1, Strings.Len(buf) - (int)ret - 1));
SRC.NET/UnitDataList.cs:                            buf = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    if (Strings.InStr(wd.Class_Renamed, "Lv") > 0)
SRC.NET/UnitDataList.cs:                while (Strings.Len(line_buf) > 0)
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(line_buf, ",");
SRC.NET/UnitDataList.cs:                    sname = Strings.Trim(Strings.Left(line_buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(line_buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    ret = (short)Strings.InStr(buf, ",");
SRC.NET/UnitDataList.cs:                    buf2 = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    buf = Strings.Mid(buf, (int)ret + 1);
SRC.NET/UnitDataList.cs:                    buf = Strings.Trim(buf);
SRC.NET/UnitDataList.cs:                    if (Strings.Len(buf) == 0)
SRC.NET/UnitDataList.cs:                    if (Strings.Right(buf, 1) == ")")
SRC.NET/UnitDataList.cs:                        ret = (short)Strings.InStr(buf, "> ");
SRC.NET/UnitDataList.cs:                                sd.NecessarySkill = Strings.Mid(buf, (int)ret + 2);
SRC.NET/UnitDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, (int)ret + 1));
SRC.NET/UnitDataList.cs:                                ret = (short)Strings.InStr(sd.NecessarySkill, "(");
SRC.NET/UnitDataList.cs:                                sd.NecessarySkill = Strings.Mid(sd.NecessarySkill, (int)ret + 1, Strings.Len(sd.NecessarySkill) - (int)ret - 1);
SRC.NET/UnitDataList.cs:                            ret = (short)Strings.InStr(buf, "(");
SRC.NET/UnitDataList.cs:                                sd.NecessarySkill = Strings.Trim(Strings.Mid(buf, (int)ret + 1, Strings.Len(buf) - (int)ret - 1));
SRC.NET/UnitDataList.cs:                                buf = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    if (Strings.Right(buf, 1) == ">")
SRC.NET/UnitDataList.cs:                        ret = (short)Strings.InStr(buf, "<");
SRC.NET/UnitDataList.cs:                            sd.NecessaryCondition = Strings.Trim(Strings.Mid(buf, (int)ret + 1, Strings.Len(buf) - (int)ret - 1));
SRC.NET/UnitDataList.cs:                            buf = Strings.Trim(Strings.Left(buf, (int)ret - 1));
SRC.NET/UnitDataList.cs:                    if (Strings.InStr(sd.Class_Renamed, "Lv") > 0)
SRC.NET/Units.cs:                            ID2 = Strings.Left(ID2, Strings.InStr(ID2, "(") - 1);
SRC.NET/VBMP3.cs:            if (Strings.InStr(Word, Conversions.ToString('\0')) > 0)
SRC.NET/VBMP3.cs:                NTrimRet = Strings.Left(Word, Strings.InStr(Word, Conversions.ToString('\0')) - 1);
SRC.NET/WeaponData.cs:            if (Strings.InStr(NicknameRet, "(") > 0)
SRC.NET/WeaponData.cs:                NicknameRet = Strings.Left(NicknameRet, Strings.InStr(NicknameRet, "(") - 1);
