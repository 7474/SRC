using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;

namespace Project1
{
    internal class Unit
    {

        // Copyright (C) 1997-2012 Kei Sakamoto / Inui Tetsuyuki
        // 本プログラムはフリーソフトであり、無保証です。
        // 本プログラムはGNU General Public License(Ver.3またはそれ以降)が定める条件の下で
        // 再頒布または改変することができます。

        // データ
        public UnitData Data;

        // 識別用ＩＤ
        public string ID;

        // ビットマップID
        // 同種のユニットは同じIDを共有
        public int BitmapID;

        // Ｘ座標
        public int x;
        // Ｙ座標
        public int y;

        // ユニットの場所（地上、水上、水中、空中、地中、宇宙）
        public string Area;

        // 使用済み行動数
        public int UsedAction;

        // 思考モード
        private string strMode;

        // ステータス
        // 出撃：マップ上に出撃
        // 他形態：他の形態に変形(ハイパーモード)中
        // 破壊：破壊されている
        // 破棄：イベントコマンド RemoveUnit などによりイベントで破壊されている
        // 格納：母艦内に格納されている
        // 待機：待機中
        // 旧形態：分離ユニットが合体前に取っていた形態
        // 離脱：Leaveコマンドにより戦線を離脱。Organizeコマンドでも表示されない
        // UPGRADE_NOTE: Status は Status にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
        public string Status;

        // ユニットに対して使用されているスペシャルパワー
        private Collection colSpecialPowerInEffect = new Collection();

        // サポートアタック＆ガードの使用回数
        public int UsedSupportAttack;
        public int UsedSupportGuard;

        // 同時援護攻撃の使用回数
        public int UsedSyncAttack;

        // カウンター攻撃の使用回数
        public int UsedCounterAttack;

        // ユニット名称
        private string strName;
        // 陣営
        private string strParty;
        // ユニットランク
        private int intRank;
        // ボスランク
        private int intBossRank;
        // ＨＰ
        private int lngMaxHP;
        private int lngHP;
        // ＥＮ
        private int intMaxEN;
        private int intEN;
        // 装甲
        private int lngArmor;
        // 運動性
        private int intMobility;
        // 移動力
        private int intSpeed;

        // 搭乗しているパイロット
        private Collection colPilot = new Collection();

        // 搭乗しているサポートパイロット
        private Collection colSupport = new Collection();

        // 関連するユニット
        // 変形ユニットにおける他形態等
        private Collection colOtherForm = new Collection();

        // 格納したユニット
        private Collection colUnitOnBoard = new Collection();

        // 装備しているアイテム
        private Collection colItem = new Collection();

        // 現在の特殊ステータス
        private Collection colCondition = new Collection();

        // 各武器の残弾数
        private double[] dblBullet;

        // アビリティの残り使用回数
        private double[] dblStock;

        // 特殊能力
        private Collection colFeature = new Collection();

        // 特殊能力(必要条件を満たさないものを含む)
        private Collection colAllFeature = new Collection();

        // 付加された特殊能力数
        public int AdditionalFeaturesNum;

        // 地形適応
        private string strAdaption;

        // 攻撃への耐性
        public string strAbsorb;
        public string strImmune;
        public string strResist;
        public string strWeakness;
        public string strEffective;
        public string strSpecialEffectImmune;

        // 武器データ
        private WeaponData[] WData;
        private int[] lngWeaponPower;
        private int[] intWeaponMaxRange;
        private int[] intWeaponPrecision;
        private int[] intWeaponCritical;
        private string[] strWeaponClass;
        private int[] intMaxBullet;

        // アビリティデータ
        private AbilityData[] adata;

        // 選択したマップ攻撃の攻撃力
        private int SelectedMapAttackPower;

        // 選択したマップ攻撃の攻撃力
        private bool IsMapAttackCanceled;

        // 召喚したユニット
        private Collection colServant = new Collection();

        // 魅了・憑依したユニット
        private Collection colSlave = new Collection();

        // 召喚主
        public Unit Summoner;

        // ご主人様
        public Unit Master;

        // 追加パイロット
        public Pilot pltAdditionalPilot;

        // 追加サポート
        public Pilot pltAdditionalSupport;


        // クラスの初期化
        // UPGRADE_NOTE: Class_Initialize は Class_Initialize にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
        private void Class_Initialize()
        {
            Status = "待機";
            intBossRank = -1;
            // UPGRADE_NOTE: オブジェクト Summoner をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Summoner = null;
            // UPGRADE_NOTE: オブジェクト Master をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Master = null;
            WData = new WeaponData[1];
            adata = new AbilityData[1];
        }

        public Unit() : base()
        {
            Class_Initialize();
        }

        // クラスの解放
        // UPGRADE_NOTE: Class_Terminate は Class_Terminate にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
        private void Class_Terminate()
        {
            int i;

            // UPGRADE_NOTE: オブジェクト Data をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Data = null;
            {
                var withBlock = colPilot;
                var loopTo = withBlock.Count;
                for (i = 1; i <= loopTo; i++)
                    withBlock.Remove(1);
            }
            // UPGRADE_NOTE: オブジェクト colPilot をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            colPilot = null;
            {
                var withBlock1 = colSupport;
                var loopTo1 = withBlock1.Count;
                for (i = 1; i <= loopTo1; i++)
                    withBlock1.Remove(1);
            }
            // UPGRADE_NOTE: オブジェクト colSupport をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            colSupport = null;
            {
                var withBlock2 = colOtherForm;
                var loopTo2 = withBlock2.Count;
                for (i = 1; i <= loopTo2; i++)
                    withBlock2.Remove(1);
            }
            // UPGRADE_NOTE: オブジェクト colOtherForm をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            colOtherForm = null;
            {
                var withBlock3 = colItem;
                var loopTo3 = withBlock3.Count;
                for (i = 1; i <= loopTo3; i++)
                    withBlock3.Remove(1);
            }
            // UPGRADE_NOTE: オブジェクト colItem をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            colItem = null;
            {
                var withBlock4 = colCondition;
                var loopTo4 = withBlock4.Count;
                for (i = 1; i <= loopTo4; i++)
                    withBlock4.Remove(1);
            }
            // UPGRADE_NOTE: オブジェクト colCondition をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            colCondition = null;
            {
                var withBlock5 = colFeature;
                var loopTo5 = withBlock5.Count;
                for (i = 1; i <= loopTo5; i++)
                    withBlock5.Remove(1);
            }
            // UPGRADE_NOTE: オブジェクト colFeature をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            colFeature = null;
            var loopTo6 = Information.UBound(WData);
            for (i = 1; i <= loopTo6; i++)
                // UPGRADE_NOTE: オブジェクト WData() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                WData[i] = null;
            var loopTo7 = Information.UBound(adata);
            for (i = 1; i <= loopTo7; i++)
                // UPGRADE_NOTE: オブジェクト adata() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                adata[i] = null;
            {
                var withBlock6 = colUnitOnBoard;
                var loopTo8 = withBlock6.Count;
                for (i = 1; i <= loopTo8; i++)
                    withBlock6.Remove(1);
            }
            // UPGRADE_NOTE: オブジェクト colUnitOnBoard をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            colUnitOnBoard = null;
            {
                var withBlock7 = colServant;
                var loopTo9 = withBlock7.Count;
                for (i = 1; i <= loopTo9; i++)
                    withBlock7.Remove(1);
            }
            // UPGRADE_NOTE: オブジェクト colServant をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            colServant = null;
            {
                var withBlock8 = colSlave;
                var loopTo10 = withBlock8.Count;
                for (i = 1; i <= loopTo10; i++)
                    withBlock8.Remove(1);
            }
            // UPGRADE_NOTE: オブジェクト colSlave をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            colSlave = null;

            // UPGRADE_NOTE: オブジェクト Summoner をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Summoner = null;
            // UPGRADE_NOTE: オブジェクト Master をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Master = null;
            // UPGRADE_NOTE: オブジェクト pltAdditionalPilot をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            pltAdditionalPilot = null;
            // UPGRADE_NOTE: オブジェクト pltAdditionalSupport をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            pltAdditionalSupport = null;
        }

        ~Unit()
        {
            Class_Terminate();
        }


        // === 各種基本ステータス ===

        // ユニット名称

        public string Name
        {
            get
            {
                string NameRet = default;
                NameRet = strName;
                return NameRet;
            }

            set
            {
                strName = value;
                Data = SRC.UDList.Item(value);
                Update();
            }
        }

        // 愛称
        public string Nickname0
        {
            get
            {
                string Nickname0Ret = default;
                int idx;
                Unit u;
                Nickname0Ret = Data.Nickname;

                // 愛称変更能力による変更
                if (IsFeatureAvailable("愛称変更"))
                {
                    Nickname0Ret = FeatureData("愛称変更");
                    idx = Strings.InStr(Nickname0Ret, "$(愛称)");
                    if (idx > 0)
                    {
                        Nickname0Ret = Strings.Left(Nickname0Ret, idx - 1) + Data.Nickname + Strings.Mid(Nickname0Ret, idx + 5);
                    }

                    idx = Strings.InStr(Nickname0Ret, "$(パイロット愛称)");
                    if (idx > 0)
                    {
                        if (CountPilot() > 0)
                        {
                            Nickname0Ret = Strings.Left(Nickname0Ret, idx - 1) + MainPilot().get_Nickname(true) + Strings.Mid(Nickname0Ret, idx + 10);
                        }
                        else
                        {
                            Nickname0Ret = Strings.Left(Nickname0Ret, idx - 1) + "○○" + Strings.Mid(Nickname0Ret, idx + 10);
                        }
                    }
                }

                u = Event.SelectedUnitForEvent;
                Event.SelectedUnitForEvent = this;
                Expression.ReplaceSubExpression(Nickname0Ret);
                Event.SelectedUnitForEvent = u;
                return Nickname0Ret;
            }
        }

        // メッセージ中で表示する際の愛称は等身大基準ではパイロット名を使う
        public string Nickname
        {
            get
            {
                string NicknameRet = default;
                if (Expression.IsOptionDefined("等身大基準"))
                {
                    if (CountPilot() > 0)
                    {
                        {
                            var withBlock = MainPilot();
                            if (Strings.InStr(withBlock.Name, "(ザコ)") == 0 && Strings.InStr(withBlock.Name, "(汎用)") == 0)
                            {
                                NicknameRet = MainPilot().get_Nickname(false);
                                return default;
                            }
                        }
                    }
                }

                NicknameRet = Nickname0;
                return NicknameRet;
            }
        }

        // 読み仮名
        public string KanaName
        {
            get
            {
                string KanaNameRet = default;
                int idx;
                Unit u;
                KanaNameRet = Data.KanaName;

                // 読み仮名変更能力による変更
                if (IsFeatureAvailable("読み仮名変更"))
                {
                    KanaNameRet = FeatureData("読み仮名変更");
                    idx = Strings.InStr(KanaNameRet, "$(読み仮名)");
                    if (idx > 0)
                    {
                        KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + Data.KanaName + Strings.Mid(KanaNameRet, idx + 5);
                    }

                    idx = Strings.InStr(KanaNameRet, "$(パイロット読み仮名)");
                    if (idx > 0)
                    {
                        if (CountPilot() > 0)
                        {
                            KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + MainPilot().KanaName + Strings.Mid(KanaNameRet, idx + 10);
                        }
                        else
                        {
                            KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + "○○" + Strings.Mid(KanaNameRet, idx + 10);
                        }
                    }
                }
                else if (IsFeatureAvailable("愛称変更"))
                {
                    KanaNameRet = FeatureData("愛称変更");
                    idx = Strings.InStr(KanaNameRet, "$(愛称)");
                    if (idx > 0)
                    {
                        KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + Data.Nickname + Strings.Mid(KanaNameRet, idx + 5);
                    }

                    idx = Strings.InStr(KanaNameRet, "$(パイロット愛称)");
                    if (idx > 0)
                    {
                        if (CountPilot() > 0)
                        {
                            KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + MainPilot().get_Nickname(false) + Strings.Mid(KanaNameRet, idx + 10);
                        }
                        else
                        {
                            KanaNameRet = Strings.Left(KanaNameRet, idx - 1) + "○○" + Strings.Mid(KanaNameRet, idx + 10);
                        }
                    }

                    KanaNameRet = GeneralLib.StrToHiragana(KanaNameRet);
                }

                u = Event.SelectedUnitForEvent;
                Event.SelectedUnitForEvent = this;
                Expression.ReplaceSubExpression(KanaNameRet);
                Event.SelectedUnitForEvent = u;
                return KanaNameRet;
            }
        }

        // ユニットランク

        public int Rank
        {
            get
            {
                int RankRet = default;
                RankRet = intRank;
                return RankRet;
            }

            set
            {
                string uname;
                if (intRank == value)
                {
                    return;
                }

                intRank = value;
                if (intRank > 999)
                {
                    intRank = 999;
                }

                // パラメータを更新
                Update();
            }
        }

        // ボスランク

        public int BossRank
        {
            get
            {
                int BossRankRet = default;
                BossRankRet = intBossRank;
                return BossRankRet;
            }

            set
            {
                if (intBossRank == value)
                {
                    return;
                }

                intBossRank = value;

                // パラメータを更新
                Update();
            }
        }

        // ユニットクラス
        // UPGRADE_NOTE: Class は Class にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
        public string Class
        {
            get
            {
                string ClassRet = default;
                ClassRet = Data.Class;
                return ClassRet;
            }
        }

        // ユニットクラスから余分な指定を除いたもの
        public string Class0
        {
            get
            {
                string Class0Ret = default;
                int i, n;
                Class0Ret = Data.Class;

                // 人間ユニット指定を削除
                if (Strings.Left(Class0Ret, 1) == "(")
                {
                    Class0Ret = Strings.Mid(Class0Ret, 2, Strings.Len(Class0Ret) - 2);
                }

                // 専用指定を削除
                if (Strings.Right(Class0Ret, 3) == "専用)")
                {
                    n = 1;
                    i = (Strings.Len(Class0Ret) - 2);
                    do
                    {
                        i = (i - 1);
                        switch (Strings.Mid(Class0Ret, i, 1) ?? "")
                        {
                            case "(":
                                {
                                    n = (n - 1);
                                    if (n == 0)
                                    {
                                        Class0Ret = Strings.Left(Class0Ret, i - 1);
                                        break;
                                    }

                                    break;
                                }

                            case ")":
                                {
                                    n = (n + 1);
                                    break;
                                }
                        }
                    }
                    while (i > 0);
                }

                return Class0Ret;
            }
        }


        // ユニットサイズ
        public string Size
        {
            get
            {
                string SizeRet = default;
                if (IsFeatureAvailable("サイズ変更"))
                {
                    SizeRet = FeatureData("サイズ変更");
                    return default;
                }

                SizeRet = Data.Size;
                return SizeRet;
            }
        }


        // 最大ＨＰ値
        public int MaxHP
        {
            get
            {
                int MaxHPRet = default;
                MaxHPRet = lngMaxHP;

                // パイロットによる修正
                if (CountPilot() > 0)
                {
                    // 霊力変換器装備ユニットは霊力に応じて最大ＨＰが変化
                    if (IsFeatureAvailable("霊力変換器"))
                    {
                        MaxHPRet = (MaxHPRet + 10d * PlanaLevel());
                    }

                    // オーラ変換器装備ユニットはオーラレベルに応じて最大ＨＰが変化
                    if (IsFeatureAvailable("オーラ変換器"))
                    {
                        MaxHPRet = (MaxHPRet + 100d * AuraLevel());
                    }
                }

                // 最大ＨＰは最低でも1
                if (MaxHPRet < 1)
                {
                    MaxHPRet = 1;
                }

                return MaxHPRet;
            }
        }

        // 最大ＥＮ値
        public int MaxEN
        {
            get
            {
                int MaxENRet = default;
                MaxENRet = intMaxEN;

                // パイロットによる修正
                if (CountPilot() > 0)
                {
                    // 霊力変換器装備ユニットは霊力に応じて最大ＥＮが変化
                    if (IsFeatureAvailable("霊力変換器"))
                    {
                        MaxENRet = (MaxENRet + 0.5d * PlanaLevel());
                    }

                    // オーラ変換器装備ユニットはオーラレベルに応じて最大ＥＮが変化
                    if (IsFeatureAvailable("オーラ変換器"))
                    {
                        MaxENRet = (MaxENRet + 10d * AuraLevel());
                    }
                }

                // 最大ＥＮは最低でも5
                if (MaxENRet < 5)
                {
                    MaxENRet = 5;
                }

                return MaxENRet;
            }
        }

        // ＨＰ

        public int HP
        {
            get
            {
                int HPRet = default;
                HPRet = lngHP;
                return HPRet;
            }

            set
            {
                lngHP = value;
                if (lngHP > MaxHP)
                {
                    lngHP = MaxHP;
                }
                else if (lngHP < 0)
                {
                    lngHP = 0;
                }
            }
        }

        // ＥＮ

        public int EN
        {
            get
            {
                int ENRet = default;
                ENRet = intEN;
                return ENRet;
            }

            set
            {
                intEN = value;
                if (intEN > MaxEN)
                {
                    intEN = MaxEN;
                }
                else if (intEN < 0)
                {
                    intEN = 0;
                }
            }
        }


        // 移動力
        public int Speed0
        {
            get
            {
                int Speed0Ret = default;
                Speed0Ret = intSpeed;
                return Speed0Ret;
            }
        }

        public int Speed
        {
            get
            {
                int SpeedRet = default;
                SpeedRet = Speed0;

                // 元々移動力が0の場合は0のまま
                if (SpeedRet == 0 && !IsFeatureAvailable("テレポート") && !IsFeatureAvailable("ジャンプ"))
                {
                    return default;
                }

                // 特殊状態による移動力修正
                if (IsUnderSpecialPowerEffect("移動力強化"))
                {
                    SpeedRet = (SpeedRet + SpecialPowerEffectLevel("移動力強化"));
                }
                else if (IsConditionSatisfied("移動力ＵＰ"))
                {
                    if (Expression.IsOptionDefined("大型マップ"))
                    {
                        SpeedRet = (SpeedRet + 2);
                    }
                    else
                    {
                        SpeedRet = (SpeedRet + 1);
                    }
                }

                if (IsConditionSatisfied("移動力ＤＯＷＮ"))
                {
                    SpeedRet = GeneralLib.MaxLng(SpeedRet / 2, 1);
                }

                // 霊力による移動力ＵＰ
                if (IsFeatureAvailable("霊力変換器"))
                {
                    if (CountPilot() > 0)
                    {
                        SpeedRet = (SpeedRet + Conversion.Int(0.01d * PlanaLevel()));
                    }
                }

                // スペシャルパワーによる移動力低下
                if (IsUnderSpecialPowerEffect("移動力低下"))
                {
                    SpeedRet = GeneralLib.MaxLng(SpeedRet / 2, 1);
                }

                // 移動不能の場合は移動力０
                if (IsConditionSatisfied("移動不能"))
                {
                    SpeedRet = 0;
                }

                // ＥＮ切れにより移動できない場合
                if (Status == "出撃")
                {
                    switch (Area ?? "")
                    {
                        case "空中":
                        case "宇宙":
                            {
                                if (EN < 5)
                                {
                                    SpeedRet = 0;
                                }

                                break;
                            }

                        case "地中":
                            {
                                if (EN < 10)
                                {
                                    SpeedRet = 0;
                                }

                                break;
                            }
                    }
                }

                return SpeedRet;
            }
        }


        // 移動形態
        public string Transportation
        {
            get
            {
                string TransportationRet = default;
                TransportationRet = Data.Transportation;

                // 特殊能力による移動可能地形追加
                if (IsFeatureAvailable("空中移動"))
                {
                    if (Strings.InStr(TransportationRet, "空") == 0)
                    {
                        TransportationRet = "空" + TransportationRet;
                    }
                }

                if (IsFeatureAvailable("陸上移動"))
                {
                    if (Strings.InStr(TransportationRet, "陸") == 0)
                    {
                        TransportationRet = "陸" + TransportationRet;
                    }
                }

                if (IsFeatureAvailable("水中移動"))
                {
                    if (Strings.InStr(TransportationRet, "水") == 0)
                    {
                        TransportationRet = "水" + TransportationRet;
                    }
                }

                if (IsFeatureAvailable("地中移動"))
                {
                    if (Strings.InStr(TransportationRet, "地中") == 0)
                    {
                        TransportationRet = TransportationRet + "地中";
                    }
                }

                if (IsFeatureAvailable("宇宙移動"))
                {
                    if (string.IsNullOrEmpty(TransportationRet))
                    {
                        TransportationRet = "宇宙";
                    }
                }

                return TransportationRet;
            }
        }


        // 地形適応
        public int get_Adaption(int idx)
        {
            int AdaptionRet = default;
            int uad = default, pad = default;

            // ユニット側の地形適応を算出
            switch (Strings.Mid(strAdaption, idx, 1) ?? "")
            {
                case "S":
                    {
                        uad = 5;
                        break;
                    }

                case "A":
                    {
                        uad = 4;
                        break;
                    }

                case "B":
                    {
                        uad = 3;
                        break;
                    }

                case "C":
                    {
                        uad = 2;
                        break;
                    }

                case "D":
                    {
                        uad = 1;
                        break;
                    }

                case "-":
                    {
                        AdaptionRet = 0;
                        return default;
                    }
            }

            // パイロット側の地形適応を算出
            if (CountPilot() > 0)
            {
                switch (Strings.Mid(MainPilot().Adaption, idx, 1) ?? "")
                {
                    case "S":
                        {
                            pad = 5;
                            break;
                        }

                    case "A":
                        {
                            pad = 4;
                            break;
                        }

                    case "B":
                        {
                            pad = 3;
                            break;
                        }

                    case "C":
                        {
                            pad = 2;
                            break;
                        }

                    case "D":
                        {
                            pad = 1;
                            break;
                        }

                    case "-":
                        {
                            AdaptionRet = 0;
                            return default;
                        }
                }
            }
            else
            {
                pad = 4;
            }

            if (Expression.IsOptionDefined("地形適応総和計算"))
            {
                // ユニットとパイロットの地形適応の総和から地形適応を決定
                switch ((uad + pad))
                {
                    case 9:
                    case 10:
                        {
                            AdaptionRet = 5;
                            break;
                        }

                    case 7:
                    case 8:
                        {
                            AdaptionRet = 4;
                            break;
                        }

                    case 5:
                    case 6:
                        {
                            AdaptionRet = 3;
                            break;
                        }

                    case 3:
                    case 4:
                        {
                            AdaptionRet = 2;
                            break;
                        }

                    case 1:
                    case 2:
                        {
                            AdaptionRet = 1;
                            break;
                        }

                    default:
                        {
                            AdaptionRet = 0;
                            break;
                        }
                }
            }
            // ユニットとパイロットの地形適応の低い方を使用
            else if (uad > pad)
            {
                AdaptionRet = pad;
            }
            else
            {
                AdaptionRet = uad;
            }

            return AdaptionRet;
        }

        // 地形適応による修正値
        public double get_AdaptionMod(int idx, int ad_mod)
        {
            double AdaptionModRet = default;
            int uad;
            uad = get_Adaption(idx);

            // 元々属性がSでない限り、Sにはしない
            if (uad == 5)
            {
                uad = GeneralLib.MinLng(uad + ad_mod, 5);
            }
            else
            {
                uad = GeneralLib.MinLng(uad + ad_mod, 4);
            }

            // Optionコマンドの設定に応じて適応修正値を設定
            if (Expression.IsOptionDefined("地形適応修正緩和"))
            {
                if (Expression.IsOptionDefined("地形適応修正繰り下げ"))
                {
                    switch (uad)
                    {
                        case 5:
                            {
                                AdaptionModRet = 1.1d;
                                break;
                            }

                        case 4:
                            {
                                AdaptionModRet = 1d;
                                break;
                            }

                        case 3:
                            {
                                AdaptionModRet = 0.9d;
                                break;
                            }

                        case 2:
                            {
                                AdaptionModRet = 0.8d;
                                break;
                            }

                        case 1:
                            {
                                AdaptionModRet = 0.7d;
                                break;
                            }

                        default:
                            {
                                AdaptionModRet = 0d;
                                break;
                            }
                    }
                }
                else
                {
                    switch (uad)
                    {
                        case 5:
                            {
                                AdaptionModRet = 1.2d;
                                break;
                            }

                        case 4:
                            {
                                AdaptionModRet = 1.1d;
                                break;
                            }

                        case 3:
                            {
                                AdaptionModRet = 1d;
                                break;
                            }

                        case 2:
                            {
                                AdaptionModRet = 0.9d;
                                break;
                            }

                        case 1:
                            {
                                AdaptionModRet = 0.8d;
                                break;
                            }

                        default:
                            {
                                AdaptionModRet = 0d;
                                break;
                            }
                    }
                }
            }
            else
            {
                if (Expression.IsOptionDefined("地形適応修正繰り下げ"))
                {
                    switch (uad)
                    {
                        case 5:
                            {
                                AdaptionModRet = 1.2d;
                                break;
                            }

                        case 4:
                            {
                                AdaptionModRet = 1d;
                                break;
                            }

                        case 3:
                            {
                                AdaptionModRet = 0.8d;
                                break;
                            }

                        case 2:
                            {
                                AdaptionModRet = 0.6d;
                                break;
                            }

                        case 1:
                            {
                                AdaptionModRet = 0.4d;
                                break;
                            }

                        default:
                            {
                                AdaptionModRet = 0d;
                                break;
                            }
                    }
                }
                else
                {
                    switch (uad)
                    {
                        case 5:
                            {
                                AdaptionModRet = 1.4d;
                                break;
                            }

                        case 4:
                            {
                                AdaptionModRet = 1.2d;
                                break;
                            }

                        case 3:
                            {
                                AdaptionModRet = 1d;
                                break;
                            }

                        case 2:
                            {
                                AdaptionModRet = 0.8d;
                                break;
                            }

                        case 1:
                            {
                                AdaptionModRet = 0.6d;
                                break;
                            }

                        default:
                            {
                                AdaptionModRet = 0d;
                                break;
                            }
                    }
                }
            }

            return AdaptionModRet;
        }


        // 装甲
        public int get_Armor(string ref_mode)
        {
            int ArmorRet = default;
            ArmorRet = lngArmor;

            // ステータス表示用
            switch (ref_mode ?? "")
            {
                case "基本値":
                    {
                        if (IsConditionSatisfied("装甲劣化"))
                        {
                            ArmorRet = ArmorRet / 2;
                        }

                        if (IsConditionSatisfied("石化"))
                        {
                            ArmorRet = 2 * ArmorRet;
                        }

                        if (IsConditionSatisfied("凍結"))
                        {
                            ArmorRet = ArmorRet / 2;
                        }

                        return default;
                    }

                case "修正値":
                    {
                        ArmorRet = 0;
                        break;
                    }
            }

            // パイロットによる修正
            if (CountPilot() > 0)
            {
                // 霊力による装甲修正
                if (IsFeatureAvailable("霊力変換器"))
                {
                    ArmorRet = (ArmorRet + 5d * PlanaLevel());
                }

                // サイキックドライブ装備ユニットは超能力レベルに応じて装甲が変化
                if (IsFeatureAvailable("サイキックドライブ"))
                {
                    ArmorRet = (ArmorRet + 100d * PsychicLevel());
                }

                // オーラ変換器装備ユニットはオーラレベルに応じて装甲が変化
                if (IsFeatureAvailable("オーラ変換器"))
                {
                    ArmorRet = (ArmorRet + 50d * AuraLevel());
                }
            }

            // 装甲が劣化している場合は装甲値は半減
            if (IsConditionSatisfied("装甲劣化"))
            {
                ArmorRet = ArmorRet / 2;
            }

            // 石化しているユニットはとても固い……
            if (IsConditionSatisfied("石化"))
            {
                ArmorRet = 2 * ArmorRet;
            }

            // 凍っているユニットは脆くなる
            if (IsConditionSatisfied("凍結"))
            {
                ArmorRet = ArmorRet / 2;
            }

            return ArmorRet;
        }

        // 運動性
        public int get_Mobility(string ref_mode)
        {
            int MobilityRet = default;
            MobilityRet = intMobility;
            switch (ref_mode ?? "")
            {
                case "基本値":
                    {
                        return default;
                    }

                case "修正値":
                    {
                        MobilityRet = 0;
                        break;
                    }
            }

            // パイロットによる修正
            if (CountPilot() > 0)
            {
                // サイキックドライブ装備ユニットは超能力レベルに応じて運動性が変化
                if (IsFeatureAvailable("サイキックドライブ"))
                {
                    MobilityRet = (MobilityRet + 5d * PsychicLevel());
                }

                // オーラ変換器装備ユニットはオーラレベルに応じて運動性が変化
                if (IsFeatureAvailable("オーラ変換器"))
                {
                    MobilityRet = (MobilityRet + 2d * AuraLevel());
                }

                // シンクロドライブ装備ユニットは同調率レベルに応じて運動性が変化
                if (IsFeatureAvailable("シンクロドライブ"))
                {
                    if (MainPilot().SynchroRate() > 0)
                    {
                        MobilityRet = (MobilityRet + (long)(SyncLevel() - 50d) / 2L);
                    }
                }
            }

            return MobilityRet;
        }

        // ビットマップ
        public string get_Bitmap(bool use_orig)
        {
            string BitmapRet = default;
            if (IsConditionSatisfied("ユニット画像"))
            {
                BitmapRet = GeneralLib.LIndex(ConditionData(argIndex1), 2);
                return default;
            }

            if (IsFeatureAvailable("ユニット画像"))
            {
                BitmapRet = FeatureData("ユニット画像");
                return default;
            }

            if (use_orig)
            {
                BitmapRet = Data.Bitmap0;
            }
            else
            {
                BitmapRet = Data.Bitmap;
            }

            return BitmapRet;
        }

        // 修理費(獲得資金)
        public int Value
        {
            get
            {
                int ValueRet = default;
                ValueRet = Data.Value;
                if (IsFeatureAvailable("修理費修正"))
                {
                    ValueRet = GeneralLib.MaxLng((ValueRet + 1000d * FeatureLevel("修理費修正")), 0);
                }

                if (BossRank > 0)
                {
                    ValueRet = (ValueRet * (1d + 0.5d * BossRank + 0.05d * Rank));
                }
                else
                {
                    ValueRet = (ValueRet * (1d + 0.05d * Rank));
                }

                return ValueRet;
            }
        }

        // 経験値
        public int ExpValue
        {
            get
            {
                int ExpValueRet = default;
                ExpValueRet = Data.ExpValue;
                if (IsFeatureAvailable("経験値修正"))
                {
                    ExpValueRet = GeneralLib.MaxLng((ExpValueRet + 10d * FeatureLevel("経験値修正")), 0);
                }

                if (BossRank > 0)
                {
                    ExpValueRet = ExpValueRet + 20 * BossRank;
                }

                return ExpValueRet;
            }
        }

        // 残り行動数
        public int Action
        {
            get
            {
                int ActionRet = default;
                if (MaxAction() > 0)
                {
                    ActionRet = GeneralLib.MaxLng(MaxAction() - UsedAction, 0);
                }
                else
                {
                    ActionRet = 0;
                }

                return ActionRet;
            }
        }


        // === 行動パターンを規定するパラメータ関連処理 ===

        // 陣営
        public string Party0
        {
            get
            {
                string Party0Ret = default;
                Party0Ret = strParty;
                return Party0Ret;
            }
        }

        public string Party
        {
            get
            {
                string PartyRet = default;
                PartyRet = strParty;

                // 魅了されている場合
                if (IsConditionSatisfied("魅了") && Master is object)
                {
                    PartyRet = Master.Party;
                    if (PartyRet == "味方")
                    {
                        // 味方になっても自分では操作できない
                        PartyRet = "ＮＰＣ";
                    }
                }

                // 憑依されている場合
                if (IsConditionSatisfied("憑依") && Master is object)
                {
                    PartyRet = Master.Party;
                }

                // コントロール不能の味方ユニットはＮＰＣとして扱う
                if (PartyRet == "味方")
                {
                    if (IsConditionSatisfied("暴走") || IsConditionSatisfied("混乱") || IsConditionSatisfied("恐怖") || IsConditionSatisfied("踊り") || IsConditionSatisfied("狂戦士"))
                    {
                        PartyRet = "ＮＰＣ";
                    }
                }

                return PartyRet;
            }

            set
            {
                strParty = value;
            }
        }

        // 思考モード

        public string Mode
        {
            get
            {
                string ModeRet = default;
                int i;
                if (IsUnderSpecialPowerEffect("挑発"))
                {
                    // 挑発を最優先
                    var loopTo = CountSpecialPower();
                    for (i = 1; i <= loopTo; i++)
                    {
                        // UPGRADE_WARNING: オブジェクト SpecialPower(i).IsEffectAvailable(挑発) の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                        SpecialPowerData localSpecialPower() { object argIndex1 = i; var ret = SpecialPower(argIndex1); return ret; }

                        if (Conversions.ToBoolean(localSpecialPower().IsEffectAvailable("挑発")))
                        {
                            ModeRet = SpecialPowerData(i);
                            return default;
                        }
                    }
                }

                if (IsConditionSatisfied("暴走") || IsConditionSatisfied("混乱") || IsConditionSatisfied("憑依") || IsConditionSatisfied("狂戦士"))
                {
                    // 正常な判断が出来ない場合は当初の目的を忘れてしまうため
                    // 常に通常モードとして扱う
                    ModeRet = "通常";
                    return default;
                }

                if (IsConditionSatisfied("恐怖"))
                {
                    // 恐怖にかられた場合は逃亡
                    ModeRet = "逃亡";
                    return default;
                }

                if (IsConditionSatisfied("踊り"))
                {
                    // 踊るのに忙しい……
                    ModeRet = "固定";
                    return default;
                }

                ModeRet = strMode;
                return ModeRet;
            }

            set
            {
                strMode = value;
            }
        }

        // 地形 area_name での移動が可能かどうか
        public bool IsTransAvailable(string area_name)
        {
            bool IsTransAvailableRet = default;
            // 移動可能地形に含まれているか？
            if (Strings.InStr(Transportation, area_name) > 0)
            {
                IsTransAvailableRet = true;
            }
            else
            {
                IsTransAvailableRet = false;
            }

            // 水上移動の場合
            if (area_name == "水上")
            {
                if (IsFeatureAvailable("水上移動") || IsFeatureAvailable("ホバー移動"))
                {
                    IsTransAvailableRet = true;
                }
            }

            return IsTransAvailableRet;
        }


        // === ユニット用特殊能力関連処理 ===

        // 特殊能力の総数
        public int CountFeature()
        {
            int CountFeatureRet = default;
            CountFeatureRet = colFeature.Count;
            return CountFeatureRet;
        }

        // 特殊能力
        public string Feature(object Index)
        {
            string FeatureRet = default;
            FeatureData fd;
            fd = (FeatureData)colFeature[Index];
            FeatureRet = fd.Name;
            return FeatureRet;
        }

        // 特殊能力の名称
        public string FeatureName(object Index)
        {
            string FeatureNameRet = default;
            FeatureNameRet = FeatureNameInt(Index, colFeature);
            return FeatureNameRet;
        }

        private string FeatureNameInt(object Index, Collection feature_list)
        {
            string FeatureNameIntRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 30194


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)feature_list[Index];
            // 非表示の能力
            switch (fd.Name ?? "")
            {
                case "ノーマルモード":
                case "パーツ合体":
                case "換装":
                case "制限時間":
                case "制御不可":
                case "主形態":
                case "他形態":
                case "合体制限":
                case "格闘武器":
                case "迎撃武器":
                case "合体技":
                case "変形技":
                case "ランクアップ":
                case "追加パイロット":
                case "暴走時パイロット":
                case "追加サポート":
                case "装備個所":
                case "ハードポイント":
                case "武器クラス":
                case "防具クラス":
                case "ＢＧＭ":
                case "武器ＢＧＭ":
                case "アビリティＢＧＭ":
                case "合体ＢＧＭ":
                case "分離ＢＧＭ":
                case "変形ＢＧＭ":
                case "ハイパーモードＢＧＭ":
                case "ユニット画像":
                case "パイロット画像":
                case "パイロット愛称":
                case "パイロット読み仮名":
                case "性別":
                case "性格変更":
                case "吸収":
                case "無効化":
                case "耐性":
                case "弱点":
                case "有効":
                case "特殊効果無効化":
                case "アイテム所有":
                case "レアアイテム所有":
                case "ラーニング可能技":
                case "改造費修正":
                case "最大改造数":
                case "パイロット能力付加":
                case "パイロット能力強化":
                case "非表示":
                case "攻撃属性":
                case "射程延長":
                case "武器強化":
                case "命中率強化":
                case "ＣＴ率強化":
                case "特殊効果発動率強化":
                case "必要技能":
                case "不必要技能":
                case "ダミーユニット":
                case "地形ユニット":
                case "召喚解除コマンド名":
                case "変身解除コマンド名":
                case "１人乗り可能":
                case "特殊効果":
                case "戦闘アニメ":
                case "パイロット地形適応変更":
                case "メッセージクラス":
                case "用語名":
                case "発光":
                    {
                        // ユニット用特殊能力
                        FeatureNameIntRet = "";
                        return FeatureNameIntRet;
                    }

                case "愛称変更":
                case "読み仮名変更":
                case "サイズ変更":
                case "地形適応変更":
                case "地形適応固定変更":
                case "空中移動":
                case "陸上移動":
                case "水中移動":
                case "宇宙移動":
                case "地中移動":
                case "修理費修正":
                case "経験値修正":
                case "最大弾数増加":
                case "ＥＮ消費減少":
                case "Ｖ－ＵＰ":
                case "大型アイテム":
                case "呪い":
                    {
                        // アイテム用特殊能力
                        FeatureNameIntRet = "";
                        return FeatureNameIntRet;
                    }
            }

            // ADD START MARGE
            // 拡大画像能力は「拡大画像(文字列)」といった指定もあるので他の非表示能力と異なる
            // 判定方法を使う
            if (Strings.InStr(fd.Name, "拡大画像") == 1)
            {
                FeatureNameIntRet = "";
                return FeatureNameIntRet;
            }
            // ADD END MARGE

            if (Strings.Len(fd.StrData) > 0)
            {
                // 別名の指定あり
                FeatureNameIntRet = GeneralLib.ListIndex(fd.StrData, 1);
                if (FeatureNameIntRet == "非表示" || FeatureNameIntRet == "解説")
                {
                    FeatureNameIntRet = "";
                }
            }
            else if (fd.Level == SRC.DEFAULT_LEVEL)
            {
                // レベル指定なし
                FeatureNameIntRet = fd.Name;
            }
            else if (fd.Level >= 0d)
            {
                // レベル指定あり
                FeatureNameIntRet = fd.Name + "Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(fd.Level);
                if (fd.Name == "射撃強化")
                {
                    if (CountPilot() > 0)
                    {
                        if (MainPilot().HasMana())
                        {
                            FeatureNameIntRet = "魔力強化Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(fd.Level);
                        }
                    }
                }
            }
            else
            {
                // マイナスのレベル指定
                switch (fd.Name ?? "")
                {
                    case "格闘強化":
                        {
                            FeatureNameIntRet = "格闘低下" + "Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Math.Abs(fd.Level));
                            break;
                        }

                    case "射撃強化":
                        {
                            FeatureNameIntRet = "射撃低下" + "Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Math.Abs(fd.Level));
                            if (CountPilot() > 0)
                            {
                                if (MainPilot().HasMana())
                                {
                                    FeatureNameIntRet = "魔力低下Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Math.Abs(fd.Level));
                                }
                            }

                            break;
                        }

                    case "命中強化":
                        {
                            FeatureNameIntRet = "命中低下" + "Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Math.Abs(fd.Level));
                            break;
                        }

                    case "回避強化":
                        {
                            FeatureNameIntRet = "回避低下" + "Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Math.Abs(fd.Level));
                            break;
                        }

                    case "技量強化":
                        {
                            FeatureNameIntRet = "技量低下" + "Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Math.Abs(fd.Level));
                            break;
                        }

                    case "反応強化":
                        {
                            FeatureNameIntRet = "反応低下" + "Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(Math.Abs(fd.Level));
                            break;
                        }

                    default:
                        {
                            FeatureNameIntRet = fd.Name + "Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(fd.Level);
                            break;
                        }
                }
            }

            return FeatureNameIntRet;
            ErrorHandler:
            ;

            // 見つからなかった場合
            // UPGRADE_WARNING: オブジェクト Index の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
            FeatureNameIntRet = Conversions.ToString(Index);
        }

        public string FeatureName0(object Index)
        {
            string FeatureName0Ret = default;
            FeatureName0Ret = FeatureName(Index);
            if (Strings.InStr(FeatureName0Ret, "Lv") > 0)
            {
                FeatureName0Ret = Strings.Left(FeatureName0Ret, Strings.InStr(FeatureName0Ret, "Lv") - 1);
            }

            return FeatureName0Ret;
        }

        // 特殊能力のレベル
        public double FeatureLevel(object Index)
        {
            double FeatureLevelRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 34249


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colFeature[Index];
            FeatureLevelRet = fd.Level;
            if (fd.Level == SRC.DEFAULT_LEVEL)
            {
                FeatureLevelRet = 1d;
            }

            return FeatureLevelRet;
            ErrorHandler:
            ;
            FeatureLevelRet = 0d;
        }

        // 特殊能力のデータ
        public string FeatureData(object Index)
        {
            string FeatureDataRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 34649


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colFeature[Index];
            FeatureDataRet = fd.StrData;
            return FeatureDataRet;
            ErrorHandler:
            ;
            FeatureDataRet = "";
        }

        // 特殊能力の必要技能
        public string FeatureNecessarySkill(object Index)
        {
            string FeatureNecessarySkillRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 34947


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colFeature[Index];
            FeatureNecessarySkillRet = fd.NecessarySkill;
            return FeatureNecessarySkillRet;
            ErrorHandler:
            ;
            FeatureNecessarySkillRet = "";
        }

        // 指定した特殊能力を所有しているか？
        public bool IsFeatureAvailable(string fname)
        {
            bool IsFeatureAvailableRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 35278


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colFeature[fname];
            IsFeatureAvailableRet = true;
            return IsFeatureAvailableRet;
            ErrorHandler:
            ;
            IsFeatureAvailableRet = false;
        }

        // 特殊能力にレベル指定がされている？
        public bool IsFeatureLevelSpecified(object Index)
        {
            bool IsFeatureLevelSpecifiedRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 35598


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colFeature[Index];
            if (fd.Level == SRC.DEFAULT_LEVEL)
            {
                IsFeatureLevelSpecifiedRet = false;
            }
            else
            {
                IsFeatureLevelSpecifiedRet = true;
            }

            return IsFeatureLevelSpecifiedRet;
            ErrorHandler:
            ;
            IsFeatureLevelSpecifiedRet = false;
        }

        // 特殊能力の総数(必要条件を満たさないものを含む)
        public int CountAllFeature()
        {
            int CountAllFeatureRet = default;
            CountAllFeatureRet = colAllFeature.Count;
            return CountAllFeatureRet;
        }

        // 特殊能力(必要条件を満たさないものを含む)
        public string AllFeature(object Index)
        {
            string AllFeatureRet = default;
            FeatureData fd;
            fd = (FeatureData)colAllFeature[Index];
            AllFeatureRet = fd.Name;
            return AllFeatureRet;
        }

        // 特殊能力の名称(必要条件を満たさないものを含む)
        public string AllFeatureName(object Index)
        {
            string AllFeatureNameRet = default;
            AllFeatureNameRet = FeatureNameInt(Index, colAllFeature);
            return AllFeatureNameRet;
        }

        // 特殊能力のレベル(必要条件を満たさないものを含む)
        public double AllFeatureLevel(object Index)
        {
            double AllFeatureLevelRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 36565


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colAllFeature[Index];
            AllFeatureLevelRet = fd.Level;
            if (fd.Level == SRC.DEFAULT_LEVEL)
            {
                AllFeatureLevelRet = 1d;
            }

            return AllFeatureLevelRet;
            ErrorHandler:
            ;
            AllFeatureLevelRet = 0d;
        }

        // 特殊能力のレベルが指定されているか(必要条件を満たさないものを含む)
        public bool AllFeatureLevelSpecified(object Index)
        {
            bool AllFeatureLevelSpecifiedRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 37017


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colAllFeature[Index];
            if (fd.Level != SRC.DEFAULT_LEVEL)
            {
                AllFeatureLevelSpecifiedRet = true;
            }

            return AllFeatureLevelSpecifiedRet;
            ErrorHandler:
            ;
            AllFeatureLevelSpecifiedRet = false;
        }

        // 特殊能力のデータ(必要条件を満たさないものを含む)
        public string AllFeatureData(object Index)
        {
            string AllFeatureDataRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 37422


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colAllFeature[Index];
            AllFeatureDataRet = fd.StrData;
            return AllFeatureDataRet;
            ErrorHandler:
            ;
            AllFeatureDataRet = "";
        }

        // 特殊能力にレベル指定がされている？(必要条件を満たさないものを含む)
        public bool IsAllFeatureLevelSpecified(object Index)
        {
            bool IsAllFeatureLevelSpecifiedRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 37760


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colAllFeature[Index];
            if (fd.Level == SRC.DEFAULT_LEVEL)
            {
                IsAllFeatureLevelSpecifiedRet = false;
            }
            else
            {
                IsAllFeatureLevelSpecifiedRet = true;
            }

            return IsAllFeatureLevelSpecifiedRet;
            ErrorHandler:
            ;
            IsAllFeatureLevelSpecifiedRet = false;
        }

        // 特殊能力が必要条件を満たしているか
        public bool IsFeatureActivated(object Index)
        {
            bool IsFeatureActivatedRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 38217


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colAllFeature[Index];
            foreach (FeatureData fd2 in colFeature)
            {
                if (ReferenceEquals(fd, fd2))
                {
                    IsFeatureActivatedRet = true;
                    return IsFeatureActivatedRet;
                }
            }

            IsFeatureActivatedRet = false;
            return IsFeatureActivatedRet;
            ErrorHandler:
            ;
            IsFeatureActivatedRet = false;
        }


        // === ユニットステータスの更新処理 ===

        // ユニットの各種パラメータを更新するサブルーチン
        // パラメータや武器、アビリティデータ等が変化する際には必ず呼び出す必要がある。
        public void Update(bool without_refresh = false)
        {
            WeaponData[] prev_wdata;
            double[] prev_wbullets;
            AbilityData[] prev_adata;
            double[] prev_astocks;
            int l, j, i, k, num;
            string ch, buf;
            FeatureData fd;
            Item itm;
            string stype, sdata;
            double slevel;
            string stype2, sdata2;
            double slevel2;
            string wname, wnickname;
            string wnskill, wclass, wtype, sname;
            string fdata;
            int flen;
            bool found, flag;
            bool[] flags;
            bool with_not;
            int false_count;
            var uadaption = new int[5];
            double hp_ratio, en_ratio;
            string ubitmap;
            int pmorale;
            bool is_stable, is_uncontrollable, is_invisible;

            // ＨＰとＥＮの値を記録
            hp_ratio = 100 * HP / (double)MaxHP;
            en_ratio = 100 * EN / (double)MaxEN;

            // ユニット用画像ファイル名を記録しておく
            ubitmap = get_Bitmap(false);

            // 非表示かどうか記録しておく
            is_invisible = IsFeatureAvailable("非表示");

            // 制御不可がどうかを記録しておく
            is_uncontrollable = IsFeatureAvailable("制御不可");

            // 不安定がどうかを記録しておく
            is_stable = IsFeatureAvailable("不安定");
            TryAgain:
            ;


            // アイテムが現在の形態で効力を発揮してくれるか判定
            foreach (Item currentItm in colItem)
            {
                itm = currentItm;
                itm.Activated = itm.IsAvailable(this);
            }

            // ランクアップによるデータ変更
            while (Data.IsFeatureAvailable("ランクアップ"))
            {
                {
                    var withBlock = Data;
                    if (Rank < withBlock.FeatureLevel("ランクアップ"))
                    {
                        break;
                    }

                    bool localIsNecessarySkillSatisfied() { object argIndex1 = "ランクアップ"; string argnabilities = withBlock.FeatureNecessarySkill(argIndex1); Pilot argp = null; var ret = IsNecessarySkillSatisfied(argnabilities, p: argp); return ret; }

                    if (!localIsNecessarySkillSatisfied())
                    {
                        break;
                    }

                    fdata = withBlock.FeatureData("ランクアップ");
                }

                {
                    var withBlock1 = SRC.UDList;
                    bool localIsDefined() { object argIndex1 = fdata; var ret = withBlock1.IsDefined(argIndex1); return ret; }

                    if (!localIsDefined())
                    {
                        GUI.ErrorMessage(Name + "のランクアップ先ユニット「" + fdata + "」のデータが定義されていません");
                        SRC.TerminateSRC();
                    }

                    Data = withBlock1.Item(fdata);
                }
            }

            // 特殊能力を更新

            // まず特殊能力リストをクリア
            {
                var withBlock2 = colFeature;
                foreach (FeatureData currentFd in colFeature)
                {
                    fd = currentFd;
                    withBlock2.Remove(1);
                }
            }

            // 付加された特殊能力
            foreach (Condition cnd in colCondition)
            {
                if (cnd.Lifetime != 0)
                {
                    if (Strings.Right(cnd.Name, 2) == "付加")
                    {
                        fd = new FeatureData();
                        fd.Name = Strings.Left(cnd.Name, Strings.Len(cnd.Name) - 2);
                        fd.Level = cnd.Level;
                        fd.StrData = cnd.StrData;
                        colFeature.Add(fd, fd.Name);
                    }
                }
            }

            AdditionalFeaturesNum = colFeature.Count;

            // ユニットデータで定義されている特殊能力
            AddFeatures(Data.colFeature);

            // アイテムで得られた特殊能力
            var loopTo = CountItem();
            for (i = 1; i <= loopTo; i++)
            {
                {
                    var withBlock3 = Item(i);
                    if (withBlock3.Activated)
                    {
                        AddFeatures(withBlock3.Data.colFeature, true);
                    }
                }
            }

            // パイロットデータで定義されている特殊能力
            if (CountPilot() > 0)
            {
                if (IsFeatureAvailable("追加パイロット"))
                {
                    // 特殊能力を付加する前に必要技能が満たされているかどうか判定
                    UpdateFeatures("追加パイロット");
                }

                AddFeatures(MainPilot().Data.colFeature);
                var loopTo1 = CountPilot();
                for (i = 2; i <= loopTo1; i++)
                {
                    Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    AddFeatures(localPilot().Data.colFeature);
                }

                var loopTo2 = CountSupport();
                for (i = 1; i <= loopTo2; i++)
                {
                    Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    AddFeatures(localSupport().Data.colFeature);
                }

                if (IsFeatureAvailable("追加サポート"))
                {
                    // 特殊能力を付加する前に必要技能が満たされているかどうか判定
                    UpdateFeatures("追加サポート");
                    if (IsFeatureAvailable("追加サポート"))
                    {
                        AddFeatures(AdditionalSupport().Data.colFeature);
                    }
                }
            }

            // パイロット能力付加＆強化の効果をクリア
            i = 1;
            while (i <= CountCondition())
            {
                string localCondition() { object argIndex1 = i; var ret = Condition(argIndex1); return ret; }

                switch (Strings.Right(localCondition(), 3) ?? "")
                {
                    case "付加２":
                    case "強化２":
                        {
                            DeleteCondition(i);
                            break;
                        }

                    default:
                        {
                            i = (i + 1);
                            break;
                        }
                }
            }

            // パイロット能力付加
            found = false;
            flag = false;
            flags = new bool[colFeature.Count + 1];
            AddSkills:
            ;
            i = 1;
            foreach (FeatureData currentFd1 in colFeature)
            {
                fd = currentFd1;
                if (flags[i])
                {
                    goto NextFeature;
                }

                switch (fd.Name ?? "")
                {
                    case "パイロット能力付加":
                        {
                            // 必要技能を満たしている？
                            if (!IsNecessarySkillSatisfied(fd.NecessarySkill, p: null))
                            {
                                found = true;
                                goto NextFeature;
                            }
                            // 必要条件を満たしている？
                            if (!IsNecessarySkillSatisfied(fd.NecessaryCondition, p: null))
                            {
                                found = true;
                                goto NextFeature;
                            }

                            flags[i] = true;

                            // 能力指定が「"」で囲まれている場合は「"」を削除
                            if (Strings.Asc(fd.StrData) == 34) // "
                            {
                                buf = Strings.Mid(fd.StrData, 2, Strings.Len(fd.StrData) - 2);
                            }
                            else
                            {
                                buf = fd.StrData;
                            }

                            // 付加する特殊能力の種類、レベル、データを解析
                            if (Strings.InStr(buf, "=") > 0)
                            {
                                sdata = Strings.Mid(buf, Strings.InStr(buf, "=") + 1);
                                buf = Strings.Left(buf, Strings.InStr(buf, "=") - 1);
                                if (Strings.InStr(buf, "Lv") > 0)
                                {
                                    stype = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
                                    if (Information.IsNumeric(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2)))
                                    {
                                        slevel = Conversions.ToDouble(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2));
                                    }
                                    else
                                    {
                                        slevel = 1d;
                                    }
                                }
                                else
                                {
                                    stype = buf;
                                    slevel = SRC.DEFAULT_LEVEL;
                                }
                            }
                            else
                            {
                                sdata = "";
                                if (Strings.InStr(buf, "Lv") > 0)
                                {
                                    stype = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
                                    if (Information.IsNumeric(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2)))
                                    {
                                        slevel = Conversions.ToDouble(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2));
                                    }
                                    else
                                    {
                                        slevel = 1d;
                                    }
                                }
                                else
                                {
                                    stype = buf;
                                    slevel = SRC.DEFAULT_LEVEL;
                                }
                            }

                            // エリアスが定義されている？
                            if (SRC.ALDList.IsDefined(stype))
                            {
                                {
                                    var withBlock4 = SRC.ALDList.Item(stype);
                                    var loopTo3 = withBlock4.Count;
                                    for (j = 1; j <= loopTo3; j++)
                                    {
                                        // エリアスの定義に従って特殊能力定義を置き換える
                                        stype2 = withBlock4.get_AliasType(j);
                                        string localLIndex() { string arglist = withBlock4.get_AliasData(j); var ret = GeneralLib.LIndex(arglist, 1); withBlock4.get_AliasData(j) = arglist; return ret; }

                                        if (localLIndex() == "解説")
                                        {
                                            // 特殊能力の解説
                                            if (!string.IsNullOrEmpty(sdata))
                                            {
                                                stype2 = GeneralLib.LIndex(sdata, 1);
                                            }

                                            slevel2 = SRC.DEFAULT_LEVEL;
                                            sdata2 = withBlock4.get_AliasData(j);
                                        }
                                        else
                                        {
                                            // 通常の能力
                                            if (withBlock4.get_AliasLevelIsPlusMod(j))
                                            {
                                                if (slevel == SRC.DEFAULT_LEVEL)
                                                {
                                                    slevel = 1d;
                                                }

                                                slevel2 = slevel + withBlock4.get_AliasLevel(j);
                                            }
                                            else if (withBlock4.get_AliasLevelIsMultMod(j))
                                            {
                                                if (slevel == SRC.DEFAULT_LEVEL)
                                                {
                                                    slevel = 1d;
                                                }

                                                slevel2 = slevel * withBlock4.get_AliasLevel(j);
                                            }
                                            else if (slevel != SRC.DEFAULT_LEVEL)
                                            {
                                                slevel2 = slevel;
                                            }
                                            else
                                            {
                                                slevel2 = withBlock4.get_AliasLevel(j);
                                            }

                                            sdata2 = withBlock4.get_AliasData(j);
                                            if (!string.IsNullOrEmpty(sdata))
                                            {
                                                if (Strings.InStr(sdata2, "非表示") != 1)
                                                {
                                                    sdata2 = sdata + " " + GeneralLib.ListTail(sdata2, (GeneralLib.LLength(sdata) + 1));
                                                }
                                            }

                                            if (withBlock4.get_AliasLevelIsPlusMod(j) || withBlock4.get_AliasLevelIsMultMod(j))
                                            {
                                                sdata2 = GeneralLib.LIndex(sdata2, 1) + "Lv" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(slevel) + " " + GeneralLib.ListTail(sdata2, 2);
                                                sdata2 = Strings.Trim(sdata2);
                                            }
                                        }

                                        // 属性使用不能攻撃により使用不能になった技能を封印する。
                                        if (ConditionLifetime(stype2 + "使用不能") > 0)
                                        {
                                            goto NextFeature;
                                        }

                                        AddCondition(stype2 + "付加２", -1, slevel2, sdata2);
                                    }
                                }
                            }
                            else
                            {
                                // 属性使用不能攻撃により使用不能になった技能を封印する。
                                if (ConditionLifetime(stype + "使用不能") > 0)
                                {
                                    goto NextFeature;
                                }

                                AddCondition(stype + "付加２", -1, slevel, sdata);
                            }

                            break;
                        }

                    case "パイロット能力強化":
                        {
                            // 必要技能を満たしている？
                            if (!IsNecessarySkillSatisfied(fd.NecessarySkill, p: null))
                            {
                                found = true;
                                goto NextFeature;
                            }
                            // 必要条件を満たしている？
                            if (!IsNecessarySkillSatisfied(fd.NecessaryCondition, p: null))
                            {
                                found = true;
                                goto NextFeature;
                            }

                            flags[i] = true;

                            // 能力指定が「"」で囲まれている場合は「"」を削除
                            if (Strings.Asc(fd.StrData) == 34) // "
                            {
                                buf = Strings.Mid(fd.StrData, 2, Strings.Len(fd.StrData) - 2);
                            }
                            else
                            {
                                buf = fd.StrData;
                            }

                            // 強化する特殊能力の種類、レベル、データを解析
                            if (Strings.InStr(buf, "=") > 0)
                            {
                                sdata = Strings.Mid(buf, Strings.InStr(buf, "=") + 1);
                                buf = Strings.Left(buf, Strings.InStr(buf, "=") - 1);
                                if (Strings.InStr(buf, "Lv") > 0)
                                {
                                    stype = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
                                    if (Information.IsNumeric(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2)))
                                    {
                                        slevel = Conversions.ToDouble(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2));
                                    }
                                    else
                                    {
                                        slevel = 1d;
                                    }
                                }
                                else
                                {
                                    stype = buf;
                                    slevel = 1d;
                                }
                            }
                            else
                            {
                                sdata = "";
                                if (Strings.InStr(buf, "Lv") > 0)
                                {
                                    stype = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
                                    if (Information.IsNumeric(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2)))
                                    {
                                        slevel = Conversions.ToDouble(Strings.Mid(buf, Strings.InStr(buf, "Lv") + 2));
                                    }
                                    else
                                    {
                                        slevel = 1d;
                                    }
                                }
                                else
                                {
                                    stype = buf;
                                    slevel = 1d;
                                }
                            }

                            // エリアスが定義されている？
                            if (SRC.ALDList.IsDefined(stype))
                            {
                                {
                                    var withBlock5 = SRC.ALDList.Item(stype);
                                    var loopTo4 = withBlock5.Count;
                                    for (j = 1; j <= loopTo4; j++)
                                    {
                                        // エリアスの定義に従って特殊能力定義を置き換える
                                        stype2 = withBlock5.get_AliasType(j);

                                        // 属性使用不能攻撃により使用不能になった技能を封印する。
                                        if (ConditionLifetime(stype2 + "使用不能") > 0)
                                        {
                                            goto NextFeature;
                                        }

                                        string localLIndex1() { string arglist = withBlock5.get_AliasData(j); var ret = GeneralLib.LIndex(arglist, 1); withBlock5.get_AliasData(j) = arglist; return ret; }

                                        if (localLIndex1() == "解説")
                                        {
                                            // 特殊能力の解説
                                            if (!string.IsNullOrEmpty(sdata))
                                            {
                                                stype2 = GeneralLib.LIndex(sdata, 1);
                                            }

                                            slevel2 = SRC.DEFAULT_LEVEL;
                                            sdata2 = withBlock5.get_AliasData(j);
                                            // 属性使用不能攻撃により使用不能になった技能を封印する。
                                            if (ConditionLifetime(stype2 + "使用不能") > 0)
                                            {
                                                goto NextFeature;
                                            }

                                            AddCondition(stype2 + "付加２", -1, slevel2, sdata2);
                                        }
                                        else
                                        {
                                            // 通常の能力
                                            if (withBlock5.get_AliasLevelIsMultMod(j))
                                            {
                                                if (slevel == SRC.DEFAULT_LEVEL)
                                                {
                                                    slevel = 1d;
                                                }

                                                slevel2 = slevel * withBlock5.get_AliasLevel(j);
                                            }
                                            else if (slevel != SRC.DEFAULT_LEVEL)
                                            {
                                                slevel2 = slevel;
                                            }
                                            else
                                            {
                                                slevel2 = withBlock5.get_AliasLevel(j);
                                            }

                                            sdata2 = withBlock5.get_AliasData(j);
                                            if (!string.IsNullOrEmpty(sdata))
                                            {
                                                if (Strings.InStr(sdata2, "非表示") != 1)
                                                {
                                                    sdata2 = sdata + " " + GeneralLib.ListTail(sdata2, (GeneralLib.LLength(sdata) + 1));
                                                }
                                            }

                                            // 強化するレベルは累積する
                                            if (IsConditionSatisfied(stype2 + "強化２"))
                                            {
                                                double localConditionLevel() { object argIndex1 = stype2 + "強化２"; var ret = ConditionLevel(argIndex1); return ret; }

                                                slevel2 = slevel2 + localConditionLevel();
                                                DeleteCondition(stype2 + "強化２");
                                            }

                                            AddCondition(stype2 + "強化２", -1, slevel2, sdata2);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                // 強化するレベルは累積する
                                if (IsConditionSatisfied(stype + "強化２"))
                                {
                                    double localConditionLevel1() { object argIndex1 = stype + "強化２"; var ret = ConditionLevel(argIndex1); return ret; }

                                    slevel = slevel + localConditionLevel1();
                                    DeleteCondition(stype + "強化２");
                                }

                                AddCondition(stype + "強化２", -1, slevel, sdata);
                            }

                            break;
                        }
                }

                NextFeature:
                ;
                i = (i + 1);
            }
            // 必要技能＆必要条件付きのパイロット能力付加＆強化がある場合は付加や強化の結果、
            // 必要技能＆必要条件が満たされることがあるので一度だけやり直す
            if (!flag && found)
            {
                flag = true;
                goto AddSkills;
            }

            // パイロット用特殊能力の付加＆強化が完了したので必要技能の判定が可能になった。
            UpdateFeatures();

            // アイテムが必要技能を満たすか再度チェック。
            found = false;
            foreach (Item currentItm1 in colItem)
            {
                itm = currentItm1;
                if (itm.Activated != itm.IsAvailable(this))
                {
                    found = true;
                    break;
                }
            }

            if (found)
            {
                // アイテムの使用可否が変化したので最初からやり直す
                goto TryAgain;
            }

            // ランクアップするか再度チェック。
            {
                var withBlock6 = Data;
                if (withBlock6.IsFeatureAvailable("ランクアップ"))
                {
                    if (Rank >= withBlock6.FeatureLevel("ランクアップ"))
                    {
                        if (IsNecessarySkillSatisfied(withBlock6.FeatureNecessarySkill("ランクアップ"), p: null))
                        {
                            // ランクアップが可能になったので最初からやり直す
                            goto TryAgain;
                        }
                    }
                }
            }

            if (CountPilot() > 0)
            {
                // パイロット能力をアップデート
                var loopTo5 = CountPilot();
                for (i = 2; i <= loopTo5; i++)
                {
                    Pilot localPilot1() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    localPilot1().Update();
                }

                var loopTo6 = CountSupport();
                for (i = 1; i <= loopTo6; i++)
                {
                    Pilot localSupport1() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    localSupport1().Update();
                }

                // メインパイロットは他のパイロットのサポートを受ける関係上
                // 最後にアップデートする
                Pilot(1).Update();
                if (!ReferenceEquals(MainPilot(), Pilot(1)))
                {
                    MainPilot().Update();
                }
            }

            // ユニット画像用ファイル名に変化がある場合はユニット画像を更新
            if (BitmapID != 0)
            {
                if ((ubitmap ?? "") != (get_Bitmap(false) ?? ""))
                {
                    BitmapID = GUI.MakeUnitBitmap(this);
                    var loopTo7 = CountOtherForm();
                    for (i = 1; i <= loopTo7; i++)
                    {
                        Unit localOtherForm() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                        localOtherForm().BitmapID = 0;
                    }

                    if (!without_refresh)
                    {
                        if (Status == "出撃")
                        {
                            if (!GUI.IsPictureVisible && !string.IsNullOrEmpty(Map.MapFileName))
                            {
                                GUI.PaintUnitBitmap(this);
                            }
                        }
                    }
                }
            }

            // ユニットの表示、非表示が切り替わった場合
            if (is_invisible != IsFeatureAvailable("非表示"))
            {
                if (Status == "出撃")
                {
                    if (!GUI.IsPictureVisible && !string.IsNullOrEmpty(Map.MapFileName))
                    {
                        BitmapID = GUI.MakeUnitBitmap(this);
                        if (IsFeatureAvailable("非表示"))
                        {
                            GUI.EraseUnitBitmap(x, y, !without_refresh);
                        }
                        else if (!without_refresh)
                        {
                            GUI.PaintUnitBitmap(this);
                        }
                    }
                }
            }

            // 各種パラメータ
            {
                var withBlock7 = Data;
                lngMaxHP = withBlock7.HP + 200 * Rank;
                intMaxEN = (withBlock7.EN + 10 * Rank);
                lngArmor = withBlock7.Armor + 100 * Rank;
                intMobility = (withBlock7.Mobility + 5 * Rank);
                intSpeed = withBlock7.Speed;
            }

            // ボスランクによる修正
            if (IsHero() || Expression.IsOptionDefined("等身大基準"))
            {
                switch (BossRank)
                {
                    case 1:
                        {
                            lngMaxHP = lngMaxHP + Data.HP;
                            break;
                        }

                    case 2:
                        {
                            lngMaxHP = lngMaxHP + Data.HP + 10000;
                            break;
                        }

                    case 3:
                        {
                            lngMaxHP = lngMaxHP + Data.HP + 20000;
                            break;
                        }

                    case 4:
                        {
                            lngMaxHP = lngMaxHP + Data.HP + 40000;
                            break;
                        }

                    case 5:
                        {
                            lngMaxHP = lngMaxHP + Data.HP + 80000;
                            break;
                        }
                }

                if (BossRank > 0)
                {
                    lngArmor = lngArmor + 200 * BossRank;
                }
            }
            else
            {
                switch (BossRank)
                {
                    case 1:
                        {
                            lngMaxHP = (lngMaxHP + 0.5d * Data.HP);
                            break;
                        }

                    case 2:
                        {
                            lngMaxHP = lngMaxHP + Data.HP;
                            break;
                        }

                    case 3:
                        {
                            lngMaxHP = lngMaxHP + Data.HP + 10000;
                            break;
                        }

                    case 4:
                        {
                            lngMaxHP = lngMaxHP + Data.HP + 20000;
                            break;
                        }

                    case 5:
                        {
                            lngMaxHP = lngMaxHP + Data.HP + 40000;
                            break;
                        }
                }

                if (Expression.IsOptionDefined("BossRank装甲修正低下"))
                {
                    if (BossRank > 0)
                    {
                        lngArmor = lngArmor + 300 * BossRank;
                    }
                }
                else
                {
                    switch (BossRank)
                    {
                        case 1:
                            {
                                lngArmor = lngArmor + 300;
                                break;
                            }

                        case 2:
                            {
                                lngArmor = lngArmor + 600;
                                break;
                            }

                        case 3:
                            {
                                lngArmor = lngArmor + 1000;
                                break;
                            }

                        case 4:
                            {
                                lngArmor = lngArmor + 1500;
                                break;
                            }

                        case 5:
                            {
                                lngArmor = lngArmor + 2500;
                                break;
                            }
                    }
                }
            }

            if (BossRank > 0)
            {
                intMaxEN = (intMaxEN + 20 * BossRank);
                intMobility = (intMobility + 5 * BossRank);
            }

            // ＨＰ成長オプション
            if (Expression.IsOptionDefined("ＨＰ成長"))
            {
                if (CountPilot() > 0)
                {
                    lngMaxHP = GeneralLib.MinLng((lngMaxHP / 100d * (100 + this.MainPilot().Level)), 9999999);
                }
            }

            // ＥＮ成長オプション
            if (Expression.IsOptionDefined("ＥＮ成長"))
            {
                if (CountPilot() > 0)
                {
                    intMaxEN = GeneralLib.MinLng((intMaxEN / 100d * (100 + this.MainPilot().Level)), 9999);
                }
            }

            // 特殊能力による修正
            if (CountPilot() > 0)
            {
                pmorale = MainPilot().Morale;
            }
            else
            {
                pmorale = 100;
            }

            foreach (FeatureData currentFd2 in colFeature)
            {
                fd = currentFd2;
                switch (fd.Name ?? "")
                {
                    // 固定値による強化
                    case "ＨＰ強化":
                        {
                            int localStrToLng() { string argexpr = GeneralLib.LIndex(fd.StrData, 2); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (pmorale >= localStrToLng())
                            {
                                lngMaxHP = (lngMaxHP + 200d * fd.Level);
                            }

                            break;
                        }

                    case "ＥＮ強化":
                        {
                            int localStrToLng1() { string argexpr = GeneralLib.LIndex(fd.StrData, 2); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (pmorale >= localStrToLng1())
                            {
                                intMaxEN = (intMaxEN + 10d * fd.Level);
                            }

                            break;
                        }

                    case "装甲強化":
                        {
                            int localStrToLng2() { string argexpr = GeneralLib.LIndex(fd.StrData, 2); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (pmorale >= localStrToLng2())
                            {
                                lngArmor = (lngArmor + 100d * fd.Level);
                            }

                            break;
                        }

                    case "運動性強化":
                        {
                            int localStrToLng3() { string argexpr = GeneralLib.LIndex(fd.StrData, 2); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (pmorale >= localStrToLng3())
                            {
                                intMobility = (intMobility + 5d * fd.Level);
                            }

                            break;
                        }

                    case "移動力強化":
                        {
                            int localStrToLng4() { string argexpr = GeneralLib.LIndex(fd.StrData, 2); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (pmorale >= localStrToLng4())
                            {
                                intSpeed = (intSpeed + fd.Level);
                            }

                            break;
                        }
                    // 割合による強化
                    case "ＨＰ割合強化":
                        {
                            int localStrToLng5() { string argexpr = GeneralLib.LIndex(fd.StrData, 2); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (pmorale >= localStrToLng5())
                            {
                                lngMaxHP = (lngMaxHP + (long)(Data.HP * fd.Level) / 20L);
                            }

                            break;
                        }

                    case "ＥＮ割合強化":
                        {
                            int localStrToLng6() { string argexpr = GeneralLib.LIndex(fd.StrData, 2); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (pmorale >= localStrToLng6())
                            {
                                intMaxEN = (intMaxEN + (long)(Data.EN * fd.Level) / 20L);
                            }

                            break;
                        }

                    case "装甲割合強化":
                        {
                            int localStrToLng7() { string argexpr = GeneralLib.LIndex(fd.StrData, 2); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (pmorale >= localStrToLng7())
                            {
                                lngArmor = (lngArmor + (long)(Data.Armor * fd.Level) / 20L);
                            }

                            break;
                        }

                    case "運動性割合強化":
                        {
                            int localStrToLng8() { string argexpr = GeneralLib.LIndex(fd.StrData, 2); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (pmorale >= localStrToLng8())
                            {
                                intMobility = (intMobility + (long)(Data.Mobility * fd.Level) / 20L);
                            }

                            break;
                        }
                }
            }

            // アイテムによる修正
            foreach (Item currentItm2 in colItem)
            {
                itm = currentItm2;
                if (itm.Activated)
                {
                    lngMaxHP = lngMaxHP + itm.HP();
                    intMaxEN = (intMaxEN + itm.EN());
                    lngArmor = lngArmor + itm.Armor();
                    intMobility = (intMobility + itm.Mobility());
                    intSpeed = (intSpeed + itm.Speed());
                }
            }

            // 装備している「Ｖ－ＵＰ=ユニット」アイテムによる修正
            num = 0;
            if (IsConditionSatisfied("Ｖ－ＵＰ"))
            {
                switch (FeatureData("Ｖ－ＵＰ") ?? "")
                {
                    case "全":
                    case "ユニット":
                        {
                            num = (num + 1);
                            break;
                        }
                }
            }

            foreach (Item currentItm3 in colItem)
            {
                itm = currentItm3;
                if (itm.IsFeatureAvailable("Ｖ－ＵＰ"))
                {
                    switch (itm.FeatureData("Ｖ－ＵＰ") ?? "")
                    {
                        case "全":
                        case "ユニット":
                            {
                                num = (num + 1);
                                break;
                            }
                    }
                }
            }

            if (CountPilot() > 0)
            {
                {
                    var withBlock8 = MainPilot().Data;
                    if (withBlock8.IsFeatureAvailable("Ｖ－ＵＰ"))
                    {
                        switch (withBlock8.FeatureData("Ｖ－ＵＰ") ?? "")
                        {
                            case "全":
                            case "ユニット":
                                {
                                    num = (num + 1);
                                    break;
                                }
                        }
                    }
                }
            }

            if (num > 0)
            {
                {
                    var withBlock9 = Data;
                    lngMaxHP = lngMaxHP + 100 * num * (withBlock9.ItemNum + 1);
                    intMaxEN = (intMaxEN + 20 * num * withBlock9.ItemNum);
                    lngArmor = lngArmor + 50 * num * withBlock9.ItemNum;
                    intMobility = (intMobility + 5 * num * withBlock9.ItemNum);
                }
            }

            // 追加移動力
            if (IsFeatureAvailable("追加移動力"))
            {
                foreach (FeatureData currentFd3 in colFeature)
                {
                    fd = currentFd3;
                    if (fd.Name == "追加移動力")
                    {
                        if ((Area ?? "") == (GeneralLib.LIndex(fd.StrData, 2) ?? ""))
                        {
                            intSpeed = (intSpeed + fd.Level);
                        }
                    }
                }

                intSpeed = GeneralLib.MaxLng(intSpeed, 0);
            }

            // 上限値を超えないように
            lngMaxHP = GeneralLib.MinLng(lngMaxHP, 9999999);
            intMaxEN = GeneralLib.MinLng(intMaxEN, 9999);
            lngArmor = GeneralLib.MinLng(lngArmor, 99999);
            intMobility = GeneralLib.MinLng(intMobility, 9999);
            intSpeed = GeneralLib.MinLng(intSpeed, 99);

            // ＨＰ、ＥＮの最大値の変動に対応
            HP = (MaxHP * hp_ratio / 100d);
            EN = (MaxEN * en_ratio / 100d);

            // 切り下げの結果ＨＰが0になることを防ぐ
            if (hp_ratio > 0d)
            {
                if (HP == 0)
                {
                    HP = 1;
                }
            }

            // 地形適応
            for (i = 1; i <= 4; i++)
            {
                switch (Strings.Mid(Data.Adaption, i, 1) ?? "")
                {
                    case "S":
                        {
                            uadaption[i] = 5;
                            break;
                        }

                    case "A":
                        {
                            uadaption[i] = 4;
                            break;
                        }

                    case "B":
                        {
                            uadaption[i] = 3;
                            break;
                        }

                    case "C":
                        {
                            uadaption[i] = 2;
                            break;
                        }

                    case "D":
                        {
                            uadaption[i] = 1;
                            break;
                        }

                    case "E":
                    case "-":
                        {
                            uadaption[i] = 0;
                            break;
                        }
                }
            }

            // 移動タイプ追加による地形適応修正
            if (IsFeatureAvailable("空中移動"))
            {
                uadaption[1] = GeneralLib.MaxLng(uadaption[1], 4);
            }

            if (IsFeatureAvailable("陸上移動"))
            {
                uadaption[2] = GeneralLib.MaxLng(uadaption[2], 4);
            }

            if (IsFeatureAvailable("水中移動"))
            {
                uadaption[3] = GeneralLib.MaxLng(uadaption[3], 4);
            }

            if (IsFeatureAvailable("宇宙移動"))
            {
                uadaption[4] = GeneralLib.MaxLng(uadaption[4], 4);
            }

            // 地形適応変更能力による修正
            foreach (FeatureData currentFd4 in colFeature)
            {
                fd = currentFd4;
                switch (fd.Name ?? "")
                {
                    case "地形適応変更":
                        {
                            for (i = 1; i <= 4; i++)
                            {
                                num = GeneralLib.StrToLng(GeneralLib.LIndex(fd.StrData, i));
                                if (num > 0)
                                {
                                    if (uadaption[i] < 4)
                                    {
                                        uadaption[i] = (uadaption[i] + num);
                                        // 地形適応はAより高くはならない
                                        if (uadaption[i] > 4)
                                        {
                                            uadaption[i] = 4;
                                        }
                                    }
                                }
                                else
                                {
                                    uadaption[i] = (uadaption[i] + num);
                                }
                            }

                            break;
                        }

                    case "地形適応固定変更":
                        {
                            for (i = 1; i <= 4; i++)
                            {
                                num = GeneralLib.StrToLng(GeneralLib.LIndex(fd.StrData, i));
                                if (GeneralLib.LIndex(fd.StrData, 5) == "強制")
                                {
                                    // 強制変更の場合
                                    if (num >= 0 && num <= 5)
                                    {
                                        uadaption[i] = num;
                                    }
                                }
                                // 高いほうを優先する場合
                                else if (num > uadaption[i] && num <= 5)
                                {
                                    uadaption[i] = num;
                                }
                            }

                            break;
                        }
                }
            }

            strAdaption = "";
            for (i = 1; i <= 4; i++)
            {
                switch (uadaption[i])
                {
                    case var @case when @case >= 5:
                        {
                            strAdaption = strAdaption + "S";
                            break;
                        }

                    case 4:
                        {
                            strAdaption = strAdaption + "A";
                            break;
                        }

                    case 3:
                        {
                            strAdaption = strAdaption + "B";
                            break;
                        }

                    case 2:
                        {
                            strAdaption = strAdaption + "C";
                            break;
                        }

                    case 1:
                        {
                            strAdaption = strAdaption + "D";
                            break;
                        }

                    case var case1 when case1 <= 0:
                        {
                            strAdaption = strAdaption + "-";
                            break;
                        }
                }
            }

            // 空中に留まることが出来るかチェック
            if (Status == "出撃" && Area == "空中" && !IsTransAvailable("空"))
            {
                // 地上(水中)に戻す
                switch (Map.TerrainClass(x, y) ?? "")
                {
                    case "陸":
                    case "屋内":
                        {
                            Area = "地上";
                            break;
                        }

                    case "水":
                    case "深水":
                        {
                            if (IsTransAvailable("水上"))
                            {
                                Area = "水上";
                            }
                            else
                            {
                                Area = "水中";
                            }

                            break;
                        }
                }

                if (!without_refresh)
                {
                    if (!GUI.IsPictureVisible && !string.IsNullOrEmpty(Map.MapFileName))
                    {
                        GUI.PaintUnitBitmap(this);
                    }
                }
            }

            // 攻撃への耐性を更新
            strAbsorb = "";
            strImmune = "";
            strResist = "";
            strWeakness = "";
            strEffective = "";
            strSpecialEffectImmune = "";
            // 特殊能力によって得られた耐性
            foreach (FeatureData currentFd5 in colFeature)
            {
                fd = currentFd5;
                switch (fd.Name ?? "")
                {
                    case "吸収":
                        {
                            strAbsorb = strAbsorb + fd.StrData;
                            break;
                        }

                    case "無効化":
                        {
                            strImmune = strImmune + fd.StrData;
                            break;
                        }

                    case "耐性":
                        {
                            strResist = strResist + fd.StrData;
                            break;
                        }

                    case "弱点":
                        {
                            strWeakness = strWeakness + fd.StrData;
                            break;
                        }

                    case "有効":
                        {
                            strEffective = strEffective + fd.StrData;
                            break;
                        }

                    case "特殊効果無効化":
                        {
                            strSpecialEffectImmune = strSpecialEffectImmune + fd.StrData;
                            break;
                        }
                }
            }
            // 弱点、有効付加属性攻撃による弱点、有効の付加
            var loopTo8 = CountCondition();
            for (i = 1; i <= loopTo8; i++)
            {
                if (ConditionLifetime(i) != 0)
                {
                    ch = Condition(i);
                    switch (Strings.Right(ch, 6) ?? "")
                    {
                        case "属性弱点付加":
                            {
                                strWeakness = strWeakness + Strings.Left(ch, Strings.Len(ch) - 6);
                                break;
                            }

                        case "属性有効付加":
                            {
                                strEffective = strEffective + Strings.Left(ch, Strings.Len(ch) - 6);
                                break;
                            }
                    }
                }
            }
            // 属性のダブりをなくす
            buf = "";
            var loopTo9 = Strings.Len(strAbsorb);
            for (i = 1; i <= loopTo9; i++)
            {
                ch = GeneralLib.GetClassBundle(strAbsorb, i);
                if (GeneralLib.InStrNotNest(buf, ch) == 0)
                {
                    buf = buf + ch;
                }
            }

            strAbsorb = buf;
            buf = "";
            var loopTo10 = Strings.Len(strImmune);
            for (i = 1; i <= loopTo10; i++)
            {
                ch = GeneralLib.GetClassBundle(strImmune, i);
                if (GeneralLib.InStrNotNest(buf, ch) == 0)
                {
                    buf = buf + ch;
                }
            }

            strImmune = buf;
            buf = "";
            var loopTo11 = Strings.Len(strResist);
            for (i = 1; i <= loopTo11; i++)
            {
                ch = GeneralLib.GetClassBundle(strResist, i);
                if (GeneralLib.InStrNotNest(buf, ch) == 0)
                {
                    buf = buf + ch;
                }
            }

            strResist = buf;
            buf = "";
            var loopTo12 = Strings.Len(strWeakness);
            for (i = 1; i <= loopTo12; i++)
            {
                ch = GeneralLib.GetClassBundle(strWeakness, i);
                if (GeneralLib.InStrNotNest(buf, ch) == 0)
                {
                    buf = buf + ch;
                }
            }

            strWeakness = buf;
            buf = "";
            var loopTo13 = Strings.Len(strEffective);
            for (i = 1; i <= loopTo13; i++)
            {
                ch = GeneralLib.GetClassBundle(strEffective, i);
                if (GeneralLib.InStrNotNest(buf, ch) == 0)
                {
                    buf = buf + ch;
                }
            }

            strEffective = buf;
            buf = "";
            var loopTo14 = Strings.Len(strSpecialEffectImmune);
            for (i = 1; i <= loopTo14; i++)
            {
                ch = GeneralLib.GetClassBundle(strSpecialEffectImmune, i);
                if (GeneralLib.InStrNotNest(buf, ch) == 0)
                {
                    buf = buf + ch;
                }
            }

            strSpecialEffectImmune = buf;

            // 武器データを更新
            prev_wdata = new WeaponData[Information.UBound(WData) + 1];
            prev_wbullets = new double[Information.UBound(WData) + 1];
            var loopTo15 = Information.UBound(WData);
            for (i = 1; i <= loopTo15; i++)
            {
                prev_wdata[i] = WData[i];
                prev_wbullets[i] = dblBullet[i];
            }

            {
                var withBlock10 = Data;
                WData = new WeaponData[(withBlock10.CountWeapon() + 1)];
                var loopTo16 = withBlock10.CountWeapon();
                for (i = 1; i <= loopTo16; i++)
                {
                    WData[i] = withBlock10.Weapon(i);
                }
            }

            if (CountPilot() > 0)
            {
                {
                    var withBlock11 = MainPilot().Data;
                    var loopTo17 = withBlock11.CountWeapon();
                    for (i = 1; i <= loopTo17; i++)
                    {
                        Array.Resize(WData, Information.UBound(WData) + 1 + 1);
                        WData[Information.UBound(WData)] = withBlock11.Weapon(i);
                    }
                }

                var loopTo18 = CountPilot();
                for (i = 2; i <= loopTo18; i++)
                {
                    Pilot localPilot2() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    {
                        var withBlock12 = localPilot2().Data;
                        var loopTo19 = withBlock12.CountWeapon();
                        for (j = 1; j <= loopTo19; j++)
                        {
                            Array.Resize(WData, Information.UBound(WData) + 1 + 1);
                            WData[Information.UBound(WData)] = withBlock12.Weapon(j);
                        }
                    }
                }

                var loopTo20 = CountSupport();
                for (i = 1; i <= loopTo20; i++)
                {
                    Pilot localSupport2() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    {
                        var withBlock13 = localSupport2().Data;
                        var loopTo21 = withBlock13.CountWeapon();
                        for (j = 1; j <= loopTo21; j++)
                        {
                            Array.Resize(WData, Information.UBound(WData) + 1 + 1);
                            WData[Information.UBound(WData)] = withBlock13.Weapon(j);
                        }
                    }
                }

                if (IsFeatureAvailable("追加サポート"))
                {
                    {
                        var withBlock14 = AdditionalSupport().Data;
                        var loopTo22 = withBlock14.CountWeapon();
                        for (i = 1; i <= loopTo22; i++)
                        {
                            Array.Resize(WData, Information.UBound(WData) + 1 + 1);
                            WData[Information.UBound(WData)] = withBlock14.Weapon(i);
                        }
                    }
                }
            }

            foreach (Item currentItm4 in colItem)
            {
                itm = currentItm4;
                if (itm.Activated)
                {
                    var loopTo23 = itm.CountWeapon();
                    for (i = 1; i <= loopTo23; i++)
                    {
                        Array.Resize(WData, Information.UBound(WData) + 1 + 1);
                        WData[Information.UBound(WData)] = itm.Weapon(i);
                    }
                }
            }

            // 武器属性を更新
            strWeaponClass = new string[(CountWeapon() + 1)];
            var loopTo24 = CountWeapon();
            for (i = 1; i <= loopTo24; i++)
                strWeaponClass[i] = Weapon(i).Class;
            string hidden_attr;
            bool skipped;
            if (IsFeatureAvailable("攻撃属性"))
            {
                var loopTo25 = CountWeapon();
                for (i = 1; i <= loopTo25; i++)
                {
                    {
                        var withBlock15 = Weapon(i);
                        wname = withBlock15.Name;
                        wnickname = WeaponNickname(i);
                        wnskill = withBlock15.NecessarySkill;
                    }

                    wclass = strWeaponClass[i];

                    // 非表示の属性がある場合は一旦抜き出す
                    if (GeneralLib.InStrNotNest(wclass, "|") > 0)
                    {
                        strWeaponClass[i] = Strings.Left(wclass, GeneralLib.InStrNotNest(wclass, "|") - 1);
                        hidden_attr = Strings.Mid(wclass, GeneralLib.InStrNotNest(wclass, "|") + 1);
                    }
                    else
                    {
                        hidden_attr = "";
                    }

                    var loopTo26 = CountFeature();
                    for (j = 1; j <= loopTo26; j++)
                    {
                        if (Feature(j) == "攻撃属性")
                        {
                            fdata = FeatureData(j);

                            // 「"」を除去
                            if (Strings.Left(fdata, 1) == "\"")
                            {
                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
                            }

                            flen = GeneralLib.LLength(fdata);
                            if (flen == 1)
                            {
                                // 武器指定がない場合はすべての武器に属性を付加
                                flag = true;
                                k = 2;
                            }
                            else if (GeneralLib.LIndex(fdata, 1) == "非表示")
                            {
                                // 非表示指定がある場合 (武器指定がある場合を含む)
                                if (flen == 2)
                                {
                                    // 武器指定無し
                                    flag = true;
                                }
                                else
                                {
                                    // 武器指定あり
                                    flag = false;
                                }

                                k = 3;
                            }
                            else
                            {
                                // 武器指定がある場合
                                flag = false;
                                k = 2;
                            }

                            // 武器指定がある場合はそれぞれの指定をチェック
                            false_count = 0;
                            while (k <= flen)
                            {
                                wtype = GeneralLib.LIndex(fdata, k);
                                if (Strings.Left(wtype, 1) == "!")
                                {
                                    wtype = Strings.Mid(wtype, 2);
                                    with_not = true;
                                }
                                else
                                {
                                    with_not = false;
                                }

                                found = false;
                                switch (wtype ?? "")
                                {
                                    case "全":
                                        {
                                            found = true;
                                            break;
                                        }

                                    case "物":
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, "魔") == 0 || GeneralLib.InStrNotNest(wclass, "魔武") > 0 || GeneralLib.InStrNotNest(wclass, "魔突") > 0 || GeneralLib.InStrNotNest(wclass, "魔接") > 0 || GeneralLib.InStrNotNest(wclass, "魔銃") > 0 || GeneralLib.InStrNotNest(wclass, "魔実") > 0)
                                            {
                                                found = true;
                                            }

                                            break;
                                        }

                                    default:
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, wtype) > 0 || (wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                                            {
                                                found = true;
                                            }
                                            else
                                            {
                                                var loopTo27 = GeneralLib.LLength(wnskill);
                                                for (l = 1; l <= loopTo27; l++)
                                                {
                                                    sname = GeneralLib.LIndex(wnskill, l);
                                                    if (Strings.InStr(sname, "Lv") > 0)
                                                    {
                                                        sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
                                                    }

                                                    if ((sname ?? "") == (wtype ?? ""))
                                                    {
                                                        found = true;
                                                        break;
                                                    }
                                                }
                                            }

                                            break;
                                        }
                                }

                                if (with_not)
                                {
                                    // !指定あり
                                    if (found)
                                    {
                                        // 条件を満たした場合は適用しない
                                        flag = false;
                                        false_count = (false_count + 1);
                                    }
                                }
                                else if (found)
                                {
                                    // !指定無しの条件を満たした
                                    flag = true;
                                }
                                else
                                {
                                    // !指定無しの条件を満たさず
                                    false_count = (false_count + 1);
                                }

                                k = (k + 1);
                            }

                            // 属性を追加
                            if (flag || false_count == 0)
                            {
                                buf = GeneralLib.LIndex(fdata, 1);
                                if (buf == "非表示")
                                {
                                    // 非表示の属性の場合
                                    hidden_attr = hidden_attr + GeneralLib.LIndex(fdata, 2);
                                }
                                else
                                {
                                    // 属性が重複しないように付加
                                    skipped = false;
                                    var loopTo28 = Strings.Len(buf);
                                    for (k = 1; k <= loopTo28; k++)
                                    {
                                        ch = GeneralLib.GetClassBundle(buf, k);
                                        if (!Information.IsNumeric(ch) && ch != "L" && ch != ".")
                                        {
                                            skipped = false;
                                        }

                                        if ((GeneralLib.InStrNotNest(strWeaponClass[i], ch) == 0 || Information.IsNumeric(ch) || ch == "L" || ch == ".") && !skipped)
                                        {
                                            if (ch == "魔")
                                            {
                                                // 魔属性を付加する場合は武器を魔法武器化する
                                                l = GeneralLib.InStrNotNest(strWeaponClass[i], "武");
                                                l = GeneralLib.MaxLng(GeneralLib.InStrNotNest(strWeaponClass[i], "突"), l);
                                                l = GeneralLib.MaxLng(GeneralLib.InStrNotNest(strWeaponClass[i], "接"), l);
                                                l = GeneralLib.MaxLng(GeneralLib.InStrNotNest(strWeaponClass[i], "銃"), l);
                                                l = GeneralLib.MaxLng(GeneralLib.InStrNotNest(strWeaponClass[i], "実"), l);
                                                if (l > 0)
                                                {
                                                    strWeaponClass[i] = Strings.Left(strWeaponClass[i], l - 1) + ch + Strings.Mid(strWeaponClass[i], l);
                                                }
                                                else
                                                {
                                                    strWeaponClass[i] = strWeaponClass[i] + ch;
                                                }
                                            }
                                            else
                                            {
                                                strWeaponClass[i] = strWeaponClass[i] + ch;
                                            }
                                        }
                                        else
                                        {
                                            skipped = true;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // 非表示の属性を追加
                    if (Strings.Len(hidden_attr) > 0)
                    {
                        strWeaponClass[i] = strWeaponClass[i] + "|" + hidden_attr;
                    }
                }
            }

            // 武器攻撃力を更新
            lngWeaponPower = new int[(CountWeapon() + 1)];

            // 装備している「Ｖ－ＵＰ=武器」アイテムの個数をカウントしておく
            num = 0;
            if (IsConditionSatisfied("Ｖ－ＵＰ"))
            {
                switch (FeatureData("Ｖ－ＵＰ") ?? "")
                {
                    case "全":
                    case "武器":
                        {
                            num = (num + 1);
                            break;
                        }
                }
            }

            foreach (Item currentItm5 in colItem)
            {
                itm = currentItm5;
                if (itm.Activated)
                {
                    if (itm.IsFeatureAvailable("Ｖ－ＵＰ"))
                    {
                        switch (itm.FeatureData("Ｖ－ＵＰ") ?? "")
                        {
                            case "全":
                            case "武器":
                                {
                                    num = (num + 1);
                                    break;
                                }
                        }
                    }
                }
            }

            if (CountPilot() > 0)
            {
                {
                    var withBlock16 = MainPilot().Data;
                    if (withBlock16.IsFeatureAvailable("Ｖ－ＵＰ"))
                    {
                        switch (withBlock16.FeatureData("Ｖ－ＵＰ") ?? "")
                        {
                            case "全":
                            case "武器":
                                {
                                    num = (num + 1);
                                    break;
                                }
                        }
                    }
                }
            }

            num = (num * Data.ItemNum);
            var loopTo29 = CountWeapon();
            for (i = 1; i <= loopTo29; i++)
            {
                lngWeaponPower[i] = Weapon(i).Power;

                // もともと攻撃力が0の武器は0に固定
                if (lngWeaponPower[i] == 0)
                {
                    goto NextWeapon;
                }

                // 武器強化による修正
                if (IsFeatureAvailable("武器強化"))
                {
                    {
                        var withBlock17 = Weapon(i);
                        wname = withBlock17.Name;
                        wnickname = WeaponNickname(i);
                        wnskill = withBlock17.NecessarySkill;
                    }

                    wclass = strWeaponClass[i];
                    var loopTo30 = CountFeature();
                    for (j = 1; j <= loopTo30; j++)
                    {
                        if (Feature(j) == "武器強化")
                        {
                            fdata = FeatureData(j);

                            // 「"」を除去
                            if (Strings.Left(fdata, 1) == "\"")
                            {
                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
                            }

                            flen = GeneralLib.LLength(fdata);
                            flag = false;

                            // 武器指定がない場合はすべての武器を強化
                            if (flen == 0)
                            {
                                flag = true;
                            }

                            // 武器指定がある場合はそれぞれの指定をチェック
                            false_count = 0;
                            var loopTo31 = flen;
                            for (k = 1; k <= loopTo31; k++)
                            {
                                wtype = GeneralLib.LIndex(fdata, k);
                                if (Strings.Left(wtype, 1) == "!")
                                {
                                    wtype = Strings.Mid(wtype, 2);
                                    with_not = true;
                                }
                                else
                                {
                                    with_not = false;
                                }

                                found = false;
                                if (IsWeaponClassifiedAs(i, "固"))
                                {
                                    // ダメージ固定武器は武器指定が武器名、武器表示名、「固」の
                                    // いずれかで行われた場合にのみ強化
                                    if (wtype == "固" || (wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                                    {
                                        found = true;
                                    }
                                }
                                else
                                {
                                    switch (wtype ?? "")
                                    {
                                        case "全":
                                            {
                                                found = true;
                                                break;
                                            }

                                        case "物":
                                            {
                                                if (GeneralLib.InStrNotNest(wclass, "魔") == 0 || GeneralLib.InStrNotNest(wclass, "魔武") > 0 || GeneralLib.InStrNotNest(wclass, "魔突") > 0 || GeneralLib.InStrNotNest(wclass, "魔接") > 0 || GeneralLib.InStrNotNest(wclass, "魔銃") > 0 || GeneralLib.InStrNotNest(wclass, "魔実") > 0)
                                                {
                                                    found = true;
                                                }

                                                break;
                                            }

                                        default:
                                            {
                                                if (GeneralLib.InStrNotNest(wclass, wtype) > 0 || (wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                                                {
                                                    found = true;
                                                }
                                                else
                                                {
                                                    // 必要技能による指定
                                                    var loopTo32 = GeneralLib.LLength(wnskill);
                                                    for (l = 1; l <= loopTo32; l++)
                                                    {
                                                        sname = GeneralLib.LIndex(wnskill, l);
                                                        if (Strings.InStr(sname, "Lv") > 0)
                                                        {
                                                            sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
                                                        }

                                                        if ((sname ?? "") == (wtype ?? ""))
                                                        {
                                                            found = true;
                                                            break;
                                                        }
                                                    }
                                                }

                                                break;
                                            }
                                    }
                                }

                                if (with_not)
                                {
                                    // !指定あり
                                    if (found)
                                    {
                                        // 条件を満たした場合は適用しない
                                        flag = false;
                                        false_count = (false_count + 1);
                                    }
                                }
                                else if (found)
                                {
                                    // !指定無しの条件を満たした
                                    flag = true;
                                }
                                else
                                {
                                    // !指定無しの条件を満たさず
                                    false_count = (false_count + 1);
                                }
                            }

                            if (flag || false_count == 0)
                            {
                                double localFeatureLevel() { object argIndex1 = j; var ret = FeatureLevel(argIndex1); return ret; }

                                lngWeaponPower[i] = (lngWeaponPower[i] + 100d * localFeatureLevel());
                            }
                        }
                    }
                }

                // ADD START MARGE
                // 武器割合強化による修正
                if (IsFeatureAvailable("武器割合強化"))
                {
                    {
                        var withBlock18 = Weapon(i);
                        wname = withBlock18.Name;
                        wnickname = WeaponNickname(i);
                        wnskill = withBlock18.NecessarySkill;
                    }

                    wclass = strWeaponClass[i];
                    var loopTo33 = CountFeature();
                    for (j = 1; j <= loopTo33; j++)
                    {
                        if (Feature(j) == "武器割合強化")
                        {
                            fdata = FeatureData(j);

                            // 「"」を除去
                            if (Strings.Left(fdata, 1) == "\"")
                            {
                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
                            }

                            flen = GeneralLib.LLength(fdata);
                            flag = false;

                            // 武器指定がない場合はすべての武器を強化
                            if (flen == 0)
                            {
                                flag = true;
                            }

                            // 武器指定がある場合はそれぞれの指定をチェック
                            false_count = 0;
                            var loopTo34 = flen;
                            for (k = 1; k <= loopTo34; k++)
                            {
                                wtype = GeneralLib.LIndex(fdata, k);
                                if (Strings.Left(wtype, 1) == "!")
                                {
                                    wtype = Strings.Mid(wtype, 2);
                                    with_not = true;
                                }
                                else
                                {
                                    with_not = false;
                                }

                                found = false;
                                if (IsWeaponClassifiedAs(i, "固"))
                                {
                                    // ダメージ固定武器は武器指定が武器名、武器表示名、「固」の
                                    // いずれかで行われた場合にのみ強化
                                    if (wtype == "固" || (wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                                    {
                                        found = true;
                                    }
                                }
                                else
                                {
                                    switch (wtype ?? "")
                                    {
                                        case "全":
                                            {
                                                found = true;
                                                break;
                                            }

                                        case "物":
                                            {
                                                if (GeneralLib.InStrNotNest(wclass, "魔") == 0 || GeneralLib.InStrNotNest(wclass, "魔武") > 0 || GeneralLib.InStrNotNest(wclass, "魔突") > 0 || GeneralLib.InStrNotNest(wclass, "魔接") > 0 || GeneralLib.InStrNotNest(wclass, "魔銃") > 0 || GeneralLib.InStrNotNest(wclass, "魔実") > 0)
                                                {
                                                    found = true;
                                                }

                                                break;
                                            }

                                        default:
                                            {
                                                if (GeneralLib.InStrNotNest(wclass, wtype) > 0 || (wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                                                {
                                                    found = true;
                                                }
                                                else
                                                {
                                                    // 必要技能による指定
                                                    var loopTo35 = GeneralLib.LLength(wnskill);
                                                    for (l = 1; l <= loopTo35; l++)
                                                    {
                                                        sname = GeneralLib.LIndex(wnskill, l);
                                                        if (Strings.InStr(sname, "Lv") > 0)
                                                        {
                                                            sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
                                                        }

                                                        if ((sname ?? "") == (wtype ?? ""))
                                                        {
                                                            found = true;
                                                            break;
                                                        }
                                                    }
                                                }

                                                break;
                                            }
                                    }
                                }

                                if (with_not)
                                {
                                    // !指定あり
                                    if (found)
                                    {
                                        // 条件を満たした場合は適用しない
                                        flag = false;
                                        false_count = (false_count + 1);
                                    }
                                }
                                else if (found)
                                {
                                    // !指定無しの条件を満たした
                                    flag = true;
                                }
                                else
                                {
                                    // !指定無しの条件を満たさず
                                    false_count = (false_count + 1);
                                }
                            }

                            if (flag || false_count == 0)
                            {
                                double localFeatureLevel1() { object argIndex1 = j; var ret = FeatureLevel(argIndex1); return ret; }

                                lngWeaponPower[i] = (lngWeaponPower[i] + (long)(this.Weapon(i).Power * localFeatureLevel1()) / 20L);
                            }
                        }
                    }
                }
                // ADD END MARGE

                // ダメージ固定武器
                if (IsWeaponClassifiedAs(i, "固"))
                {
                    goto NextWeapon;
                }

                if (IsWeaponClassifiedAs(i, "Ｒ"))
                {
                    // 低成長型の攻撃
                    if (IsWeaponLevelSpecified(i, "Ｒ"))
                    {
                        // レベル設定されている場合、増加量をレベル×１０×ランクにする
                        lngWeaponPower[i] = (lngWeaponPower[i] + 10d * WeaponLevel(i, "Ｒ") * (Rank + num));
                        // オ・シ・超と併用した場合
                        if (IsWeaponClassifiedAs(i, "オ") || IsWeaponClassifiedAs(i, "超") || IsWeaponClassifiedAs(i, "シ"))
                        {
                            lngWeaponPower[i] = (lngWeaponPower[i] + 10d * (10d - WeaponLevel(i, "Ｒ")) * (Rank + num));

                            // オーラ技
                            if (IsWeaponClassifiedAs(i, "オ"))
                            {
                                lngWeaponPower[i] = (lngWeaponPower[i] + 10d * WeaponLevel(i, "Ｒ") * AuraLevel());
                            }

                            // サイキック攻撃
                            if (IsWeaponClassifiedAs(i, "超"))
                            {
                                lngWeaponPower[i] = (lngWeaponPower[i] + 10d * WeaponLevel(i, "Ｒ") * PsychicLevel());
                            }

                            // 同調率対象攻撃
                            if (IsWeaponClassifiedAs(i, "シ"))
                            {
                                if (CountPilot() > 0)
                                {
                                    if (MainPilot().SynchroRate() > 0)
                                    {
                                        lngWeaponPower[i] = (lngWeaponPower[i] + (long)(15d * WeaponLevel(i, "Ｒ") * (SyncLevel() - 50d)) / 10L);
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // レベル指定されていない場合は今までどおりランク×５０
                        lngWeaponPower[i] = lngWeaponPower[i] + 50 * (Rank + num);

                        // オ・シ・超と併用した場合
                        if (IsWeaponClassifiedAs(i, "オ") || IsWeaponClassifiedAs(i, "超") || IsWeaponClassifiedAs(i, "シ"))
                        {
                            lngWeaponPower[i] = lngWeaponPower[i] + 50 * (Rank + num);

                            // オーラ技
                            if (IsWeaponClassifiedAs(i, "オ"))
                            {
                                lngWeaponPower[i] = (lngWeaponPower[i] + 50d * AuraLevel());
                            }

                            // サイキック攻撃
                            if (IsWeaponClassifiedAs(i, "超"))
                            {
                                lngWeaponPower[i] = (lngWeaponPower[i] + 50d * PsychicLevel());
                            }

                            // 同調率対象攻撃
                            if (IsWeaponClassifiedAs(i, "シ"))
                            {
                                if (CountPilot() > 0)
                                {
                                    if (MainPilot().SynchroRate() > 0)
                                    {
                                        lngWeaponPower[i] = (lngWeaponPower[i] + (long)(15d * (SyncLevel() - 50d)) / 2L);
                                    }
                                }
                            }
                        }
                    }
                }
                else if (IsWeaponClassifiedAs(i, "改"))
                {
                    // 改属性＝オ・超・シ属性を無視したＲ属性
                    if (IsWeaponLevelSpecified(i, "改"))
                    {
                        // レベル設定されている場合、増加量をレベル×１０×ランクにする
                        lngWeaponPower[i] = (lngWeaponPower[i] + 10d * WeaponLevel(i, "改") * (Rank + num));
                    }
                    else
                    {
                        // レベル指定がない場合、増加量は５０×ランク
                        lngWeaponPower[i] = lngWeaponPower[i] + 50 * (Rank + num);
                    }

                    // オーラ技
                    if (IsWeaponClassifiedAs(i, "オ"))
                    {
                        lngWeaponPower[i] = (lngWeaponPower[i] + 100d * AuraLevel());
                    }

                    // サイキック攻撃
                    if (IsWeaponClassifiedAs(i, "超"))
                    {
                        lngWeaponPower[i] = (lngWeaponPower[i] + 100d * PsychicLevel());
                    }

                    // 同調率対象攻撃
                    if (IsWeaponClassifiedAs(i, "シ"))
                    {
                        if (CountPilot() > 0)
                        {
                            if (MainPilot().SynchroRate() > 0)
                            {
                                lngWeaponPower[i] = (lngWeaponPower[i] + 15d * (SyncLevel() - 50d));
                            }
                        }
                    }
                }
                else
                {
                    // Ｒ、改属性が両方ともない場合
                    lngWeaponPower[i] = lngWeaponPower[i] + 100 * (Rank + num);

                    // オーラ技
                    if (IsWeaponClassifiedAs(i, "オ"))
                    {
                        lngWeaponPower[i] = (lngWeaponPower[i] + 100d * AuraLevel());
                    }

                    // サイキック攻撃
                    if (IsWeaponClassifiedAs(i, "超"))
                    {
                        lngWeaponPower[i] = (lngWeaponPower[i] + 100d * PsychicLevel());
                    }

                    // 同調率対象攻撃
                    if (IsWeaponClassifiedAs(i, "シ"))
                    {
                        if (CountPilot() > 0)
                        {
                            if (MainPilot().SynchroRate() > 0)
                            {
                                lngWeaponPower[i] = (lngWeaponPower[i] + 15d * (SyncLevel() - 50d));
                            }
                        }
                    }
                }

                // ボスランクによる修正
                if (BossRank > 0)
                {
                    lngWeaponPower[i] = lngWeaponPower[i] + GeneralLib.MinLng(100 * BossRank, 300);
                }

                // 攻撃力の最高値は99999
                if (lngWeaponPower[i] > 99999)
                {
                    lngWeaponPower[i] = 99999;
                }

                // 最低値は1
                if (lngWeaponPower[i] <= 0)
                {
                    lngWeaponPower[i] = 1;
                }

                NextWeapon:
                ;
            }

            // 武器射程を更新
            intWeaponMaxRange = new int[(CountWeapon() + 1)];
            var loopTo36 = CountWeapon();
            for (i = 1; i <= loopTo36; i++)
            {
                intWeaponMaxRange[i] = Weapon(i).MaxRange;

                // 最大射程がもともと１ならそれ以上変化しない
                if (intWeaponMaxRange[i] == 1)
                {
                    goto NextWeapon2;
                }

                // 思念誘導攻撃のＮＴ能力による射程延長
                if (GeneralLib.InStrNotNest(strWeaponClass[i], "サ") > 0)
                {
                    if (CountPilot() > 0)
                    {
                        {
                            var withBlock19 = MainPilot();
                            intWeaponMaxRange[i] = (intWeaponMaxRange[i] + (long)withBlock19.SkillLevel("超感覚", ref_mode: "") / 4L + (long)withBlock19.SkillLevel("知覚強化", ref_mode: "") / 4L);
                        }
                    }
                }

                // マップ攻撃には適用されない
                if (GeneralLib.InStrNotNest(strWeaponClass[i], "Ｍ") > 0)
                {
                    goto NextWeapon2;
                }

                // 接近戦武器には適用されない
                if (GeneralLib.InStrNotNest(strWeaponClass[i], "武") > 0 || GeneralLib.InStrNotNest(strWeaponClass[i], "突") > 0 || GeneralLib.InStrNotNest(strWeaponClass[i], "接") > 0)
                {
                    goto NextWeapon2;
                }

                // 有線式誘導攻撃には適用されない
                if (GeneralLib.InStrNotNest(strWeaponClass[i], "有") > 0)
                {
                    goto NextWeapon2;
                }

                // 射程延長による修正
                if (IsFeatureAvailable("射程延長"))
                {
                    {
                        var withBlock20 = Weapon(i);
                        wname = withBlock20.Name;
                        wnickname = WeaponNickname(i);
                        wnskill = withBlock20.NecessarySkill;
                    }

                    wclass = strWeaponClass[i];
                    var loopTo37 = CountFeature();
                    for (j = 1; j <= loopTo37; j++)
                    {
                        if (Feature(j) == "射程延長")
                        {
                            fdata = FeatureData(j);

                            // 「"」を除去
                            if (Strings.Left(fdata, 1) == "\"")
                            {
                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
                            }

                            flen = GeneralLib.LLength(fdata);
                            flag = false;

                            // 武器指定がない場合はすべての武器を強化
                            if (flen == 0)
                            {
                                flag = true;
                            }

                            // 武器指定がある場合はそれぞれの指定をチェック
                            false_count = 0;
                            var loopTo38 = flen;
                            for (k = 1; k <= loopTo38; k++)
                            {
                                wtype = GeneralLib.LIndex(fdata, k);
                                if (Strings.Left(wtype, 1) == "!")
                                {
                                    wtype = Strings.Mid(wtype, 2);
                                    with_not = true;
                                }
                                else
                                {
                                    with_not = false;
                                }

                                found = false;
                                switch (wtype ?? "")
                                {
                                    case "全":
                                        {
                                            found = true;
                                            break;
                                        }

                                    case "物":
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, "魔") == 0 || GeneralLib.InStrNotNest(wclass, "魔武") > 0 || GeneralLib.InStrNotNest(wclass, "魔突") > 0 || GeneralLib.InStrNotNest(wclass, "魔接") > 0 || GeneralLib.InStrNotNest(wclass, "魔銃") > 0 || GeneralLib.InStrNotNest(wclass, "魔実") > 0)
                                            {
                                                found = true;
                                            }

                                            break;
                                        }

                                    default:
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, wtype) > 0 || (wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                                            {
                                                found = true;
                                            }
                                            else
                                            {
                                                var loopTo39 = GeneralLib.LLength(wnskill);
                                                for (l = 1; l <= loopTo39; l++)
                                                {
                                                    sname = GeneralLib.LIndex(wnskill, l);
                                                    if (Strings.InStr(sname, "Lv") > 0)
                                                    {
                                                        sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
                                                    }

                                                    if ((sname ?? "") == (wtype ?? ""))
                                                    {
                                                        found = true;
                                                        break;
                                                    }
                                                }
                                            }

                                            break;
                                        }
                                }

                                if (with_not)
                                {
                                    // !指定あり
                                    if (found)
                                    {
                                        // 条件を満たした場合は適用しない
                                        flag = false;
                                        false_count = (false_count + 1);
                                    }
                                }
                                else if (found)
                                {
                                    // !指定無しの条件を満たした
                                    flag = true;
                                }
                                else
                                {
                                    // !指定無しの条件を満たさず
                                    false_count = (false_count + 1);
                                }
                            }

                            if (flag || false_count == 0)
                            {
                                double localFeatureLevel2() { object argIndex1 = j; var ret = FeatureLevel(argIndex1); return ret; }

                                intWeaponMaxRange[i] = (intWeaponMaxRange[i] + localFeatureLevel2());
                            }
                        }
                    }
                }

                // 最低値は1
                if (intWeaponMaxRange[i] <= 0)
                {
                    intWeaponMaxRange[i] = 1;
                }

                NextWeapon2:
                ;
            }

            // 武器命中率を更新
            intWeaponPrecision = new int[(CountWeapon() + 1)];
            var loopTo40 = CountWeapon();
            for (i = 1; i <= loopTo40; i++)
            {
                intWeaponPrecision[i] = Weapon(i).Precision;

                // 武器強化による修正
                if (IsFeatureAvailable("命中率強化"))
                {
                    {
                        var withBlock21 = Weapon(i);
                        wname = withBlock21.Name;
                        wnickname = WeaponNickname(i);
                        wnskill = withBlock21.NecessarySkill;
                    }

                    wclass = strWeaponClass[i];
                    var loopTo41 = CountFeature();
                    for (j = 1; j <= loopTo41; j++)
                    {
                        if (Feature(j) == "命中率強化")
                        {
                            fdata = FeatureData(j);

                            // 「"」を除去
                            if (Strings.Left(fdata, 1) == "\"")
                            {
                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
                            }

                            flen = GeneralLib.LLength(fdata);
                            flag = false;

                            // 武器指定がない場合はすべての武器を強化
                            if (flen == 0)
                            {
                                flag = true;
                            }

                            // 武器指定がある場合はそれぞれの指定をチェック
                            false_count = 0;
                            var loopTo42 = flen;
                            for (k = 1; k <= loopTo42; k++)
                            {
                                wtype = GeneralLib.LIndex(fdata, k);
                                if (Strings.Left(wtype, 1) == "!")
                                {
                                    wtype = Strings.Mid(wtype, 2);
                                    with_not = true;
                                }
                                else
                                {
                                    with_not = false;
                                }

                                found = false;
                                switch (wtype ?? "")
                                {
                                    case "全":
                                        {
                                            found = true;
                                            break;
                                        }

                                    case "物":
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, "魔") == 0 || GeneralLib.InStrNotNest(wclass, "魔武") > 0 || GeneralLib.InStrNotNest(wclass, "魔突") > 0 || GeneralLib.InStrNotNest(wclass, "魔接") > 0 || GeneralLib.InStrNotNest(wclass, "魔銃") > 0 || GeneralLib.InStrNotNest(wclass, "魔実") > 0)
                                            {
                                                found = true;
                                            }

                                            break;
                                        }

                                    default:
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, wtype) > 0 || (wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                                            {
                                                found = true;
                                            }
                                            else
                                            {
                                                var loopTo43 = GeneralLib.LLength(wnskill);
                                                for (l = 1; l <= loopTo43; l++)
                                                {
                                                    sname = GeneralLib.LIndex(wnskill, l);
                                                    if (Strings.InStr(sname, "Lv") > 0)
                                                    {
                                                        sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
                                                    }

                                                    if ((sname ?? "") == (wtype ?? ""))
                                                    {
                                                        found = true;
                                                        break;
                                                    }
                                                }
                                            }

                                            break;
                                        }
                                }

                                if (with_not)
                                {
                                    // !指定あり
                                    if (found)
                                    {
                                        // 条件を満たした場合は適用しない
                                        flag = false;
                                        false_count = (false_count + 1);
                                    }
                                }
                                else if (found)
                                {
                                    // !指定無しの条件を満たした
                                    flag = true;
                                }
                                else
                                {
                                    // !指定無しの条件を満たさず
                                    false_count = (false_count + 1);
                                }
                            }

                            if (flag || false_count == 0)
                            {
                                double localFeatureLevel3() { object argIndex1 = j; var ret = FeatureLevel(argIndex1); return ret; }

                                intWeaponPrecision[i] = (intWeaponPrecision[i] + 5d * localFeatureLevel3());
                            }
                        }
                    }
                }
            }

            // 武器のＣＴ率を更新
            intWeaponCritical = new int[(CountWeapon() + 1)];
            var loopTo44 = CountWeapon();
            for (i = 1; i <= loopTo44; i++)
            {
                intWeaponCritical[i] = Weapon(i).Critical;

                // ＣＴ率強化による修正
                if (IsFeatureAvailable("ＣＴ率強化") && IsNormalWeapon(i))
                {
                    {
                        var withBlock22 = Weapon(i);
                        wname = withBlock22.Name;
                        wnickname = WeaponNickname(i);
                        wnskill = withBlock22.NecessarySkill;
                    }

                    wclass = strWeaponClass[i];
                    var loopTo45 = CountFeature();
                    for (j = 1; j <= loopTo45; j++)
                    {
                        if (Feature(j) == "ＣＴ率強化")
                        {
                            fdata = FeatureData(j);

                            // 「"」を除去
                            if (Strings.Left(fdata, 1) == "\"")
                            {
                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
                            }

                            flen = GeneralLib.LLength(fdata);
                            flag = false;

                            // 武器指定がない場合はすべての武器を強化
                            if (flen == 0)
                            {
                                flag = true;
                            }

                            // 武器指定がある場合はそれぞれの指定をチェック
                            false_count = 0;
                            var loopTo46 = flen;
                            for (k = 1; k <= loopTo46; k++)
                            {
                                wtype = GeneralLib.LIndex(fdata, k);
                                if (Strings.Left(wtype, 1) == "!")
                                {
                                    wtype = Strings.Mid(wtype, 2);
                                    with_not = true;
                                }
                                else
                                {
                                    with_not = false;
                                }

                                found = false;
                                switch (wtype ?? "")
                                {
                                    case "全":
                                        {
                                            found = true;
                                            break;
                                        }

                                    case "物":
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, "魔") == 0 || GeneralLib.InStrNotNest(wclass, "魔武") > 0 || GeneralLib.InStrNotNest(wclass, "魔突") > 0 || GeneralLib.InStrNotNest(wclass, "魔接") > 0 || GeneralLib.InStrNotNest(wclass, "魔銃") > 0 || GeneralLib.InStrNotNest(wclass, "魔実") > 0)
                                            {
                                                found = !with_not;
                                            }

                                            break;
                                        }

                                    default:
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, wtype) > 0 || (wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                                            {
                                                found = true;
                                            }
                                            else
                                            {
                                                var loopTo47 = GeneralLib.LLength(wnskill);
                                                for (l = 1; l <= loopTo47; l++)
                                                {
                                                    sname = GeneralLib.LIndex(wnskill, l);
                                                    if (Strings.InStr(sname, "Lv") > 0)
                                                    {
                                                        sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
                                                    }

                                                    if ((sname ?? "") == (wtype ?? ""))
                                                    {
                                                        found = true;
                                                        break;
                                                    }
                                                }
                                            }

                                            break;
                                        }
                                }

                                if (with_not)
                                {
                                    // !指定あり
                                    if (found)
                                    {
                                        // 条件を満たした場合は適用しない
                                        flag = false;
                                        false_count = (false_count + 1);
                                    }
                                }
                                else if (found)
                                {
                                    // !指定無しの条件を満たした
                                    flag = true;
                                }
                                else
                                {
                                    // !指定無しの条件を満たさず
                                    false_count = (false_count + 1);
                                }
                            }

                            if (flag || false_count == 0)
                            {
                                double localFeatureLevel4() { object argIndex1 = j; var ret = FeatureLevel(argIndex1); return ret; }

                                intWeaponCritical[i] = (intWeaponCritical[i] + 5d * localFeatureLevel4());
                            }
                        }
                    }
                }

                // 特殊効果発動率強化による修正
                if (IsFeatureAvailable("特殊効果発動率強化") && !IsNormalWeapon(i))
                {
                    {
                        var withBlock23 = Weapon(i);
                        wname = withBlock23.Name;
                        wnickname = WeaponNickname(i);
                        wnskill = withBlock23.NecessarySkill;
                    }

                    wclass = strWeaponClass[i];
                    var loopTo48 = CountFeature();
                    for (j = 1; j <= loopTo48; j++)
                    {
                        if (Feature(j) == "特殊効果発動率強化")
                        {
                            fdata = FeatureData(j);

                            // 「"」を除去
                            if (Strings.Left(fdata, 1) == "\"")
                            {
                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
                            }

                            flen = GeneralLib.LLength(fdata);
                            flag = false;

                            // 武器指定がない場合はすべての武器を強化
                            if (flen == 0)
                            {
                                flag = true;
                            }

                            // 武器指定がある場合はそれぞれの指定をチェック
                            false_count = 0;
                            var loopTo49 = flen;
                            for (k = 1; k <= loopTo49; k++)
                            {
                                wtype = GeneralLib.LIndex(fdata, k);
                                if (Strings.Left(wtype, 1) == "!")
                                {
                                    wtype = Strings.Mid(wtype, 2);
                                    with_not = true;
                                }
                                else
                                {
                                    with_not = false;
                                }

                                found = false;
                                switch (wtype ?? "")
                                {
                                    case "全":
                                        {
                                            found = true;
                                            break;
                                        }

                                    case "物":
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, "魔") == 0 || GeneralLib.InStrNotNest(wclass, "魔武") > 0 || GeneralLib.InStrNotNest(wclass, "魔突") > 0 || GeneralLib.InStrNotNest(wclass, "魔接") > 0 || GeneralLib.InStrNotNest(wclass, "魔銃") > 0 || GeneralLib.InStrNotNest(wclass, "魔実") > 0)
                                            {
                                                found = true;
                                            }

                                            break;
                                        }

                                    default:
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, wtype) > 0 || (wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                                            {
                                                found = true;
                                            }
                                            else
                                            {
                                                var loopTo50 = GeneralLib.LLength(wnskill);
                                                for (l = 1; l <= loopTo50; l++)
                                                {
                                                    buf = GeneralLib.LIndex(wnskill, l);
                                                    if (Strings.InStr(buf, "Lv") > 0)
                                                    {
                                                        buf = Strings.Left(buf, Strings.InStr(buf, "Lv") - 1);
                                                    }

                                                    if ((buf ?? "") == (wtype ?? ""))
                                                    {
                                                        found = true;
                                                        break;
                                                    }
                                                }
                                            }

                                            break;
                                        }
                                }

                                if (with_not)
                                {
                                    // !指定あり
                                    if (found)
                                    {
                                        // 条件を満たした場合は適用しない
                                        flag = false;
                                        false_count = (false_count + 1);
                                    }
                                }
                                else if (found)
                                {
                                    // !指定無しの条件を満たした
                                    flag = true;
                                }
                                else
                                {
                                    // !指定無しの条件を満たさず
                                    false_count = (false_count + 1);
                                }
                            }

                            if (flag || false_count == 0)
                            {
                                double localFeatureLevel5() { object argIndex1 = j; var ret = FeatureLevel(argIndex1); return ret; }

                                intWeaponCritical[i] = (intWeaponCritical[i] + 5d * localFeatureLevel5());
                            }
                        }
                    }
                }
            }

            // 最大弾数を更新
            intMaxBullet = new int[(CountWeapon() + 1)];
            // UPGRADE_NOTE: rate は rate にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
            double rate;
            var loopTo51 = CountWeapon();
            for (i = 1; i <= loopTo51; i++)
            {
                intMaxBullet[i] = Weapon(i).Bullet;

                // 最大弾数の増加率
                rate = 0d;

                // ボスランクによる修正
                if (intBossRank > 0)
                {
                    rate = 0.2d * BossRank;
                }

                // 最大弾数増加による修正
                if (IsFeatureAvailable("最大弾数増加"))
                {
                    {
                        var withBlock24 = Weapon(i);
                        wname = withBlock24.Name;
                        wnickname = WeaponNickname(i);
                        wnskill = withBlock24.NecessarySkill;
                    }

                    wclass = strWeaponClass[i];
                    var loopTo52 = CountFeature();
                    for (j = 1; j <= loopTo52; j++)
                    {
                        if (Feature(j) == "最大弾数増加")
                        {
                            fdata = FeatureData(j);

                            // 「"」を除去
                            if (Strings.Left(fdata, 1) == "\"")
                            {
                                fdata = Strings.Mid(fdata, 2, Strings.Len(fdata) - 2);
                            }

                            flen = GeneralLib.LLength(fdata);
                            flag = false;

                            // 武器指定がない場合はすべての武器の弾数を増加
                            if (flen == 0)
                            {
                                flag = true;
                            }

                            // 武器指定がある場合はそれぞれの指定をチェック
                            false_count = 0;
                            var loopTo53 = flen;
                            for (k = 1; k <= loopTo53; k++)
                            {
                                wtype = GeneralLib.LIndex(fdata, k);
                                if (Strings.Left(wtype, 1) == "!")
                                {
                                    wtype = Strings.Mid(wtype, 2);
                                    with_not = true;
                                }
                                else
                                {
                                    with_not = false;
                                }

                                found = false;
                                switch (wtype ?? "")
                                {
                                    case "全":
                                        {
                                            found = true;
                                            break;
                                        }

                                    case "物":
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, "魔") == 0 || GeneralLib.InStrNotNest(wclass, "魔武") > 0 || GeneralLib.InStrNotNest(wclass, "魔突") > 0 || GeneralLib.InStrNotNest(wclass, "魔接") > 0 || GeneralLib.InStrNotNest(wclass, "魔銃") > 0 || GeneralLib.InStrNotNest(wclass, "魔実") > 0)
                                            {
                                                found = true;
                                            }

                                            break;
                                        }

                                    default:
                                        {
                                            if (GeneralLib.InStrNotNest(wclass, wtype) > 0 || (wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                                            {
                                                found = true;
                                            }
                                            else
                                            {
                                                var loopTo54 = GeneralLib.LLength(wnskill);
                                                for (l = 1; l <= loopTo54; l++)
                                                {
                                                    sname = GeneralLib.LIndex(wnskill, l);
                                                    if (Strings.InStr(sname, "Lv") > 0)
                                                    {
                                                        sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
                                                    }

                                                    if ((sname ?? "") == (wtype ?? ""))
                                                    {
                                                        found = true;
                                                        break;
                                                    }
                                                }
                                            }

                                            break;
                                        }
                                }

                                if (with_not)
                                {
                                    // !指定あり
                                    if (found)
                                    {
                                        // 条件を満たした場合は適用しない
                                        flag = false;
                                        false_count = (false_count + 1);
                                    }
                                }
                                else if (found)
                                {
                                    // !指定無しの条件を満たした
                                    flag = true;
                                }
                                else
                                {
                                    // !指定無しの条件を満たさず
                                    false_count = (false_count + 1);
                                }
                            }

                            if (flag || false_count == 0)
                            {
                                double localFeatureLevel6() { object argIndex1 = j; var ret = FeatureLevel(argIndex1); return ret; }

                                rate = rate + 0.5d * localFeatureLevel6();
                            }
                        }
                    }
                }

                // 増加率に合わせて弾数を修正
                intMaxBullet[i] = ((1d + rate) * intMaxBullet[i]);

                // 最大値は99
                if (intMaxBullet[i] > 99)
                {
                    intMaxBullet[i] = 99;
                }
                // 最低値は0
                if (intMaxBullet[i] < 0)
                {
                    intMaxBullet[i] = 0;
                }
            }

            // 弾数を更新
            Array.Resize(dblBullet, CountWeapon() + 1);
            flags = new bool[Information.UBound(prev_wdata) + 1];
            var loopTo55 = CountWeapon();
            for (i = 1; i <= loopTo55; i++)
            {
                dblBullet[i] = 1d;
                var loopTo56 = Information.UBound(prev_wdata);
                for (j = 1; j <= loopTo56; j++)
                {
                    if (ReferenceEquals(WData[i], prev_wdata[j]) && !flags[j])
                    {
                        dblBullet[i] = prev_wbullets[j];
                        flags[j] = true;
                        break;
                    }
                }
            }

            // アビリティデータを更新
            prev_adata = new AbilityData[Information.UBound(adata) + 1];
            prev_astocks = new double[Information.UBound(adata) + 1];
            var loopTo57 = Information.UBound(adata);
            for (i = 1; i <= loopTo57; i++)
            {
                prev_adata[i] = adata[i];
                prev_astocks[i] = dblStock[i];
            }

            {
                var withBlock25 = Data;
                adata = new AbilityData[(withBlock25.CountAbility() + 1)];
                var loopTo58 = withBlock25.CountAbility();
                for (i = 1; i <= loopTo58; i++)
                {
                    adata[i] = withBlock25.Ability(i);
                }
            }

            if (CountPilot() > 0)
            {
                {
                    var withBlock26 = MainPilot().Data;
                    var loopTo59 = withBlock26.CountAbility();
                    for (i = 1; i <= loopTo59; i++)
                    {
                        Array.Resize(adata, Information.UBound(adata) + 1 + 1);
                        adata[Information.UBound(adata)] = withBlock26.Ability(i);
                    }
                }

                var loopTo60 = CountPilot();
                for (i = 2; i <= loopTo60; i++)
                {
                    Pilot localPilot3() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    {
                        var withBlock27 = localPilot3().Data;
                        var loopTo61 = withBlock27.CountAbility();
                        for (j = 1; j <= loopTo61; j++)
                        {
                            Array.Resize(adata, Information.UBound(adata) + 1 + 1);
                            adata[Information.UBound(adata)] = withBlock27.Ability(j);
                        }
                    }
                }

                var loopTo62 = CountSupport();
                for (i = 1; i <= loopTo62; i++)
                {
                    Pilot localSupport3() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    {
                        var withBlock28 = localSupport3().Data;
                        var loopTo63 = withBlock28.CountAbility();
                        for (j = 1; j <= loopTo63; j++)
                        {
                            Array.Resize(adata, Information.UBound(adata) + 1 + 1);
                            adata[Information.UBound(adata)] = withBlock28.Ability(j);
                        }
                    }
                }

                if (IsFeatureAvailable("追加サポート"))
                {
                    {
                        var withBlock29 = AdditionalSupport().Data;
                        var loopTo64 = withBlock29.CountAbility();
                        for (i = 1; i <= loopTo64; i++)
                        {
                            Array.Resize(adata, Information.UBound(adata) + 1 + 1);
                            adata[Information.UBound(adata)] = withBlock29.Ability(i);
                        }
                    }
                }
            }

            foreach (Item currentItm6 in colItem)
            {
                itm = currentItm6;
                if (itm.Activated)
                {
                    var loopTo65 = itm.CountAbility();
                    for (i = 1; i <= loopTo65; i++)
                    {
                        Array.Resize(adata, Information.UBound(adata) + 1 + 1);
                        adata[Information.UBound(adata)] = itm.Ability(i);
                    }
                }
            }

            // 使用回数を更新
            Array.Resize(dblStock, CountAbility() + 1);
            flags = new bool[Information.UBound(prev_adata) + 1];
            var loopTo66 = CountAbility();
            for (i = 1; i <= loopTo66; i++)
            {
                dblStock[i] = 1d;
                var loopTo67 = Information.UBound(prev_adata);
                for (j = 1; j <= loopTo67; j++)
                {
                    if (ReferenceEquals(adata[i], prev_adata[j]) && !flags[j])
                    {
                        dblStock[i] = prev_astocks[j];
                        flags[j] = true;
                        break;
                    }
                }
            }

            if (Status != "出撃")
            {
                return;
            }

            // 制御不能？
            if (IsFeatureAvailable("制御不可"))
            {
                if (!is_uncontrollable)
                {
                    AddCondition("暴走", -1, cdata: "");
                }
            }
            else if (is_uncontrollable)
            {
                if (IsConditionSatisfied("暴走"))
                {
                    DeleteCondition("暴走");
                }
            }

            // 不安定？
            if (IsFeatureAvailable("不安定"))
            {
                if (!is_stable)
                {
                    if (HP <= MaxHP / 4)
                    {
                        AddCondition("暴走", -1, cdata: "");
                    }
                }
            }
            else if (is_stable)
            {
                if (IsConditionSatisfied("暴走"))
                {
                    DeleteCondition("暴走");
                }
            }
        }

        // 特殊能力を登録
        private void AddFeatures(Collection fdc, bool is_item = false)
        {
            if (fdc is null)
            {
                return;
            }

            foreach (FeatureData fd in fdc)
            {
                // アイテムで指定された下記の能力はアイテムそのものの属性なので
                // ユニット側には追加しない
                if (is_item)
                {
                    switch (fd.Name ?? "")
                    {
                        case "必要技能":
                        case "不必要技能":
                        case "表示":
                        case "非表示":
                        case "呪い":
                            {
                                goto NextFeature;
                                break;
                            }
                    }
                }

                // 封印されている？
                bool localIsDisabled() { string argfname = GeneralLib.LIndex(fd.StrData, 1); var ret = IsDisabled(argfname); return ret; }

                if (IsDisabled(fd.Name) || localIsDisabled())
                {
                    goto NextFeature;
                }

                // 既にその能力が登録されている？
                if (!IsFeatureRegistered(fd.Name))
                {
                    colFeature.Add(fd, fd.Name);
                }
                else
                {
                    colFeature.Add(fd, fd.Name + ":" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(colFeature.Count));
                }

                NextFeature:
                ;
            }
        }

        // 特殊能力を登録済み？
        private bool IsFeatureRegistered(string fname)
        {
            bool IsFeatureRegisteredRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 107792


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colFeature[fname];
            IsFeatureRegisteredRet = true;
            return IsFeatureRegisteredRet;
            ErrorHandler:
            ;
            IsFeatureRegisteredRet = false;
        }

        // 特殊能力を登録済み？(必要条件を満たさない特殊能力を含む)
        private bool IsAllFeatureRegistered(string fname)
        {
            bool IsAllFeatureRegisteredRet = default;
            FeatureData fd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 108130


            Input:

                    On Error GoTo ErrorHandler

             */
            fd = (FeatureData)colAllFeature[fname];
            IsAllFeatureRegisteredRet = true;
            return IsAllFeatureRegisteredRet;
            ErrorHandler:
            ;
            IsAllFeatureRegisteredRet = false;
        }

        // 特殊能力が必要条件を満たしているかどうか判定し、満たしていない能力を削除する
        // fnameが指定された場合、指定された特殊能力に対してのみ必要技能を判定
        private void UpdateFeatures(string fname = "")
        {
            FeatureData fd;
            FeatureData[] farray;
            int i;
            bool found;
            if (!string.IsNullOrEmpty(fname))
            {
                // 必要技能＆条件を満たしてない特殊能力を削除。
                found = false;
                i = 1;
                {
                    var withBlock = colFeature;
                    while (i <= withBlock.Count)
                    {
                        // 必要技能を満たしている？
                        // UPGRADE_WARNING: オブジェクト colFeature.Item(i).Name の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                        if (Conversions.ToBoolean(Operators.ConditionalCompareObjectEqual(fname, withBlock[i].Name, false)))
                        {
                            // UPGRADE_WARNING: オブジェクト colFeature.Item().NecessaryCondition の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                            // UPGRADE_WARNING: オブジェクト colFeature.Item().NecessarySkill の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                            bool localIsNecessarySkillSatisfied() { string argnabilities = Conversions.ToString(withBlock[i].NecessarySkill); Pilot argp = null; var ret = IsNecessarySkillSatisfied(argnabilities, p: argp); return ret; }

                            bool localIsNecessarySkillSatisfied1() { string argnabilities = Conversions.ToString(withBlock[i].NecessaryCondition); Pilot argp = null; var ret = IsNecessarySkillSatisfied(argnabilities, p: argp); return ret; }

                            if (!localIsNecessarySkillSatisfied() || !localIsNecessarySkillSatisfied1())
                            {
                                // 必要技能＆条件を満たしていないので削除
                                withBlock.Remove(i);
                                found = true;
                            }
                            else
                            {
                                i = (i + 1);
                            }
                        }
                        else
                        {
                            i = (i + 1);
                        }
                    }
                }
            }
            else
            {
                // 必要技能を満たしてない特殊能力を削除。
                found = false;
                i = 1;
                {
                    var withBlock1 = colFeature;
                    while (i <= withBlock1.Count)
                    {
                        // 必要技能を満たしている？
                        // UPGRADE_WARNING: オブジェクト colFeature.Item().NecessarySkill の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                        bool localIsNecessarySkillSatisfied2() { string argnabilities = Conversions.ToString(withBlock1[i].NecessarySkill); Pilot argp = null; var ret = IsNecessarySkillSatisfied(argnabilities, p: argp); return ret; }

                        if (!localIsNecessarySkillSatisfied2())
                        {
                            // 必要技能を満たしていないので削除
                            withBlock1.Remove(i);
                            found = true;
                        }
                        else
                        {
                            i = (i + 1);
                        }
                    }
                }

                // 必要条件を適用する前の特殊能力を保存
                {
                    var withBlock2 = colAllFeature;
                    foreach (FeatureData currentFd in colAllFeature)
                    {
                        fd = currentFd;
                        withBlock2.Remove(1);
                    }

                    foreach (FeatureData currentFd1 in colFeature)
                    {
                        fd = currentFd1;
                        if (!IsAllFeatureRegistered(fd.Name))
                        {
                            withBlock2.Add(fd, fd.Name);
                        }
                        else
                        {
                            withBlock2.Add(fd, fd.Name + ":" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock2.Count + 1));
                        }
                    }
                }

                // 必要条件を満たしてない特殊能力を削除。
                i = 1;
                {
                    var withBlock3 = colFeature;
                    while (i <= withBlock3.Count)
                    {
                        // 必要条件を満たしている？
                        // UPGRADE_WARNING: オブジェクト colFeature.Item().NecessaryCondition の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                        bool localIsNecessarySkillSatisfied3() { string argnabilities = Conversions.ToString(withBlock3[i].NecessaryCondition); Pilot argp = null; var ret = IsNecessarySkillSatisfied(argnabilities, p: argp); return ret; }

                        if (!localIsNecessarySkillSatisfied3())
                        {
                            // 必要条件を満たしていないので削除
                            withBlock3.Remove(i);
                            found = true;
                        }
                        else
                        {
                            i = (i + 1);
                        }
                    }
                }
            }

            // 特殊能力が削除された場合、特殊能力の保持判定が正しく行われるように特殊能力を
            // 登録しなおす必要がある。
            if (found)
            {
                {
                    var withBlock4 = colFeature;
                    farray = new FeatureData[withBlock4.Count + 1];
                    var loopTo = withBlock4.Count;
                    for (i = 1; i <= loopTo; i++)
                        farray[i] = (FeatureData)withBlock4[i];
                    var loopTo1 = withBlock4.Count;
                    for (i = 1; i <= loopTo1; i++)
                        withBlock4.Remove(1);
                    var loopTo2 = Information.UBound(farray);
                    for (i = 1; i <= loopTo2; i++)
                    {
                        if (!IsFeatureRegistered(farray[i].Name))
                        {
                            withBlock4.Add(farray[i], farray[i].Name);
                        }
                        else
                        {
                            withBlock4.Add(farray[i], farray[i].Name + ":" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(i));
                        }
                    }
                }
            }
        }


        // === 他形態関連処理 ===

        // 他形態を登録
        public void AddOtherForm(Unit u)
        {
            colOtherForm.Add(u, u.ID);
        }

        // 他形態を削除
        public void DeleteOtherForm(object Index)
        {
            int i;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 112015


            Input:

                    On Error GoTo ErrorHandler

             */
            colOtherForm.Remove(Index);
            return;
            ErrorHandler:
            ;

            // 見つからなければユニット名称で検索
            var loopTo = colOtherForm.Count;
            for (i = 1; i <= loopTo; i++)
            {
                // UPGRADE_WARNING: オブジェクト colOtherForm(i).Name の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                if (Conversions.ToBoolean(Operators.ConditionalCompareObjectEqual(colOtherForm[i].Name, Index, false)))
                {
                    colOtherForm.Remove(i);
                    return;
                }
            }
        }

        // 他形態の総数
        public int CountOtherForm()
        {
            int CountOtherFormRet = default;
            CountOtherFormRet = colOtherForm.Count;
            return CountOtherFormRet;
        }

        // 他形態
        public Unit OtherForm(object Index)
        {
            Unit OtherFormRet = default;
            Unit u;
            string uname;
            int i;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 112769


            Input:

                    On Error GoTo ErrorHandler

             */
            OtherFormRet = (Unit)colOtherForm[Index];
            return OtherFormRet;
            ErrorHandler:
            ;

            // 見つからなければユニット名称で検索
            // UPGRADE_WARNING: オブジェクト Index の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
            uname = Conversions.ToString(Index);
            foreach (Unit currentU in colOtherForm)
            {
                u = currentU;
                if ((u.Name ?? "") == (uname ?? ""))
                {
                    OtherFormRet = u;
                    return OtherFormRet;
                }
            }

            // 該当するユニットがなければ作成して追加
            if (SRC.UDList.IsDefined(uname))
            {
                u = new Unit();
                {
                    var withBlock = u;
                    UnitData localItem() { object argIndex1 = uname; var ret = SRC.UDList.Item(argIndex1); return ret; }

                    withBlock.Name = localItem().Name;
                    withBlock.Rank = Rank;
                    withBlock.BossRank = BossRank;
                    withBlock.Party = Party0;
                    withBlock.ID = SRC.UList.CreateID(uname);
                    withBlock.Status = "他形態";
                    withBlock.x = x;
                    withBlock.y = y;
                    var loopTo = CountOtherForm();
                    for (i = 1; i <= loopTo; i++)
                    {
                        Unit localOtherForm() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                        withBlock.AddOtherForm(localOtherForm());
                        Unit localOtherForm1() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                        localOtherForm1().AddOtherForm(u);
                    }

                    withBlock.AddOtherForm(this);
                    AddOtherForm(u);
                }

                SRC.UList.Add2(u);
                OtherFormRet = u;
            }
            else
            {
                GUI.ErrorMessage("ユニットデータ「" + uname + "」が見つかりません");
            }
        }

        // 指定した他形態が登録されているか？
        public bool IsOtherFormDefined(string uname)
        {
            bool IsOtherFormDefinedRet = default;
            foreach (Unit u in colOtherForm)
            {
                if ((u.Name ?? "") == (uname ?? ""))
                {
                    IsOtherFormDefinedRet = true;
                    return IsOtherFormDefinedRet;
                }
            }

            IsOtherFormDefinedRet = false;
            return IsOtherFormDefinedRet;
        }

        // 不要な形態を削除
        public void DeleteTemporaryOtherForm()
        {
            string[] uarray;
            string fname, fdata;
            int k, i, j, n;

            // 必要な形態の一覧を作成
            n = 1;
            uarray = new string[2];
            uarray[1] = Name;
            var loopTo = CountFeature();
            for (i = 1; i <= loopTo; i++)
            {
                fname = Feature(i);
                switch (fname ?? "")
                {
                    case "変形":
                        {
                            fdata = FeatureData(fname);
                            n = (n + GeneralLib.LLength(fdata) - 1);
                            Array.Resize(uarray, n + 1);
                            var loopTo1 = (GeneralLib.LLength(fdata) - 1);
                            for (j = 1; j <= loopTo1; j++)
                                uarray[n - j + 1] = GeneralLib.LIndex(fdata, (j + 1));
                            break;
                        }

                    case "換装":
                    case "他形態":
                        {
                            fdata = FeatureData(fname);
                            n = (n + GeneralLib.LLength(fdata));
                            Array.Resize(uarray, n + 1);
                            var loopTo2 = GeneralLib.LLength(fdata);
                            for (j = 1; j <= loopTo2; j++)
                                uarray[n - j + 1] = GeneralLib.LIndex(fdata, j);
                            break;
                        }

                    case "ハイパーモード":
                    case "パーツ分離":
                    case "変形技":
                        {
                            fdata = FeatureData(fname);
                            n = (n + 1);
                            Array.Resize(uarray, n + 1);
                            uarray[n] = GeneralLib.LIndex(fdata, 2);
                            break;
                        }

                    case "ノーマルモード":
                    case "パーツ合体":
                        {
                            fdata = FeatureData(fname);
                            n = (n + 1);
                            Array.Resize(uarray, n + 1);
                            uarray[n] = GeneralLib.LIndex(fdata, 1);
                            break;
                        }
                }
            }

            // 他形態から必要ない形態へのリンクを削除
            var loopTo3 = CountOtherForm();
            for (i = 1; i <= loopTo3; i++)
            {
                {
                    var withBlock = OtherForm(i);
                    if (withBlock.Status == "他形態")
                    {
                        j = 1;
                        while (j <= withBlock.CountOtherForm())
                        {
                            {
                                var withBlock1 = withBlock.OtherForm(j);
                                var loopTo4 = n;
                                for (k = 1; k <= loopTo4; k++)
                                {
                                    if ((withBlock1.Name ?? "") == (uarray[k] ?? ""))
                                    {
                                        break;
                                    }
                                }
                            }

                            if (k > n)
                            {
                                withBlock.DeleteOtherForm(j);
                            }
                            else
                            {
                                j = (j + 1);
                            }
                        }
                    }
                }
            }

            // 必要ない形態を破棄し、リンクを削除
            i = 1;
            while (i <= CountOtherForm())
            {
                {
                    var withBlock2 = OtherForm(i);
                    var loopTo5 = n;
                    for (j = 1; j <= loopTo5; j++)
                    {
                        if ((withBlock2.Name ?? "") == (uarray[j] ?? ""))
                        {
                            break;
                        }
                    }
                }

                if (j > n)
                {
                    Unit localOtherForm() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                    localOtherForm().Status = "破棄";
                    DeleteOtherForm(i);
                }
                else
                {
                    i = (i + 1);
                }
            }
        }


        // === パイロット関連処理 ===

        // パイロットを追加
        public void AddPilot(Pilot p)
        {
            colPilot.Add(p, p.ID);
        }

        // パイロットを削除
        public void DeletePilot(object Index)
        {
            colPilot.Remove(Index);
        }

        // パイロットの入れ替え
        public void ReplacePilot(Pilot p, object Index)
        {
            int i;
            Pilot prev_p;
            Pilot[] pilot_list;
            p.Unit = this;
            prev_p = (Pilot)colPilot[Index];
            pilot_list = new Pilot[colPilot.Count + 1];
            var loopTo = Information.UBound(pilot_list);
            for (i = 1; i <= loopTo; i++)
                pilot_list[i] = (Pilot)colPilot[i];
            var loopTo1 = Information.UBound(pilot_list);
            for (i = 1; i <= loopTo1; i++)
                colPilot.Remove(1);
            var loopTo2 = Information.UBound(pilot_list);
            for (i = 1; i <= loopTo2; i++)
            {
                if (ReferenceEquals(pilot_list[i], prev_p))
                {
                    colPilot.Add(p, p.ID);
                }
                else
                {
                    colPilot.Add(pilot_list[i], pilot_list[i].ID);
                }
            }
            // UPGRADE_NOTE: オブジェクト prev_p.Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            prev_p.Unit = null;
            prev_p.Alive = false;
        }

        // 搭乗員数
        public int CountPilot()
        {
            int CountPilotRet = default;
            CountPilotRet = colPilot.Count;
            return CountPilotRet;
        }

        // パイロット
        public Pilot Pilot(object Index)
        {
            Pilot PilotRet = default;
            PilotRet = (Pilot)colPilot[Index];
            return PilotRet;
        }

        // メインパイロット
        // 各判定にはこのパイロットの能力を用いる
        public Pilot MainPilot(bool without_update = false)
        {
            Pilot MainPilotRet = default;
            string pname;
            Pilot p;
            int i;
            bool need_update;

            // パイロットが乗っていない？
            if (CountPilot() == 0)
            {
                if (!IsFeatureAvailable("追加パイロット"))
                {
                    GUI.ErrorMessage("ユニット「" + Name + "」にパイロットが乗っていません");
                    SRC.TerminateSRC();
                }
            }

            // 破棄された場合はメインパイロットの変更を行わない
            if (Status == "破棄")
            {
                MainPilotRet = (Pilot)colPilot[1];
                return MainPilotRet;
            }

            // 能力コピー中は同じパイロットが複数のユニットのメインパイロットに使用されるのを防ぐため
            // 追加パイロットと暴走時パイロットを使用しない
            if (IsConditionSatisfied("能力コピー"))
            {
                MainPilotRet = (Pilot)colPilot[1];
                return MainPilotRet;
            }

            // 暴走時の特殊パイロット
            if (IsConditionSatisfied("暴走"))
            {
                if (IsFeatureAvailable("暴走時パイロット"))
                {
                    pname = FeatureData("暴走時パイロット");
                    if (SRC.PDList.IsDefined(pname))
                    {
                        PilotData localItem() { object argIndex1 = pname; var ret = SRC.PDList.Item(argIndex1); return ret; }

                        pname = localItem().Name;
                    }
                    else
                    {
                        GUI.ErrorMessage("暴走時パイロット「" + pname + "」のデータが定義されていません");
                    }

                    if (SRC.PList.IsDefined(pname))
                    {
                        // 既に暴走時パイロットが作成済み
                        MainPilotRet = SRC.PList.Item(pname);
                        MainPilotRet.Unit = this;
                        MainPilotRet.Morale = Pilot(1).Morale;
                        MainPilotRet.Level = Pilot(1).Level;
                        MainPilotRet.Exp = Pilot(1).Exp;
                        if (!without_update)
                        {
                            if (!ReferenceEquals(MainPilotRet.Unit, this))
                            {
                                MainPilotRet.Unit = this;
                                MainPilotRet.Update();
                                MainPilotRet.UpdateSupportMod();
                            }
                        }

                        return MainPilotRet;
                    }
                    else
                    {
                        // 暴走時パイロットが作成されていないので作成する
                        MainPilotRet = SRC.PList.Add(pname, Pilot(1).Level, Party0, gid: "");
                        this.Party0 = argpparty;
                        MainPilotRet.Morale = Pilot(1).Morale;
                        MainPilotRet.Exp = Pilot(1).Exp;
                        MainPilotRet.Unit = this;
                        MainPilotRet.Update();
                        MainPilotRet.UpdateSupportMod();
                        return MainPilotRet;
                    }
                }
            }

            // 追加パイロットがいれば、それを使用
            if (IsFeatureAvailable("追加パイロット"))
            {
                pname = FeatureData("追加パイロット");
                if (SRC.PDList.IsDefined(pname))
                {
                    PilotData localItem1() { object argIndex1 = pname; var ret = SRC.PDList.Item(argIndex1); return ret; }

                    pname = localItem1().Name;
                }
                else
                {
                    GUI.ErrorMessage("追加パイロット「" + pname + "」のデータが定義されていません");
                }

                // 登録済みのパイロットをまずチェック
                if (pltAdditionalPilot is object)
                {
                    if ((pltAdditionalPilot.Name ?? "") == (pname ?? ""))
                    {
                        MainPilotRet = pltAdditionalPilot;
                        {
                            var withBlock = pltAdditionalPilot;
                            if (withBlock.IsAdditionalPilot && !ReferenceEquals(withBlock.Unit, this))
                            {
                                withBlock.Unit = this;
                                withBlock.Party = Party0;
                                withBlock.Exp = Pilot(1).Exp;
                                if (withBlock.Personality != "機械")
                                {
                                    withBlock.Morale = Pilot(1).Morale;
                                }

                                if (withBlock.Level != this.Pilot(1).Level)
                                {
                                    withBlock.Level = Pilot(1).Level;
                                    withBlock.Update();
                                }
                            }
                        }

                        return MainPilotRet;
                    }
                }

                var loopTo = CountOtherForm();
                for (i = 1; i <= loopTo; i++)
                {
                    Unit localOtherForm2() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                    Unit localOtherForm3() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm3().pltAdditionalPilot is object)
                    {
                        Unit localOtherForm1() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                        {
                            var withBlock1 = localOtherForm1().pltAdditionalPilot;
                            if ((withBlock1.Name ?? "") == (pname ?? ""))
                            {
                                Unit localOtherForm() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                                pltAdditionalPilot = localOtherForm().pltAdditionalPilot;
                                withBlock1.Party = Party0;
                                withBlock1.Unit = this;
                                if (withBlock1.IsAdditionalPilot && !ReferenceEquals(withBlock1.Unit, this))
                                {
                                    withBlock1.Level = Pilot(1).Level;
                                    withBlock1.Exp = Pilot(1).Exp;
                                    if (withBlock1.Personality != "機械")
                                    {
                                        withBlock1.Morale = Pilot(1).Morale;
                                    }

                                    withBlock1.Update();
                                    withBlock1.UpdateSupportMod();
                                }

                                MainPilotRet = pltAdditionalPilot;
                                return MainPilotRet;
                            }
                        }
                    }
                }

                // 次に搭乗しているパイロットから検索
                if (CountPilot() > 0)
                {
                    // 単なるメインパイロットの交代として扱うため、IsAdditionalPilotのフラグは立てない
                    var loopTo1 = CountPilot();
                    for (i = 1; i <= loopTo1; i++)
                    {
                        Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                        if ((localPilot().Name ?? "") == (pname ?? ""))
                        {
                            pltAdditionalPilot = Pilot(i);
                            MainPilotRet = pltAdditionalPilot;
                            return MainPilotRet;
                        }
                    }
                }

                // 既に作成されていればそれを使う
                // (ただし複数作成可能なパイロットで、他のユニットの追加パイロットとして登録済みの場合は除く)
                if (SRC.PList.IsDefined(pname))
                {
                    p = SRC.PList.Item(pname);
                    if (!p.IsAdditionalPilot || Strings.InStr(pname, "(ザコ)") == 0 && Strings.InStr(pname, "(汎用)") == 0)
                    {
                        pltAdditionalPilot = p;
                        {
                            var withBlock2 = pltAdditionalPilot;
                            withBlock2.IsAdditionalPilot = true;
                            withBlock2.Party = Party0;
                            withBlock2.Level = Pilot(1).Level;
                            withBlock2.Exp = Pilot(1).Exp;
                            if (withBlock2.Personality != "機械")
                            {
                                withBlock2.Morale = Pilot(1).Morale;
                            }

                            if (!without_update)
                            {
                                if (!ReferenceEquals(withBlock2.Unit, this))
                                {
                                    withBlock2.Unit = this;
                                    withBlock2.Update();
                                    withBlock2.UpdateSupportMod();
                                }
                            }
                            else
                            {
                                withBlock2.Unit = this;
                            }
                        }

                        MainPilotRet = pltAdditionalPilot;
                        return MainPilotRet;
                    }
                }

                // まだ作成されていないので作成する
                if (CountPilot() > 0)
                {
                    pltAdditionalPilot = SRC.PList.Add(pname, Pilot(1).Level, Party0, gid: "");
                    this.Party0 = argpparty1;
                    {
                        var withBlock3 = pltAdditionalPilot;
                        withBlock3.IsAdditionalPilot = true;
                        withBlock3.Exp = Pilot(1).Exp;
                        if (withBlock3.Personality != "機械")
                        {
                            withBlock3.Morale = Pilot(1).Morale;
                        }
                    }
                }
                else
                {
                    pltAdditionalPilot = SRC.PList.Add(pname, 1, Party0, gid: "");
                    this.Party0 = argpparty2;
                    pltAdditionalPilot.IsAdditionalPilot = true;
                }

                {
                    var withBlock4 = pltAdditionalPilot;
                    withBlock4.Unit = this;
                    if (!without_update)
                    {
                        withBlock4.Update();
                        withBlock4.UpdateSupportMod();
                    }
                }

                MainPilotRet = pltAdditionalPilot;
                return MainPilotRet;
            }

            // そうでなければ第１パイロットを使用
            MainPilotRet = (Pilot)colPilot[1];
            return MainPilotRet;
        }


        // サポートパイロットを追加
        public void AddSupport(Pilot p)
        {
            colSupport.Add(p, p.Name);
        }

        // サポートパイロットを削除
        public void DeleteSupport(object Index)
        {
            colSupport.Remove(Index);
        }

        // サポートパイロットの入れ替え
        public void ReplaceSupport(Pilot p, object Index)
        {
            int i;
            Pilot prev_p;
            Pilot[] support_list;
            p.Unit = this;
            prev_p = (Pilot)colSupport[Index];
            support_list = new Pilot[colSupport.Count + 1];
            var loopTo = Information.UBound(support_list);
            for (i = 1; i <= loopTo; i++)
                support_list[i] = (Pilot)colSupport[i];
            var loopTo1 = Information.UBound(support_list);
            for (i = 1; i <= loopTo1; i++)
                colSupport.Remove(1);
            var loopTo2 = Information.UBound(support_list);
            for (i = 1; i <= loopTo2; i++)
            {
                if ((support_list[i].ID ?? "") == (prev_p.ID ?? ""))
                {
                    colSupport.Add(p, p.ID);
                }
                else
                {
                    colSupport.Add(support_list[i], support_list[i].ID);
                }
            }
            // UPGRADE_NOTE: オブジェクト prev_p.Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            prev_p.Unit = null;
            prev_p.Alive = false;
        }

        // 総サポートパイロット数
        public int CountSupport()
        {
            int CountSupportRet = default;
            CountSupportRet = colSupport.Count;
            return CountSupportRet;
        }

        // サポート
        public Pilot Support(object Index)
        {
            Pilot SupportRet = default;
            SupportRet = (Pilot)colSupport[Index];
            return SupportRet;
        }

        // 追加サポート
        public Pilot AdditionalSupport()
        {
            Pilot AdditionalSupportRet = default;
            string pname;
            Pilot p;
            int i;

            // 追加サポートパイロットの名称
            pname = FeatureData("追加サポート");

            // 追加サポートが存在しない？
            if (string.IsNullOrEmpty(pname))
            {
                return AdditionalSupportRet;
            }

            // 他にパイロットが乗っていない場合は無効
            if (CountPilot() == 0)
            {
                return AdditionalSupportRet;
            }

            // 既に登録済みであるかチェック
            if (pltAdditionalSupport is object)
            {
                if ((pltAdditionalSupport.Name ?? "") == (pname ?? ""))
                {
                    AdditionalSupportRet = pltAdditionalSupport;
                    pltAdditionalSupport.Unit = this;
                    return AdditionalSupportRet;
                }
            }

            var loopTo = CountOtherForm();
            for (i = 1; i <= loopTo; i++)
            {
                {
                    var withBlock = OtherForm(i);
                    if (withBlock.pltAdditionalSupport is object)
                    {
                        if ((withBlock.pltAdditionalSupport.Name ?? "") == (pname ?? ""))
                        {
                            withBlock.pltAdditionalSupport.Unit = this;
                            AdditionalSupportRet = withBlock.pltAdditionalSupport;
                            return AdditionalSupportRet;
                        }
                    }
                }
            }

            // 既に作成されていればそれを使う
            // (ただし他のユニットの追加サポートとして登録済みの場合は除く)
            if (SRC.PList.IsDefined(pname))
            {
                p = SRC.PList.Item(pname);
                if (!p.IsAdditionalSupport || Strings.InStr(pname, "(ザコ)") == 0 && Strings.InStr(pname, "(汎用)") == 0)
                {
                    pltAdditionalSupport = p;
                    {
                        var withBlock1 = pltAdditionalSupport;
                        withBlock1.IsAdditionalSupport = true;
                        withBlock1.Party = Party0;
                        withBlock1.Unit = this;
                        withBlock1.Level = Pilot(1).Level;
                        withBlock1.Exp = Pilot(1).Exp;
                        if (withBlock1.Personality != "機械")
                        {
                            withBlock1.Morale = Pilot(1).Morale;
                        }
                    }

                    AdditionalSupportRet = pltAdditionalSupport;
                    return AdditionalSupportRet;
                }
            }

            // まだ作成されていないので作成する
            bool localIsDefined() { object argIndex1 = pname; var ret = SRC.PDList.IsDefined(argIndex1); return ret; }

            if (!localIsDefined())
            {
                GUI.ErrorMessage("追加サポート「" + pname + "」のデータが定義されていません");
                return AdditionalSupportRet;
            }

            pltAdditionalSupport = SRC.PList.Add(pname, Pilot(1).Level, Party0, gid: "");
            this.Party0 = argpparty;
            {
                var withBlock2 = pltAdditionalSupport;
                withBlock2.IsAdditionalSupport = true;
                withBlock2.Unit = this;
                withBlock2.Exp = Pilot(1).Exp;
                if (withBlock2.Personality != "機械")
                {
                    withBlock2.Morale = Pilot(1).Morale;
                }
            }

            AdditionalSupportRet = pltAdditionalSupport;
            return AdditionalSupportRet;
        }

        // いずれかのパイロットが特殊能力 sname を持っているか判定
        public bool IsSkillAvailable(string sname)
        {
            bool IsSkillAvailableRet = default;
            int i;
            if (CountPilot() == 0)
            {
                return IsSkillAvailableRet;
            }

            // メインパイロット
            if (MainPilot().IsSkillAvailable(sname))
            {
                IsSkillAvailableRet = true;
                return IsSkillAvailableRet;
            }

            // パイロット数が負の場合はメインパイロットの能力のみが有効
            if (Data.PilotNum > 0)
            {
                var loopTo = CountPilot();
                for (i = 2; i <= loopTo; i++)
                {
                    Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    if (localPilot().IsSkillAvailable(sname))
                    {
                        IsSkillAvailableRet = true;
                        return IsSkillAvailableRet;
                    }
                }
            }

            // サポート
            var loopTo1 = CountSupport();
            for (i = 1; i <= loopTo1; i++)
            {
                Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                if (localSupport().IsSkillAvailable(sname))
                {
                    IsSkillAvailableRet = true;
                    return IsSkillAvailableRet;
                }
            }

            // 追加サポート
            if (IsFeatureAvailable("追加サポート"))
            {
                if (AdditionalSupport().IsSkillAvailable(sname))
                {
                    IsSkillAvailableRet = true;
                    return IsSkillAvailableRet;
                }
            }

            IsSkillAvailableRet = false;
            return IsSkillAvailableRet;
        }

        // パイロット全員によるパイロット能力レベル
        public double SkillLevel(string sname, double default_slevel = 1d)
        {
            double SkillLevelRet = default;
            if (CountPilot() == 0)
            {
                return SkillLevelRet;
            }

            // エリアスが設定されてるかチェック
            if (SRC.ALDList.IsDefined(sname))
            {
                AliasDataType localItem() { object argIndex1 = sname; var ret = SRC.ALDList.Item(argIndex1); return ret; }

                sname = localItem().get_AliasType(1);
            }

            switch (sname ?? "")
            {
                case "同調率":
                    {
                        SkillLevelRet = SyncLevel();
                        break;
                    }

                case "霊力":
                    {
                        SkillLevelRet = PlanaLevel();
                        break;
                    }

                case "オーラ":
                    {
                        SkillLevelRet = AuraLevel();
                        break;
                    }

                case "超能力":
                    {
                        SkillLevelRet = PsychicLevel();
                        break;
                    }

                case "Ｓ防御":
                case "切り払い":
                    {
                        SkillLevelRet = MainPilot().SkillLevel(sname, 1.ToString());
                        break;
                    }

                case "超感覚":
                    {
                        if (MaxSkillLevel("超感覚", 1d) > MaxSkillLevel("知覚強化", 1d))
                        {
                            SkillLevelRet = MaxSkillLevel("超感覚", 1d);
                        }
                        else
                        {
                            SkillLevelRet = MaxSkillLevel("知覚強化", 1d);
                        }

                        break;
                    }

                default:
                    {
                        SkillLevelRet = MaxSkillLevel(sname, default_slevel);
                        break;
                    }
            }

            return SkillLevelRet;
        }

        // パイロット中での最も高いパイロット能力レベルを返す
        private double MaxSkillLevel(string sname, double default_slevel)
        {
            double MaxSkillLevelRet = default;
            double slevel;
            int i;
            if (CountPilot() == 0)
            {
                return MaxSkillLevelRet;
            }

            // メインパイロット
            {
                var withBlock = MainPilot();
                if (withBlock.IsSkillLevelSpecified(sname))
                {
                    MaxSkillLevelRet = withBlock.SkillLevel(sname, ref_mode: "");
                }
                else if (withBlock.IsSkillAvailable(sname))
                {
                    MaxSkillLevelRet = default_slevel;
                }
                else
                {
                    MaxSkillLevelRet = 0d;
                }
            }

            // パイロット数が負の場合はメインパイロットの能力のみが有効
            if (Data.PilotNum > 0)
            {
                var loopTo = CountPilot();
                for (i = 2; i <= loopTo; i++)
                {
                    {
                        var withBlock1 = Pilot(i);
                        if (withBlock1.IsSkillLevelSpecified(sname))
                        {
                            slevel = withBlock1.SkillLevel(sname, ref_mode: "");
                        }
                        else if (withBlock1.IsSkillAvailable(sname))
                        {
                            slevel = default_slevel;
                        }
                        else
                        {
                            slevel = 0d;
                        }

                        if (slevel > MaxSkillLevelRet)
                        {
                            MaxSkillLevelRet = slevel;
                        }
                    }
                }
            }

            // サポート
            var loopTo1 = CountSupport();
            for (i = 1; i <= loopTo1; i++)
            {
                {
                    var withBlock2 = Support(i);
                    if (withBlock2.IsSkillLevelSpecified(sname))
                    {
                        slevel = withBlock2.SkillLevel(sname, ref_mode: "");
                    }
                    else if (withBlock2.IsSkillAvailable(sname))
                    {
                        slevel = default_slevel;
                    }
                    else
                    {
                        slevel = 0d;
                    }

                    if (slevel > MaxSkillLevelRet)
                    {
                        MaxSkillLevelRet = slevel;
                    }
                }
            }

            // 追加サポート
            if (IsFeatureAvailable("追加サポート"))
            {
                {
                    var withBlock3 = AdditionalSupport();
                    if (withBlock3.IsSkillLevelSpecified(sname))
                    {
                        slevel = withBlock3.SkillLevel(sname, ref_mode: "");
                    }
                    else if (withBlock3.IsSkillAvailable(sname))
                    {
                        slevel = default_slevel;
                    }
                    else
                    {
                        slevel = 0d;
                    }

                    if (slevel > MaxSkillLevelRet)
                    {
                        MaxSkillLevelRet = slevel;
                    }
                }
            }

            return MaxSkillLevelRet;
        }

        // ユニットのオーラ力レベル
        public double AuraLevel(bool no_limit = false)
        {
            double AuraLevelRet = default;
            switch (CountPilot())
            {
                case 0:
                    {
                        return AuraLevelRet;
                    }

                case 1:
                    {
                        AuraLevelRet = MainPilot().SkillLevel("オーラ", ref_mode: "");
                        break;
                    }

                default:
                    {
                        // パイロットが２名以上の場合は２人目のオーラ力を加算
                        AuraLevelRet = MainPilot().SkillLevel("オーラ", ref_mode: "") + Pilot(2).SkillLevel("オーラ", ref_mode: "") / 2d;
                        break;
                    }
            }

            // サポートのオーラ力を加算
            if (IsFeatureAvailable("追加サポート"))
            {
                AuraLevelRet = AuraLevelRet + AdditionalSupport().SkillLevel("オーラ", ref_mode: "") / 2d;
            }
            else if (CountSupport() > 0)
            {
                AuraLevelRet = AuraLevelRet + Support(1).SkillLevel("オーラ", ref_mode: "") / 2d;
            }

            // オーラ変換器レベルによる制限
            if (IsFeatureAvailable("オーラ変換器") && !no_limit)
            {
                if (IsFeatureLevelSpecified("オーラ変換器"))
                {
                    AuraLevelRet = GeneralLib.MinDbl(AuraLevelRet, FeatureLevel("オーラ変換器"));
                }
            }

            return AuraLevelRet;
        }

        // ユニットの超能力レベル
        public double PsychicLevel(bool no_limit = false)
        {
            double PsychicLevelRet = default;
            switch (CountPilot())
            {
                case 0:
                    {
                        return PsychicLevelRet;
                    }

                case 1:
                    {
                        PsychicLevelRet = MainPilot().SkillLevel("超能力", ref_mode: "");
                        break;
                    }

                default:
                    {
                        // パイロットが２名以上の場合は２人目の超能力を加算
                        PsychicLevelRet = MainPilot().SkillLevel("超能力", ref_mode: "") + Pilot(2).SkillLevel("超能力", ref_mode: "") / 2d;
                        break;
                    }
            }

            // サポートのオーラ力を加算
            if (IsFeatureAvailable("追加サポート"))
            {
                PsychicLevelRet = PsychicLevelRet + AdditionalSupport().SkillLevel("超能力", ref_mode: "") / 2d;
            }
            else if (CountSupport() > 0)
            {
                // サポートの超能力を加算
                PsychicLevelRet = PsychicLevelRet + Support(1).SkillLevel("超能力", ref_mode: "") / 2d;
            }

            // サイキックドライブによる制限
            if (IsFeatureAvailable("サイキックドライブ") && !no_limit)
            {
                if (IsFeatureLevelSpecified("サイキックドライブ"))
                {
                    PsychicLevelRet = GeneralLib.MinDbl(PsychicLevelRet, FeatureLevel("サイキックドライブ"));
                }
            }

            return PsychicLevelRet;
        }

        // ユニットの同調率
        public double SyncLevel(bool no_limit = false)
        {
            double SyncLevelRet = default;
            if (CountPilot() == 0)
            {
                return SyncLevelRet;
            }

            SyncLevelRet = MainPilot().SynchroRate();

            // シンクロドライブレベルによる制限
            if (IsFeatureAvailable("シンクロドライブ") && !no_limit)
            {
                if (IsFeatureLevelSpecified("シンクロドライブ"))
                {
                    SyncLevelRet = GeneralLib.MinDbl(SyncLevelRet, FeatureLevel("シンクロドライブ"));
                }
            }

            return SyncLevelRet;
        }

        // ユニットの霊力レベル
        public double PlanaLevel(bool no_limit = false)
        {
            double PlanaLevelRet = default;
            if (CountPilot() == 0)
            {
                return PlanaLevelRet;
            }

            PlanaLevelRet = MainPilot().Plana;

            // 霊力変換器レベルによる制限
            if (IsFeatureAvailable("霊力変換器") && !no_limit)
            {
                if (IsFeatureLevelSpecified("霊力変換器"))
                {
                    PlanaLevelRet = GeneralLib.MinDbl(PlanaLevelRet, FeatureLevel("霊力変換器"));
                }
            }

            return PlanaLevelRet;
        }

        // パイロット全員からパイロット能力名を検索
        public string SkillName0(string sname)
        {
            string SkillName0Ret = default;
            int i;
            if (SRC.ALDList.IsDefined(sname))
            {
                AliasDataType localItem() { object argIndex1 = sname; var ret = SRC.ALDList.Item(argIndex1); return ret; }

                sname = localItem().get_AliasType(1);
            }

            if (CountPilot() == 0)
            {
                SkillName0Ret = sname;
                return SkillName0Ret;
            }

            // メインパイロット
            SkillName0Ret = MainPilot().SkillName0(sname);
            if ((SkillName0Ret ?? "") != (sname ?? ""))
            {
                return SkillName0Ret;
            }

            // パイロット数が負の場合はメインパイロットの能力のみが有効
            if (Data.PilotNum > 0)
            {
                var loopTo = CountPilot();
                for (i = 2; i <= loopTo; i++)
                {
                    Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    SkillName0Ret = localPilot().SkillName0(sname);
                    if ((SkillName0Ret ?? "") != (sname ?? ""))
                    {
                        return SkillName0Ret;
                    }
                }
            }

            // サポート
            var loopTo1 = CountSupport();
            for (i = 1; i <= loopTo1; i++)
            {
                Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                SkillName0Ret = localSupport().SkillName0(sname);
                if ((SkillName0Ret ?? "") != (sname ?? ""))
                {
                    return SkillName0Ret;
                }
            }

            // 追加サポート
            if (IsFeatureAvailable("追加サポート"))
            {
                SkillName0Ret = AdditionalSupport().SkillName0(sname);
            }

            return SkillName0Ret;
        }


        // === 行動数関連処理 ===

        // １ターンに可能な行動数
        public int MaxAction(bool ignore_en = false)
        {
            int MaxActionRet = default;
            // ステータス異常？
            if (IsConditionSatisfied("行動不能") || IsConditionSatisfied("麻痺") || IsConditionSatisfied("石化") || IsConditionSatisfied("凍結") || IsConditionSatisfied("睡眠") || IsConditionSatisfied("チャージ") || IsConditionSatisfied("消耗") || IsUnderSpecialPowerEffect("行動不能"))
            {
                return MaxActionRet;
            }

            // ＥＮ切れ？
            if (!ignore_en)
            {
                if (EN == 0)
                {
                    if (!Expression.IsOptionDefined("ＥＮ０時行動可"))
                    {
                        return MaxActionRet;
                    }
                }
            }

            if (CountPilot() == 0)
            {
                return MaxActionRet;
            }

            // ２回行動可能？
            if (Expression.IsOptionDefined("２回行動能力使用"))
            {
                if (MainPilot().IsSkillAvailable("２回行動"))
                {
                    MaxActionRet = 2;
                }
                else
                {
                    MaxActionRet = 1;
                }
            }
            else if (this.MainPilot().Intuition >= 200)
            {
                MaxActionRet = 2;
            }
            else
            {
                MaxActionRet = 1;
            }

            return MaxActionRet;
        }

        // 行動数を消費
        public void UseAction()
        {
            int max_action;

            // ２回行動可能？
            if (CountPilot() == 0)
            {
                max_action = 1;
            }
            else if (Expression.IsOptionDefined("２回行動能力使用"))
            {
                if (MainPilot().IsSkillAvailable("２回行動"))
                {
                    max_action = 2;
                }
                else
                {
                    max_action = 1;
                }
            }
            else if (this.MainPilot().Intuition >= 200)
            {
                max_action = 2;
            }
            else
            {
                max_action = 1;
            }

            // 最大行動数まで行動消費量をカウント
            UsedAction = GeneralLib.MinLng(UsedAction + 1, max_action);
        }


        // === スペシャルパワー関連処理 ===

        // 影響下にあるスペシャルパワー一覧
        public string SpecialPowerInEffect()
        {
            string SpecialPowerInEffectRet = default;
            Condition cnd;
            foreach (Condition currentCnd in colSpecialPowerInEffect)
            {
                cnd = currentCnd;
                {
                    var withBlock = SRC.SPDList.Item((object)cnd.Name);
                    if (withBlock.intName == "非表示")
                    {
                        // イベント専用
                        goto NextSpecialPower;
                    }

                    if (withBlock.Duration == "みがわり")
                    {
                        // みがわりは別表示
                        goto NextSpecialPower;
                    }

                    SpecialPowerInEffectRet = SpecialPowerInEffectRet + withBlock.intName;
                }

                NextSpecialPower:
                ;
            }

            // みがわりはかばってくれるユニットを表示する
            foreach (Condition currentCnd1 in colSpecialPowerInEffect)
            {
                cnd = currentCnd1;
                {
                    var withBlock1 = SRC.SPDList.Item((object)cnd.Name);
                    if (withBlock1.Duration == "みがわり")
                    {
                        if (SRC.PList.IsDefined((object)cnd.StrData))
                        {
                            SpecialPowerInEffectRet = SpecialPowerInEffectRet + withBlock1.intName + "(" + SRC.PList.Item((object)cnd.StrData).get_Nickname(false) + ")";
                        }

                        return SpecialPowerInEffectRet;
                    }
                }
            }

            return SpecialPowerInEffectRet;
        }

        // ユニットがスペシャルパワー sname の影響下にあるかどうか
        public bool IsSpecialPowerInEffect(string sname)
        {
            bool IsSpecialPowerInEffectRet = default;
            Condition cnd;
            if (colSpecialPowerInEffect.Count == 0)
            {
                return IsSpecialPowerInEffectRet;
            };
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 137362


            Input:

                    On Error GoTo ErrorHandler

             */
            cnd = (Condition)colSpecialPowerInEffect[sname];
            IsSpecialPowerInEffectRet = true;
            return IsSpecialPowerInEffectRet;
            ErrorHandler:
            ;
        }

        // ユニットがスペシャルパワー効果 sptype の影響下にあるかどうか
        public bool IsUnderSpecialPowerEffect(string sptype)
        {
            bool IsUnderSpecialPowerEffectRet = default;
            int i;
            foreach (Condition cnd in colSpecialPowerInEffect)
            {
                {
                    var withBlock = SRC.SPDList.Item((object)cnd.Name);
                    var loopTo = withBlock.CountEffect();
                    for (i = 1; i <= loopTo; i++)
                    {
                        if ((withBlock.EffectType(i) ?? "") == (sptype ?? ""))
                        {
                            IsUnderSpecialPowerEffectRet = true;
                            return IsUnderSpecialPowerEffectRet;
                        }
                    }
                }
            }

            IsUnderSpecialPowerEffectRet = false;
            return IsUnderSpecialPowerEffectRet;
        }

        // 影響下にあるスペシャルパワーの総数
        public int CountSpecialPower()
        {
            int CountSpecialPowerRet = default;
            CountSpecialPowerRet = colSpecialPowerInEffect.Count;
            return CountSpecialPowerRet;
        }

        // 影響下にあるスペシャルパワー
        public SpecialPowerData SpecialPower(object Index)
        {
            SpecialPowerData SpecialPowerRet = default;
            Condition cnd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 138333


            Input:

                    On Error GoTo ErrorHandler

             */
            cnd = (Condition)colSpecialPowerInEffect[Index];
            SpecialPowerRet = SRC.SPDList.Item((object)cnd.Name);
            return SpecialPowerRet;
            ErrorHandler:
            ;

            // UPGRADE_NOTE: オブジェクト SpecialPower をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            SpecialPowerRet = null;
        }

        // スペシャルパワー mname の効果レベル
        public double SpecialPowerEffectLevel(string sname)
        {
            double SpecialPowerEffectLevelRet = default;
            int i;
            double lv;
            lv = SRC.DEFAULT_LEVEL;
            foreach (Condition cnd in colSpecialPowerInEffect)
            {
                {
                    var withBlock = SRC.SPDList.Item((object)cnd.Name);
                    var loopTo = withBlock.CountEffect();
                    for (i = 1; i <= loopTo; i++)
                    {
                        if ((withBlock.EffectType(i) ?? "") == (sname ?? ""))
                        {
                            if (withBlock.EffectLevel(i) > lv)
                            {
                                lv = withBlock.EffectLevel(i);
                            }

                            break;
                        }
                    }
                }
            }

            if (lv != SRC.DEFAULT_LEVEL)
            {
                SpecialPowerEffectLevelRet = lv;
            }

            return SpecialPowerEffectLevelRet;
        }

        // スペシャルパワーのデータ
        public string SpecialPowerData(object Index)
        {
            string SpecialPowerDataRet = default;
            Condition cnd;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 139541


            Input:

                    On Error GoTo ErrorHandler

             */
            cnd = (Condition)colSpecialPowerInEffect[Index];
            SpecialPowerDataRet = cnd.StrData;
            return SpecialPowerDataRet;
            ErrorHandler:
            ;
        }

        // スペシャルパワー sname の効果を適用
        public void MakeSpecialPowerInEffect(string sname, [Optional, DefaultParameterValue("")] string sdata)
        {
            var cnd = new Condition();

            // すでに使用されていればなにもしない
            if (IsSpecialPowerInEffect(sname))
            {
                return;
            }

            cnd.Name = sname;
            cnd.StrData = sdata;
            colSpecialPowerInEffect.Add(cnd, sname);
        }

        // 持続時間が stype であるスペシャルパワーの効果を発動後、取り除く
        public void RemoveSpecialPowerInEffect(string stype)
        {
            SpecialPowerData sd;
            int i;
            bool is_message_form_visible;
            string pid;

            // メッセージウィンドウが表示されているか記録
            is_message_form_visible = My.MyProject.Forms.frmMessage.Visible;
            i = 1;
            while (i <= CurrentForm().CountSpecialPower())
            {
                sd = SpecialPower(i);

                // スペシャルパワーの持続期間が指定したものと一致しているかチェック
                if ((stype ?? "") != (sd.Duration ?? ""))
                {
                    i = (i + 1);
                    goto NextSP;
                }

                // 持続期間が敵ターンの場合、スペシャルパワーをかけてきた敵のフェイズ
                // が来るまで効果を削除しない
                if (stype == "敵ターン")
                {
                    if (SRC.PList.IsDefined(SpecialPowerData((object)sd.Name)))
                    {
                        {
                            var withBlock = SRC.PList.Item(SpecialPowerData((object)sd.Name));
                            if (withBlock.Unit is object)
                            {
                                if ((withBlock.Unit.CurrentForm().Party ?? "") != (SRC.Stage ?? ""))
                                {
                                    i = (i + 1);
                                    goto NextSP;
                                }
                            }
                        }
                    }
                }

                // 消去するスペシャルパワーの効果を発動
                if (CurrentForm().Status == "出撃")
                {
                    sd.Apply(CurrentForm().MainPilot(), CurrentForm(), false, true);
                }

                // スペシャルパワーの効果を削除
                CurrentForm().RemoveSpecialPowerInEffect2(i);
                NextSP:
                ;
            }

            // メッセージウィンドウが元から表示されていなければ閉じておく
            if (!is_message_form_visible && My.MyProject.Forms.frmMessage.Visible)
            {
                GUI.CloseMessageForm();
            }
        }

        // スペシャルパワー sname の効果を取り除く
        public void RemoveSpecialPowerInEffect2(object Index)
        {
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 141635


            Input:
                    On Error GoTo ErrorHandler

             */
            colSpecialPowerInEffect.Remove(Index);
            return;
            ErrorHandler:
            ;
        }

        // 全てのスペシャルパワーの効果を取り除く
        public void RemoveAllSpecialPowerInEffect()
        {
            int i;
            {
                var withBlock = colSpecialPowerInEffect;
                var loopTo = withBlock.Count;
                for (i = 1; i <= loopTo; i++)
                    withBlock.Remove(1);
            }
        }

        // スペシャルパワーの効果をユニット u にコピーする
        public void CopySpecialPowerInEffect(Unit u)
        {
            foreach (Condition cnd in colSpecialPowerInEffect)
                u.MakeSpecialPowerInEffect(cnd.Name, cnd.StrData);
        }


        // === 特殊状態関連処理 ===

        // 特殊状態を付加
        public void AddCondition(string cname, int ltime, double clevel = SRC.DEFAULT_LEVEL, [Optional, DefaultParameterValue("")] string cdata)
        {
            var new_condition = new Condition();

            // 同じ特殊状態が既に付加されている？
            foreach (Condition cnd in colCondition)
            {
                if ((cnd.Name ?? "") == (cname ?? ""))
                {
                    if (cnd.Lifetime < 0 || ltime < 0)
                    {
                        cnd.Lifetime = -1;
                    }
                    else
                    {
                        cnd.Lifetime = GeneralLib.MaxLng(cnd.Lifetime, ltime);
                    }

                    cnd.Name = cname;
                    cnd.Level = clevel;
                    cnd.StrData = cdata;
                    return;
                }
            }

            // 特殊状態を付加
            new_condition.Name = cname;
            new_condition.Lifetime = ltime;
            new_condition.Level = clevel;
            new_condition.StrData = cdata;
            colCondition.Add(new_condition, cname);
        }

        // 特殊状態を削除
        public void DeleteCondition(object Index)
        {
            {
                var withBlock = colCondition[Index];
                colCondition.Remove(Index);

                // 特殊能力付加の場合はユニットのステータスをアップデート
                // UPGRADE_WARNING: オブジェクト colCondition.Item().StrData の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                // UPGRADE_WARNING: オブジェクト colCondition.Item().Name の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                if (Strings.Right(Conversions.ToString(withBlock.Name), 2) == "付加" && Strings.InStr(Conversions.ToString(withBlock.StrData), "パイロット能力付加") == 0)
                {
                    Update();
                }
            }
        }

        public void DeleteCondition0(object Index)
        {
            colCondition.Remove(Index);
        }

        // 付加された特殊状態の総数
        public int CountCondition()
        {
            int CountConditionRet = default;
            CountConditionRet = colCondition.Count;
            return CountConditionRet;
        }

        // 特殊状態
        public string Condition(object Index)
        {
            string ConditionRet = default;
            // UPGRADE_WARNING: オブジェクト colCondition.Item().Name の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
            ConditionRet = Conversions.ToString(colCondition[Index].Name);
            return ConditionRet;
        }

        // 特殊状態の残りターン数
        public int ConditionLifetime(object Index)
        {
            int ConditionLifetimeRet = default;
            ;
            // UPGRADE_WARNING: オブジェクト colCondition.Item().Lifetime の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
            ConditionLifetimeRet = Conversions.Toint(colCondition[Index].Lifetime);
            return ConditionLifetimeRet;
            ErrorHandler:
            ;
            ConditionLifetimeRet = -1;
        }

        // 指定した特殊能力が付加されているか？
        public bool IsConditionSatisfied(object Index)
        {
            bool IsConditionSatisfiedRet = default;
            int ltime;
            ;
            // UPGRADE_WARNING: オブジェクト colCondition.Item().Lifetime の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
            ltime = Conversions.Toint(colCondition[Index].Lifetime);
            IsConditionSatisfiedRet = true;
            return IsConditionSatisfiedRet;
            ErrorHandler:
            ;
            IsConditionSatisfiedRet = false;
        }

        // 特殊状態のレベル
        public double ConditionLevel(object Index)
        {
            double ConditionLevelRet = default;
            ;
            // UPGRADE_WARNING: オブジェクト colCondition.Item().Level の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
            ConditionLevelRet = Conversions.ToDouble(colCondition[Index].Level);
            return ConditionLevelRet;
            ErrorHandler:
            ;
            ConditionLevelRet = 0d;
        }

        // 特殊状態のレベルの変更
        public void SetConditionLevel(object Index, double lv)
        {
            ;
            // UPGRADE_WARNING: オブジェクト colCondition.Item().Level の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
            colCondition[Index].Level = lv;
            ErrorHandler:
            ;
        }

        // 特殊能力のデータ
        public string ConditionData(object Index)
        {
            string ConditionDataRet = default;
            ;
            // UPGRADE_WARNING: オブジェクト colCondition.Item().StrData の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
            ConditionDataRet = Conversions.ToString(colCondition[Index].StrData);
            return ConditionDataRet;
            ErrorHandler:
            ;
            ConditionDataRet = "";
        }

        // 特殊能力の残りターン数を更新
        public void UpdateCondition(bool decrement_lifetime = false)
        {
            var update_is_necessary = default(bool);
            var charge_complete = default(bool);
            foreach (Condition cnd in colCondition)
            {
                if (decrement_lifetime)
                {
                    // 残りターン数を1減らす
                    if (cnd.Lifetime > 0)
                    {
                        cnd.Lifetime = (cnd.Lifetime - 1);
                    }
                }

                if (cnd.Lifetime == 0)
                {
                    // 残りターン数が0なら削除
                    colCondition.Remove(cnd.Name);
                    switch (cnd.Name ?? "")
                    {
                        case "魅了":
                            {
                                // 魅了を解除
                                if (Master is object)
                                {
                                    Master.CurrentForm().DeleteSlave(ID);
                                    // UPGRADE_NOTE: オブジェクト Master をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                    Master = null;
                                }

                                Mode = "通常";
                                break;
                            }

                        case "チャージ":
                            {
                                // チャージ完了
                                charge_complete = true;
                                break;
                            }

                        case "活動限界":
                            {
                                // 活動限界時間切れ
                                GUI.Center(x, y);
                                Escape();
                                GUI.OpenMessageForm(u1: null, u2: null);
                                GUI.DisplaySysMessage(Nickname + "は強制的に退却させられた。");
                                GUI.CloseMessageForm();
                                Event.HandleEvent("破壊", MainPilot().ID);
                                break;
                            }

                        default:
                            {
                                // 特殊能力付加を解除
                                if (Strings.Right(cnd.Name, 2) == "付加" || Strings.Right(cnd.Name, 2) == "強化")
                                {
                                    update_is_necessary = true;
                                }

                                break;
                            }
                    }
                }
            }

            // チャージ状態が終了したらチャージ完了状態にする
            if (charge_complete)
            {
                AddCondition("チャージ完了", 1, cdata: "");
            }

            // ユニットのステータス変化あり？
            if (update_is_necessary)
            {
                Update();
            }
        }


        // === 武器関連処理 ===

        // 武器
        public WeaponData Weapon(int w)
        {
            WeaponData WeaponRet = default;
            WeaponRet = WData[w];
            return WeaponRet;
        }

        // 武器の総数
        public int CountWeapon()
        {
            int CountWeaponRet = default;
            CountWeaponRet = Information.UBound(WData);
            return CountWeaponRet;
        }

        // 武器の愛称
        public string WeaponNickname(int w)
        {
            string WeaponNicknameRet = default;
            Unit u;

            // 愛称内の式置換のため、デフォルトユニットを一時的に変更する
            u = Event.SelectedUnitForEvent;
            Event.SelectedUnitForEvent = this;
            WeaponNicknameRet = WData[w].Nickname();
            Event.SelectedUnitForEvent = u;
            return WeaponNicknameRet;
        }

        // 武器の攻撃力
        // tarea は敵のいる地形
        public int WeaponPower(int w, string tarea)
        {
            int WeaponPowerRet = default;
            int pat;
            // 攻撃補正一時保存
            double ed_atk;
            WeaponPowerRet = lngWeaponPower[w];

            // 「体」属性を持つ武器は残りＨＰに応じて攻撃力が増える
            if (IsWeaponClassifiedAs(w, "体"))
            {
                WeaponPowerRet = (WeaponPowerRet + HP / (double)MaxHP * 100d * WeaponLevel(w, "体"));
            }

            // 「尽」属性を持つ武器は残りＥＮに応じて攻撃力が増える
            if (IsWeaponClassifiedAs(w, "尽"))
            {
                if (EN >= WeaponENConsumption(w))
                {
                    WeaponPowerRet = (WeaponPowerRet + (EN - WeaponENConsumption(w)) * WeaponLevel(w, "尽"));
                }
            }

            // ダメージ固定武器
            double wad;
            if (IsWeaponClassifiedAs(w, "固"))
            {

                // 武器一覧の場合は攻撃力をそのまま表示
                if (string.IsNullOrEmpty(tarea))
                {
                    return WeaponPowerRet;
                }

                // マップ攻撃は攻撃開始時に保存した攻撃力をそのまま使う
                if (IsWeaponClassifiedAs(w, "Ｍ"))
                {
                    if (SelectedMapAttackPower > 0)
                    {
                        WeaponPowerRet = SelectedMapAttackPower;
                    }
                }

                // 地形適応による修正のみを適用
                wad = WeaponAdaption(w, tarea);

                // 地形適応修正繰り下げオプションの効果は適用しない
                if (Expression.IsOptionDefined("地形適応修正繰り下げ"))
                {
                    if (Expression.IsOptionDefined("地形適応修正緩和"))
                    {
                        wad = wad + 0.1d;
                    }
                    else
                    {
                        wad = wad + 0.2d;
                    }
                }

                // 地形適応がＡの場合に攻撃力と同じダメージを与えるようにする
                if (Expression.IsOptionDefined("地形適応修正緩和"))
                {
                    wad = wad - 0.1d;
                }
                else
                {
                    wad = wad - 0.2d;
                }

                if (wad > 0d)
                {
                    WeaponPowerRet = (WeaponPowerRet * wad);
                }
                else
                {
                    WeaponPowerRet = 0;
                }

                return WeaponPowerRet;
            }

            // 部隊ユニットはダメージを受けると攻撃力が低下
            if (IsFeatureAvailable("部隊ユニット"))
            {
                WeaponPowerRet = ((long)(WeaponPowerRet * (50d + 50 * HP / (double)MaxHP)) / 100L);
            }

            // 標的のいる地形が設定されていないときは武器の一覧表示用なので各種補正を省く
            if (string.IsNullOrEmpty(tarea))
            {
                return WeaponPowerRet;
            }

            {
                var withBlock = MainPilot();
                if (SRC.BCList.IsDefined("攻撃補正"))
                {
                    // バトルコンフィグデータの設定による修正
                    if (IsWeaponClassifiedAs(w, "複"))
                    {
                        pat = (withBlock.Infight + withBlock.Shooting) / 2;
                    }
                    else if (IsWeaponClassifiedAs(w, "格闘系"))
                    {
                        pat = withBlock.Infight;
                    }
                    else
                    {
                        pat = withBlock.Shooting;
                    }

                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = this;
                    BCVariable.AtkUnit = this;
                    // UPGRADE_NOTE: オブジェクト BCVariable.DefUnit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                    BCVariable.DefUnit = null;
                    BCVariable.WeaponNumber = w;
                    BCVariable.AttackExp = pat;
                    BCVariable.WeaponPower = WeaponPowerRet;
                    WeaponPowerRet = SRC.BCList.Item("攻撃補正").Calculate();
                }
                else
                {
                    // パイロットの攻撃力による修正

                    if (IsWeaponClassifiedAs(w, "複"))
                    {
                        WeaponPowerRet = WeaponPowerRet * (withBlock.Infight + withBlock.Shooting) / 200;
                    }
                    else if (IsWeaponClassifiedAs(w, "格闘系"))
                    {
                        WeaponPowerRet = WeaponPowerRet * withBlock.Infight / 100;
                    }
                    else
                    {
                        WeaponPowerRet = WeaponPowerRet * withBlock.Shooting / 100;
                    }

                    // 気力による修正
                    if (Expression.IsOptionDefined("気力効果小"))
                    {
                        WeaponPowerRet = WeaponPowerRet * (50 + (withBlock.Morale + withBlock.MoraleMod) / 2) / 100;
                    }
                    else
                    {
                        WeaponPowerRet = WeaponPowerRet * (withBlock.Morale + withBlock.MoraleMod) / 100;
                    }
                }

                // 覚悟
                if (HP <= MaxHP / 4)
                {
                    if (withBlock.IsSkillAvailable("覚悟"))
                    {
                        if (Expression.IsOptionDefined("ダメージ倍率低下"))
                        {
                            WeaponPowerRet = (1.1d * WeaponPowerRet);
                        }
                        else
                        {
                            WeaponPowerRet = (1.2d * WeaponPowerRet);
                        }
                    }
                }
            }

            // マップ攻撃用に攻撃力算出
            if (tarea == "初期値")
            {
                return WeaponPowerRet;
            }

            // マップ攻撃は攻撃開始時に保存した攻撃力をそのまま使う
            if (IsWeaponClassifiedAs(w, "Ｍ"))
            {
                if (SelectedMapAttackPower > 0)
                {
                    WeaponPowerRet = SelectedMapAttackPower;
                }
            }

            // 地形補正
            if (SRC.BCList.IsDefined("攻撃地形補正"))
            {
                // 事前にデータを登録
                BCVariable.DataReset();
                BCVariable.MeUnit = this;
                BCVariable.AtkUnit = this;
                // UPGRADE_NOTE: オブジェクト BCVariable.DefUnit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                BCVariable.DefUnit = null;
                BCVariable.WeaponNumber = w;
                BCVariable.AttackExp = WeaponPowerRet;
                BCVariable.TerrainAdaption = WeaponAdaption(w, tarea);
                WeaponPowerRet = SRC.BCList.Item("攻撃地形補正").Calculate();
            }
            else
            {
                WeaponPowerRet = (WeaponPowerRet * WeaponAdaption(w, tarea));
            }

            return WeaponPowerRet;
        }

        // 武器 w の地形 tarea におけるダメージ修正値
        public double WeaponAdaption(int w, string tarea)
        {
            double WeaponAdaptionRet = default;
            int wad = default, uad, xad;
            int ind;

            // 武器の地形適応値の計算に使用する適応値を決定
            switch (tarea ?? "")
            {
                case "空中":
                    {
                        ind = 1;
                        break;
                    }

                case "地上":
                    {
                        if (Map.TerrainClass(x, y) == "月面")
                        {
                            ind = 4;
                        }
                        else
                        {
                            ind = 2;
                        }

                        break;
                    }

                case "水上":
                    {
                        if (Strings.Mid(Weapon(w).Adaption, 3, 1) == "A")
                        {
                            ind = 3;
                        }
                        else
                        {
                            ind = 2;
                        }

                        break;
                    }

                case "水中":
                    {
                        ind = 3;
                        break;
                    }

                case "宇宙":
                    {
                        ind = 4;
                        break;
                    }

                case "地中":
                    {
                        WeaponAdaptionRet = 0d;
                        return WeaponAdaptionRet;
                    }

                default:
                    {
                        xad = 4;
                        goto CalcAdaption;
                        break;
                    }
            }

            // 武器の地形適応値
            switch (Strings.Mid(Weapon(w).Adaption, ind, 1) ?? "")
            {
                case "S":
                    {
                        wad = 5;
                        break;
                    }

                case "A":
                    {
                        wad = 4;
                        break;
                    }

                case "B":
                    {
                        wad = 3;
                        break;
                    }

                case "C":
                    {
                        wad = 2;
                        break;
                    }

                case "D":
                    {
                        wad = 1;
                        break;
                    }

                case "-":
                    {
                        WeaponAdaptionRet = 0d;
                        return WeaponAdaptionRet;
                    }
            }

            // ユニットの地形適応値の計算に使用する適応値を決定
            if (!IsWeaponClassifiedAs(w, "武") && !IsWeaponClassifiedAs(w, "突") && !IsWeaponClassifiedAs(w, "接"))
            {
                // 格闘戦以外の場合はユニットがいる地形を参照
                switch (Area ?? "")
                {
                    case "空中":
                        {
                            ind = 1;
                            break;
                        }

                    case "地上":
                        {
                            if (Map.TerrainClass(x, y) == "月面")
                            {
                                ind = 4;
                            }
                            else
                            {
                                ind = 2;
                            }

                            break;
                        }

                    case "水上":
                        {
                            ind = 2;
                            break;
                        }

                    case "水中":
                        {
                            ind = 3;
                            break;
                        }

                    case "宇宙":
                        {
                            ind = 4;
                            break;
                        }

                    case "地中":
                        {
                            WeaponAdaptionRet = 0d;
                            return WeaponAdaptionRet;
                        }
                }
                // ユニットの地形適応値
                uad = get_Adaption(ind);
            }
            else
            {
                // 格闘戦の場合はターゲットがいる地形を参照
                switch (tarea ?? "")
                {
                    case "空中":
                        {
                            uad = get_Adaption(1);
                            // ジャンプ攻撃
                            if (IsWeaponClassifiedAs(w, "Ｊ"))
                            {
                                uad = (uad + WeaponLevel(w, "Ｊ"));
                            }

                            break;
                        }

                    case "地上":
                        {
                            if (get_Adaption(2) > 0)
                            {
                                uad = get_Adaption(2);
                            }
                            else
                            {
                                // 空中専用ユニットが地上のユニットに格闘戦をしかけられるようにする
                                uad = GeneralLib.MaxLng(get_Adaption(1) - 1, 0);
                            }

                            break;
                        }

                    case "水上":
                        {
                            // 水中専用ユニットが水上のユニットに格闘戦をしかけられるようにする
                            uad = GeneralLib.MaxDbl(get_Adaption(2), get_Adaption(3));
                            if (uad <= 0)
                            {
                                // 空中専用ユニットが地上のユニットに格闘戦をしかけられるようにする
                                uad = GeneralLib.MaxLng(get_Adaption(1) - 1, 0);
                            }

                            break;
                        }

                    case "水中":
                        {
                            uad = get_Adaption(3);
                            break;
                        }

                    case "宇宙":
                        {
                            uad = get_Adaption(4);
                            if (Area == "地上" && Map.TerrainClass(x, y) == "月面")
                            {
                                // 月面からのジャンプ攻撃
                                if (IsWeaponClassifiedAs(w, "Ｊ"))
                                {
                                    uad = (uad + WeaponLevel(w, "Ｊ"));
                                }
                            }

                            break;
                        }

                    default:
                        {
                            uad = get_Adaption(ind);
                            break;
                        }
                }
            }

            // 地形適応が命中率に適応される場合、ユニットの地形適応は攻撃可否の判定にのみ用いる
            if (Expression.IsOptionDefined("地形適応命中率修正"))
            {
                if (uad > 0)
                {
                    xad = wad;
                    goto CalcAdaption;
                }
                else
                {
                    WeaponAdaptionRet = 0d;
                    return WeaponAdaptionRet;
                }
            }

            // 武器側とユニット側の地形適応の低い方を優先
            if (uad > wad)
            {
                xad = wad;
            }
            else
            {
                xad = uad;
            }

            CalcAdaption:
            ;


            // Optionコマンドの設定に従って地形適応値を算出
            if (Expression.IsOptionDefined("地形適応修正緩和"))
            {
                if (Expression.IsOptionDefined("地形適応修正繰り下げ"))
                {
                    switch (xad)
                    {
                        case 5:
                            {
                                WeaponAdaptionRet = 1.1d;
                                break;
                            }

                        case 4:
                            {
                                WeaponAdaptionRet = 1d;
                                break;
                            }

                        case 3:
                            {
                                WeaponAdaptionRet = 0.9d;
                                break;
                            }

                        case 2:
                            {
                                WeaponAdaptionRet = 0.8d;
                                break;
                            }

                        case 1:
                            {
                                WeaponAdaptionRet = 0.7d;
                                break;
                            }

                        default:
                            {
                                WeaponAdaptionRet = 0d;
                                break;
                            }
                    }
                }
                else
                {
                    switch (xad)
                    {
                        case 5:
                            {
                                WeaponAdaptionRet = 1.2d;
                                break;
                            }

                        case 4:
                            {
                                WeaponAdaptionRet = 1.1d;
                                break;
                            }

                        case 3:
                            {
                                WeaponAdaptionRet = 1d;
                                break;
                            }

                        case 2:
                            {
                                WeaponAdaptionRet = 0.9d;
                                break;
                            }

                        case 1:
                            {
                                WeaponAdaptionRet = 0.8d;
                                break;
                            }

                        default:
                            {
                                WeaponAdaptionRet = 0d;
                                break;
                            }
                    }
                }
            }
            else
            {
                if (Expression.IsOptionDefined("地形適応修正繰り下げ"))
                {
                    switch (xad)
                    {
                        case 5:
                            {
                                WeaponAdaptionRet = 1.2d;
                                break;
                            }

                        case 4:
                            {
                                WeaponAdaptionRet = 1d;
                                break;
                            }

                        case 3:
                            {
                                WeaponAdaptionRet = 0.8d;
                                break;
                            }

                        case 2:
                            {
                                WeaponAdaptionRet = 0.6d;
                                break;
                            }

                        case 1:
                            {
                                WeaponAdaptionRet = 0.4d;
                                break;
                            }

                        default:
                            {
                                WeaponAdaptionRet = 0d;
                                break;
                            }
                    }
                }
                else
                {
                    switch (xad)
                    {
                        case 5:
                            {
                                WeaponAdaptionRet = 1.4d;
                                break;
                            }

                        case 4:
                            {
                                WeaponAdaptionRet = 1.2d;
                                break;
                            }

                        case 3:
                            {
                                WeaponAdaptionRet = 1d;
                                break;
                            }

                        case 2:
                            {
                                WeaponAdaptionRet = 0.8d;
                                break;
                            }

                        case 1:
                            {
                                WeaponAdaptionRet = 0.6d;
                                break;
                            }

                        default:
                            {
                                WeaponAdaptionRet = 0d;
                                break;
                            }
                    }
                }
            }

            return WeaponAdaptionRet;
        }

        // 武器 w の最大射程
        public int WeaponMaxRange(int w)
        {
            int WeaponMaxRangeRet = default;
            WeaponMaxRangeRet = intWeaponMaxRange[w];

            // 最大射程がもともと１ならそれ以上変化しない
            if (WeaponMaxRangeRet == 1)
            {
                return WeaponMaxRangeRet;
            }

            // マップ攻撃には適用されない
            if (IsWeaponClassifiedAs(w, "Ｍ"))
            {
                return WeaponMaxRangeRet;
            }

            // 接近戦武器には適用されない
            if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
            {
                return WeaponMaxRangeRet;
            }

            // 有線式誘導攻撃には適用されない
            if (IsWeaponClassifiedAs(w, "有"))
            {
                return WeaponMaxRangeRet;
            }

            // スペシャルパワーによる射程延長
            if (IsUnderSpecialPowerEffect("射程延長"))
            {
                WeaponMaxRangeRet = (WeaponMaxRangeRet + SpecialPowerEffectLevel("射程延長"));
            }

            return WeaponMaxRangeRet;
        }

        // 武器 w の消費ＥＮ
        public int WeaponENConsumption(int w)
        {
            int WeaponENConsumptionRet = default;
            // UPGRADE_NOTE: rate は rate にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
            double rate;
            int i;
            {
                var withBlock = Weapon(w);
                WeaponENConsumptionRet = withBlock.ENConsumption;

                // パイロットの能力によって術及び技の消費ＥＮは減少する
                if (CountPilot() > 0)
                {
                    // 術に該当するか？
                    if (IsSpellWeapon(w))
                    {
                        // 術に該当する場合は術技能によってＥＮ消費量を変える
                        switch (MainPilot().SkillLevel("術", ref_mode: ""))
                        {
                            case 1d:
                                {
                                    break;
                                }

                            case 2d:
                                {
                                    WeaponENConsumptionRet = (0.9d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 3d:
                                {
                                    WeaponENConsumptionRet = (0.8d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 4d:
                                {
                                    WeaponENConsumptionRet = (0.7d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 5d:
                                {
                                    WeaponENConsumptionRet = (0.6d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 6d:
                                {
                                    WeaponENConsumptionRet = (0.5d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 7d:
                                {
                                    WeaponENConsumptionRet = (0.45d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 8d:
                                {
                                    WeaponENConsumptionRet = (0.4d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 9d:
                                {
                                    WeaponENConsumptionRet = (0.35d * WeaponENConsumptionRet);
                                    break;
                                }

                            case var @case when @case >= 10d:
                                {
                                    WeaponENConsumptionRet = (0.3d * WeaponENConsumptionRet);
                                    break;
                                }
                        }

                        WeaponENConsumptionRet = GeneralLib.MinLng(GeneralLib.MaxLng(WeaponENConsumptionRet, 5), withBlock.ENConsumption);
                    }

                    // 技に該当するか？
                    if (IsFeatWeapon(w))
                    {
                        // 技に該当する場合は技技能によってＥＮ消費量を変える
                        switch (MainPilot().SkillLevel("技", ref_mode: ""))
                        {
                            case 1d:
                                {
                                    break;
                                }

                            case 2d:
                                {
                                    WeaponENConsumptionRet = (0.9d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 3d:
                                {
                                    WeaponENConsumptionRet = (0.8d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 4d:
                                {
                                    WeaponENConsumptionRet = (0.7d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 5d:
                                {
                                    WeaponENConsumptionRet = (0.6d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 6d:
                                {
                                    WeaponENConsumptionRet = (0.5d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 7d:
                                {
                                    WeaponENConsumptionRet = (0.45d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 8d:
                                {
                                    WeaponENConsumptionRet = (0.4d * WeaponENConsumptionRet);
                                    break;
                                }

                            case 9d:
                                {
                                    WeaponENConsumptionRet = (0.35d * WeaponENConsumptionRet);
                                    break;
                                }

                            case var case1 when case1 >= 10d:
                                {
                                    WeaponENConsumptionRet = (0.3d * WeaponENConsumptionRet);
                                    break;
                                }
                        }

                        WeaponENConsumptionRet = GeneralLib.MinLng(GeneralLib.MaxLng(WeaponENConsumptionRet, 5), withBlock.ENConsumption);
                    }
                }

                // ＥＮ消費減少能力による修正
                rate = 1d;
                if (IsFeatureAvailable("ＥＮ消費減少"))
                {
                    var loopTo = CountFeature();
                    for (i = 1; i <= loopTo; i++)
                    {
                        if (Feature(i) == "ＥＮ消費減少")
                        {
                            double localFeatureLevel() { object argIndex1 = i; var ret = FeatureLevel(argIndex1); return ret; }

                            rate = rate - 0.1d * localFeatureLevel();
                        }
                    }
                }

                if (rate < 0.1d)
                {
                    rate = 0.1d;
                }

                WeaponENConsumptionRet = (rate * WeaponENConsumptionRet);
            }

            return WeaponENConsumptionRet;
        }

        // 武器 w の命中率
        public int WeaponPrecision(int w)
        {
            int WeaponPrecisionRet = default;
            WeaponPrecisionRet = intWeaponPrecision[w];
            return WeaponPrecisionRet;
        }

        // 武器 w のＣＴ率
        public int WeaponCritical(int w)
        {
            int WeaponCriticalRet = default;
            WeaponCriticalRet = intWeaponCritical[w];
            return WeaponCriticalRet;
        }

        // 武器 w の属性
        public string WeaponClass(int w)
        {
            string WeaponClassRet = default;
            WeaponClassRet = strWeaponClass[w];
            return WeaponClassRet;
        }

        // 武器 w が武器属性 attr を持っているかどうか
        public bool IsWeaponClassifiedAs(int w, string attr)
        {
            bool IsWeaponClassifiedAsRet = default;
            string wclass;
            wclass = strWeaponClass[w];

            // 属性が２文字以下ならそのまま判定
            if (Strings.Len(attr) <= 2)
            {
                if (GeneralLib.InStrNotNest(wclass, attr) > 0)
                {
                    IsWeaponClassifiedAsRet = true;
                }
                else
                {
                    IsWeaponClassifiedAsRet = false;
                }

                return IsWeaponClassifiedAsRet;
            }

            // 属性の頭文字が弱攻剋ならそのまま判定
            if (Strings.InStr("弱効剋", Strings.Left(attr, 1)) > 0)
            {
                if (GeneralLib.InStrNotNest(wclass, attr) > 0)
                {
                    IsWeaponClassifiedAsRet = true;
                }
                else
                {
                    IsWeaponClassifiedAsRet = false;
                }

                return IsWeaponClassifiedAsRet;
            }

            // 条件が複雑な場合
            switch (attr ?? "")
            {
                case "格闘系":
                    {
                        if (GeneralLib.InStrNotNest(wclass, "格") > 0)
                        {
                            IsWeaponClassifiedAsRet = true;
                        }
                        else if (GeneralLib.InStrNotNest(wclass, "射") > 0)
                        {
                            IsWeaponClassifiedAsRet = false;
                        }
                        else if (this.Weapon(w).MaxRange == 1)
                        {
                            IsWeaponClassifiedAsRet = true;
                        }
                        else
                        {
                            IsWeaponClassifiedAsRet = false;
                        }

                        return IsWeaponClassifiedAsRet;
                    }

                case "射撃系":
                    {
                        if (GeneralLib.InStrNotNest(wclass, "格") > 0)
                        {
                            IsWeaponClassifiedAsRet = false;
                        }
                        else if (GeneralLib.InStrNotNest(wclass, "射") > 0)
                        {
                            IsWeaponClassifiedAsRet = true;
                        }
                        else if (this.Weapon(w).MaxRange == 1)
                        {
                            IsWeaponClassifiedAsRet = false;
                        }
                        else
                        {
                            IsWeaponClassifiedAsRet = true;
                        }

                        break;
                    }

                case "移動後攻撃可":
                    {
                        if (IsUnderSpecialPowerEffect("全武器移動後使用可能") && GeneralLib.InStrNotNest(wclass, "Ｍ") == 0 && GeneralLib.InStrNotNest(wclass, "Ｑ") == 0)
                        {
                            IsWeaponClassifiedAsRet = true;
                        }
                        else if (this.Weapon(w).MaxRange == 1)
                        {
                            if (GeneralLib.InStrNotNest(wclass, "Ｑ") == 0)
                            {
                                IsWeaponClassifiedAsRet = true;
                            }
                            else
                            {
                                IsWeaponClassifiedAsRet = false;
                            }
                        }
                        else if (GeneralLib.InStrNotNest(wclass, "Ｐ") > 0)
                        {
                            IsWeaponClassifiedAsRet = true;
                        }

                        break;
                    }
            }

            return IsWeaponClassifiedAsRet;
        }

        // 武器 w の属性 attr におけるレベル
        public double WeaponLevel(int w, string attr)
        {
            double WeaponLevelRet = default;
            string attrlv, wclass;
            int start_idx, i;
            string c;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 164587


            Input:

                    On Error GoTo ErrorHandler

             */
            attrlv = attr + "L";

            // 武器属性を調べてみる
            wclass = strWeaponClass[w];

            // レベル指定があるか？
            start_idx = GeneralLib.InStrNotNest(wclass, attrlv);
            if (start_idx == 0)
            {
                return WeaponLevelRet;
            }

            // レベル指定部分の切り出し
            start_idx = (start_idx + Strings.Len(attrlv));
            i = start_idx;
            while (true)
            {
                c = Strings.Mid(wclass, i, 1);
                if (string.IsNullOrEmpty(c))
                {
                    break;
                }

                switch (Strings.Asc(c))
                {
                    case var @case when 45 <= @case && @case <= 46:
                    case var case1 when 48 <= case1 && case1 <= 57: // "-", ".", 0-9
                        {
                            break;
                        }

                    default:
                        {
                            break;
                        }
                }

                i = (i + 1);
            }

            WeaponLevelRet = Conversions.ToDouble(Strings.Mid(wclass, start_idx, i - start_idx));
            return WeaponLevelRet;
            ErrorHandler:
            ;
            GUI.ErrorMessage(Name + "の" + "武装「" + Weapon(w).Name + "」の" + "属性「" + attr + "」のレベル指定が不正です");
        }

        // 武器 w の属性 attr にレベル指定がなされているか
        public bool IsWeaponLevelSpecified(int w, string attr)
        {
            bool IsWeaponLevelSpecifiedRet = default;
            if (Strings.InStr(strWeaponClass[w], attr + "L") > 0)
            {
                IsWeaponLevelSpecifiedRet = true;
                return IsWeaponLevelSpecifiedRet;
            }

            return IsWeaponLevelSpecifiedRet;
        }

        // 武器 w が通常武器かどうか
        public bool IsNormalWeapon(int w)
        {
            bool IsNormalWeaponRet = default;
            int i;
            string wclass;
            int ret;

            // 特殊効果属性を持つ？
            wclass = strWeaponClass[w];
            var loopTo = Strings.Len(wclass);
            for (i = 1; i <= loopTo; i++)
            {
                ret = Strings.InStr("Ｓ縛劣中石凍痺眠乱魅恐踊狂ゾ害憑盲毒撹不止黙除即告脱Ｄ低吹Ｋ引転衰滅盗習写化弱効剋", Strings.Mid(wclass, i, 1));
                if (ret > 0)
                {
                    return IsNormalWeaponRet;
                }
            }

            IsNormalWeaponRet = true;
            return IsNormalWeaponRet;
        }

        // 武器が持つ特殊効果の数を返す
        public int CountWeaponEffect(int w)
        {
            int CountWeaponEffectRet = default;
            string wclass, wattr;
            int i, ret;
            wclass = strWeaponClass[w];
            var loopTo = Strings.Len(wclass);
            for (i = 1; i <= loopTo; i++)
            {
                // 弱Ｓのような入れ子があれば、入れ子の分カウントを進める
                wattr = GeneralLib.GetClassBundle(wclass, i, 1);

                // 非表示部分は無視
                if (wattr == "|")
                {
                    break;
                }

                // ＣＴ時発動系
                ret = Strings.InStr("Ｓ縛劣中石凍痺眠乱魅恐踊狂ゾ害憑盲毒撹不止黙除即告脱Ｄ低吹Ｋ引転衰滅盗習写化弱効剋", wattr);
                if (ret > 0)
                {
                    CountWeaponEffectRet = (CountWeaponEffectRet + 1);
                }

                // それ以外
                ret = Strings.InStr("先再忍貫固殺無浸破間浄吸減奪", wattr);
                if (ret > 0)
                {
                    CountWeaponEffectRet = (CountWeaponEffectRet + 1);
                }
            }

            return CountWeaponEffectRet;
        }

        // 武器 w が術かどうか
        public bool IsSpellWeapon(int w)
        {
            bool IsSpellWeaponRet = default;
            int i;
            string nskill;
            if (IsWeaponClassifiedAs(w, "術"))
            {
                IsSpellWeaponRet = true;
                return IsSpellWeaponRet;
            }

            {
                var withBlock = MainPilot();
                var loopTo = GeneralLib.LLength(Weapon(w).NecessarySkill);
                for (i = 1; i <= loopTo; i++)
                {
                    nskill = GeneralLib.LIndex(Weapon(w).NecessarySkill, i);
                    if (Strings.InStr(nskill, "Lv") > 0)
                    {
                        nskill = Strings.Left(nskill, Strings.InStr(nskill, "Lv") - 1);
                    }

                    if (withBlock.SkillType(nskill) == "術")
                    {
                        IsSpellWeaponRet = true;
                        return IsSpellWeaponRet;
                    }
                }
            }

            return IsSpellWeaponRet;
        }

        // 武器 w が技かどうか
        public bool IsFeatWeapon(int w)
        {
            bool IsFeatWeaponRet = default;
            int i;
            string nskill;
            if (IsWeaponClassifiedAs(w, "技"))
            {
                IsFeatWeaponRet = true;
                return IsFeatWeaponRet;
            }

            {
                var withBlock = MainPilot();
                var loopTo = GeneralLib.LLength(Weapon(w).NecessarySkill);
                for (i = 1; i <= loopTo; i++)
                {
                    nskill = GeneralLib.LIndex(Weapon(w).NecessarySkill, i);
                    if (Strings.InStr(nskill, "Lv") > 0)
                    {
                        nskill = Strings.Left(nskill, Strings.InStr(nskill, "Lv") - 1);
                    }

                    if (withBlock.SkillType(nskill) == "技")
                    {
                        IsFeatWeaponRet = true;
                        return IsFeatWeaponRet;
                    }
                }
            }

            return IsFeatWeaponRet;
        }

        // 武器 w が使用可能かどうか
        // ref_mode はユニットの状態（移動前、移動後）を示す
        public bool IsWeaponAvailable(int w, string ref_mode)
        {
            bool IsWeaponAvailableRet = default;
            int i;
            WeaponData wd;
            string wclass;
            IsWeaponAvailableRet = false;

            // ADD START MARGE
            // 武器が取得できない場合はFalse（防御や無抵抗の場合、wが0や-1になる）
            if (!(w > 0))
            {
                return IsWeaponAvailableRet;
            }
            // ADD END MARGE

            wd = Weapon(w);
            wclass = WeaponClass(w);

            // イベントコマンド「Disable」で封印されている？
            if (IsDisabled(wd.Name))
            {
                return IsWeaponAvailableRet;
            }

            // パイロットが乗っていなければ常に使用可能と判定
            if (CountPilot() == 0)
            {
                IsWeaponAvailableRet = true;
                return IsWeaponAvailableRet;
            }

            // 必要技能＆必要条件
            if (ref_mode != "必要技能無視")
            {
                if (!IsWeaponMastered(w))
                {
                    return IsWeaponAvailableRet;
                }

                if (!IsWeaponEnabled(w))
                {
                    return IsWeaponAvailableRet;
                }
            }

            // ステータス表示では必要技能だけ満たしていればＯＫ
            if (ref_mode == "インターミッション" || string.IsNullOrEmpty(ref_mode))
            {
                IsWeaponAvailableRet = true;
                return IsWeaponAvailableRet;
            }

            {
                var withBlock = MainPilot();
                // 必要気力
                if (wd.NecessaryMorale > 0)
                {
                    if (withBlock.Morale < wd.NecessaryMorale)
                    {
                        return IsWeaponAvailableRet;
                    }
                }

                // 霊力消費攻撃
                if (GeneralLib.InStrNotNest(wclass, "霊") > 0)
                {
                    if (withBlock.Plana < WeaponLevel(w, "霊") * 5d)
                    {
                        return IsWeaponAvailableRet;
                    }
                }
                else if (GeneralLib.InStrNotNest(wclass, "プ") > 0)
                {
                    if (withBlock.Plana < WeaponLevel(w, "プ") * 5d)
                    {
                        return IsWeaponAvailableRet;
                    }
                }
            }

            // 属性使用不能状態
            if (ConditionLifetime("オーラ使用不能") > 0)
            {
                if (IsWeaponClassifiedAs(w, "オ"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            if (ConditionLifetime("超能力使用不能") > 0)
            {
                if (IsWeaponClassifiedAs(w, "超"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            if (ConditionLifetime("同調率使用不能") > 0)
            {
                if (IsWeaponClassifiedAs(w, "シ"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            if (ConditionLifetime("超感覚使用不能") > 0)
            {
                if (IsWeaponClassifiedAs(w, "サ"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            if (ConditionLifetime("知覚強化使用不能") > 0)
            {
                if (IsWeaponClassifiedAs(w, "サ"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            if (ConditionLifetime("霊力使用不能") > 0)
            {
                if (IsWeaponClassifiedAs(w, "霊"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            if (ConditionLifetime("術使用不能") > 0)
            {
                if (IsWeaponClassifiedAs(w, "術"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            if (ConditionLifetime("技使用不能") > 0)
            {
                if (IsWeaponClassifiedAs(w, "技"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            var loopTo = CountCondition();
            for (i = 1; i <= loopTo; i++)
            {
                string localCondition3() { object argIndex1 = i; var ret = Condition(argIndex1); return ret; }

                if (Strings.Len(localCondition3()) > 6)
                {
                    string localCondition2() { object argIndex1 = i; var ret = Condition(argIndex1); return ret; }

                    if (Strings.Right(localCondition2(), 6) == "属性使用不能")
                    {
                        string localCondition() { object argIndex1 = i; var ret = Condition(argIndex1); return ret; }

                        string localCondition1() { object argIndex1 = i; var ret = Condition(argIndex1); return ret; }

                        if (GeneralLib.InStrNotNest(WeaponClass(w), Strings.Left(localCondition(), Strings.Len(localCondition1()) - 6)) > 0)
                        {
                            return IsWeaponAvailableRet;
                        }
                    }
                }
            }

            // 弾数が足りるか
            if (wd.Bullet > 0)
            {
                if (Bullet(w) < 1)
                {
                    return IsWeaponAvailableRet;
                }
            }

            // ＥＮが足りるか
            if (wd.ENConsumption > 0)
            {
                if (EN < WeaponENConsumption(w))
                {
                    return IsWeaponAvailableRet;
                }
            }

            // お金が足りるか……
            if (Party == "味方")
            {
                if (GeneralLib.InStrNotNest(wclass, "銭") > 0)
                {
                    if (SRC.Money < GeneralLib.MaxLng(WeaponLevel(w, "銭"), 1) * Value / 10)
                    {
                        return IsWeaponAvailableRet;
                    }
                }
            }

            // 攻撃不能？
            if (ref_mode != "ステータス")
            {
                if (IsConditionSatisfied("攻撃不能"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            if (Area == "地中")
            {
                return IsWeaponAvailableRet;
            }

            // 移動不能時には移動型マップ攻撃は使用不能
            if (IsConditionSatisfied("移動不能"))
            {
                if (GeneralLib.InStrNotNest(wclass, "Ｍ移") > 0)
                {
                    return IsWeaponAvailableRet;
                }
            }

            // 術および音は沈黙状態では使用不能
            if (IsConditionSatisfied("沈黙"))
            {
                if (IsSpellWeapon(w) || GeneralLib.InStrNotNest(wclass, "音") > 0)
                {
                    return IsWeaponAvailableRet;
                }
            }

            // 合体技の処理
            if (GeneralLib.InStrNotNest(wclass, "合") > 0)
            {
                if (!IsCombinationAttackAvailable(w))
                {
                    return IsWeaponAvailableRet;
                }
            }

            // 変形技の場合は今いる地形で変形できる必要あり
            if (GeneralLib.InStrNotNest(wclass, "変") > 0)
            {
                if (IsFeatureAvailable("変形技"))
                {
                    var loopTo1 = CountFeature();
                    for (i = 1; i <= loopTo1; i++)
                    {
                        string localFeature() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                        string localFeatureData1() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        string localLIndex1() { string arglist = hs333745e4b9954fad9f002aac9fe60516(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                        if (localFeature() == "変形技" && (localLIndex1() ?? "") == (wd.Name ?? ""))
                        {
                            string localFeatureData() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            string localLIndex() { string arglist = hsabc0da5e677a47f9bc7fb2c4e22fffab(); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                            Unit localOtherForm() { object argIndex1 = (object)hs70465cd27baa4b1bac8f45eec4036bb3(); var ret = OtherForm(argIndex1); return ret; }

                            if (!localOtherForm().IsAbleToEnter(x, y))
                            {
                                return IsWeaponAvailableRet;
                            }
                        }
                    }
                }
                else if (IsFeatureAvailable("ノーマルモード"))
                {
                    string localLIndex2() { object argIndex1 = "ノーマルモード"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                    Unit localOtherForm1() { object argIndex1 = (object)hs8f54e202dcbe4b6290740ebc209beb99(); var ret = OtherForm(argIndex1); return ret; }

                    if (!localOtherForm1().IsAbleToEnter(x, y))
                    {
                        return IsWeaponAvailableRet;
                    }
                }

                if (IsConditionSatisfied("形態固定"))
                {
                    return IsWeaponAvailableRet;
                }

                if (IsConditionSatisfied("機体固定"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            // 瀕死時限定
            if (GeneralLib.InStrNotNest(wclass, "瀕") > 0)
            {
                if (HP > MaxHP / 4)
                {
                    return IsWeaponAvailableRet;
                }
            }

            // 自動チャージ攻撃を再充填中
            if (IsConditionSatisfied(WeaponNickname(w) + "充填中"))
            {
                return IsWeaponAvailableRet;
            }
            // 共有武器＆アビリティが充填中の場合も使用不可
            int lv;
            if (GeneralLib.InStrNotNest(wclass, "共") > 0)
            {
                lv = WeaponLevel(w, "共");
                var loopTo2 = CountWeapon();
                for (i = 1; i <= loopTo2; i++)
                {
                    if (IsWeaponClassifiedAs(i, "共"))
                    {
                        if (lv == WeaponLevel(i, "共"))
                        {
                            if (IsConditionSatisfied(WeaponNickname(i) + "充填中"))
                            {
                                return IsWeaponAvailableRet;
                            }
                        }
                    }
                }

                var loopTo3 = CountAbility();
                for (i = 1; i <= loopTo3; i++)
                {
                    if (IsAbilityClassifiedAs(i, "共"))
                    {
                        if (lv == AbilityLevel(i, "共"))
                        {
                            if (IsConditionSatisfied(AbilityNickname(i) + "充填中"))
                            {
                                return IsWeaponAvailableRet;
                            }
                        }
                    }
                }
            }

            // 能力コピー
            if (GeneralLib.InStrNotNest(wclass, "写") > 0 || GeneralLib.InStrNotNest(wclass, "化") > 0)
            {
                if (IsFeatureAvailable("ノーマルモード"))
                {
                    // 既に変身済みの場合はコピー出来ない
                    return IsWeaponAvailableRet;
                }
            }

            // 使用禁止
            if (GeneralLib.InStrNotNest(wclass, "禁") > 0)
            {
                return IsWeaponAvailableRet;
            }

            // チャージ判定であればここまででＯＫ
            if (ref_mode == "チャージ")
            {
                IsWeaponAvailableRet = true;
                return IsWeaponAvailableRet;
            }

            // チャージ式攻撃
            if (GeneralLib.InStrNotNest(wclass, "Ｃ") > 0)
            {
                if (!IsConditionSatisfied("チャージ完了"))
                {
                    return IsWeaponAvailableRet;
                }
            }

            if (ref_mode == "ステータス")
            {
                IsWeaponAvailableRet = true;
                return IsWeaponAvailableRet;
            }

            // 反撃かどうかの判定
            // 自軍のフェイズでなければ反撃時である
            if ((Party ?? "") != (SRC.Stage ?? ""))
            {
                // 反撃ではマップ攻撃、合体技は使用できない
                if (GeneralLib.InStrNotNest(wclass, "Ｍ") > 0 || GeneralLib.InStrNotNest(wclass, "合") > 0)
                {
                    return IsWeaponAvailableRet;
                }

                // 攻撃専用武器
                if (GeneralLib.InStrNotNest(wclass, "攻") > 0)
                {
                    var loopTo4 = Strings.Len(wclass);
                    for (i = 1; i <= loopTo4; i++)
                    {
                        if (Strings.Mid(wclass, i, 1) == "攻")
                        {
                            if (i == 1)
                            {
                                return IsWeaponAvailableRet;
                            }

                            if (Strings.Mid(wclass, i - 1, 1) != "低")
                            {
                                return IsWeaponAvailableRet;
                            }
                        }
                    }
                }
            }
            else
            {
                // 反撃専用攻撃
                if (GeneralLib.InStrNotNest(wclass, "反") > 0)
                {
                    return IsWeaponAvailableRet;
                }
            }

            // 移動前か後か……
            if (ref_mode == "移動前" || ref_mode == "必要技能無視" || !ReferenceEquals(Commands.SelectedUnit, this))
            {
                IsWeaponAvailableRet = true;
                return IsWeaponAvailableRet;
            }

            // 移動後の場合
            if (IsUnderSpecialPowerEffect("全武器移動後使用可能") && !(GeneralLib.InStrNotNest(wclass, "Ｍ") > 0))
            {
                IsWeaponAvailableRet = true;
            }
            else if (WeaponMaxRange(w) > 1)
            {
                if (GeneralLib.InStrNotNest(wclass, "Ｐ") > 0)
                {
                    IsWeaponAvailableRet = true;
                }
                else
                {
                    IsWeaponAvailableRet = false;
                }
            }
            else
            {
                if (GeneralLib.InStrNotNest(wclass, "Ｑ") > 0)
                {
                    IsWeaponAvailableRet = false;
                }
                else
                {
                    IsWeaponAvailableRet = true;
                }
            }

            return IsWeaponAvailableRet;
        }

        // 武器 w の使用技能を満たしているか。
        public bool IsWeaponMastered(int w)
        {
            bool IsWeaponMasteredRet = default;
            IsWeaponMasteredRet = IsNecessarySkillSatisfied(Weapon(w).NecessarySkill, p: null);
            return IsWeaponMasteredRet;
        }

        // 武器 w の使用条件を満たしているか。
        public bool IsWeaponEnabled(int w)
        {
            bool IsWeaponEnabledRet = default;
            IsWeaponEnabledRet = IsNecessarySkillSatisfied(Weapon(w).NecessaryCondition, p: null);
            return IsWeaponEnabledRet;
        }

        // 武器が使用可能であり、かつ射程内に敵がいるかどうか
        public bool IsWeaponUseful(int w, string ref_mode)
        {
            bool IsWeaponUsefulRet = default;
            int i, j;
            Unit u;
            int max_range;

            // 武器が使用可能か？
            if (!IsWeaponAvailable(w, ref_mode))
            {
                IsWeaponUsefulRet = false;
                return IsWeaponUsefulRet;
            }

            // 扇型マップ攻撃は特殊なので判定ができない
            // 移動型マップ攻撃は移動手段として使うことを考慮
            if (IsWeaponClassifiedAs(w, "Ｍ扇") || IsWeaponClassifiedAs(w, "Ｍ移"))
            {
                IsWeaponUsefulRet = true;
                return IsWeaponUsefulRet;
            }

            max_range = WeaponMaxRange(w);

            // 投下型マップ攻撃は効果範囲が広い
            max_range = (max_range + WeaponLevel(w, "Ｍ投"));

            // 敵の存在判定
            var loopTo = GeneralLib.MinLng(x + max_range, Map.MapWidth);
            for (i = GeneralLib.MaxLng(x - max_range, 1); i <= loopTo; i++)
            {
                var loopTo1 = GeneralLib.MinLng(y + max_range, Map.MapHeight);
                for (j = GeneralLib.MaxLng(y - max_range, 1); j <= loopTo1; j++)
                {
                    u = Map.MapDataForUnit[i, j];
                    if (u is null)
                    {
                        goto NextUnit;
                    }

                    {
                        var withBlock = u;
                        switch (Party ?? "")
                        {
                            case "味方":
                            case "ＮＰＣ":
                                {
                                    switch (withBlock.Party ?? "")
                                    {
                                        case "味方":
                                        case "ＮＰＣ":
                                            {
                                                // ステータス異常の場合は味方ユニットでも排除可能
                                                if (!withBlock.IsConditionSatisfied("暴走") && !withBlock.IsConditionSatisfied("混乱") && !withBlock.IsConditionSatisfied("魅了") && !withBlock.IsConditionSatisfied("憑依") && !withBlock.IsConditionSatisfied("睡眠"))
                                                {
                                                    goto NextUnit;
                                                }

                                                break;
                                            }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if ((Party ?? "") == (withBlock.Party ?? ""))
                                    {
                                        // ステータス異常の場合は味方ユニットでも排除可能
                                        if (!withBlock.IsConditionSatisfied("暴走") && !withBlock.IsConditionSatisfied("混乱") && !withBlock.IsConditionSatisfied("魅了") && !withBlock.IsConditionSatisfied("憑依"))
                                        {
                                            goto NextUnit;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    if (IsTargetWithinRange(w, u))
                    {
                        if (this.Weapon(w).Power > 0)
                        {
                            if (Damage(w, u, true) != 0)
                            {
                                IsWeaponUsefulRet = true;
                                return IsWeaponUsefulRet;
                            }
                        }
                        else if (CriticalProbability(w, u) > 0)
                        {
                            IsWeaponUsefulRet = true;
                            return IsWeaponUsefulRet;
                        }
                    }

                    NextUnit:
                    ;
                }
            }

            // 敵は見つからなかった
            IsWeaponUsefulRet = false;
            return IsWeaponUsefulRet;
        }


        // ユニット t が武器 w の射程範囲内にいるかをチェック
        public bool IsTargetWithinRange(int w, Unit t)
        {
            bool IsTargetWithinRangeRet = default;
            int max_range, distance, range_mod;
            int lv;
            IsTargetWithinRangeRet = true;
            var partners = default(Unit[]);
            // 距離を算出
            distance = (Math.Abs((x - t.x)) + Math.Abs((y - t.y)));

            // Ｍ投武器は目標地点からさらに効果範囲が伸びるので射程修正を行う
            range_mod = WeaponLevel(w, "Ｍ投");

            // 最大射程チェック
            max_range = WeaponMaxRange(w);
            if (distance > (max_range + range_mod))
            {
                IsTargetWithinRangeRet = false;
                return IsTargetWithinRangeRet;
            }

            // 最小射程チェック
            if (distance < (this.Weapon(w).MinRange - range_mod))
            {
                IsTargetWithinRangeRet = false;
                return IsTargetWithinRangeRet;
            }

            // 敵がステルスの場合
            if (t.IsFeatureAvailable("ステルス"))
            {
                if (t.IsFeatureLevelSpecified("ステルス"))
                {
                    lv = t.FeatureLevel("ステルス");
                }
                else
                {
                    lv = 3;
                }

                if (!t.IsConditionSatisfied("ステルス無効") && !IsFeatureAvailable("ステルス無効化") && distance > lv)
                {
                    IsTargetWithinRangeRet = false;
                    return IsTargetWithinRangeRet;
                }
            }

            // 隠れ身中？
            if (t.IsUnderSpecialPowerEffect("隠れ身"))
            {
                if (!t.IsUnderSpecialPowerEffect("無防備"))
                {
                    IsTargetWithinRangeRet = false;
                    return IsTargetWithinRangeRet;
                }
            }

            // 攻撃できない地形にいる場合は射程外とみなす
            if (WeaponAdaption(w, t.Area) == 0d)
            {
                IsTargetWithinRangeRet = false;
                return IsTargetWithinRangeRet;
            }

            // 合体技で射程が１の場合は相手を囲んでいる必要がある
            if (IsWeaponClassifiedAs(w, "合") && !IsWeaponClassifiedAs(w, "Ｍ") && max_range == 1)
            {
                CombinationPartner("武装", w, partners, t.x, t.y);
                if (Information.UBound(partners) == 0)
                {
                    IsTargetWithinRangeRet = false;
                    return IsTargetWithinRangeRet;
                }
            }

            return IsTargetWithinRangeRet;
        }

        // 移動を併用した場合にユニット t が武器 w の射程範囲内にいるかをチェック
        public bool IsTargetReachable(int w, Unit t)
        {
            bool IsTargetReachableRet = default;
            int i, j;
            int max_range, min_range;
            var partners = default(Unit[]);
            // 地形適応をチェック
            if (WeaponAdaption(w, t.Area) == 0d)
            {
                IsTargetReachableRet = false;
                return IsTargetReachableRet;
            }

            // 隠れ身使用中？
            if (t.IsUnderSpecialPowerEffect("隠れ身"))
            {
                if (!t.IsUnderSpecialPowerEffect("無防備"))
                {
                    IsTargetReachableRet = false;
                    return IsTargetReachableRet;
                }
            }

            // 射程計算
            min_range = Weapon(w).MinRange;
            max_range = WeaponMaxRange(w);
            // 敵がステルスの場合
            if (t.IsFeatureAvailable("ステルス") && !t.IsConditionSatisfied("ステルス無効") && !IsFeatureAvailable("ステルス無効化"))
            {
                if (t.IsFeatureLevelSpecified("ステルス"))
                {
                    max_range = GeneralLib.MinLng(max_range, (t.FeatureLevel("ステルス") + 1d));
                }
                else
                {
                    max_range = GeneralLib.MinLng(max_range, 4);
                }
            }

            // 隣接していれば必ず届く
            if (min_range == 1 && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
            {
                // ただし合体技の場合は例外……
                // 合体技で射程が１の場合は相手を囲んでいる必要がある
                if (IsWeaponClassifiedAs(w, "合") && !IsWeaponClassifiedAs(w, "Ｍ") && WeaponMaxRange(w) == 1)
                {
                    CombinationPartner("武装", w, partners, t.x, t.y);
                    if (Information.UBound(partners) == 0)
                    {
                        IsTargetReachableRet = false;
                        return IsTargetReachableRet;
                    }
                }

                IsTargetReachableRet = true;
                return IsTargetReachableRet;
            }

            // 移動範囲から敵に攻撃が届くかをチェック
            var loopTo = GeneralLib.MinLng(t.x + max_range, Map.MapWidth);
            for (i = GeneralLib.MaxLng(t.x - max_range, 1); i <= loopTo; i++)
            {
                var loopTo1 = GeneralLib.MinLng(t.y + (max_range - Math.Abs((t.x - i))), Map.MapHeight);
                for (j = GeneralLib.MaxLng(t.y - (max_range - Math.Abs((t.x - i))), 1); j <= loopTo1; j++)
                {
                    if (min_range <= (Math.Abs((t.x - i)) + Math.Abs((t.y - i))))
                    {
                        if (!Map.MaskData[i, j])
                        {
                            IsTargetReachableRet = true;
                            return IsTargetReachableRet;
                        }
                    }
                }
            }

            IsTargetReachableRet = false;
            return IsTargetReachableRet;
        }

        // 武器 w のユニット t に対する命中率
        // 敵ユニットはスペシャルパワー等による補正を考慮しないので
        // is_true_value によって補正を省くかどうかを指定できるようにしている
        public int HitProbability(int w, Unit t, bool is_true_value)
        {
            int HitProbabilityRet = default;
            int prob;
            int mpskill;
            int i, j;
            Unit u;
            var wclass = default(string);
            double ecm_lv = default, eccm_lv = default;
            string buf;
            string fdata;
            double flevel, prob_mod;
            int nmorale;
            // 命中、回避、地形補正、サイズ補正の数値を定義
            int ed_hit, ed_avd;
            double ed_aradap, ed_size = default;

            // 初期値
            ed_aradap = 1d;

            // スペシャルパワーによる捨て身状態
            if (t.IsUnderSpecialPowerEffect("無防備"))
            {
                HitProbabilityRet = 100;
                return HitProbabilityRet;
            }

            // パイロットの技量によって命中率を正確に予測できるか左右される
            mpskill = MainPilot().TacticalTechnique();

            // スペシャルパワーによる影響
            if (is_true_value || mpskill >= 160)
            {
                if (t.IsUnderSpecialPowerEffect("絶対回避"))
                {
                    HitProbabilityRet = 0;
                    return HitProbabilityRet;
                }

                if (IsUnderSpecialPowerEffect("絶対命中"))
                {
                    HitProbabilityRet = 1000;
                    return HitProbabilityRet;
                }
            }

            // 自ユニットによる修正
            {
                var withBlock = MainPilot();
                if (SRC.BCList.IsDefined("命中補正"))
                {
                    // 命中を一時保存
                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = this;
                    BCVariable.AtkUnit = this;
                    BCVariable.DefUnit = t;
                    BCVariable.WeaponNumber = w;
                    BCVariable.AttackExp = WeaponPrecision(w);
                    ed_hit = SRC.BCList.Item("命中補正").Calculate();
                }
                else
                {
                    // 命中を一時保存
                    ed_hit = 100 + withBlock.Hit + withBlock.Intuition + get_Mobility("") + WeaponPrecision(w);
                }
            }

            // 敵ユニットによる修正
            {
                var withBlock1 = t.MainPilot();
                if (SRC.BCList.IsDefined("回避補正"))
                {
                    // 回避を一時保存
                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = t;
                    BCVariable.AtkUnit = this;
                    BCVariable.DefUnit = t;
                    BCVariable.WeaponNumber = w;
                    ed_avd = SRC.BCList.Item("回避補正").Calculate();
                }
                else
                {
                    // 回避を一時保存
                    ed_avd = (withBlock1.Dodge + withBlock1.Intuition) + t.get_Mobility("");
                }
            }

            // 地形適応、サイズ修正の位置を変更
            var uadaption = default(double);
            string tarea;
            int tx, ty;
            {
                var withBlock2 = t;
                // 地形修正
                if (withBlock2.Area != "空中" && (withBlock2.Area != "宇宙" || Map.TerrainClass(withBlock2.x, withBlock2.y) != "月面"))
                {
                    // 地形修正を一時保存
                    ed_aradap = ed_aradap * (100 - Map.TerrainEffectForHit(withBlock2.x, withBlock2.y)) / 100d;
                }

                // 地形適応修正
                if (Expression.IsOptionDefined("地形適応命中率修正"))
                {

                    // 接近戦攻撃の場合はターゲット側の地形を参照
                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                    {
                        tarea = withBlock2.Area;
                        tx = withBlock2.x;
                        ty = withBlock2.y;
                    }
                    else
                    {
                        tarea = Area;
                        tx = x;
                        ty = y;
                    }

                    switch (tarea ?? "")
                    {
                        case "空中":
                            {
                                uadaption = get_AdaptionMod(1, 0);
                                // ジャンプ攻撃の場合はＪ属性による修正を加える
                                if ((withBlock2.Area == "空中" || withBlock2.Area == "宇宙") && Area != "空中" && Area != "宇宙" && !IsTransAvailable("空"))
                                {
                                    if (Conversions.ToBoolean(GeneralLib.InStrNotNest(wclass, "武") || GeneralLib.InStrNotNest(wclass, "突") || GeneralLib.InStrNotNest(wclass, "接")))
                                    {
                                        uadaption = get_AdaptionMod(1, WeaponLevel(w, "Ｊ"));
                                    }
                                }

                                break;
                            }

                        case "地上":
                            {
                                if (Map.TerrainClass(tx, ty) == "月面")
                                {
                                    uadaption = get_AdaptionMod(4, 0);
                                }
                                else
                                {
                                    uadaption = get_AdaptionMod(2, 0);
                                }

                                break;
                            }

                        case "水上":
                            {
                                uadaption = get_AdaptionMod(2, 0);
                                break;
                            }

                        case "水中":
                            {
                                uadaption = get_AdaptionMod(3, 0);
                                break;
                            }

                        case "宇宙":
                            {
                                uadaption = get_AdaptionMod(4, 0);
                                break;
                            }

                        case "地中":
                            {
                                HitProbabilityRet = 0;
                                return HitProbabilityRet;
                            }
                    }

                    // 地形修正を一時保存
                    ed_aradap = ed_aradap * uadaption;
                }

                // サイズ補正
                switch (withBlock2.Size ?? "")
                {
                    case "M":
                        {
                            ed_size = 1d;
                            break;
                        }

                    case "L":
                        {
                            ed_size = 1.2d;
                            break;
                        }

                    case "S":
                        {
                            ed_size = 0.8d;
                            break;
                        }

                    case "LL":
                        {
                            ed_size = 1.4d;
                            break;
                        }

                    case "SS":
                        {
                            ed_size = 0.5d;
                            break;
                        }

                    case "XL":
                        {
                            ed_size = 2d;
                            break;
                        }
                }
            }

            // 命中率計算実行
            if (SRC.BCList.IsDefined("命中率"))
            {
                // 事前にデータを登録
                BCVariable.DataReset();
                BCVariable.MeUnit = this;
                BCVariable.AtkUnit = this;
                BCVariable.DefUnit = t;
                BCVariable.WeaponNumber = w;
                BCVariable.AttackVariable = ed_hit;
                BCVariable.DffenceVariable = ed_avd;
                BCVariable.TerrainAdaption = ed_aradap;
                BCVariable.SizeMod = ed_size;
                prob = SRC.BCList.Item("命中率").Calculate();
            }
            else
            {
                prob = ((ed_hit - ed_avd) * ed_aradap * ed_size);
            }

            // 不意打ち
            if (IsFeatureAvailable("ステルス") && !IsConditionSatisfied("ステルス無効") && !t.IsFeatureAvailable("ステルス無効化"))
            {
                prob = prob + 20;
            }

            wclass = WeaponClass(w);
            int uad;
            {
                var withBlock3 = t;
                // 散属性武器は指定したレベル以上離れるほど命中がアップ
                if (GeneralLib.InStrNotNest(wclass, "散") > 0)
                {
                    switch ((Math.Abs((x - withBlock3.x)) + Math.Abs((y - withBlock3.y))))
                    {
                        case 1:
                            {
                                break;
                            }
                        // 修正なし
                        case 2:
                            {
                                prob = prob + 5;
                                break;
                            }

                        case 3:
                            {
                                prob = prob + 10;
                                break;
                            }

                        case 4:
                            {
                                prob = prob + 15;
                                break;
                            }

                        default:
                            {
                                prob = prob + 20;
                                break;
                            }
                    }
                }

                if (GeneralLib.InStrNotNest(wclass, "サ") == 0 && GeneralLib.InStrNotNest(wclass, "有") == 0 && GeneralLib.InStrNotNest(wclass, "誘") == 0 && GeneralLib.InStrNotNest(wclass, "追") == 0 && GeneralLib.InStrNotNest(wclass, "武") == 0 && GeneralLib.InStrNotNest(wclass, "突") == 0 && GeneralLib.InStrNotNest(wclass, "接") == 0)
                {
                    // 距離修正
                    if (Expression.IsOptionDefined("距離修正"))
                    {
                        if (GeneralLib.InStrNotNest(wclass, "Ｈ") == 0 && GeneralLib.InStrNotNest(wclass, "Ｍ") == 0)
                        {
                            if (Expression.IsOptionDefined("大型マップ"))
                            {
                                switch ((Math.Abs((x - withBlock3.x)) + Math.Abs((y - withBlock3.y))))
                                {
                                    case var @case when 1 <= @case && @case <= 4:
                                        {
                                            break;
                                        }
                                    // 修正なし
                                    case 5:
                                    case 6:
                                        {
                                            prob = (0.9d * prob);
                                            break;
                                        }

                                    case 7:
                                    case 8:
                                        {
                                            prob = (0.8d * prob);
                                            break;
                                        }

                                    case 9:
                                    case 10:
                                        {
                                            prob = (0.7d * prob);
                                            break;
                                        }

                                    default:
                                        {
                                            prob = (0.6d * prob);
                                            break;
                                        }
                                }
                            }
                            else if (Expression.IsOptionDefined("小型マップ"))
                            {
                                switch ((Math.Abs((x - withBlock3.x)) + Math.Abs((y - withBlock3.y))))
                                {
                                    case 1:
                                        {
                                            break;
                                        }
                                    // 修正なし
                                    case 2:
                                        {
                                            prob = (0.9d * prob);
                                            break;
                                        }

                                    case 3:
                                        {
                                            prob = (0.8d * prob);
                                            break;
                                        }

                                    case 4:
                                        {
                                            prob = (0.75d * prob);
                                            break;
                                        }

                                    case 5:
                                        {
                                            prob = (0.7d * prob);
                                            break;
                                        }

                                    case 6:
                                        {
                                            prob = (0.65d * prob);
                                            break;
                                        }

                                    default:
                                        {
                                            prob = (0.6d * prob);
                                            break;
                                        }
                                }
                            }
                            else
                            {
                                switch ((Math.Abs((x - withBlock3.x)) + Math.Abs((y - withBlock3.y))))
                                {
                                    case var case1 when 1 <= case1 && case1 <= 3:
                                        {
                                            break;
                                        }
                                    // 修正なし
                                    case 4:
                                        {
                                            prob = (0.9d * prob);
                                            break;
                                        }

                                    case 5:
                                        {
                                            prob = (0.8d * prob);
                                            break;
                                        }

                                    case 6:
                                        {
                                            prob = (0.7d * prob);
                                            break;
                                        }

                                    default:
                                        {
                                            prob = (0.6d * prob);
                                            break;
                                        }
                                }
                            }
                        }
                    }

                    // ＥＣＭ
                    var loopTo = GeneralLib.MinLng(withBlock3.x + 2, Map.MapWidth);
                    for (i = GeneralLib.MaxLng(withBlock3.x - 2, 1); i <= loopTo; i++)
                    {
                        var loopTo1 = GeneralLib.MinLng(withBlock3.y + 2, Map.MapHeight);
                        for (j = GeneralLib.MaxLng(withBlock3.y - 2, 1); j <= loopTo1; j++)
                        {
                            if (Math.Abs((withBlock3.x - i)) + Math.Abs((withBlock3.y - j)) <= 3)
                            {
                                u = Map.MapDataForUnit[i, j];
                                if (u is object)
                                {
                                    if (u.IsAlly(t))
                                    {
                                        ecm_lv = GeneralLib.MaxDbl(ecm_lv, u.FeatureLevel("ＥＣＭ"));
                                    }
                                    else if (u.IsAlly(this))
                                    {
                                        eccm_lv = GeneralLib.MaxDbl(eccm_lv, u.FeatureLevel("ＥＣＭ"));
                                    }
                                }
                            }
                        }
                    }
                    // ホーミング攻撃はＥＣＭの影響を強く受ける
                    if (GeneralLib.InStrNotNest(wclass, "Ｈ") > 0)
                    {
                        prob = ((long)(prob * (100d - 10d * GeneralLib.MaxDbl(ecm_lv - eccm_lv, 0d))) / 100L);
                    }
                    else
                    {
                        prob = ((long)(prob * (100d - 5d * GeneralLib.MaxDbl(ecm_lv - eccm_lv, 0d))) / 100L);
                    }
                }

                // ステルスによる補正
                if (withBlock3.IsFeatureAvailable("ステルス") && !IsFeatureAvailable("ステルス無効化"))
                {
                    if (withBlock3.IsFeatureLevelSpecified("ステルス"))
                    {
                        if (Math.Abs((x - withBlock3.x)) + Math.Abs((y - withBlock3.y)) > withBlock3.FeatureLevel("ステルス"))
                        {
                            prob = (prob * 0.8d);
                        }
                    }
                    else if (Math.Abs((x - withBlock3.x)) + Math.Abs((y - withBlock3.y)) > 3)
                    {
                        prob = (prob * 0.8d);
                    }
                }

                // 地上から空中の敵に攻撃する
                if ((withBlock3.Area == "空中" || withBlock3.Area == "宇宙") && Area != "空中" && Area != "宇宙")
                {
                    if (Conversions.ToBoolean(GeneralLib.InStrNotNest(wclass, "武") || GeneralLib.InStrNotNest(wclass, "突") || GeneralLib.InStrNotNest(wclass, "接")))
                    {
                        // ジャンプ攻撃
                        if (!Expression.IsOptionDefined("地形適応命中率修正"))
                        {
                            if (!IsTransAvailable("空"))
                            {
                                uad = get_Adaption(1);
                                if (GeneralLib.InStrNotNest(wclass, "Ｊ") > 0)
                                {
                                    uad = GeneralLib.MinLng((uad + WeaponLevel(w, "Ｊ")), 4);
                                }

                                uad = GeneralLib.MinLng(uad, 4);
                                prob = (uad + 6) * prob / 10;
                            }
                        }
                    }
                    else
                    {
                        // 通常攻撃
                        if (Expression.IsOptionDefined("高度修正"))
                        {
                            if (GeneralLib.InStrNotNest(wclass, "空") == 0)
                            {
                                prob = (0.7d * prob);
                            }
                        }
                    }
                }

                // 局地戦能力
                if (withBlock3.IsFeatureAvailable("地形適応"))
                {
                    var loopTo2 = withBlock3.CountFeature();
                    for (i = 1; i <= loopTo2; i++)
                    {
                        if (withBlock3.Feature(i) == "地形適応")
                        {
                            buf = withBlock3.FeatureData(i);
                            var loopTo3 = GeneralLib.LLength(buf);
                            for (j = 2; j <= loopTo3; j++)
                            {
                                if ((Map.TerrainName(withBlock3.x, withBlock3.y) ?? "") == (GeneralLib.LIndex(buf, j) ?? ""))
                                {
                                    prob = prob - 10;
                                    break;
                                }
                            }
                        }
                    }
                }

                // 攻撃回避
                if (withBlock3.IsFeatureAvailable("攻撃回避"))
                {
                    prob_mod = 0d;
                    var loopTo4 = withBlock3.CountFeature();
                    for (i = 1; i <= loopTo4; i++)
                    {
                        if (withBlock3.Feature(i) == "攻撃回避")
                        {
                            fdata = withBlock3.FeatureData(i);
                            flevel = withBlock3.FeatureLevel(i);

                            // 必要条件
                            if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                            {
                                nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                            }
                            else
                            {
                                nmorale = 0;
                            }

                            // 発動可能？
                            bool localIsAttributeClassified() { string argaclass1 = GeneralLib.LIndex(fdata, 2); var ret = withBlock3.IsAttributeClassified(argaclass1, wclass); return ret; }

                            if (withBlock3.MainPilot().Morale >= nmorale && localIsAttributeClassified())
                            {
                                // 攻撃回避発動
                                prob_mod = prob_mod + flevel;
                            }
                        }
                    }

                    prob = ((long)(prob * (10d - prob_mod)) / 10L);
                }

                // 動けなければ絶対に命中
                if (withBlock3.IsConditionSatisfied("行動不能") || withBlock3.IsConditionSatisfied("麻痺") || withBlock3.IsConditionSatisfied("睡眠") || withBlock3.IsConditionSatisfied("石化") || withBlock3.IsConditionSatisfied("凍結") || withBlock3.IsUnderSpecialPowerEffect("行動不能"))
                {
                    HitProbabilityRet = 1000;
                    return HitProbabilityRet;
                }

                // ステータス異常による修正
                if (GeneralLib.InStrNotNest(wclass, "Ｈ") == 0 && GeneralLib.InStrNotNest(wclass, "追") == 0)
                {
                    if (IsConditionSatisfied("撹乱"))
                    {
                        prob = prob / 2;
                    }

                    if (IsConditionSatisfied("恐怖"))
                    {
                        prob = prob / 2;
                    }

                    if (IsConditionSatisfied("盲目"))
                    {
                        prob = prob / 2;
                    }
                }

                // ターゲットのステータス異常による修正
                if (withBlock3.IsConditionSatisfied("盲目"))
                {
                    prob = (1.5d * prob);
                }

                if (withBlock3.IsConditionSatisfied("チャージ"))
                {
                    prob = (1.5d * prob);
                }

                if (withBlock3.IsConditionSatisfied("消耗"))
                {
                    prob = (1.5d * prob);
                }

                if (withBlock3.IsConditionSatisfied("狂戦士"))
                {
                    prob = (1.5d * prob);
                }

                if (withBlock3.IsConditionSatisfied("移動不能"))
                {
                    prob = (1.5d * prob);
                }

                // 底力
                if (HP <= MaxHP / 4)
                {
                    {
                        var withBlock4 = MainPilot();
                        if (withBlock4.IsSkillAvailable("超底力"))
                        {
                            prob = prob + 50;
                        }
                        else if (withBlock4.IsSkillAvailable("底力"))
                        {
                            prob = prob + 30;
                        }
                    }
                }

                if (withBlock3.HP <= withBlock3.MaxHP / 4)
                {
                    {
                        var withBlock5 = withBlock3.MainPilot();
                        if (withBlock5.IsSkillAvailable("超底力"))
                        {
                            prob = prob - 50;
                        }
                        else if (withBlock5.IsSkillAvailable("底力"))
                        {
                            prob = prob - 30;
                        }
                    }
                }

                // スペシャルパワー及び特殊状態による補正
                if (is_true_value || mpskill >= 160)
                {
                    if (IsUnderSpecialPowerEffect("命中強化"))
                    {
                        prob = (prob + 10d * SpecialPowerEffectLevel("命中強化"));
                    }
                    else if (IsConditionSatisfied("運動性ＵＰ"))
                    {
                        prob = prob + 15;
                    }

                    if (withBlock3.IsUnderSpecialPowerEffect("回避強化"))
                    {
                        prob = (prob - 10d * withBlock3.SpecialPowerEffectLevel("回避強化"));
                    }
                    else if (withBlock3.IsConditionSatisfied("運動性ＵＰ"))
                    {
                        prob = prob - 15;
                    }

                    if (IsConditionSatisfied("運動性ＤＯＷＮ"))
                    {
                        prob = prob - 15;
                    }

                    if (withBlock3.IsConditionSatisfied("運動性ＤＯＷＮ"))
                    {
                        prob = prob + 15;
                    }

                    if (IsUnderSpecialPowerEffect("命中低下"))
                    {
                        prob = (prob - 10d * SpecialPowerEffectLevel("命中低下"));
                    }

                    if (withBlock3.IsUnderSpecialPowerEffect("回避低下"))
                    {
                        prob = (prob + 10d * withBlock3.SpecialPowerEffectLevel("回避低下"));
                    }

                    if (IsUnderSpecialPowerEffect("命中率低下"))
                    {
                        prob = ((long)(prob * (10d - SpecialPowerEffectLevel("命中率低下"))) / 10L);
                    }
                }
            }

            // 最終命中率を定義する。これがないときは何もしない
            if (SRC.BCList.IsDefined("最終命中率"))
            {
                // 事前にデータを登録
                BCVariable.DataReset();
                BCVariable.MeUnit = this;
                BCVariable.AtkUnit = this;
                BCVariable.DefUnit = t;
                BCVariable.WeaponNumber = w;
                BCVariable.LastVariable = prob;
                prob = SRC.BCList.Item("最終命中率").Calculate();
            }

            if (prob < 0)
            {
                HitProbabilityRet = 0;
            }
            else
            {
                HitProbabilityRet = prob;
            }

            return HitProbabilityRet;
        }

        // 武器 w のユニット t に対するダメージ
        // 敵ユニットはスペシャルパワー等による補正を考慮しないので
        // is_true_value によって補正を省くかどうかを指定できるようにしている
        public int Damage(int w, Unit t, bool is_true_value, bool is_support_attack = false)
        {
            int DamageRet = default;
            int arm, arm_mod;
            int j, i, idx;
            string ch, wclass, buf;
            int mpskill;
            string fname, fdata;
            double flevel;
            double slevel;
            string sdata;
            int nmorale;
            bool neautralize;
            double lv_mod;
            string opt;
            string tname;
            double dmg_mod, uadaption = default;
            // 装甲、装甲補正一時保存
            double ed_amr;
            double ed_amr_fix;
            wclass = WeaponClass(w);

            // パイロットの技量によってダメージを正確に予測できるか左右される
            mpskill = MainPilot().TacticalTechnique();
            // 武器攻撃力
            DamageRet = WeaponPower(w, t.Area);
            // 攻撃力が0の場合は常にダメージ0
            if (DamageRet == 0)
            {
                return DamageRet;
            }

            // 基本装甲値
            arm = t.get_Armor("");

            // アーマー能力
            if (!t.IsFeatureAvailable("アーマー"))
            {
                goto SkipArmor;
            }
            // ザコはアーマーを考慮しない
            if (!is_true_value && mpskill < 150)
            {
                goto SkipArmor;
            }

            arm_mod = 0;
            var loopTo = t.CountFeature();
            for (i = 1; i <= loopTo; i++)
            {
                if (t.Feature(i) == "アーマー")
                {
                    fname = t.FeatureName0(i);
                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 必要条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo1 = GeneralLib.LLength(fdata);
                    for (j = 4; j <= loopTo1; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (opt ?? "")
                        {
                            case "能力必要":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * (t.MainPilot().SynchroRate() - 30);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 2d;
                                    }

                                    slevel = lv_mod * t.MainPilot().Plana;
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 50d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 50d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超感覚":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 50d;
                                    }

                                    slevel = lv_mod * (t.MainPilot().SkillLevel("超感覚", ref_mode: "") + t.MainPilot().SkillLevel("知覚強化", ref_mode: ""));
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 50d;
                                    }

                                    double localSkillLevel() { object argIndex1 = opt; string argref_mode = ""; var ret = t.MainPilot().SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                    slevel = lv_mod * localSkillLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified() { string argaclass1 = GeneralLib.LIndex(fdata, 2); var ret = t.IsAttributeClassified(argaclass1, wclass); return ret; }

                    if (t.MainPilot().Morale >= nmorale && localIsAttributeClassified() && !neautralize)
                    {
                        // アーマー発動
                        arm_mod = (arm_mod + 100d * flevel + slevel);
                    }
                }
            }

            // 装甲が劣化している場合はアーマーによる装甲追加も半減
            if (t.IsConditionSatisfied("装甲劣化"))
            {
                arm_mod = arm_mod / 2;
            }

            arm = arm + arm_mod;
            SkipArmor:
            ;


            // 地形適応による装甲修正
            if (!Expression.IsOptionDefined("地形適応命中率修正"))
            {
                switch (t.Area ?? "")
                {
                    case "空中":
                        {
                            uadaption = t.get_AdaptionMod(1, 0);
                            break;
                        }

                    case "地上":
                        {
                            if (Map.TerrainClass(t.x, t.y) == "月面")
                            {
                                uadaption = t.get_AdaptionMod(4, 0);
                            }
                            else
                            {
                                uadaption = t.get_AdaptionMod(2, 0);
                            }

                            break;
                        }

                    case "水上":
                        {
                            uadaption = t.get_AdaptionMod(2, 0);
                            break;
                        }

                    case "水中":
                        {
                            uadaption = t.get_AdaptionMod(3, 0);
                            break;
                        }

                    case "宇宙":
                        {
                            uadaption = t.get_AdaptionMod(4, 0);
                            break;
                        }

                    case "地中":
                        {
                            DamageRet = 0;
                            return DamageRet;
                        }
                }

                if (uadaption == 0d)
                {
                    uadaption = 0.6d;
                }
            }
            else if (t.Area == "地中")
            {
                DamageRet = 0;
                return DamageRet;
            }
            else
            {
                uadaption = 1d;
            }

            // 不屈による装甲修正
            if (t.MainPilot().IsSkillAvailable("不屈"))
            {
                if (Expression.IsOptionDefined("防御力倍率低下"))
                {
                    if (t.HP <= t.MaxHP / 8)
                    {
                        arm = (1.15d * arm);
                    }
                    else if (t.HP <= t.MaxHP / 4)
                    {
                        arm = (1.1d * arm);
                    }
                    else if (t.HP <= t.MaxHP / 2)
                    {
                        arm = (1.05d * arm);
                    }
                }
                else if (t.HP <= t.MaxHP / 8)
                {
                    arm = (1.3d * arm);
                }
                else if (t.HP <= t.MaxHP / 4)
                {
                    arm = (1.2d * arm);
                }
                else if (t.HP <= t.MaxHP / 2)
                {
                    arm = (1.1d * arm);
                }
            }

            // スペシャルパワーによる無防備状態
            if (t.IsUnderSpecialPowerEffect("無防備"))
            {
                arm = 0;
            }

            if (is_true_value || mpskill >= 160)
            {
                // スペシャルパワーによる修正
                // 装甲強化
                if (t.IsUnderSpecialPowerEffect("装甲強化"))
                {
                    arm = (arm * (1d + 0.1d * t.SpecialPowerEffectLevel("装甲強化")));
                }
                else if (t.IsConditionSatisfied("防御力ＵＰ"))
                {
                    if (Expression.IsOptionDefined("防御力倍率低下"))
                    {
                        arm = (1.25d * arm);
                    }
                    else
                    {
                        arm = (1.5d * arm);
                    }
                }

                if (t.IsUnderSpecialPowerEffect("装甲低下"))
                {
                    arm = (arm * (1d + 0.1d * t.SpecialPowerEffectLevel("装甲低下")));
                }
                else if (t.IsConditionSatisfied("防御力ＤＯＷＮ"))
                {
                    arm = (0.75d * arm);
                }
            }

            // 貫通型攻撃
            if (IsUnderSpecialPowerEffect("貫通攻撃"))
            {
                arm = arm / 2;
            }
            else if (IsWeaponClassifiedAs(w, "貫"))
            {
                if (IsWeaponLevelSpecified(w, "貫"))
                {
                    arm = ((long)(arm * (10d - WeaponLevel(w, "貫"))) / 10L);
                }
                else
                {
                    arm = arm / 2;
                }
            }

            if (is_true_value || mpskill >= 140)
            {
                // 弱点
                if (t.Weakness(wclass))
                {
                    arm = arm / 2;
                }
                // 吸収する場合は装甲を無視して判定
                else if (!t.Effective(wclass) && t.Absorb(wclass))
                {
                    arm = 0;
                }
            }

            if (SRC.BCList.IsDefined("防御補正"))
            {
                // バトルコンフィグデータによる計算実行
                BCVariable.DataReset();
                BCVariable.MeUnit = t;
                BCVariable.AtkUnit = this;
                BCVariable.DefUnit = t;
                BCVariable.WeaponNumber = w;
                BCVariable.Armor = arm;
                BCVariable.TerrainAdaption = uadaption;
                arm = SRC.BCList.Item("防御補正").Calculate();
            }
            else
            {
                {
                    var withBlock = t.MainPilot();
                    // 気力による装甲修正
                    if (Expression.IsOptionDefined("気力効果小"))
                    {
                        arm = arm * (50 + (withBlock.Morale + withBlock.MoraleMod) / 2) / 100;
                    }
                    else
                    {
                        arm = arm * (withBlock.Morale + withBlock.MoraleMod) / 100;
                    }

                    // レベルアップによる装甲修正＋耐久能力
                    arm = arm * withBlock.Defense / 100;
                }

                // 地形適応による装甲修正
                arm = (arm * uadaption);
            }

            // ダメージ固定武器の場合は装甲と地形＆距離修正を無視
            if (GeneralLib.InStrNotNest(wclass, "固") > 0)
            {
                goto SkipDamageMod;
            }

            if (SRC.BCList.IsDefined("ダメージ"))
            {
                // バトルコンフィグデータによる計算実行
                // 事前にデータを登録
                BCVariable.DataReset();
                BCVariable.MeUnit = this;
                BCVariable.AtkUnit = this;
                BCVariable.DefUnit = t;
                BCVariable.WeaponNumber = w;
                BCVariable.AttackVariable = DamageRet;
                BCVariable.DffenceVariable = arm;
                if (Map.TerrainClass(t.x, t.y) == "月面")
                {
                    if (t.Area == "地上")
                    {
                        BCVariable.TerrainAdaption = (100 - Map.TerrainEffectForDamage(t.x, t.y)) / 100d;
                    }
                    else
                    {
                        BCVariable.TerrainAdaption = 1d;
                    }
                }
                else if (t.Area != "空中")
                {
                    BCVariable.TerrainAdaption = (100 - Map.TerrainEffectForDamage(t.x, t.y)) / 100d;
                }
                else
                {
                    BCVariable.TerrainAdaption = 1d;
                }

                DamageRet = SRC.BCList.Item("ダメージ").Calculate();
            }
            else
            {
                // 装甲値によってダメージを軽減
                DamageRet = DamageRet - arm;

                // 地形補正
                if (Map.TerrainClass(t.x, t.y) == "月面")
                {
                    if (t.Area == "地上")
                    {
                        DamageRet = (DamageRet * ((100 - Map.TerrainEffectForDamage(t.x, t.y)) / 100d));
                    }
                }
                else if (t.Area != "空中")
                {
                    DamageRet = (DamageRet * ((100 - Map.TerrainEffectForDamage(t.x, t.y)) / 100d));
                }
            }

            // 散属性武器は離れるほどダメージダウン
            if (GeneralLib.InStrNotNest(wclass, "散") > 0)
            {
                switch ((Math.Abs((x - t.x)) + Math.Abs((y - t.y))))
                {
                    case 1:
                        {
                            break;
                        }
                    // 修正なし
                    case 2:
                        {
                            DamageRet = (0.95d * DamageRet);
                            break;
                        }

                    case 3:
                        {
                            DamageRet = (0.9d * DamageRet);
                            break;
                        }

                    case 4:
                        {
                            DamageRet = (0.85d * DamageRet);
                            break;
                        }

                    default:
                        {
                            DamageRet = (0.8d * DamageRet);
                            break;
                        }
                }
            }

            // 距離修正
            if (Expression.IsOptionDefined("距離修正"))
            {
                if (GeneralLib.InStrNotNest(wclass, "実") == 0 && GeneralLib.InStrNotNest(wclass, "武") == 0 && GeneralLib.InStrNotNest(wclass, "突") == 0 && GeneralLib.InStrNotNest(wclass, "接") == 0 && GeneralLib.InStrNotNest(wclass, "爆") == 0)
                {
                    if (Expression.IsOptionDefined("大型マップ"))
                    {
                        switch ((Math.Abs((x - t.x)) + Math.Abs((y - t.y))))
                        {
                            case var @case when 1 <= @case && @case <= 4:
                                {
                                    break;
                                }
                            // 修正なし
                            case 5:
                            case 6:
                                {
                                    DamageRet = (0.95d * DamageRet);
                                    break;
                                }

                            case 7:
                            case 8:
                                {
                                    DamageRet = (0.9d * DamageRet);
                                    break;
                                }

                            case 9:
                            case 10:
                                {
                                    DamageRet = (0.85d * DamageRet);
                                    break;
                                }

                            default:
                                {
                                    DamageRet = (0.8d * DamageRet);
                                    break;
                                }
                        }
                    }
                    else if (Expression.IsOptionDefined("小型マップ"))
                    {
                        switch ((Math.Abs((x - t.x)) + Math.Abs((y - t.y))))
                        {
                            case 1:
                                {
                                    break;
                                }
                            // 修正なし
                            case 2:
                                {
                                    DamageRet = (0.95d * DamageRet);
                                    break;
                                }

                            case 3:
                                {
                                    DamageRet = (0.9d * DamageRet);
                                    break;
                                }

                            case 4:
                                {
                                    DamageRet = (0.85d * DamageRet);
                                    break;
                                }

                            case 5:
                                {
                                    DamageRet = (0.8d * DamageRet);
                                    break;
                                }

                            case 6:
                                {
                                    DamageRet = (0.75d * DamageRet);
                                    break;
                                }

                            default:
                                {
                                    DamageRet = (0.7d * DamageRet);
                                    break;
                                }
                        }
                    }
                    else
                    {
                        switch ((Math.Abs((x - t.x)) + Math.Abs((y - t.y))))
                        {
                            case var case1 when 1 <= case1 && case1 <= 3:
                                {
                                    break;
                                }
                            // 修正なし
                            case 4:
                                {
                                    DamageRet = (0.95d * DamageRet);
                                    break;
                                }

                            case 5:
                                {
                                    DamageRet = (0.9d * DamageRet);
                                    break;
                                }

                            case 6:
                                {
                                    DamageRet = (0.85d * DamageRet);
                                    break;
                                }

                            default:
                                {
                                    DamageRet = (0.8d * DamageRet);
                                    break;
                                }
                        }
                    }
                }
            }

            SkipDamageMod:
            ;


            // 封印攻撃は弱点もしくは有効を持つユニット以外には効かない
            if (GeneralLib.InStrNotNest(wclass, "封") > 0)
            {
                buf = t.strWeakness + t.strEffective;
                var loopTo2 = Strings.Len(buf);
                for (i = 1; i <= loopTo2; i++)
                {
                    // 属性をひとまとめずつ取得
                    ch = GeneralLib.GetClassBundle(buf, i);
                    if (ch != "物" && ch != "魔")
                    {
                        if (GeneralLib.InStrNotNest(wclass, ch) > 0)
                        {
                            break;
                        }
                    }
                }

                if (i > Strings.Len(buf))
                {
                    DamageRet = 0;
                    return DamageRet;
                }
            }

            // 限定攻撃は指定属性に対して弱点もしくは有効を持つユニット以外には効かない
            idx = GeneralLib.InStrNotNest(wclass, "限");
            if (idx > 0)
            {
                buf = t.strWeakness + t.strEffective;
                var loopTo3 = Strings.Len(buf);
                for (i = 1; i <= loopTo3; i++)
                {
                    // 属性をひとまとめずつ取得
                    ch = GeneralLib.GetClassBundle(buf, i);
                    if (ch != "物" && ch != "魔")
                    {
                        if (GeneralLib.InStrNotNest(wclass, ch) > idx)
                        {
                            break;
                        }
                    }
                }

                if (i > Strings.Len(buf))
                {
                    DamageRet = 0;
                    return DamageRet;
                }
            }

            // 特定レベル限定攻撃
            if (WeaponLevel(w, "対") > 0d)
            {
                // UPGRADE_WARNING: Mod に新しい動作が指定されています。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="9B7D5ADD-D8FE-4819-A36C-6DEDAF088CC7"' をクリックしてください。
                if (t.MainPilot().Level % WeaponLevel(w, "対") != 0d)
                {
                    DamageRet = 0;
                    return DamageRet;
                }
            }

            if (is_true_value || mpskill >= 140)
            {
                // 弱点、有効、吸収を優先
                if (!t.Weakness(wclass) && !t.Effective(wclass) && !t.Absorb(wclass))
                {
                    // 無効化
                    if (t.Immune(wclass))
                    {
                        DamageRet = 0;
                        return DamageRet;
                    }
                    // 耐性
                    else if (t.Resist(wclass))
                    {
                        DamageRet = DamageRet / 2;
                    }
                }
            }

            // 盲目状態には視覚攻撃は効かない
            if (is_true_value || mpskill >= 140)
            {
                if (GeneralLib.InStrNotNest(wclass, "視") > 0)
                {
                    if (t.IsConditionSatisfied("盲目"))
                    {
                        DamageRet = 0;
                        return DamageRet;
                    }
                }
            }

            // 機械には精神攻撃は効かない
            if (is_true_value || mpskill >= 140)
            {
                if (GeneralLib.InStrNotNest(wclass, "精") > 0)
                {
                    if (t.MainPilot().Personality == "機械")
                    {
                        DamageRet = 0;
                        return DamageRet;
                    }
                }
            }

            // 性別限定武器
            if (GeneralLib.InStrNotNest(wclass, "♂") > 0)
            {
                if (t.MainPilot().Sex != "男性")
                {
                    DamageRet = 0;
                    return DamageRet;
                }
            }

            if (GeneralLib.InStrNotNest(wclass, "♀") > 0)
            {
                if (t.MainPilot().Sex != "女性")
                {
                    DamageRet = 0;
                    return DamageRet;
                }
            }

            // 寝こみを襲うとダメージ1.5倍
            if (t.IsConditionSatisfied("睡眠"))
            {
                DamageRet = (1.5d * DamageRet);
            }

            {
                var withBlock1 = MainPilot();
                // 高気力時のダメージ増加能力
                if (withBlock1.Morale >= 130)
                {
                    if (Expression.IsOptionDefined("ダメージ倍率低下"))
                    {
                        if (withBlock1.IsSkillAvailable("潜在力開放"))
                        {
                            DamageRet = (1.2d * DamageRet);
                        }

                        if (IsFeatureAvailable("ブースト"))
                        {
                            DamageRet = (1.2d * DamageRet);
                        }
                    }
                    else
                    {
                        if (withBlock1.IsSkillAvailable("潜在力開放"))
                        {
                            DamageRet = (1.25d * DamageRet);
                        }

                        if (IsFeatureAvailable("ブースト"))
                        {
                            DamageRet = (1.25d * DamageRet);
                        }
                    }
                }

                // 得意技
                if (withBlock1.IsSkillAvailable("得意技"))
                {
                    sdata = withBlock1.SkillData("得意技");
                    var loopTo4 = Strings.Len(sdata);
                    for (i = 1; i <= loopTo4; i++)
                    {
                        if (GeneralLib.InStrNotNest(wclass, Strings.Mid(sdata, i, 1)) > 0)
                        {
                            DamageRet = (1.2d * DamageRet);
                            break;
                        }
                    }
                }

                // 不得手
                if (withBlock1.IsSkillAvailable("不得手"))
                {
                    sdata = withBlock1.SkillData("不得手");
                    var loopTo5 = Strings.Len(sdata);
                    for (i = 1; i <= loopTo5; i++)
                    {
                        if (GeneralLib.InStrNotNest(wclass, Strings.Mid(sdata, i, 1)) > 0)
                        {
                            DamageRet = (0.8d * DamageRet);
                            break;
                        }
                    }
                }
            }

            // ハンター能力
            // (ターゲットのMainPilotを参照するため、「With .MainPilot」は使えない)
            if (MainPilot().IsSkillAvailable("ハンター"))
            {
                var loopTo6 = MainPilot().CountSkill();
                for (i = 1; i <= loopTo6; i++)
                {
                    if (MainPilot().Skill(i) == "ハンター")
                    {
                        sdata = MainPilot().SkillData(i);
                        var loopTo7 = GeneralLib.LLength(sdata);
                        for (j = 2; j <= loopTo7; j++)
                        {
                            tname = GeneralLib.LIndex(sdata, j);
                            if ((t.Name ?? "") == (tname ?? "") || (t.Class0 ?? "") == (tname ?? "") || (t.Size + "サイズ" ?? "") == (tname ?? "") || (t.MainPilot().Name ?? "") == (tname ?? "") || (t.MainPilot().Sex ?? "") == (tname ?? ""))
                            {
                                break;
                            }
                        }

                        if (j <= GeneralLib.LLength(sdata))
                        {
                            double localSkillLevel1() { object argIndex1 = i; string argref_mode = ""; var ret = MainPilot().SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                            DamageRet = ((long)((10d + localSkillLevel1()) * DamageRet) / 10L);
                            break;
                        }
                    }
                }

                if (IsConditionSatisfied("ハンター付加") || IsConditionSatisfied("ハンター付加２"))
                {
                    sdata = MainPilot().SkillData("ハンター");
                    var loopTo8 = GeneralLib.LLength(sdata);
                    for (i = 2; i <= loopTo8; i++)
                    {
                        tname = GeneralLib.LIndex(sdata, i);
                        if ((t.Name ?? "") == (tname ?? "") || (t.Class0 ?? "") == (tname ?? "") || (t.Size + "サイズ" ?? "") == (tname ?? "") || (t.MainPilot().Name ?? "") == (tname ?? "") || (t.MainPilot().Sex ?? "") == (tname ?? ""))
                        {
                            break;
                        }
                    }

                    if (i <= GeneralLib.LLength(sdata))
                    {
                        DamageRet = ((long)((10d + MainPilot().SkillLevel("ハンター", ref_mode: "")) * DamageRet) / 10L);
                    }
                }
            }

            // スペシャルパワー、特殊状態によるダメージ増加
            dmg_mod = 1d;
            if (IsConditionSatisfied("攻撃力ＵＰ") || IsConditionSatisfied("狂戦士"))
            {
                if (Expression.IsOptionDefined("ダメージ倍率低下"))
                {
                    dmg_mod = 1.2d;
                }
                else
                {
                    dmg_mod = 1.25d;
                }
            }
            // サポートアタックの場合はスペシャルパワーによる修正が無い
            if (!is_support_attack)
            {
                if (is_true_value || mpskill >= 160)
                {
                    // スペシャルパワーによるダメージ増加は特殊状態による増加と重複しない
                    dmg_mod = GeneralLib.MaxDbl(dmg_mod, 1d + 0.1d * SpecialPowerEffectLevel("ダメージ増加"));
                    dmg_mod = dmg_mod + 0.1d * t.SpecialPowerEffectLevel("被ダメージ増加");
                }
            }

            DamageRet = (dmg_mod * DamageRet);

            // スペシャルパワー、特殊状態、サポートアタックによるダメージ低下
            if (is_true_value || mpskill >= 160)
            {
                dmg_mod = 1d;
                dmg_mod = dmg_mod - 0.1d * SpecialPowerEffectLevel("ダメージ低下");
                dmg_mod = dmg_mod - 0.1d * t.SpecialPowerEffectLevel("被ダメージ低下");
                DamageRet = (dmg_mod * DamageRet);
            }

            if (IsConditionSatisfied("攻撃力ＤＯＷＮ"))
            {
                DamageRet = (0.75d * DamageRet);
            }

            if (IsConditionSatisfied("恐怖"))
            {
                DamageRet = (0.8d * DamageRet);
            }

            if (is_support_attack)
            {
                // サポートアタックダメージ低下
                if (Expression.IsOptionDefined("サポートアタックダメージ低下"))
                {
                    DamageRet = (0.7d * DamageRet);
                }
            }

            // レジスト能力
            dmg_mod = 0d;
            if (!t.IsFeatureAvailable("レジスト"))
            {
                goto SkipResist;
            }
            // ザコはレジストを考慮しない
            if (!is_true_value && mpskill < 150)
            {
                goto SkipResist;
            }

            var loopTo9 = t.CountFeature();
            for (i = 1; i <= loopTo9; i++)
            {
                if (t.Feature(i) == "レジスト")
                {
                    fname = t.FeatureName0(i);
                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 必要条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo10 = GeneralLib.LLength(fdata);
                    for (j = 4; j <= loopTo10; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (opt ?? "")
                        {
                            case "能力必要":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 0.5d;
                                    }

                                    slevel = lv_mod * (t.MainPilot().SynchroRate() - 30);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 0.2d;
                                    }

                                    slevel = lv_mod * t.MainPilot().Plana;
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超感覚":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * (t.MainPilot().SkillLevel("超感覚", ref_mode: "") + t.MainPilot().SkillLevel("知覚強化", ref_mode: ""));
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    double localSkillLevel2() { object argIndex1 = opt; string argref_mode = ""; var ret = t.MainPilot().SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                    slevel = lv_mod * localSkillLevel2();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified1() { string argaclass1 = GeneralLib.LIndex(fdata, 2); var ret = t.IsAttributeClassified(argaclass1, wclass); return ret; }

                    if (t.MainPilot().Morale >= nmorale && localIsAttributeClassified1() && !neautralize)
                    {
                        // レジスト発動
                        dmg_mod = dmg_mod + 10d * flevel + slevel;
                    }
                }
            }

            DamageRet = ((long)(DamageRet * (100d - dmg_mod)) / 100L);
            SkipResist:
            ;
            if (SRC.BCList.IsDefined("最終ダメージ"))
            {
                // バトルコンフィグデータによる計算実行
                BCVariable.DataReset();
                BCVariable.MeUnit = this;
                BCVariable.AtkUnit = this;
                BCVariable.DefUnit = t;
                BCVariable.WeaponNumber = w;
                BCVariable.LastVariable = DamageRet;
                DamageRet = SRC.BCList.Item("最終ダメージ").Calculate();
            }

            // 最低ダメージは10
            if (dmg_mod < 100d)
            {
                if (DamageRet < 10)
                {
                    // MOD START MARGE
                    // Damage = 10
                    if (Expression.IsOptionDefined("ダメージ下限解除"))
                    {
                        DamageRet = GeneralLib.MaxLng(DamageRet, 0);
                    }
                    else if (Expression.IsOptionDefined("ダメージ下限１"))
                    {
                        DamageRet = GeneralLib.MaxLng(DamageRet, 1);
                    }
                    else
                    {
                        DamageRet = 10;
                    }
                    // MOD END MARGE
                }
            }

            // ダメージを吸収する場合は最後に反転
            if (is_true_value || mpskill >= 140)
            {
                // 弱点、有効を優先
                if (!t.Weakness(wclass) && !t.Effective(wclass))
                {
                    // 吸収
                    if (DamageRet > 0 && t.Absorb(wclass))
                    {
                        DamageRet = -DamageRet / 2;
                    }
                }
            }

            return DamageRet;
        }

        // クリティカルの発生率
        public int CriticalProbability(int w, Unit t, string def_mode = "")
        {
            int CriticalProbabilityRet = default;
            int i, prob, idx;
            string wclass;
            string buf, c;
            var is_special = default(bool);
            // クリティカル攻撃、防御の一時保存変数
            int ed_crtatk, ed_crtdfe;
            if (IsNormalWeapon(w))
            {
                // 通常攻撃

                // スペシャルパワーとの効果の重ね合わせが禁止されている場合
                if (Expression.IsOptionDefined("スペシャルパワー使用時クリティカル無効") || Expression.IsOptionDefined("スペシャルパワー使用時クリティカル無効"1))
                {
                    if (IsUnderSpecialPowerEffect("ダメージ増加"))
                    {
                        return CriticalProbabilityRet;
                    }
                }

                // 攻撃側による補正
                if (SRC.BCList.IsDefined("クリティカル攻撃補正"))
                {
                    // バトルコンフィグデータの設定による修正
                    // 一時保存変数に一時保存
                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = this;
                    BCVariable.AtkUnit = this;
                    BCVariable.DefUnit = t;
                    BCVariable.WeaponNumber = w;
                    BCVariable.AttackExp = WeaponCritical(w);
                    ed_crtatk = SRC.BCList.Item("クリティカル攻撃補正").Calculate();
                }
                else
                {
                    // 一時保存変数に一時保存
                    ed_crtatk = (WeaponCritical(w) + this.MainPilot().Technique);
                }

                // 防御側による補正
                if (SRC.BCList.IsDefined("クリティカル防御補正"))
                {
                    // バトルコンフィグデータの設定による修正
                    // 一時保存変数に一時保存
                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = t;
                    BCVariable.AtkUnit = this;
                    BCVariable.DefUnit = t;
                    BCVariable.WeaponNumber = w;
                    ed_crtdfe = SRC.BCList.Item("クリティカル防御補正").Calculate();
                }
                else
                {
                    // 一時保存変数に一時保存
                    ed_crtdfe = t.MainPilot().Technique;
                }

                // クリティカル発生率計算
                if (SRC.BCList.IsDefined("クリティカル発生率"))
                {
                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = this;
                    BCVariable.AtkUnit = this;
                    BCVariable.DefUnit = t;
                    BCVariable.WeaponNumber = w;
                    BCVariable.AttackVariable = ed_crtatk;
                    BCVariable.DffenceVariable = ed_crtdfe;
                    prob = SRC.BCList.Item("クリティカル発生率").Calculate();
                }
                else
                {
                    prob = (ed_crtatk - ed_crtdfe);
                }

                // 超反応による修正
                prob = (prob + 2d * MainPilot().SkillLevel("超反応", ref_mode: "") - 2d * t.MainPilot().SkillLevel("超反応", ref_mode: ""));

                // 超能力による修正
                if (MainPilot().IsSkillAvailable("超能力"))
                {
                    prob = (prob + 5);
                }

                // 底力、超底力、覚悟による修正
                if (HP <= MaxHP / 4)
                {
                    if (MainPilot().IsSkillAvailable("底力") || MainPilot().IsSkillAvailable("超底力") || MainPilot().IsSkillAvailable("覚悟"))
                    {
                        prob = (prob + 50);
                    }
                }

                // スペシャルパワーにる修正
                prob = (prob + 10d * SpecialPowerEffectLevel("クリティカル率増加"));
            }
            else
            {
                // 特殊効果を伴う攻撃
                is_special = true;

                // 攻撃側による補正
                if (SRC.BCList.IsDefined("特殊効果攻撃補正"))
                {
                    // バトルコンフィグデータの設定による修正
                    // 一時保存変数に一時保存
                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = this;
                    BCVariable.AtkUnit = this;
                    BCVariable.DefUnit = t;
                    BCVariable.WeaponNumber = w;
                    BCVariable.AttackExp = WeaponCritical(w);
                    ed_crtatk = SRC.BCList.Item("特殊効果攻撃補正").Calculate();
                }
                else
                {
                    // 一時保存変数に一時保存
                    ed_crtatk = (WeaponCritical(w) + this.MainPilot().Technique / 2);
                }

                // 防御側による補正
                if (SRC.BCList.IsDefined("特殊効果防御補正"))
                {
                    // バトルコンフィグデータの設定による修正
                    // 一時保存変数に一時保存
                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = t;
                    BCVariable.AtkUnit = this;
                    BCVariable.DefUnit = t;
                    BCVariable.WeaponNumber = w;
                    // 特殊効果の場合は相手がザコの時に確率が増加
                    if (Strings.InStr(t.MainPilot().Name, "(ザコ)") > 0)
                    {
                        BCVariable.CommonEnemy = 30;
                    }

                    ed_crtdfe = SRC.BCList.Item("特殊効果防御補正").Calculate();
                }
                else
                {
                    // 一時保存変数に一時保存
                    ed_crtdfe = (t.MainPilot().Technique / 2);

                    // 特殊効果の場合は相手がザコの時に確率が増加
                    if (Strings.InStr(t.MainPilot().Name, "(ザコ)") > 0)
                    {
                        // 一時保存変数に一時保存
                        ed_crtdfe = (ed_crtdfe - 30);
                    }
                }

                // 特殊効果発生率計算
                if (SRC.BCList.IsDefined("特殊効果発生率"))
                {
                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = this;
                    BCVariable.AtkUnit = this;
                    BCVariable.DefUnit = t;
                    BCVariable.WeaponNumber = w;
                    BCVariable.AttackVariable = ed_crtatk;
                    BCVariable.DffenceVariable = ed_crtdfe;
                    prob = SRC.BCList.Item("特殊効果発生率").Calculate();
                }
                else
                {
                    prob = (ed_crtatk - ed_crtdfe);
                }

                // 抵抗力による修正
                prob = (prob - 10d * t.FeatureLevel("抵抗力"));
            }

            // 不意打ち
            if (IsFeatureAvailable("ステルス") && !IsConditionSatisfied("ステルス無効") && !t.IsFeatureAvailable("ステルス無効化") && IsWeaponClassifiedAs(w, "忍"))
            {
                prob = (prob + 10);
            }

            // 相手が動けなければ確率アップ
            if (t.IsConditionSatisfied("行動不能") || t.IsConditionSatisfied("石化") || t.IsConditionSatisfied("凍結") || t.IsConditionSatisfied("麻痺") || t.IsConditionSatisfied("睡眠") || t.IsUnderSpecialPowerEffect("行動不能"))
            {
                prob = (prob + 10);
            }

            // 以下の修正は特殊効果発動確率にのみ影響
            if (is_special)
            {
                wclass = WeaponClass(w);

                // 封印攻撃は弱点、有効を持つユニット以外には効かない
                if (GeneralLib.InStrNotNest(wclass, "封") > 0)
                {
                    buf = t.strWeakness + t.strEffective;
                    var loopTo = Strings.Len(buf);
                    for (i = 1; i <= loopTo; i++)
                    {
                        // 属性をひとまとめずつ取得
                        c = GeneralLib.GetClassBundle(buf, i);
                        if (c != "物" && c != "魔")
                        {
                            if (GeneralLib.InStrNotNest(wclass, c) > 0)
                            {
                                break;
                            }
                        }
                    }

                    if (i > Strings.Len(buf))
                    {
                        CriticalProbabilityRet = 0;
                        return CriticalProbabilityRet;
                    }
                }

                // 限定攻撃は弱点、有効を持つユニット以外には効かない
                idx = GeneralLib.InStrNotNest(wclass, "限");
                if (idx > 0)
                {
                    buf = t.strWeakness + t.strEffective;
                    var loopTo1 = Strings.Len(buf);
                    for (i = 1; i <= loopTo1; i++)
                    {
                        // 属性をひとまとめずつ取得
                        c = GeneralLib.GetClassBundle(buf, i);
                        if (c != "物" && c != "魔")
                        {
                            if (GeneralLib.InStrNotNest(wclass, c) > idx)
                            {
                                break;
                            }
                        }
                    }

                    if (i > Strings.Len(buf))
                    {
                        CriticalProbabilityRet = 0;
                        return CriticalProbabilityRet;
                    }
                }

                // 特定レベル限定攻撃
                if (GeneralLib.InStrNotNest(wclass, "対") > 0)
                {
                    // UPGRADE_WARNING: Mod に新しい動作が指定されています。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="9B7D5ADD-D8FE-4819-A36C-6DEDAF088CC7"' をクリックしてください。
                    if (t.MainPilot().Level % WeaponLevel(w, "対") != 0d)
                    {
                        CriticalProbabilityRet = 0;
                        return CriticalProbabilityRet;
                    }
                }

                // クリティカル率については、
                // 弱、効属性の指定属性に対しての防御特性を考慮する。
                buf = "";
                i = GeneralLib.InStrNotNest(wclass, "弱");
                while (i > 0)
                {
                    buf = buf + Strings.Mid(GeneralLib.GetClassBundle(wclass, i), 2);
                    i = GeneralLib.InStrNotNest(wclass, "弱", (i + 1));
                }

                i = GeneralLib.InStrNotNest(wclass, "効");
                while (i > 0)
                {
                    buf = buf + Strings.Mid(GeneralLib.GetClassBundle(wclass, i), 2);
                    i = GeneralLib.InStrNotNest(wclass, "効", (i + 1));
                }

                buf = buf + wclass;

                // 弱点
                // 変化なし
                // 封印技
                // 限定技
                if (t.Weakness(buf))
                {
                    prob = (prob + 10);
                }
                // 有効
                else if (t.Effective(buf))
                {
                }
                else if (GeneralLib.InStrNotNest(wclass, "封") > 0)
                {
                    CriticalProbabilityRet = 0;
                    return CriticalProbabilityRet;
                }
                else if (GeneralLib.InStrNotNest(wclass, "限") > 0)
                {
                    CriticalProbabilityRet = 0;
                    return CriticalProbabilityRet;
                }
                // 吸収
                else if (t.Absorb(buf))
                {
                    CriticalProbabilityRet = 0;
                    return CriticalProbabilityRet;
                }
                // 無効化
                else if (t.Immune(buf))
                {
                    CriticalProbabilityRet = 0;
                    return CriticalProbabilityRet;
                }
                // 耐性
                else if (t.Resist(buf))
                {
                    prob = (prob / 2);
                }

                // 盲目状態には視覚攻撃は効かない
                if (GeneralLib.InStrNotNest(wclass, "視") > 0)
                {
                    if (t.IsConditionSatisfied("盲目"))
                    {
                        CriticalProbabilityRet = 0;
                        return CriticalProbabilityRet;
                    }
                }

                // 機械には精神攻撃は効かない
                if (GeneralLib.InStrNotNest(wclass, "精") > 0)
                {
                    if (t.MainPilot().Personality == "機械")
                    {
                        CriticalProbabilityRet = 0;
                        return CriticalProbabilityRet;
                    }
                }

                // 性別限定武器
                if (GeneralLib.InStrNotNest(wclass, "♂") > 0)
                {
                    if (t.MainPilot().Sex != "男性")
                    {
                        CriticalProbabilityRet = 0;
                        return CriticalProbabilityRet;
                    }
                }

                if (GeneralLib.InStrNotNest(wclass, "♀") > 0)
                {
                    if (t.MainPilot().Sex != "女性")
                    {
                        CriticalProbabilityRet = 0;
                        return CriticalProbabilityRet;
                    }
                }
            }

            // 防御時はクリティカル発生確率が半減
            if (def_mode == "防御")
            {
                prob = (prob / 2);
            }

            // 最終クリティカル/特殊効果を定義する。これがないときは何もしない
            if (IsNormalWeapon(w))
            {
                // クリティカル
                if (SRC.BCList.IsDefined("最終クリティカル発生率"))
                {
                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = this;
                    BCVariable.AtkUnit = this;
                    BCVariable.DefUnit = t;
                    BCVariable.WeaponNumber = w;
                    BCVariable.LastVariable = prob;
                    prob = SRC.BCList.Item("最終クリティカル発生率").Calculate();
                }
            }
            else
            {
                // 特殊効果
                if (SRC.BCList.IsDefined("最終特殊効果発生率"))
                {
                    // 事前にデータを登録
                    BCVariable.DataReset();
                    BCVariable.MeUnit = this;
                    BCVariable.AtkUnit = this;
                    BCVariable.DefUnit = t;
                    BCVariable.WeaponNumber = w;
                    BCVariable.LastVariable = prob;
                    prob = SRC.BCList.Item("最終特殊効果発生率").Calculate();
                }
            }

            if (prob > 100)
            {
                CriticalProbabilityRet = 100;
            }
            else if (prob < 1)
            {
                CriticalProbabilityRet = 1;
            }
            else
            {
                CriticalProbabilityRet = prob;
            }

            return CriticalProbabilityRet;
        }

        // 武器wでユニットtに攻撃をかけた時のダメージの期待値
        public int ExpDamage(int w, Unit t, bool is_true_value, double dmg_mod = 0d)
        {
            int ExpDamageRet = default;
            int dmg;
            int j, i, idx;
            double slevel;
            string wclass;
            string fname, fdata;
            double flevel;
            int ecost, nmorale;
            bool neautralize;
            double lv_mod;
            string opt;
            wclass = WeaponClass(w);

            // 攻撃力が0であれば常にダメージ0
            if (WeaponPower(w, "") <= 0)
            {
                return ExpDamageRet;
            }

            // ダメージ
            dmg = Damage(w, t, is_true_value);

            // ダメージに修正を加える場合
            if (dmg_mod > 0d)
            {
                if (GeneralLib.InStrNotNest(wclass, "殺") == 0)
                {
                    dmg = (dmg * dmg_mod);
                }
            }

            // 抹殺攻撃は一撃で相手を倒せない限り効果がない
            if (GeneralLib.InStrNotNest(wclass, "殺") > 0)
            {
                if (t.HP > dmg)
                {
                    return ExpDamageRet;
                }
            }

            // ダメージが与えられない場合
            if (dmg <= 0)
            {
                // 地形適応や封印武器、限定武器、性別限定武器、無効化、吸収が原因であれば期待値は0
                if (WeaponAdaption(w, t.Area) == 0d || GeneralLib.InStrNotNest(wclass, "封") > 0 || GeneralLib.InStrNotNest(wclass, "限") > 0 || GeneralLib.InStrNotNest(wclass, "♂") > 0 || GeneralLib.InStrNotNest(wclass, "♀") > 0 || t.Immune(wclass) || t.Absorb(wclass))
                {
                    return ExpDamageRet;
                }

                // それ以外の要因であればダミーでダメージwとする。
                // こうしておかないと敵が攻撃が無駄の場合はまったく自分から
                // 攻撃しなくなってしまうので。
                // 単純にExpDamage=1などとしないのは攻撃力の高い武器を優先させて使わせるため
                ExpDamageRet = w;
                return ExpDamageRet;
            }

            // バリア無効化
            if (GeneralLib.InStrNotNest(wclass, "無") > 0 || IsUnderSpecialPowerEffect("防御能力無効化"))
            {
                // 抹殺攻撃は一撃で相手を倒せない限り効果がない
                if (GeneralLib.InStrNotNest(wclass, "殺") > 0)
                {
                    if (t.HP > dmg)
                    {
                        return ExpDamageRet;
                    }
                }

                ExpDamageRet = dmg;
                return ExpDamageRet;
            }

            // 技量の低い敵はバリアを考慮せず攻撃をかける
            {
                var withBlock = MainPilot();
                if (!is_true_value && withBlock.TacticalTechnique() < 150)
                {
                    // 抹殺攻撃は一撃で相手を倒せない限り効果がない
                    if (GeneralLib.InStrNotNest(wclass, "殺") > 0)
                    {
                        if (t.HP > dmg)
                        {
                            return ExpDamageRet;
                        }
                    }

                    ExpDamageRet = dmg;
                    return ExpDamageRet;
                }
            }
            // バリア能力
            var loopTo = t.CountFeature();
            for (i = 1; i <= loopTo; i++)
            {
                if (t.Feature(i) == "バリア")
                {
                    fname = t.FeatureName0(i);
                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 必要条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        ecost = 10;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo1 = GeneralLib.LLength(fdata);
                    for (j = 5; j <= loopTo1; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (opt ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData("バリア")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData("バリア")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("バリア");
                                        if (flevel <= 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (GeneralLib.InStrNotNest(wclass, "武") > 0 || GeneralLib.InStrNotNest(wclass, "突") > 0 || GeneralLib.InStrNotNest(wclass, "接") > 0)
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    neautralize = true;
                                    break;
                                }

                            case "能力必要":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 20d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 10d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // バリア無効化で無効化されている？
                    if (t.IsConditionSatisfied("バリア無効化"))
                    {
                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
                        {
                            neautralize = true;
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified() { string argaclass1 = GeneralLib.LIndex(fdata, 2); var ret = t.IsAttributeClassified(argaclass1, wclass); return ret; }

                    if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && localIsAttributeClassified() && !neautralize)
                    {
                        // バリア発動
                        if (dmg <= 1000d * flevel + slevel)
                        {
                            ExpDamageRet = w;
                            return ExpDamageRet;
                        }
                    }
                }
            }

            // フィールド能力
            var loopTo2 = t.CountFeature();
            for (i = 1; i <= loopTo2; i++)
            {
                if (t.Feature(i) == "フィールド")
                {
                    fname = t.FeatureName0(i);
                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 必要条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        ecost = 0;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo3 = GeneralLib.LLength(fdata);
                    for (j = 5; j <= loopTo3; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (opt ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData("フィールド")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData("フィールド")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("フィールド");
                                        if (flevel <= 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (GeneralLib.InStrNotNest(wclass, "武") > 0 || GeneralLib.InStrNotNest(wclass, "突") > 0 || GeneralLib.InStrNotNest(wclass, "接") > 0)
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    neautralize = true;
                                    break;
                                }

                            case "能力必要":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 20d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 10d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // バリア無効化で無効化されている？
                    if (t.IsConditionSatisfied("バリア無効化"))
                    {
                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
                        {
                            neautralize = true;
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified1() { string argaclass1 = GeneralLib.LIndex(fdata, 2); var ret = t.IsAttributeClassified(argaclass1, wclass); return ret; }

                    if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && localIsAttributeClassified1() && !neautralize)
                    {
                        // フィールド発動
                        if (dmg <= 500d * flevel + slevel)
                        {
                            ExpDamageRet = w;
                            return ExpDamageRet;
                        }
                        else if (flevel > 0d || slevel > 0d)
                        {
                            dmg = (dmg - 500d * flevel - slevel);
                        }
                    }
                }
            }

            // プロテクション能力
            var loopTo4 = t.CountFeature();
            for (i = 1; i <= loopTo4; i++)
            {
                if (t.Feature(i) == "プロテクション")
                {
                    fname = t.FeatureName0(i);
                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 必要条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        ecost = 10;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo5 = GeneralLib.LLength(fdata);
                    for (j = 5; j <= loopTo5; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (opt ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData("プロテクション")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData("プロテクション")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("プロテクション");
                                        if (flevel <= 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (GeneralLib.InStrNotNest(wclass, "武") > 0 || GeneralLib.InStrNotNest(wclass, "突") > 0 || GeneralLib.InStrNotNest(wclass, "接") > 0)
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    neautralize = true;
                                    break;
                                }

                            case "能力必要":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 0.5d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 0.2d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // バリア無効化で無効化されている？
                    if (t.IsConditionSatisfied("バリア無効化"))
                    {
                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
                        {
                            neautralize = true;
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified2() { string argaclass1 = GeneralLib.LIndex(fdata, 2); var ret = t.IsAttributeClassified(argaclass1, wclass); return ret; }

                    if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && localIsAttributeClassified2() && !neautralize)
                    {
                        // プロテクション発動
                        dmg = ((long)(dmg * (100d - 10d * flevel - slevel)) / 100L);
                        if (dmg <= 0)
                        {
                            ExpDamageRet = w;
                            return ExpDamageRet;
                        }
                    }
                }
            }

            // 対ビーム用防御能力
            if (GeneralLib.InStrNotNest(wclass, "Ｂ") > 0)
            {
                // ビーム吸収
                if (t.IsFeatureAvailable("ビーム吸収"))
                {
                    ExpDamageRet = w;
                    return ExpDamageRet;
                }
            }

            // 抹殺攻撃は一撃で相手を倒せる場合にのみ有効
            if (GeneralLib.InStrNotNest(wclass, "殺") > 0)
            {
                if (dmg < t.HP)
                {
                    dmg = 0;
                }
            }

            // 盾防御
            if (t.IsFeatureAvailable("盾") && t.MainPilot().IsSkillAvailable("Ｓ防御") && t.MaxAction() > 0 && !IsWeaponClassifiedAs(w, "精") && !IsWeaponClassifiedAs(w, "浸") && !IsWeaponClassifiedAs(w, "殺") && (t.IsConditionSatisfied("盾付加") || t.FeatureLevel("盾") > t.ConditionLevel("盾ダメージ")))
            {
                if (IsWeaponClassifiedAs(w, "破"))
                {
                    dmg = (dmg - 50d * (t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") + 4d));
                }
                else
                {
                    dmg = (dmg - 100d * (t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") + 4d));
                }
            }

            // ダメージが減少されて0以下になった場合もダミーで1ダメージ
            if (dmg <= 0)
            {
                dmg = 1;
            }

            // 抹殺攻撃は一撃で相手を倒せない限り効果がない
            if (Strings.InStr(w.ToString(), "殺") > 0)
            {
                if (t.HP > dmg)
                {
                    return ExpDamageRet;
                }
            }

            ExpDamageRet = dmg;
            return ExpDamageRet;
        }


        // === 防御属性判定処理 ===

        // 属性 aname に対して吸収属性を持つか？
        public bool Absorb(string aname)
        {
            bool AbsorbRet = default;
            string c;
            int i;
            int slen;

            // 全属性に有効な場合
            if (GeneralLib.InStrNotNest(strAbsorb, "全") > 0)
            {
                AbsorbRet = true;
                return AbsorbRet;
            }

            // 無属性は物理攻撃に分類される
            if (Strings.Len(aname) == 0)
            {
                if (GeneralLib.InStrNotNest(strAbsorb, "物") > 0)
                {
                    AbsorbRet = true;
                }

                return AbsorbRet;
            }

            // 属性に該当するかを判定
            i = 1;
            slen = Strings.Len(strAbsorb);
            while (i <= slen)
            {
                // 属性をひとまとめずつ取得
                c = GeneralLib.GetClassBundle(strAbsorb, i);
                switch (c ?? "")
                {
                    case "物":
                        {
                            if (GeneralLib.InStrNotNest(aname, "魔") == 0 && GeneralLib.InStrNotNest(aname, "精") == 0)
                            {
                                AbsorbRet = true;
                                break;
                            }

                            break;
                        }

                    case "魔":
                        {
                            // 魔法武器以外の魔属性なら特性が有効
                            if (GeneralLib.InStrNotNest(aname, "魔") > 0)
                            {
                                if (GeneralLib.InStrNotNest(aname, "魔武") == 0 && GeneralLib.InStrNotNest(aname, "魔突") == 0 && GeneralLib.InStrNotNest(aname, "魔接") == 0 && GeneralLib.InStrNotNest(aname, "魔銃") == 0 && GeneralLib.InStrNotNest(aname, "魔実") == 0)
                                {
                                    AbsorbRet = true;
                                    break;
                                }
                            }

                            break;
                        }

                    default:
                        {
                            if (GeneralLib.InStrNotNest(aname, c) > 0)
                            {
                                AbsorbRet = true;
                                break;
                            }

                            break;
                        }
                }

                i = (i + 1);
            }

            return AbsorbRet;
        }

        // 属性 aname に対して無効化属性を持つか？
        public bool Immune(string aname)
        {
            bool ImmuneRet = default;
            string c;
            int i;
            int slen;

            // 全属性に有効な場合
            if (GeneralLib.InStrNotNest(strImmune, "全") > 0)
            {
                ImmuneRet = true;
                return ImmuneRet;
            }

            // 無属性は物理攻撃に分類される
            if (Strings.Len(aname) == 0)
            {
                if (GeneralLib.InStrNotNest(strImmune, "物") > 0)
                {
                    ImmuneRet = true;
                }

                return ImmuneRet;
            }

            // 属性に該当するかを判定
            i = 1;
            slen = Strings.Len(strImmune);
            while (i <= slen)
            {
                // 属性をひとまとめずつ取得
                c = GeneralLib.GetClassBundle(strImmune, i);
                switch (c ?? "")
                {
                    case "物":
                        {
                            if (GeneralLib.InStrNotNest(aname, "魔") == 0 && GeneralLib.InStrNotNest(aname, "精") == 0)
                            {
                                ImmuneRet = true;
                                break;
                            }

                            break;
                        }

                    case "魔":
                        {
                            // 魔法武器以外の魔属性なら特性が有効
                            if (GeneralLib.InStrNotNest(aname, "魔") > 0 && GeneralLib.InStrNotNest(aname, "魔武") == 0 && GeneralLib.InStrNotNest(aname, "魔突") == 0 && GeneralLib.InStrNotNest(aname, "魔接") == 0 && GeneralLib.InStrNotNest(aname, "魔銃") == 0 && GeneralLib.InStrNotNest(aname, "魔実") == 0)
                            {
                                ImmuneRet = true;
                                break;
                            }

                            break;
                        }

                    default:
                        {
                            if (GeneralLib.InStrNotNest(aname, c) > 0)
                            {
                                ImmuneRet = true;
                                break;
                            }

                            break;
                        }
                }

                i = (i + 1);
            }

            return ImmuneRet;
        }

        // 属性 aname に対して耐性属性を持つか？
        public bool Resist(string aname)
        {
            bool ResistRet = default;
            string c;
            int i;
            int slen;

            // 全属性に有効な場合
            if (GeneralLib.InStrNotNest(strResist, "全") > 0)
            {
                ResistRet = true;
                return ResistRet;
            }

            // 無属性は物理攻撃に分類される
            if (Strings.Len(aname) == 0)
            {
                if (GeneralLib.InStrNotNest(strResist, "物") > 0)
                {
                    ResistRet = true;
                }

                return ResistRet;
            }

            // 属性に該当するかを判定
            i = 1;
            slen = Strings.Len(strResist);
            while (i <= slen)
            {
                // 属性をひとまとめずつ取得
                c = GeneralLib.GetClassBundle(strResist, i);
                switch (c ?? "")
                {
                    case "物":
                        {
                            if (GeneralLib.InStrNotNest(aname, "魔") == 0 && GeneralLib.InStrNotNest(aname, "精") == 0)
                            {
                                ResistRet = true;
                                break;
                            }

                            break;
                        }

                    case "魔":
                        {
                            // 魔法武器以外の魔属性なら特性が有効
                            if (GeneralLib.InStrNotNest(aname, "魔") > 0 && GeneralLib.InStrNotNest(aname, "魔武") == 0 && GeneralLib.InStrNotNest(aname, "魔突") == 0 && GeneralLib.InStrNotNest(aname, "魔接") == 0 && GeneralLib.InStrNotNest(aname, "魔銃") == 0 && GeneralLib.InStrNotNest(aname, "魔実") == 0)
                            {
                                ResistRet = true;
                                break;
                            }

                            break;
                        }

                    default:
                        {
                            if (GeneralLib.InStrNotNest(aname, c) > 0)
                            {
                                ResistRet = true;
                                break;
                            }

                            break;
                        }
                }

                i = (i + 1);
            }

            return ResistRet;
        }

        // 属性 aname に対して弱点属性を持つか？
        public bool Weakness(string aname)
        {
            bool WeaknessRet = default;
            string c;
            int i;
            int slen;

            // 全属性に有効な場合
            if (GeneralLib.InStrNotNest(strWeakness, "全") > 0)
            {
                WeaknessRet = true;
                return WeaknessRet;
            }

            if (Strings.Len(aname) == 0)
            {
                if (GeneralLib.InStrNotNest(strWeakness, "物") > 0)
                {
                    WeaknessRet = true;
                }

                return WeaknessRet;
            }

            i = 1;
            slen = Strings.Len(strWeakness);
            while (i <= slen)
            {
                // 属性をひとまとめずつ取得
                c = GeneralLib.GetClassBundle(strWeakness, i);
                switch (c ?? "")
                {
                    case "物":
                        {
                            if (GeneralLib.InStrNotNest(aname, "魔") == 0 && GeneralLib.InStrNotNest(aname, "精") == 0)
                            {
                                WeaknessRet = true;
                                break;
                            }

                            break;
                        }

                    default:
                        {
                            if (GeneralLib.InStrNotNest(aname, c) > 0)
                            {
                                WeaknessRet = true;
                                break;
                            }

                            break;
                        }
                }

                i = (i + 1);
            }

            return WeaknessRet;
        }

        // 属性 aname に対して有効属性を持つか？
        public bool Effective(string aname)
        {
            bool EffectiveRet = default;
            string c;
            int i;
            int slen;

            // 全属性に有効な場合
            if (GeneralLib.InStrNotNest(strEffective, "全") > 0)
            {
                EffectiveRet = true;
                return EffectiveRet;
            }

            if (Strings.Len(aname) == 0)
            {
                if (GeneralLib.InStrNotNest(strEffective, "物") > 0)
                {
                    EffectiveRet = true;
                }

                return EffectiveRet;
            }

            i = 1;
            slen = Strings.Len(strEffective);
            while (i <= slen)
            {
                // 属性をひとまとめずつ取得
                c = GeneralLib.GetClassBundle(strEffective, i);
                switch (c ?? "")
                {
                    case "物":
                        {
                            if (GeneralLib.InStrNotNest(aname, "魔") == 0 && GeneralLib.InStrNotNest(aname, "精") == 0)
                            {
                                EffectiveRet = true;
                                break;
                            }

                            break;
                        }

                    default:
                        {
                            if (GeneralLib.InStrNotNest(aname, c) > 0)
                            {
                                EffectiveRet = true;
                                break;
                            }

                            break;
                        }
                }

                i = (i + 1);
            }

            return EffectiveRet;
        }

        // 属性 aname に対して特殊効果無効化属性を持つか？
        public bool SpecialEffectImmune(string aname)
        {
            bool SpecialEffectImmuneRet = default;
            // 全属性に有効な場合
            if (GeneralLib.InStrNotNest(strSpecialEffectImmune, "全") > 0)
            {
                SpecialEffectImmuneRet = true;
                return SpecialEffectImmuneRet;
            }

            if (Strings.Len(aname) == 0)
            {
                return SpecialEffectImmuneRet;
            }

            if (GeneralLib.InStrNotNest(strSpecialEffectImmune, aname) > 0)
            {
                SpecialEffectImmuneRet = true;
                return SpecialEffectImmuneRet;
            }

            // 無効化や弱点と違い、クリティカル率のみなので
            // 「火」に対する防御特性が「弱火」のクリティカル率に影響する点について
            // 直接関数内に記述できる。
            if (Strings.Left(aname, 1) == "弱" || Strings.Left(aname, 1) == "効")
            {
                if (GeneralLib.InStrNotNest(strSpecialEffectImmune, aname) > 0)
                {
                    SpecialEffectImmuneRet = true;
                    return SpecialEffectImmuneRet;
                }
            }

            return SpecialEffectImmuneRet;
        }

        // 属性の該当判定
        // aclass1 が防御属性、aclass2 が武器属性
        public bool IsAttributeClassified(string aclass1, string aclass2)
        {
            bool IsAttributeClassifiedRet = default;
            string attr;
            int alen, i;
            var with_not = default(bool);
            if (Strings.Len(aclass1) == 0)
            {
                IsAttributeClassifiedRet = true;
                return IsAttributeClassifiedRet;
            }

            if (aclass1 == "全")
            {
                IsAttributeClassifiedRet = true;
                return IsAttributeClassifiedRet;
            }

            // 無属性の攻撃は物理攻撃に分類される
            if (Strings.Len(aclass2) == 0)
            {
                if (GeneralLib.InStrNotNest(aclass1, "物") > 0)
                {
                    IsAttributeClassifiedRet = true;
                }

                if (GeneralLib.InStrNotNest(aclass1, "!") > 0)
                {
                    IsAttributeClassifiedRet = !IsAttributeClassifiedRet;
                }

                goto EndOfFunction;
            }

            i = 1;
            alen = Strings.Len(aclass1);
            while (i <= alen)
            {
                attr = GeneralLib.GetClassBundle(aclass1, i);
                switch (attr ?? "")
                {
                    case "物":
                        {
                            if (GeneralLib.InStrNotNest(aclass2, "魔") == 0 && GeneralLib.InStrNotNest(aclass2, "精") == 0)
                            {
                                IsAttributeClassifiedRet = true;
                                break;
                            }

                            break;
                        }

                    case "魔":
                        {
                            // 魔法武器以外の魔属性なら特性が有効
                            if (GeneralLib.InStrNotNest(aclass2, "魔") > 0)
                            {
                                if (GeneralLib.InStrNotNest(aclass2, "魔武") == 0 && GeneralLib.InStrNotNest(aclass2, "魔突") == 0 && GeneralLib.InStrNotNest(aclass2, "魔接") == 0 && GeneralLib.InStrNotNest(aclass2, "魔銃") == 0 && GeneralLib.InStrNotNest(aclass2, "魔実") == 0)
                                {
                                    IsAttributeClassifiedRet = true;
                                }
                                else if (with_not)
                                {
                                    IsAttributeClassifiedRet = true;
                                }

                                break;
                            }

                            break;
                        }

                    case "!":
                        {
                            with_not = true;
                            break;
                        }

                    default:
                        {
                            if (GeneralLib.InStrNotNest(aclass2, attr) > 0)
                            {
                                IsAttributeClassifiedRet = true;
                                break;
                            }

                            break;
                        }
                }

                i = (i + 1);
            }

            EndOfFunction:
            ;
            if (with_not)
            {
                IsAttributeClassifiedRet = !IsAttributeClassifiedRet;
            }

            return IsAttributeClassifiedRet;
        }



        // === 攻撃関連処理 ===

        // 武器 w でユニット t に攻撃
        // attack_mode は攻撃の種類
        // def_mode はユニット t の防御態勢
        // is_event はイベント(Attackコマンド)による攻撃かどうかを現す
        public void Attack(int w, Unit t, string attack_mode, string def_mode, bool is_event = false)
        {
            int prob;
            int dmg, prev_hp;
            bool is_hit = default, is_critical;
            string critical_type;
            bool use_shield, use_shield_msg;
            bool is_penetrated;
            bool use_protect_msg;
            bool use_support_guard;
            string wname, wnickname;
            string fname, uname = default;
            string msg, buf;
            int k, i, j, num;
            Unit su = default, orig_t;
            Unit[] partners;
            int tx, ty;
            string tarea;
            int prev_x = default, prev_y = default;
            var prev_area = default(string);
            var second_attack = default(bool);
            bool be_quiet;
            int attack_num = default, hit_count = default;
            int slevel;
            Unit saved_selected_unit;
            double hp_ratio, en_ratio;
            bool separate_parts;
            int orig_w;
            // ADD START MARGE
            bool is_ext_anime_defined;
            // ADD END MARGE

            wname = Weapon(w).Name;
            wnickname = WeaponNickname(w);

            // メッセージ表示用に選択状況を切り替え
            Commands.SaveSelections();
            saved_selected_unit = Commands.SelectedUnit;
            if (attack_mode == "反射")
            {
                Commands.SelectedUnit = Commands.SelectedTarget;
                Commands.SelectedTarget = this;
                Event.SelectedUnitForEvent = Event.SelectedTargetForEvent;
                Event.SelectedTargetForEvent = this;
                Commands.SelectedWeapon = w;
                Commands.SelectedWeaponName = wname;
            }
            else
            {
                if (ReferenceEquals(Commands.SelectedUnit, t))
                {
                    Commands.SelectedTWeapon = Commands.SelectedWeapon;
                    Commands.SelectedTWeaponName = Commands.SelectedWeaponName;
                }

                Commands.SelectedWeapon = w;
                Commands.SelectedWeaponName = wname;
                Commands.SelectedUnit = this;
                Commands.SelectedTarget = t;
                Event.SelectedUnitForEvent = this;
                Event.SelectedTargetForEvent = t;
            }

            // サポートガードを行ったユニットに関する情報をクリア
            if (!IsDefense())
            {
                // UPGRADE_NOTE: オブジェクト SupportGuardUnit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                Commands.SupportGuardUnit = null;
                // UPGRADE_NOTE: オブジェクト SupportGuardUnit2 をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                Commands.SupportGuardUnit2 = null;
            }

            // パイロットのセリフを表示するかどうかを判定
            if (attack_mode == "マップ攻撃" || attack_mode == "反射" || attack_mode == "当て身技" || attack_mode == "自動反撃")
            {
                be_quiet = true;
            }
            else
            {
                be_quiet = false;
            }

            // 戦闘アニメを表示する場合はマップウィンドウをクリアする
            if (SRC.BattleAnimation)
            {
                if (GUI.MainWidth != 15)
                {
                    Status.ClearUnitStatus();
                }

                if (!Expression.IsOptionDefined("戦闘中画面初期化無効"))
                {
                    GUI.RedrawScreen();
                }
            }

            orig_t = t;

            // かばった時にターゲットの位置を元のターゲットの位置と一致させるため記録
            tx = t.x;
            ty = t.y;
            tarea = t.Area;
            begin:
            ;


            // 情報を更新
            Update();
            MainPilot().UpdateSupportMod();
            t.Update();
            t.MainPilot().UpdateSupportMod();

            // ダメージ表示のため、ターゲットのＨＰを記録しておく
            prev_hp = t.HP;

            // 各種設定をリセット
            msg = "";
            is_critical = false;
            critical_type = "";
            use_shield = false;
            use_shield_msg = false;
            use_protect_msg = false;
            use_support_guard = false;
            is_penetrated = false;

            // 命中率を算出
            prob = HitProbability(w, t, true);

            // ダメージを算出
            dmg = Damage(w, t, true, Strings.InStr(attack_mode, "援護攻撃") > 0);

            // 特殊効果を持たない武器ならクリティカルの可能性あり
            if (IsNormalWeapon(w) && dmg > 0)
            {
                if (CriticalProbability(w, t, def_mode) >= GeneralLib.Dice(100) || attack_mode == "統率" || attack_mode == "同時援護攻撃")
                {
                    is_critical = true;
                }
            }

            partners = new Unit[1];
            Commands.SelectedPartners = new Unit[1];
            if (attack_mode != "マップ攻撃" && attack_mode != "反射" && !second_attack)
            {
                if (IsWeaponClassifiedAs(w, "合"))
                {
                    // 合体技の場合にパートナーをハイライト表示
                    if (WeaponMaxRange(w) == 1)
                    {
                        CombinationPartner("武装", w, partners, tx, ty);
                    }
                    else
                    {
                        CombinationPartner("武装", w, partners);
                    }

                    var loopTo = Information.UBound(partners);
                    for (i = 1; i <= loopTo; i++)
                    {
                        {
                            var withBlock = partners[i];
                            Map.MaskData[withBlock.x, withBlock.y] = false;
                        }
                    }

                    if (!SRC.BattleAnimation)
                    {
                        GUI.MaskScreen();
                    }
                }
                else if (!is_critical && dmg > 0 && Strings.InStr(attack_mode, "援護攻撃") == 0)
                {
                    // 連携攻撃が発動するかを判定
                    // （連携攻撃は合体技では発動しない）
                    if (this.Weapon(w).MaxRange > 1)
                    {
                        su = LookForAttackHelp(x, y);
                    }
                    else
                    {
                        su = LookForAttackHelp(tx, ty);
                    }

                    if (su is object)
                    {
                        // 連携攻撃発動
                        Map.MaskData[su.x, su.y] = false;
                        if (!SRC.BattleAnimation)
                        {
                            GUI.MaskScreen();
                        }

                        if (IsMessageDefined("連携攻撃(" + su.MainPilot().Name + ")", true))
                        {
                            PilotMessage("連携攻撃(" + su.MainPilot().Name + ")", msg_mode: "");
                        }
                        else
                        {
                            PilotMessage("連携攻撃(" + su.MainPilot().get_Nickname(false) + ")", msg_mode: "");
                        }

                        is_critical = true;
                        // UPGRADE_NOTE: オブジェクト su をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                        su = null;
                    }
                }
            }

            // クリティカルならダメージ1.5倍
            if (is_critical)
            {
                if (Expression.IsOptionDefined("ダメージ倍率低下"))
                {
                    if (IsWeaponClassifiedAs(w, "痛"))
                    {
                        dmg = ((1d + 0.1d * (WeaponLevel(w, "痛") + 2d)) * dmg);
                    }
                    else
                    {
                        dmg = (1.2d * dmg);
                    }
                }
                else
                {
                    if (IsWeaponClassifiedAs(w, "痛"))
                    {
                        dmg = ((1d + 0.25d * (WeaponLevel(w, "痛") + 2d)) * dmg);
                    }
                    else
                    {
                        dmg = (1.5d * dmg);
                    }
                }
            }

            // 攻撃種類のアニメ表示
            if (SRC.BattleAnimation)
            {
                switch (attack_mode ?? "")
                {
                    case "援護攻撃":
                    case "同時援護攻撃":
                        {
                            Effect.ShowAnimation("援護攻撃発動");
                            break;
                        }

                    case "カウンター":
                        {
                            Effect.ShowAnimation("カウンター発動");
                            break;
                        }
                }
            }

            // 攻撃側のメッセージ表示
            if (!be_quiet)
            {
                // 攻撃準備の効果音
                bool localIsSpecialEffectDefined() { string argmain_situation = wname + "(準備)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                if (IsAnimationDefined(wname + "(準備)", sub_situation: ""))
                {
                    PlayAnimation(wname + "(準備)", sub_situation: "");
                }
                else if (IsAnimationDefined(wname, sub_situation: "") && !Expression.IsOptionDefined("武器準備アニメ非表示") && SRC.WeaponAnimation)
                {
                    PlayAnimation(wname + "(準備)", sub_situation: "");
                }
                else if (localIsSpecialEffectDefined())
                {
                    SpecialEffect(wname + "(準備)", sub_situation: "");
                }
                else
                {
                    Effect.PrepareWeaponEffect(this, w);
                }

                // 攻撃メッセージの前に出力されるメッセージ
                if (second_attack)
                {
                    PilotMessage("再攻撃", msg_mode: "");
                }
                else if (Strings.InStr(attack_mode, "援護攻撃") > 0)
                {
                    {
                        var withBlock1 = Commands.AttackUnit.CurrentForm().MainPilot();
                        bool localIsMessageDefined() { string argmain_situation = "サポートアタック(" + withBlock1.get_Nickname(false) + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                        if (IsMessageDefined("サポートアタック(" + withBlock1.Name + ")"))
                        {
                            PilotMessage("サポートアタック(" + withBlock1.Name + ")", msg_mode: "");
                        }
                        else if (localIsMessageDefined())
                        {
                            PilotMessage("サポートアタック(" + withBlock1.get_Nickname(false) + ")", msg_mode: "");
                        }
                        else if (IsMessageDefined("サポートアタック"))
                        {
                            PilotMessage("サポートアタック", msg_mode: "");
                        }
                    }
                }
                else if (attack_mode == "カウンター")
                {
                    PilotMessage("カウンター", msg_mode: "");
                }
                else if (IsMessageDefined(wname) && wname != "格闘" && wname != "射撃" && wname != "攻撃" && !IsWeaponClassifiedAs(w, "合"))
                {
                    if (IsMessageDefined("かけ声(" + wname + ")"))
                    {
                        PilotMessage("かけ声(" + wname + ")", msg_mode: "");
                    }
                    else if (IsDefense())
                    {
                        PilotMessage("かけ声(反撃)", msg_mode: "");
                    }
                    else
                    {
                        PilotMessage("かけ声", msg_mode: "");
                    }
                }

                // 攻撃メッセージ
                Sound.IsWavePlayed = false;
                if (!second_attack)
                {
                    if (attack_mode == "カウンター")
                    {
                        PilotMessage(wname, "カウンター");
                    }
                    else
                    {
                        PilotMessage(wname, "攻撃");
                    }
                }

                // 攻撃アニメ
                bool localIsAnimationDefined() { string argmain_situation = wname + "(反撃)"; string argsub_situation = ""; var ret = IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                bool localIsAnimationDefined1() { string argmain_situation = wname + "(攻撃)"; string argsub_situation = ""; var ret = IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                if (IsDefense() && localIsAnimationDefined())
                {
                    PlayAnimation(wname + "(反撃)", sub_situation: "");
                }
                else if (localIsAnimationDefined1() || IsAnimationDefined(wname, sub_situation: ""))
                {
                    PlayAnimation(wname + "(攻撃)", sub_situation: "");
                }
                else if (IsSpecialEffectDefined(wname, sub_situation: ""))
                {
                    SpecialEffect(wname, sub_situation: "");
                }
                else if (!Sound.IsWavePlayed)
                {
                    Effect.AttackEffect(this, w);
                }
            }
            else if (attack_mode == "自動反撃")
            {
                // 攻撃アニメ
                bool localIsAnimationDefined2() { string argmain_situation = wname + "(反撃)"; string argsub_situation = ""; var ret = IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                bool localIsAnimationDefined3() { string argmain_situation = wname + "(攻撃)"; string argsub_situation = ""; var ret = IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                if (IsDefense() && localIsAnimationDefined2())
                {
                    PlayAnimation(wname + "(反撃)", sub_situation: "");
                }
                else if (localIsAnimationDefined3() || IsAnimationDefined(wname, sub_situation: ""))
                {
                    PlayAnimation(wname + "(攻撃)", sub_situation: "");
                }
                else if (IsSpecialEffectDefined(wname, sub_situation: ""))
                {
                    SpecialEffect(wname, sub_situation: "");
                }
                else if (!Sound.IsWavePlayed)
                {
                    Effect.AttackEffect(this, w);
                }
            }

            if (attack_mode != "マップ攻撃" && attack_mode != "反射")
            {
                // 武器使用による弾数＆ＥＮの消費
                UseWeapon(w);
                // 武器使用によるＥＮ消費の表示
                GUI.UpdateMessageForm(this, t);
            }

            // 防御手段による命中率低下
            if (def_mode == "回避")
            {
                if (!IsUnderSpecialPowerEffect("絶対命中") && !t.IsUnderSpecialPowerEffect("無防備") && !t.IsFeatureAvailable("回避不可") && !t.IsConditionSatisfied("移動不能"))
                {
                    prob = (prob / 2);
                }
            }

            // 反射攻撃の場合は命中率が低下
            if (attack_mode == "反射")
            {
                prob = (prob / 2);
            }

            // 攻撃を行ったことについてのシステムメッセージ
            if (!be_quiet)
            {
                switch (Information.UBound(partners))
                {
                    case 0:
                        {
                            // 通常攻撃
                            msg = Nickname + "は";
                            break;
                        }

                    case 1:
                        {
                            // ２体合体攻撃
                            if ((Nickname ?? "") != (partners[1].Nickname ?? ""))
                            {
                                msg = Nickname + "は[" + partners[1].Nickname + "]と共に";
                            }
                            else if ((MainPilot().get_Nickname(false) ?? "") != (partners[1].MainPilot().get_Nickname(false) ?? ""))
                            {
                                msg = MainPilot().get_Nickname(false) + "と[" + partners[1].MainPilot().get_Nickname(false) + "]は";
                            }
                            else
                            {
                                msg = Nickname + "達は";
                            }

                            break;
                        }

                    case 2:
                        {
                            // ３体合体攻撃
                            if ((Nickname ?? "") != (partners[1].Nickname ?? ""))
                            {
                                msg = Nickname + "は[" + partners[1].Nickname + "]、[" + partners[2].Nickname + "]と共に";
                            }
                            else if ((MainPilot().get_Nickname(false) ?? "") != (partners[1].MainPilot().get_Nickname(false) ?? ""))
                            {
                                msg = MainPilot().get_Nickname(false) + "は[" + partners[1].MainPilot().get_Nickname(false) + "]、[" + partners[2].MainPilot().get_Nickname(false) + "]と共に";
                            }
                            else
                            {
                                msg = Nickname + "達は";
                            }

                            break;
                        }

                    default:
                        {
                            // ３体以上による合体攻撃
                            msg = Nickname + "達は";
                            break;
                        }
                }

                // ジャンプ攻撃
                if (t.Area == "空中" && (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接")) && !IsTransAvailable("空"))
                {
                    msg = msg + "ジャンプし、";
                }

                if (second_attack)
                {
                    msg = msg + "再度";
                }
                else if (attack_mode == "カウンター" || attack_mode == "先制攻撃")
                {
                    msg = "先制攻撃！;" + msg + "先手を取り";
                }

                // 攻撃の種類によってメッセージを切り替え
                if (Strings.Right(wnickname, 2) == "攻撃" || Strings.Right(wnickname, 4) == "アタック" || wnickname == "突撃")
                {
                    msg = msg + "[" + wnickname + "]をかけた。;";
                }
                else if (IsSpellWeapon(w))
                {
                    if (Strings.Right(wnickname, 2) == "呪文")
                    {
                        msg = msg + "[" + wnickname + "]を唱えた。;";
                    }
                    else if (Strings.Right(wnickname, 2) == "の杖")
                    {
                        msg = msg + "[" + Strings.Left(wnickname, Strings.Len(wnickname) - 2) + "]の呪文を唱えた。;";
                    }
                    else
                    {
                        msg = msg + "[" + wnickname + "]の呪文を唱えた。;";
                    }
                }
                else if (IsWeaponClassifiedAs(w, "盗"))
                {
                    msg = msg + "[" + t.Nickname + "]の持ち物を盗もうとした。;";
                }
                else if (IsWeaponClassifiedAs(w, "習"))
                {
                    msg = msg + "[" + t.Nickname + "]の技を習得しようと試みた。;";
                }
                else if (IsWeaponClassifiedAs(w, "実") && (Strings.InStr(wnickname, "ミサイル") > 0 || Strings.InStr(wnickname, "ロケット") > 0))
                {
                    msg = msg + "[" + wnickname + "]を発射した。;";
                }
                else if (Strings.Right(wnickname, 1) == "息" || Strings.Right(wnickname, 3) == "ブレス" || Strings.Right(wnickname, 2) == "光線" || Strings.Right(wnickname, 1) == "光" || Strings.Right(wnickname, 3) == "ビーム" || Strings.Right(wnickname, 4) == "レーザー")
                {
                    msg = msg + "[" + wnickname + "]を放った。;";
                }
                else if (Strings.Right(wnickname, 1) == "歌")
                {
                    msg = msg + "[" + wnickname + "]を歌った。;";
                }
                else if (Strings.Right(wnickname, 2) == "踊り")
                {
                    msg = msg + "[" + wnickname + "]を踊った。;";
                }
                else
                {
                    msg = msg + "[" + wnickname + "]で攻撃をかけた。;";
                }

                // 命中率＆ＣＴ率表示
                if (is_event)
                {
                    // イベントによる攻撃の場合は命中率をスペシャルパワーの影響を含めずに表示
                    if (def_mode == "回避")
                    {
                        buf = "命中率 = " + GeneralLib.MinLng(HitProbability(w, t, false) / 2, 100) + "％" + "（" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(CriticalProbability(w, t, def_mode)) + "％）";
                    }
                    else
                    {
                        buf = "命中率 = " + GeneralLib.MinLng(HitProbability(w, t, false), 100) + "％" + "（" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(CriticalProbability(w, t, def_mode)) + "％）";
                    }
                }
                else
                {
                    buf = "命中率 = " + GeneralLib.MinLng(prob, 100) + "％" + "（" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(CriticalProbability(w, t, def_mode)) + "％）";
                }

                // 攻撃解説表示
                if (IsSysMessageDefined(wname, sub_situation: ""))
                {
                    // 「武器名(解説)」のメッセージを使用
                    SysMessage(wname, "", buf);
                }
                else if (IsSysMessageDefined("攻撃", sub_situation: ""))
                {
                    // 「攻撃(解説)」のメッセージを使用
                    SysMessage("攻撃", "", buf);
                }
                else
                {
                    GUI.DisplaySysMessage(msg + buf, SRC.BattleAnimation);
                }
            }

            msg = "";

            // 防御方法を表示
            switch (def_mode ?? "")
            {
                case "回避":
                    {
                        if (t.IsConditionSatisfied("踊り"))
                        {
                            msg = t.Nickname + "は踊っている。;";
                        }
                        else
                        {
                            msg = t.Nickname + "は回避運動をとった。;";
                        }

                        break;
                    }

                case "防御":
                    {
                        msg = t.Nickname + "は防御行動をとった。;";
                        break;
                    }
            }

            // スペシャルパワー「必殺」「瀕死」
            if (IsUnderSpecialPowerEffect("絶対破壊") || IsUnderSpecialPowerEffect("絶対瀕死"))
            {
                if (!be_quiet)
                {
                    PilotMessage(wname + "(命中)", msg_mode: "");
                }

                bool localIsSpecialEffectDefined1() { string argmain_situation = wname + "(命中)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                if (IsAnimationDefined(wname + "(命中)", sub_situation: "") || IsAnimationDefined(wname, sub_situation: ""))
                {
                    PlayAnimation(wname + "(命中)", sub_situation: "");
                }
                else if (localIsSpecialEffectDefined1())
                {
                    SpecialEffect(wname + "(命中)", sub_situation: "");
                }
                else if (!Sound.IsWavePlayed)
                {
                    Effect.HitEffect(this, w, t);
                }

                if (IsUnderSpecialPowerEffect("絶対瀕死"))
                {
                    // MOD START MARGE
                    // If t.HP > 10 Then
                    // dmg = t.HP - 10
                    // Else
                    // dmg = 0
                    // End If
                    if (Expression.IsOptionDefined("ダメージ下限解除") || Expression.IsOptionDefined("ダメージ下限１"))
                    {
                        if (t.HP > 1)
                        {
                            dmg = t.HP - 1;
                        }
                        else
                        {
                            dmg = 0;
                        }
                    }
                    else if (t.HP > 10)
                    {
                        dmg = t.HP - 10;
                    }
                    else
                    {
                        dmg = 0;
                    }
                }
                // MOD END MARGE

                else
                {
                    dmg = t.HP;
                }

                goto ApplyDamage;
            }

            // 回避能力の処理
            if (prob > 0)
            {
                if (CheckDodgeFeature(w, t, tx, ty, attack_mode, def_mode, dmg, be_quiet))
                {
                    dmg = 0;
                    goto EndAttack;
                }
            }

            // 攻撃回数を求める
            if (IsWeaponClassifiedAs(w, "連"))
            {
                attack_num = WeaponLevel(w, "連");
            }
            else
            {
                attack_num = 1;
            }

            // 命中回数を求める
            hit_count = 0;
            var loopTo1 = attack_num;
            for (i = 1; i <= loopTo1; i++)
            {
                if (GeneralLib.Dice(100) <= prob)
                {
                    hit_count = hit_count + 1;
                }
            }
            // 命中回数に基いてダメージを修正
            dmg = dmg * hit_count / attack_num;

            // 攻撃回避時の処理
            if (hit_count == 0)
            {
                bool localIsSpecialEffectDefined2() { string argmain_situation = wname + "(回避)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                if (IsAnimationDefined(wname + "(回避)", sub_situation: ""))
                {
                    PlayAnimation(wname + "(回避)", sub_situation: "");
                }
                else if (localIsSpecialEffectDefined2())
                {
                    SpecialEffect(wname + "(回避)", sub_situation: "");
                }
                else if (t.IsAnimationDefined("回避", sub_situation: ""))
                {
                    t.PlayAnimation("回避", sub_situation: "");
                }
                else if (t.IsSpecialEffectDefined("回避", sub_situation: ""))
                {
                    t.SpecialEffect("回避", sub_situation: "");
                }
                else
                {
                    Effect.DodgeEffect(this, w);
                }

                if (!be_quiet)
                {
                    t.PilotMessage("回避", msg_mode: "");
                    PilotMessage(wname + "(回避)", msg_mode: "");
                }

                if (t.IsSysMessageDefined("回避", sub_situation: ""))
                {
                    t.SysMessage("回避", sub_situation: "", add_msg: "");
                }
                else
                {
                    switch (def_mode ?? "")
                    {
                        case "回避":
                            {
                                if (t.IsConditionSatisfied("踊り"))
                                {
                                    GUI.DisplaySysMessage(t.Nickname + "は激しく踊りながら攻撃をかわした。");
                                }
                                else
                                {
                                    GUI.DisplaySysMessage(t.Nickname + "は回避運動をとり、攻撃をかわした。");
                                }

                                break;
                            }

                        case "防御":
                            {
                                GUI.DisplaySysMessage(t.Nickname + "は防御行動をとったが、攻撃は外れた。");
                                break;
                            }

                        default:
                            {
                                GUI.DisplaySysMessage(t.Nickname + "は攻撃をかわした。");
                                break;
                            }
                    }
                }

                goto EndAttack;
            }

            // 敵ユニットがかばわれた場合の処理
            if (su is null)
            {
                use_support_guard = false;
                if (t.IsUnderSpecialPowerEffect("みがわり"))
                {
                    // スペシャルパワー「みがわり」
                    i = 1;
                    while (i <= t.CountSpecialPower())
                    {
                        // UPGRADE_WARNING: オブジェクト t.SpecialPower(i).IsEffectAvailable(みがわり) の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                        SpecialPowerData localSpecialPower() { object argIndex1 = i; var ret = t.SpecialPower(argIndex1); return ret; }

                        if (Conversions.ToBoolean(localSpecialPower().IsEffectAvailable("みがわり")))
                        {
                            string localSpecialPowerData1() { object argIndex1 = i; var ret = t.SpecialPowerData(argIndex1); return ret; }

                            if (SRC.PList.IsDefined(localSpecialPowerData1()))
                            {
                                string localSpecialPowerData() { object argIndex1 = i; var ret = t.SpecialPowerData(argIndex1); return ret; }

                                Pilot localItem() { object argIndex1 = (object)hs40b56b80c15841019d507de2a6e31457(); var ret = SRC.PList.Item(argIndex1); return ret; }

                                su = localItem().Unit;
                                t.RemoveSpecialPowerInEffect("みがわり");
                                i = (i - 1);
                                if (su is object)
                                {
                                    su = su.CurrentForm();
                                    if (su.Status != "出撃")
                                    {
                                        // UPGRADE_NOTE: オブジェクト su をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                        su = null;
                                    }
                                }
                            }
                        }

                        i = (i + 1);
                    }
                }
                else if (!is_event && def_mode != "マップ攻撃" && def_mode != "援護防御")
                {
                    if (t.IsDefense())
                    {
                        // サポートガード
                        if (Commands.UseSupportGuard)
                        {
                            su = t.LookForSupportGuard(this, w);
                            if (su is object)
                            {
                                use_support_guard = true;
                                // サポートガードの残り回数を減らす
                                su.UsedSupportGuard = (su.UsedSupportGuard + 1);
                            }
                        }
                    }

                    if (su is null)
                    {
                        // かばう
                        su = t.LookForGuardHelp(this, w, is_critical);
                    }
                }

                if (su is object)
                {
                    su.Update();

                    // メッセージウィンドウの表示を入れ替え
                    if (Party == "味方" || Party == "ＮＰＣ")
                    {
                        GUI.UpdateMessageForm(su, this);
                    }
                    else
                    {
                        GUI.UpdateMessageForm(this, su);
                    }

                    if (!SRC.BattleAnimation)
                    {
                        // 身代わりになるユニットをハイライト表示
                        if (Map.MaskData[su.x, su.y])
                        {
                            Map.MaskData[su.x, su.y] = false;
                            GUI.MaskScreen();
                            Map.MaskData[su.x, su.y] = true;
                        }
                    }

                    // かばう際のメッセージ
                    bool localIsMessageDefined2() { string argmain_situation = "かばう(" + t.MainPilot().Name + ")"; var ret = su.IsMessageDefined(argmain_situation); return ret; }

                    bool localIsMessageDefined3() { string argmain_situation = "かばう(" + t.MainPilot().get_Nickname(false) + ")"; var ret = su.IsMessageDefined(argmain_situation); return ret; }

                    if (use_support_guard)
                    {
                        bool localIsMessageDefined1() { string argmain_situation = "サポートガード(" + t.MainPilot().get_Nickname(false) + ")"; var ret = su.IsMessageDefined(argmain_situation); return ret; }

                        if (su.IsMessageDefined("サポートガード(" + t.MainPilot().Name + ")"))
                        {
                            su.PilotMessage("サポートガード(" + t.MainPilot().Name + ")", msg_mode: "");
                        }
                        else if (localIsMessageDefined1())
                        {
                            su.PilotMessage("サポートガード(" + t.MainPilot().get_Nickname(false) + ")", msg_mode: "");
                        }
                        else if (su.IsMessageDefined("サポートガード"))
                        {
                            su.PilotMessage("サポートガード", msg_mode: "");
                        }
                    }
                    else if (localIsMessageDefined2())
                    {
                        su.PilotMessage("かばう(" + t.MainPilot().Name + ")", msg_mode: "");
                        use_protect_msg = true;
                    }
                    else if (localIsMessageDefined3())
                    {
                        su.PilotMessage("かばう(" + t.MainPilot().get_Nickname(false) + ")", msg_mode: "");
                        use_protect_msg = true;
                    }

                    msg = su.MainPilot().get_Nickname(false) + "は[" + t.MainPilot().get_Nickname(false) + "]をかばった。;";

                    // 身代わりになるユニットをターゲットの位置まで移動
                    {
                        var withBlock2 = su;
                        // アニメ表示
                        if (SRC.BattleAnimation)
                        {
                            if (su.IsAnimationDefined("サポートガード開始", sub_situation: ""))
                            {
                                su.PlayAnimation("サポートガード開始", sub_situation: "");
                            }
                            else if (!GUI.IsRButtonPressed())
                            {
                                if (use_support_guard)
                                {
                                    GUI.MoveUnitBitmap(su, withBlock2.x, withBlock2.y, tx, ty, 80, 4);
                                }
                                else
                                {
                                    GUI.MoveUnitBitmap(su, withBlock2.x, withBlock2.y, tx, ty, 50);
                                }
                            }
                        }

                        // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                        Map.MapDataForUnit[withBlock2.x, withBlock2.y] = null;
                        prev_x = withBlock2.x;
                        prev_y = withBlock2.y;
                        prev_area = withBlock2.Area;
                        withBlock2.x = tx;
                        withBlock2.y = ty;
                        withBlock2.Area = tarea;
                        Map.MapDataForUnit[withBlock2.x, withBlock2.y] = su;
                    }

                    // ターゲットを再設定
                    t = su;
                    Commands.SelectedTarget = t;
                    Event.SelectedTargetForEvent = t;
                }
            }

            if (su is object)
            {
                // ダメージを再計算
                {
                    var withBlock3 = t;
                    prev_hp = withBlock3.HP;
                    dmg = Damage(w, t, true);
                    if (is_critical)
                    {
                        if (Expression.IsOptionDefined("ダメージ倍率低下"))
                        {
                            if (IsWeaponClassifiedAs(w, "痛"))
                            {
                                dmg = ((1d + 0.1d * (WeaponLevel(w, "痛") + 2d)) * dmg);
                            }
                            else
                            {
                                dmg = (1.2d * dmg);
                            }
                        }
                        else
                        {
                            if (IsWeaponClassifiedAs(w, "痛"))
                            {
                                dmg = ((1d + 0.25d * (WeaponLevel(w, "痛") + 2d)) * dmg);
                            }
                            else
                            {
                                dmg = (1.5d * dmg);
                            }
                        }
                    }
                }

                // かばう場合は常に全弾命中
                hit_count = attack_num;

                // 常に防御モードに設定
                def_mode = "防御";

                // サポートガードを行うユニットに関する情報を記録
                if (IsDefense())
                {
                    Commands.SupportGuardUnit2 = su;
                    Commands.SupportGuardUnitHPRatio2 = su.HP / (double)su.MaxHP;
                }
                else
                {
                    Commands.SupportGuardUnit = su;
                    Commands.SupportGuardUnitHPRatio = su.HP / (double)su.MaxHP;
                }
            }

            // 受けの処理
            if (CheckParryFeature(w, t, tx, ty, attack_mode, def_mode, dmg, msg, be_quiet || use_protect_msg))
            {
                dmg = 0;
                goto EndAttack;
            }

            // 防御＆かばう時はダメージを半減
            if (!IsWeaponClassifiedAs(w, "殺"))
            {
                if (def_mode == "防御" && !t.IsUnderSpecialPowerEffect("無防備") && !t.IsFeatureAvailable("防御不可"))
                {
                    dmg = dmg / 2;
                }
            }

            // ダミー
            if (CheckDummyFeature(w, t, be_quiet))
            {
                dmg = 0;
                goto EndAttack;
            }

            // これ以降は命中時の処理

            is_hit = true;

            // シールド防御判定
            CheckShieldFeature(w, t, dmg, be_quiet, use_shield, use_shield_msg);

            // 防御能力の処理
            if (CheckDefenseFeature(w, t, tx, ty, attack_mode, def_mode, dmg, msg, be_quiet || use_protect_msg, is_penetrated))
            {
                if (!be_quiet)
                {
                    PilotMessage(wname + "(攻撃無効化)", msg_mode: "");
                }

                dmg = 0;
                goto EndAttack;
            }

            // 命中時の特殊効果を表示。
            // 防御能力の処理を先に行うのは攻撃無効化の特殊効果を優先させるため。
            Sound.IsWavePlayed = false;
            if (!be_quiet)
            {
                PilotMessage(wname + "(命中)", msg_mode: "");
            }

            bool localIsSpecialEffectDefined3() { string argmain_situation = wname + "(命中)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            if (IsAnimationDefined(wname + "(命中)", sub_situation: "") || IsAnimationDefined(wname, sub_situation: ""))
            {
                PlayAnimation(wname + "(命中)", sub_situation: "");
            }
            else if (localIsSpecialEffectDefined3())
            {
                SpecialEffect(wname + "(命中)", sub_situation: "");
            }
            else if (!Sound.IsWavePlayed)
            {
                Effect.HitEffect(this, w, t, hit_count);
            }

            SysMessage(wname + "(命中)", sub_situation: "", add_msg: "");

            // 無敵の場合
            if (t.IsConditionSatisfied("無敵"))
            {
                if (!be_quiet)
                {
                    t.PilotMessage("攻撃無効化", msg_mode: "");
                    PilotMessage(wname + "(攻撃無効化)", msg_mode: "");
                }

                GUI.DisplaySysMessage(msg + t.Nickname + "は[" + wnickname + "]を無効化した！");
                dmg = 0;
                goto EndAttack;
            }

            // 抹殺攻撃は一撃で倒せる場合にしか効かない
            if (IsWeaponClassifiedAs(w, "殺"))
            {
                if (t.HP > dmg)
                {
                    GUI.DisplaySysMessage(msg + t.Nickname + "は攻撃による影響を受けなかった。");
                    goto EndAttack;
                }
            }

            // ターゲット位置を変更する攻撃はサポートガードの場合は無効
            if (su is null && def_mode != "援護防御")
            {
                // 吹き飛ばし
                if (IsWeaponClassifiedAs(w, "吹") || IsWeaponClassifiedAs(w, "Ｋ"))
                {
                    CheckBlowAttack(w, t, dmg, msg, attack_mode, def_mode, critical_type);
                }

                // 引き寄せ
                if (IsWeaponClassifiedAs(w, "引"))
                {
                    CheckDrawAttack(w, t, msg, def_mode, critical_type);
                }

                // 強制転移
                if (IsWeaponClassifiedAs(w, "転"))
                {
                    CheckTeleportAwayAttack(w, t, msg, def_mode, critical_type);
                }
            }

            // クリティカルメッセージはこの時点で追加
            if (is_critical)
            {
                msg = msg + "クリティカル！;";
            }

            // シールド防御の効果適用
            int spower;
            if (use_shield)
            {
                if (IsWeaponClassifiedAs(w, "破"))
                {
                    if (t.IsFeatureAvailable("小型シールド"))
                    {
                        dmg = 5 * dmg / 6;
                    }
                    else
                    {
                        dmg = 3 * dmg / 4;
                    }
                }
                else
                {
                    if (t.IsFeatureAvailable("小型シールド"))
                    {
                        dmg = 2 * dmg / 3;
                    }
                    else
                    {
                        dmg = dmg / 2;
                    }
                }

                if (t.IsFeatureAvailable("エネルギーシールド") && t.EN > 5 && !IsWeaponClassifiedAs(w, "無") && !IsUnderSpecialPowerEffect("防御能力無効化"))
                {
                    t.EN = t.EN - 5;
                    if (IsWeaponClassifiedAs(w, "破"))
                    {
                        spower = (50d * t.FeatureLevel("エネルギーシールド"));
                    }
                    else
                    {
                        spower = (100d * t.FeatureLevel("エネルギーシールド"));
                    }

                    if (dmg <= spower)
                    {
                        if (attack_mode != "反射")
                        {
                            GUI.UpdateMessageForm(this, t);
                        }
                        else
                        {
                            GUI.UpdateMessageForm(this, null);
                        }

                        fname = t.FeatureName0("エネルギーシールド");
                        if (!be_quiet)
                        {
                            if (t.IsMessageDefined("攻撃無効化(" + fname + ")"))
                            {
                                t.PilotMessage("攻撃無効化(" + fname + ")", msg_mode: "");
                            }
                            else
                            {
                                t.PilotMessage("攻撃無効化", msg_mode: "");
                            }
                        }

                        if (t.IsAnimationDefined("攻撃無効化", fname))
                        {
                            t.PlayAnimation("攻撃無効化", fname);
                        }
                        else
                        {
                            t.SpecialEffect("攻撃無効化", fname);
                        }

                        GUI.DisplaySysMessage(msg + fname + "が攻撃を防いだ。");
                        goto EndAttack;
                    }

                    dmg = dmg - spower;
                }
            }

            // 最低ダメージは10
            if (dmg > 0 && dmg < 10)
            {
                dmg = 10;
            }

            // 都合により破壊させない場合
            if (IsUnderSpecialPowerEffect("てかげん") && this.MainPilot().Technique > t.MainPilot().Technique && Strings.InStr(attack_mode, "援護攻撃") == 0 || t.IsConditionSatisfied("不死身"))
            {
                if (t.HP <= 10)
                {
                    dmg = 0;
                }
                else if (t.HP - dmg < 10)
                {
                    dmg = t.HP - 10;
                }
            }

            // 特殊効果
            CauseEffect(w, t, msg, critical_type, def_mode, dmg >= t.HP);
            if (Strings.InStr(critical_type, "即死") > 0 && !use_support_guard && !use_protect_msg)
            {
                if (t.IsHero())
                {
                    msg = msg + WeaponNickname(w) + "が" + t.Nickname + "の命を奪った。;";
                }
                else
                {
                    msg = msg + WeaponNickname(w) + "が" + t.Nickname + "を一撃で破壊した。;";
                }

                dmg = t.HP;
            }
            else if (t.HP - dmg < 0)
            {
                dmg = t.HP;
            }


            // 確実に発生する特殊効果
            int prev_en;
            if (IsWeaponClassifiedAs(w, "減") && !t.SpecialEffectImmune("減"))
            {
                msg = msg + wnickname + "が[" + t.Nickname + "]の" + Expression.Term("ＥＮ", t) + "を低下させた。;";
                t.EN = GeneralLib.MaxLng((t.EN - t.MaxEN * (dmg / (double)t.MaxHP)), 0);
            }
            else if (IsWeaponClassifiedAs(w, "奪") && !t.SpecialEffectImmune("奪"))
            {
                msg = msg + Nickname + "は[" + t.Nickname + "]の" + Expression.Term("ＥＮ", t) + "を吸収した。;";
                prev_en = t.EN;
                t.EN = GeneralLib.MaxLng((t.EN - t.MaxEN * (dmg / (double)t.MaxHP)), 0);
                EN = EN + (prev_en - t.EN) / 2;
            }

            // クリティカル時メッセージ
            if (is_critical || Strings.Len(critical_type) > 0)
            {
                if (!be_quiet)
                {
                    PilotMessage(wname + "(クリティカル)", msg_mode: "");
                }

                bool localIsSpecialEffectDefined4() { string argmain_situation = wname + "(クリティカル)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                if (IsAnimationDefined(wname + "(クリティカル)", sub_situation: ""))
                {
                    PlayAnimation(wname + "(クリティカル)", sub_situation: "");
                }
                else if (localIsSpecialEffectDefined4())
                {
                    SpecialEffect(wname + "(クリティカル)", sub_situation: "");
                }
                else
                {
                    Effect.CriticalEffect(critical_type, w, use_support_guard || use_protect_msg);
                }
            }

            ApplyDamage:
            ;

            // ダメージの適用
            t.HP = t.HP - dmg;

            // ＨＰ吸収
            if (IsWeaponClassifiedAs(w, "吸") && !t.SpecialEffectImmune("吸"))
            {
                if (HP < MaxHP)
                {
                    msg = msg + Nickname + "は[" + t.Nickname + "]の" + Expression.Term("ＨＰ", t) + "を吸収した。;";
                    HP = HP + (prev_hp - t.HP) / 4;
                }
            }

            // マップ攻撃の場合はメッセージが表示されないので
            // その代わりに少しディレイを入れる
            if (def_mode == "マップ攻撃")
            {
                GUI.Sleep(150);
            }

            // ダメージによるＨＰゲージ減少を表示
            if (attack_mode != "反射")
            {
                GUI.UpdateMessageForm(this, t);
            }
            else
            {
                GUI.UpdateMessageForm(this, null);
            }

            // ダメージ量表示前にカットインは一旦消去しておく
            if (!Expression.IsOptionDefined("戦闘中画面初期化無効") || attack_mode == "マップ攻撃")
            {
                if (GUI.IsPictureVisible)
                {
                    GUI.ClearPicture();
                    // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                    GUI.MainForm.picMain(0).Refresh();
                }
            }

            // ダメージ量をマップウィンドウに表示
            if (!Expression.IsOptionDefined("ダメージ表示無効") || attack_mode == "マップ攻撃")
            {
                if (IsAnimationDefined(wname + "(ダメージ表示)", sub_situation: ""))
                {
                    PlayAnimation(wname + "(ダメージ表示)", sub_situation: "");
                }
                else if (IsAnimationDefined("ダメージ表示", sub_situation: ""))
                {
                    PlayAnimation("ダメージ表示", sub_situation: "");
                }
                else
                {
                    if (!SRC.BattleAnimation || WeaponPower(w, "") > 0 || dmg > 0)
                    {
                        if (!SRC.BattleAnimation && su is object)
                        {
                            GUI.DrawSysString(prev_x, prev_y, Microsoft.VisualBasic.Compatibility.VB6.Support.Format(dmg));
                        }
                        else
                        {
                            GUI.DrawSysString(t.x, t.y, Microsoft.VisualBasic.Compatibility.VB6.Support.Format(dmg));
                        }
                    }
                }
            }

            // 自動反撃発動
            if (t.HP > 0)
            {
                CheckAutoAttack(w, t, attack_mode, def_mode, dmg, be_quiet || use_protect_msg);
                if (Status != "出撃")
                {
                    goto EndAttack;
                }
            }

            // 破壊アニメ
            if (t.HP == 0)
            {
                if (t.IsAnimationDefined("破壊", sub_situation: ""))
                {
                    t.PlayAnimation("破壊", sub_situation: "");
                }
                else
                {
                    t.SpecialEffect("破壊", sub_situation: "");
                }
            }

            // パーツ分離が発動可能かチェック
            separate_parts = false;
            if (t.HP == 0)
            {
                if (t.IsFeatureAvailable("パーツ分離"))
                {
                    string localLIndex() { object argIndex1 = "パーツ分離"; string arglist = t.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                    Unit localOtherForm() { object argIndex1 = (object)hs03c1bfcb86cd46eaab84349de7f47706(); var ret = t.OtherForm(argIndex1); return ret; }

                    if (localOtherForm().IsAbleToEnter(t.x, t.y))
                    {
                        if (t.IsFeatureLevelSpecified("パーツ分離"))
                        {
                            if (GeneralLib.Dice(100) <= 10d * t.FeatureLevel("パーツ分離"))
                            {
                                separate_parts = true;
                            }
                        }
                        else
                        {
                            separate_parts = true;
                        }
                    }
                }
            }

            // 破壊メッセージ
            if (attack_mode != "マップ攻撃" && !use_protect_msg && !use_shield_msg)
            {
                if (t.HP == 0)
                {
                    if (separate_parts)
                    {
                        fname = t.FeatureName("パーツ分離");
                        bool localIsMessageDefined4() { string argmain_situation = "破壊時分離(" + fname + ")"; var ret = t.IsMessageDefined(argmain_situation); return ret; }

                        bool localIsMessageDefined5() { string argmain_situation = "分離(" + t.Name + ")"; var ret = t.IsMessageDefined(argmain_situation); return ret; }

                        bool localIsMessageDefined6() { string argmain_situation = "分離(" + fname + ")"; var ret = t.IsMessageDefined(argmain_situation); return ret; }

                        if (t.IsMessageDefined("破壊時分離(" + t.Name + ")"))
                        {
                            t.PilotMessage("破壊時分離(" + t.Name + ")", msg_mode: "");
                        }
                        else if (localIsMessageDefined4())
                        {
                            t.PilotMessage("破壊時分離(" + fname + ")", msg_mode: "");
                        }
                        else if (t.IsMessageDefined("破壊時"))
                        {
                            t.PilotMessage("破壊時分離", msg_mode: "");
                        }
                        else if (localIsMessageDefined5())
                        {
                            t.PilotMessage("分離(" + t.Name + ")", msg_mode: "");
                        }
                        else if (localIsMessageDefined6())
                        {
                            t.PilotMessage("分離(" + fname + ")", msg_mode: "");
                        }
                        else if (t.IsMessageDefined("分離"))
                        {
                            t.PilotMessage("分離", msg_mode: "");
                        }
                        else
                        {
                            t.PilotMessage("ダメージ大", msg_mode: "");
                        }
                    }
                    else
                    {
                        t.PilotMessage("破壊", msg_mode: "");
                    }
                }
            }

            if (!be_quiet)
            {
                if (t.HP == 0)
                {
                    // とどめメッセージ
                    PilotMessage(wname + "(とどめ)", msg_mode: "");
                }
                else
                {
                    // ダメージメッセージ
                    PilotMessage(wname + "(ダメージ)", msg_mode: "");
                }
            }

            // ダメージアニメ
            if (t.HP == 0)
            {
                // どどめアニメ
                if (attack_mode != "マップ攻撃" && attack_mode != "反射")
                {
                    if (IsAnimationDefined(wname + "(とどめ)", sub_situation: ""))
                    {
                        PlayAnimation(wname + "(とどめ)", sub_situation: "");
                    }
                    else
                    {
                        SpecialEffect(wname + "(とどめ)", sub_situation: "");
                    }
                }
            }
            else if ((dmg <= 0.05d * t.MaxHP && t.HP >= 0.25d * t.MaxHP || dmg <= 10) && Strings.Len(critical_type) == 0)
            {
                // ダメージが非常に小さい
                if (t.IsAnimationDefined("ダメージ小", sub_situation: ""))
                {
                    t.PlayAnimation("ダメージ小", sub_situation: "");
                }
                else
                {
                    t.SpecialEffect("ダメージ小", sub_situation: "");
                }
            }
            else if (t.HP < 0.25d * t.MaxHP)
            {
                // ダメージ大
                if (t.IsAnimationDefined("ダメージ大", sub_situation: ""))
                {
                    t.PlayAnimation("ダメージ大", sub_situation: "");
                }
                else
                {
                    t.SpecialEffect("ダメージ大", sub_situation: "");
                }
            }
            else if (t.HP > 0.8d * t.MaxHP && Strings.Len(critical_type) == 0)
            {
                // ダメージ小
                if (t.IsAnimationDefined("ダメージ小", sub_situation: ""))
                {
                    t.PlayAnimation("ダメージ小", sub_situation: "");
                }
                else
                {
                    t.SpecialEffect("ダメージ小", sub_situation: "");
                }
            }
            else
            {
                // ダメージ中
                if (t.IsAnimationDefined("ダメージ中", sub_situation: ""))
                {
                    t.PlayAnimation("ダメージ中", sub_situation: "");
                }
                else
                {
                    t.SpecialEffect("ダメージ中", sub_situation: "");
                }
            }

            // ダメージメッセージ
            if (attack_mode != "マップ攻撃" && !use_protect_msg && !use_shield_msg)
            {
                if (t.HP == 0)
                {
                }
                // 破壊時メッセージは既に表示している
                else if ((dmg <= 0.05d * t.MaxHP && t.HP >= 0.25d * t.MaxHP || dmg <= 10) && Strings.Len(critical_type) == 0)
                {
                    // ダメージが非常に小さい
                    t.PilotMessage("ダメージ小", msg_mode: "");
                }
                else if (t.HP < 0.25d * t.MaxHP)
                {
                    // ダメージ大
                    t.PilotMessage("ダメージ大", msg_mode: "");
                }
                else if (is_penetrated && t.IsMessageDefined("バリア貫通"))
                {
                    t.PilotMessage("バリア貫通", msg_mode: "");
                }
                else if (t.HP >= 0.8d * t.MaxHP && Strings.Len(critical_type) == 0)
                {
                    // ステータス異常が起こった場合は最低でもダメージ中のメッセージ
                    t.PilotMessage("ダメージ小", msg_mode: "");
                }
                else
                {
                    t.PilotMessage("ダメージ中", msg_mode: "");
                }
            }

            // シールド防御
            if (use_shield && t.HP > 0)
            {
                if (t.IsFeatureAvailable("シールド"))
                {
                    fname = t.FeatureName("シールド");
                    if (t.IsSysMessageDefined("シールド防御", fname))
                    {
                        t.SysMessage("シールド防御", fname, add_msg: "");
                    }
                    else
                    {
                        msg = msg + t.Nickname + "は[" + fname + "]で防御した。;";
                    }
                }
                else if (t.IsFeatureAvailable("エネルギーシールド") && t.EN > 5 && !IsWeaponClassifiedAs(w, "無") && !IsUnderSpecialPowerEffect("防御能力無効化"))
                {
                    t.EN = t.EN - 5;
                    fname = t.FeatureName("エネルギーシールド");
                    if (t.IsSysMessageDefined("シールド防御", fname))
                    {
                        t.SysMessage("シールド防御", fname, add_msg: "");
                    }
                    else
                    {
                        msg = msg + t.Nickname + "は[" + fname + "]を展開した。;";
                    }
                }
                else if (t.IsFeatureAvailable("小型シールド"))
                {
                    fname = t.FeatureName("小型シールド");
                    if (t.IsSysMessageDefined("シールド防御", fname))
                    {
                        t.SysMessage("シールド防御", fname, add_msg: "");
                    }
                    else
                    {
                        msg = msg + t.Nickname + "は[" + fname + "]で防御した。;";
                    }
                }
                else if (t.IsFeatureAvailable("大型シールド"))
                {
                    fname = t.FeatureName("大型シールド");
                    if (t.IsSysMessageDefined("シールド防御", fname))
                    {
                        t.SysMessage("シールド防御", fname, add_msg: "");
                    }
                    else
                    {
                        msg = msg + t.Nickname + "は[" + fname + "]で防御した。;";
                    }
                }
                else if (t.IsFeatureAvailable("アクティブシールド"))
                {
                    fname = t.FeatureName("アクティブシールド");
                    if (t.IsSysMessageDefined("シールド防御", fname))
                    {
                        t.SysMessage("シールド防御", fname, add_msg: "");
                    }
                    else if (!t.IsHero())
                    {
                        msg = msg + t.Nickname + "の[" + fname + "]が機体を守った。;";
                    }
                    else
                    {
                        msg = msg + fname + "が[" + t.Nickname + "]を守った。;";
                    }
                }
            }

            // ターゲットが生き残った場合の処理
            if (t.HP > 0)
            {
                if (dmg == 0)
                {
                    if (Strings.Len(critical_type) > 0)
                    {
                        GUI.DisplaySysMessage(msg);
                    }
                    else if (IsWeaponClassifiedAs(w, "盗"))
                    {
                        // 盗み失敗
                        if (t.IsConditionSatisfied("すかんぴん"))
                        {
                            GUI.DisplaySysMessage(msg + t.Nickname + "は盗める物を持っていなかった。");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(msg + t.Nickname + "は素早く持ち物を守った。");
                        }
                    }
                    else if (IsWeaponClassifiedAs(w, "習"))
                    {
                        // ラーニング失敗
                        if (t.IsFeatureAvailable("ラーニング可能技"))
                        {
                            buf = t.FeatureData("ラーニング可能技");
                            switch (GeneralLib.LIndex(buf, 2) ?? "")
                            {
                                case "表示":
                                case var @case when @case == "":
                                    {
                                        fname = GeneralLib.LIndex(buf, 1);
                                        break;
                                    }

                                default:
                                    {
                                        fname = GeneralLib.LIndex(buf, 2);
                                        break;
                                    }
                            }

                            if (MainPilot().IsSkillAvailable(GeneralLib.LIndex(buf, 1)))
                            {
                                GUI.DisplaySysMessage(msg + MainPilot().get_Nickname(false) + "は「" + fname + "」を既に習得していた。");
                            }
                            else
                            {
                                GUI.DisplaySysMessage(msg + MainPilot().get_Nickname(false) + "は「" + fname + "」を習得出来なかった。");
                            }
                        }
                        else
                        {
                            GUI.DisplaySysMessage(msg + t.Nickname + "は習得可能な技を持っていなかった。");
                        }
                    }
                    else if (IsWeaponClassifiedAs(w, "写") || IsWeaponClassifiedAs(w, "化"))
                    {
                    }
                    // 能力コピーの判定はこれから
                    else
                    {
                        GUI.DisplaySysMessage(msg + t.Nickname + "は攻撃による影響を受けなかった。");
                    }
                }
                else if (t.IsConditionSatisfied("データ不明"))
                {
                    if (attack_num > 1)
                    {
                        msg = msg + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(hit_count) + "回命中し、";
                    }

                    GUI.DisplaySysMessage(msg + t.Nickname + "は[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(dmg) + "]のダメージを受けた。");
                }
                else
                {
                    if (attack_num > 1)
                    {
                        msg = msg + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(hit_count) + "回命中し、";
                    }

                    GUI.DisplaySysMessage(msg + t.Nickname + "は[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(dmg) + "]のダメージを受けた。;" + "残りＨＰは" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(t.HP) + "（損傷率 = " + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (t.MaxHP - t.HP) / t.MaxHP) + "％）");
                }

                // 特殊能力「不安定」による暴走チェック
                if (t.IsFeatureAvailable("不安定"))
                {
                    if (t.HP <= t.MaxHP / 4 && !t.IsConditionSatisfied("暴走"))
                    {
                        t.AddCondition("暴走", -1, cdata: "");
                        t.Update();
                        if (t.IsHero())
                        {
                            GUI.DisplaySysMessage(t.Nickname + "は暴走した。");
                        }
                        else
                        {
                            if (Strings.Len(t.FeatureName("不安定")) > 0)
                            {
                                GUI.DisplaySysMessage(t.Nickname + "は[" + t.FeatureName("不安定") + "]の暴走のために制御不能に陥った。");
                            }
                            else
                            {
                                GUI.DisplaySysMessage(t.Nickname + "は制御不能に陥った。");
                            }
                        }
                    }
                }

                // ダメージを受ければ眠りからさめる
                if (t.IsConditionSatisfied("睡眠") && !IsWeaponClassifiedAs(w, "眠"))
                {
                    t.DeleteCondition("睡眠");
                    GUI.DisplaySysMessage(t.Nickname + "は眠りから覚めた。");
                }

                // ダメージを受けると凍結解除
                if (t.IsConditionSatisfied("凍結") && !IsWeaponClassifiedAs(w, "凍"))
                {
                    t.DeleteCondition("凍結");
                    GUI.DisplaySysMessage(t.Nickname + "は凍結状態から開放された。");
                }
            }

            // 破壊された場合の処理
            int morale_mod;
            if (t.HP == 0)
            {
                if (attack_num > 1)
                {
                    msg = msg + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(hit_count) + "回命中し、";
                }

                if (t.IsSysMessageDefined("破壊", sub_situation: ""))
                {
                    t.SysMessage("破壊", sub_situation: "", add_msg: "");
                }
                else if (t.IsHero())
                {
                    GUI.DisplaySysMessage(msg + t.Nickname + "は[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(dmg) + "]のダメージを受け倒された。");
                }
                else
                {
                    GUI.DisplaySysMessage(msg + t.Nickname + "は[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(dmg) + "]のダメージを受け破壊された。");
                }

                // 復活するかどうかのチェックを行う

                // スペシャルパワー「復活」
                if (t.IsUnderSpecialPowerEffect("復活"))
                {
                    t.RemoveSpecialPowerInEffect("破壊");
                    goto Resurrect;
                }

                // パイロット用特殊能力「英雄」＆「再生」
                if (!is_event && !IsUnderSpecialPowerEffect("絶対破壊"))
                {
                    if (GeneralLib.Dice(16) <= t.MainPilot().SkillLevel("英雄", ref_mode: ""))
                    {
                        t.HP = t.MaxHP / 2;
                        t.IncreaseMorale(10);
                        if (t.IsMessageDefined("復活"))
                        {
                            t.PilotMessage("復活", msg_mode: "");
                        }

                        if (t.IsAnimationDefined("復活", sub_situation: ""))
                        {
                            t.PlayAnimation("復活", sub_situation: "");
                        }
                        else
                        {
                            t.SpecialEffect("復活", sub_situation: "");
                        }

                        buf = t.MainPilot().SkillName0("英雄");
                        if (buf == "非表示")
                        {
                            buf = "英雄";
                        }

                        if (t.IsSysMessageDefined("復活", buf))
                        {
                            t.SysMessage("復活", buf, add_msg: "");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(t.MainPilot().get_Nickname(false) + "の熱き" + buf + "の心が[" + t.Nickname + "]を復活させた！");
                        }

                        goto Resurrect;
                    }

                    // 浄化の適用
                    if (t.MainPilot().IsSkillAvailable("再生"))
                    {
                        if (IsWeaponClassifiedAs(w, "浄"))
                        {
                            if (MainPilot().IsSkillAvailable("浄化"))
                            {
                                bool localIsMessageDefined7() { string argmain_situation = "浄解(" + wname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                                if (IsMessageDefined("浄化(" + wname + ")"))
                                {
                                    PilotMessage("浄化(" + wname + ")", msg_mode: "");
                                    if (IsAnimationDefined("浄化", wname))
                                    {
                                        PlayAnimation("浄化", wname);
                                    }
                                    else
                                    {
                                        SpecialEffect("浄化", wname);
                                    }
                                }
                                else if (IsMessageDefined("浄化"))
                                {
                                    PilotMessage("浄化", msg_mode: "");
                                    if (IsAnimationDefined("浄化", wname))
                                    {
                                        PlayAnimation("浄化", wname);
                                    }
                                    else
                                    {
                                        SpecialEffect("浄化", wname);
                                    }
                                }
                                else if (localIsMessageDefined7())
                                {
                                    PilotMessage("浄解(" + wname + ")", msg_mode: "");
                                    if (IsAnimationDefined("浄解", wname))
                                    {
                                        PlayAnimation("浄解", wname);
                                    }
                                    else
                                    {
                                        SpecialEffect("浄解", wname);
                                    }
                                }
                                else if (IsMessageDefined("浄解"))
                                {
                                    PilotMessage("浄解", msg_mode: "");
                                    if (IsAnimationDefined("浄解", wname))
                                    {
                                        PlayAnimation("浄解", wname);
                                    }
                                    else
                                    {
                                        SpecialEffect("浄解", wname);
                                    }
                                }

                                if (IsSysMessageDefined("浄化", sub_situation: ""))
                                {
                                    SysMessage("浄化", sub_situation: "", add_msg: "");
                                }
                                else
                                {
                                    GUI.DisplaySysMessage(MainPilot().get_Nickname(false) + "は浄化を行って[" + t.Nickname + "]の復活を防いだ。");
                                }

                                goto Cure;
                            }

                            var loopTo2 = CountPilot();
                            for (i = 2; i <= loopTo2; i++)
                            {
                                Pilot localPilot1() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                                if (localPilot1().IsSkillAvailable("浄化"))
                                {
                                    bool localIsMessageDefined8() { string argmain_situation = "浄解(" + wname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                                    if (IsMessageDefined("浄化(" + wname + ")"))
                                    {
                                        PilotMessage("浄化(" + wname + ")", msg_mode: "");
                                        if (IsAnimationDefined("浄化", wname))
                                        {
                                            PlayAnimation("浄化", wname);
                                        }
                                        else
                                        {
                                            SpecialEffect("浄化", wname);
                                        }
                                    }
                                    else if (IsMessageDefined("浄化"))
                                    {
                                        PilotMessage("浄化", msg_mode: "");
                                        if (IsAnimationDefined("浄化", wname))
                                        {
                                            PlayAnimation("浄化", wname);
                                        }
                                        else
                                        {
                                            SpecialEffect("浄化", wname);
                                        }
                                    }
                                    else if (localIsMessageDefined8())
                                    {
                                        PilotMessage("浄解(" + wname + ")", msg_mode: "");
                                        if (IsAnimationDefined("浄解", wname))
                                        {
                                            PlayAnimation("浄解", wname);
                                        }
                                        else
                                        {
                                            SpecialEffect("浄解", wname);
                                        }
                                    }
                                    else if (IsMessageDefined("浄解"))
                                    {
                                        PilotMessage("浄解", msg_mode: "");
                                        if (IsAnimationDefined("浄解", wname))
                                        {
                                            PlayAnimation("浄解", wname);
                                        }
                                        else
                                        {
                                            SpecialEffect("浄解", wname);
                                        }
                                    }

                                    if (IsSysMessageDefined("浄化", sub_situation: ""))
                                    {
                                        SysMessage("浄化", sub_situation: "", add_msg: "");
                                    }
                                    else
                                    {
                                        Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                                        GUI.DisplaySysMessage(localPilot().get_Nickname(false) + "は浄化を行って[" + t.Nickname + "]の復活を防いだ。");
                                    }

                                    goto Cure;
                                }
                            }

                            var loopTo3 = CountSupport();
                            for (i = 1; i <= loopTo3; i++)
                            {
                                Pilot localSupport1() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                                if (localSupport1().IsSkillAvailable("浄化"))
                                {
                                    bool localIsMessageDefined9() { string argmain_situation = "浄解(" + wname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                                    if (IsMessageDefined("浄化(" + wname + ")"))
                                    {
                                        PilotMessage("浄化(" + wname + ")", msg_mode: "");
                                        if (IsAnimationDefined("浄化", wname))
                                        {
                                            PlayAnimation("浄化", wname);
                                        }
                                        else
                                        {
                                            SpecialEffect("浄化", wname);
                                        }
                                    }
                                    else if (IsMessageDefined("浄化"))
                                    {
                                        PilotMessage("浄化", msg_mode: "");
                                        if (IsAnimationDefined("浄化", wname))
                                        {
                                            PlayAnimation("浄化", wname);
                                        }
                                        else
                                        {
                                            SpecialEffect("浄化", wname);
                                        }
                                    }
                                    else if (localIsMessageDefined9())
                                    {
                                        PilotMessage("浄解(" + wname + ")", msg_mode: "");
                                        if (IsAnimationDefined("浄解", wname))
                                        {
                                            PlayAnimation("浄解", wname);
                                        }
                                        else
                                        {
                                            SpecialEffect("浄解", wname);
                                        }
                                    }
                                    else if (IsMessageDefined("浄解"))
                                    {
                                        PilotMessage("浄解", msg_mode: "");
                                        if (IsAnimationDefined("浄解", wname))
                                        {
                                            PlayAnimation("浄解", wname);
                                        }
                                        else
                                        {
                                            SpecialEffect("浄解", wname);
                                        }
                                    }

                                    if (IsSysMessageDefined("浄化", sub_situation: ""))
                                    {
                                        SysMessage("浄化", sub_situation: "", add_msg: "");
                                    }
                                    else
                                    {
                                        Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                                        GUI.DisplaySysMessage(localSupport().get_Nickname(false) + "は浄化を行って[" + t.Nickname + "]の復活を防いだ。");
                                    }

                                    goto Cure;
                                }
                            }

                            if (IsHero())
                            {
                                bool localIsMessageDefined10() { string argmain_situation = "浄解(" + wname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                                if (IsMessageDefined("浄化(" + wname + ")"))
                                {
                                    PilotMessage("浄化(" + wname + ")", msg_mode: "");
                                    if (IsAnimationDefined("浄化", wname))
                                    {
                                        PlayAnimation("浄化", wname);
                                    }
                                    else
                                    {
                                        SpecialEffect("浄化", wname);
                                    }

                                    GUI.DisplaySysMessage(MainPilot().get_Nickname(false) + "は浄化を行って[" + t.Nickname + "]の復活を防いだ。");
                                }
                                else if (IsMessageDefined("浄化"))
                                {
                                    PilotMessage("浄化", msg_mode: "");
                                    if (IsAnimationDefined("浄化", wname))
                                    {
                                        PlayAnimation("浄化", wname);
                                    }
                                    else
                                    {
                                        SpecialEffect("浄化", wname);
                                    }

                                    GUI.DisplaySysMessage(MainPilot().get_Nickname(false) + "は浄化を行って[" + t.Nickname + "]の復活を防いだ。");
                                }
                                else if (localIsMessageDefined10())
                                {
                                    PilotMessage("浄解(" + wname + ")", msg_mode: "");
                                    if (IsAnimationDefined("浄解", wname))
                                    {
                                        PlayAnimation("浄解", wname);
                                    }
                                    else
                                    {
                                        SpecialEffect("浄解", wname);
                                    }

                                    GUI.DisplaySysMessage(MainPilot().get_Nickname(false) + "は浄化を行って[" + t.Nickname + "]の復活を防いだ。");
                                }
                                else if (IsMessageDefined("浄解"))
                                {
                                    PilotMessage("浄解", msg_mode: "");
                                    if (IsAnimationDefined("浄解", wname))
                                    {
                                        PlayAnimation("浄解", wname);
                                    }
                                    else
                                    {
                                        SpecialEffect("浄解", wname);
                                    }

                                    if (IsSysMessageDefined("浄化", sub_situation: ""))
                                    {
                                        SysMessage("浄化", sub_situation: "", add_msg: "");
                                    }
                                    else
                                    {
                                        GUI.DisplaySysMessage(MainPilot().get_Nickname(false) + "は浄化を行って[" + t.Nickname + "]の復活を防いだ。");
                                    }
                                }

                                goto Cure;
                            }
                        }

                        if (GeneralLib.Dice(16) <= t.MainPilot().SkillLevel("再生", ref_mode: ""))
                        {
                            t.HP = t.MaxHP / 2;
                            if (t.IsMessageDefined("復活"))
                            {
                                t.PilotMessage("復活", msg_mode: "");
                            }

                            if (t.IsAnimationDefined("復活", sub_situation: ""))
                            {
                                t.PlayAnimation("復活", sub_situation: "");
                            }
                            else
                            {
                                t.SpecialEffect("復活", sub_situation: "");
                            }

                            buf = t.MainPilot().SkillName0("再生");
                            if (buf == "非表示")
                            {
                                buf = "再生";
                            }

                            if (t.IsSysMessageDefined("再生", buf))
                            {
                                t.SysMessage("再生", buf, add_msg: "");
                            }
                            else
                            {
                                GUI.DisplaySysMessage(t.Nickname + "は" + buf + "の力で一瞬にして復活した！");
                            }

                            goto Resurrect;
                        }
                    }
                }

                Cure:
                ;


                // ユニット破壊によるパーツ分離
                if (separate_parts)
                {
                    uname = GeneralLib.LIndex(t.FeatureData("パーツ分離"), 2);
                    if (!t.IsHero())
                    {
                        if (SRC.BattleAnimation)
                        {
                            Effect.ExplodeAnimation(t.Size, t.x, t.y);
                            t.Size = argtsize;
                        }
                        else
                        {
                            Sound.PlayWave("Explode.wav");
                        }
                    }

                    fname = t.FeatureName("パーツ分離");
                    bool localIsAnimationDefined4() { string argmain_situation = "破壊時分離(" + fname + ")"; string argsub_situation = ""; var ret = t.IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    bool localIsSpecialEffectDefined5() { string argmain_situation = "破壊時分離(" + t.Name + ")"; string argsub_situation = ""; var ret = t.IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    bool localIsSpecialEffectDefined6() { string argmain_situation = "破壊時分離(" + fname + ")"; string argsub_situation = ""; var ret = t.IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    bool localIsAnimationDefined5() { string argmain_situation = "分離(" + t.Name + ")"; string argsub_situation = ""; var ret = t.IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    bool localIsAnimationDefined6() { string argmain_situation = "分離(" + fname + ")"; string argsub_situation = ""; var ret = t.IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    bool localIsSpecialEffectDefined7() { string argmain_situation = "分離(" + t.Name + ")"; string argsub_situation = ""; var ret = t.IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    bool localIsSpecialEffectDefined8() { string argmain_situation = "分離(" + fname + ")"; string argsub_situation = ""; var ret = t.IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    if (t.IsAnimationDefined("破壊時分離(" + t.Name + ")", sub_situation: ""))
                    {
                        t.PlayAnimation("破壊時分離(" + t.Name + ")", sub_situation: "");
                    }
                    else if (localIsAnimationDefined4())
                    {
                        t.PlayAnimation("破壊時分離(" + fname + ")", sub_situation: "");
                    }
                    else if (t.IsAnimationDefined("破壊時分離", sub_situation: ""))
                    {
                        t.PlayAnimation("破壊時分離", sub_situation: "");
                    }
                    else if (localIsSpecialEffectDefined5())
                    {
                        t.SpecialEffect("破壊時分離(" + t.Name + ")", sub_situation: "");
                    }
                    else if (localIsSpecialEffectDefined6())
                    {
                        t.SpecialEffect("破壊時分離(" + fname + ")", sub_situation: "");
                    }
                    else if (t.IsSpecialEffectDefined("破壊時分離", sub_situation: ""))
                    {
                        t.SpecialEffect("破壊時分離", sub_situation: "");
                    }
                    else if (localIsAnimationDefined5())
                    {
                        t.PlayAnimation("分離(" + t.Name + ")", sub_situation: "");
                    }
                    else if (localIsAnimationDefined6())
                    {
                        t.PlayAnimation("分離(" + fname + ")", sub_situation: "");
                    }
                    else if (t.IsAnimationDefined("分離", sub_situation: ""))
                    {
                        t.PlayAnimation("分離", sub_situation: "");
                    }
                    else if (localIsSpecialEffectDefined7())
                    {
                        t.SpecialEffect("分離(" + t.Name + ")", sub_situation: "");
                    }
                    else if (localIsSpecialEffectDefined8())
                    {
                        t.SpecialEffect("分離(" + fname + ")", sub_situation: "");
                    }
                    else
                    {
                        t.SpecialEffect("分離", sub_situation: "");
                    }

                    t.Transform(uname);
                    {
                        var withBlock4 = t.CurrentForm();
                        withBlock4.HP = withBlock4.MaxHP;
                        // 自分から攻撃して破壊された時には行動数を0に
                        if ((withBlock4.Party ?? "") == (SRC.Stage ?? ""))
                        {
                            withBlock4.UsedAction = withBlock4.MaxAction();
                        }
                    }

                    bool localIsSysMessageDefined() { string argmain_situation = "破壊時分離(" + fname + ")"; string argsub_situation = ""; var ret = t.IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    bool localIsSysMessageDefined1() { string argmain_situation = "分離(" + t.Name + ")"; string argsub_situation = ""; var ret = t.IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    bool localIsSysMessageDefined2() { string argmain_situation = "分離(" + fname + ")"; string argsub_situation = ""; var ret = t.IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    if (t.IsSysMessageDefined("破壊時分離(" + t.Name + ")", sub_situation: ""))
                    {
                        t.SysMessage("破壊時分離(" + t.Name + ")", sub_situation: "", add_msg: "");
                    }
                    else if (localIsSysMessageDefined())
                    {
                        t.SysMessage("破壊時分離(" + fname + ")", sub_situation: "", add_msg: "");
                    }
                    else if (t.IsSysMessageDefined("破壊時分離", sub_situation: ""))
                    {
                        t.SysMessage("破壊時分離", sub_situation: "", add_msg: "");
                    }
                    else if (localIsSysMessageDefined1())
                    {
                        t.SysMessage("分離(" + t.Name + ")", sub_situation: "", add_msg: "");
                    }
                    else if (localIsSysMessageDefined2())
                    {
                        t.SysMessage("分離(" + fname + ")", sub_situation: "", add_msg: "");
                    }
                    else if (t.IsSysMessageDefined("分離", sub_situation: ""))
                    {
                        t.SysMessage("分離", sub_situation: "", add_msg: "");
                    }
                    else if (t.IsHero())
                    {
                        Unit localOtherForm2() { object argIndex1 = uname; var ret = t.OtherForm(argIndex1); return ret; }

                        if ((t.Nickname ?? "") != (localOtherForm2().Nickname ?? ""))
                        {
                            Unit localOtherForm1() { object argIndex1 = uname; var ret = t.OtherForm(argIndex1); return ret; }

                            GUI.DisplaySysMessage(t.Nickname + "は" + localOtherForm1().Nickname + "に変化した。");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(t.Nickname + "は変化し、蘇った。");
                        }
                    }
                    else
                    {
                        GUI.DisplaySysMessage(t.Nickname + "は破壊されたパーツを分離させた。");
                    }

                    t = t.CurrentForm();
                    Commands.SelectedTarget = t;
                    Event.SelectedTargetForEvent = t;
                    goto Resurrect;
                }

                // ユニット破壊による気力の変動
                if (attack_mode != "マップ攻撃")
                {
                    // 敵を破壊したユニットのパイロットはトータルで気力+4
                    if (Strings.InStr(attack_mode, "援護攻撃") > 0)
                    {
                        Commands.AttackUnit.CurrentForm().IncreaseMorale(3);
                    }
                    else
                    {
                        IncreaseMorale(3);
                    }

                    // それ以外のパイロット
                    foreach (Pilot p in SRC.PList)
                    {
                        // 出撃中のパイロットのみが対象
                        if (p.Unit is null)
                        {
                            goto NextPilot;
                        }

                        if (p.Unit.Status != "出撃")
                        {
                            goto NextPilot;
                        }

                        if ((p.Party ?? "") == (Party ?? ""))
                        {
                            // 敵を破壊したユニットの陣営のパイロットは気力+1
                            if (p.Personality != "機械")
                            {
                                p.Morale = (p.Morale + 1);
                            }
                        }
                        else if ((p.Party ?? "") == (t.Party ?? ""))
                        {
                            // 破壊されたユニットの陣営のパイロットは性格に応じて気力を変化
                            switch (p.Personality ?? "")
                            {
                                case "超強気":
                                    {
                                        morale_mod = 2;
                                        break;
                                    }

                                case "強気":
                                    {
                                        morale_mod = 1;
                                        break;
                                    }

                                case "弱気":
                                    {
                                        morale_mod = -1;
                                        break;
                                    }

                                default:
                                    {
                                        morale_mod = 0;
                                        break;
                                    }
                            }

                            // 味方の場合の気力変化量はオプションで変化する
                            if (p.Party == "味方" && Expression.IsOptionDefined("破壊時味方気力変化５倍"))
                            {
                                p.Morale = (p.Morale + 5 * morale_mod);
                            }
                            else
                            {
                                p.Morale = (p.Morale + morale_mod);
                            }
                        }

                        NextPilot:
                        ;
                    }
                }

                // 脱出メッセージの表示
                bool localIsEventDefined() { string arglname = "破壊 " + t.MainPilot().ID; var ret = Event.IsEventDefined(arglname, true); return ret; }

                if (t.IsMessageDefined("脱出") && !is_event && !localIsEventDefined())
                {
                    t.PilotMessage("脱出", msg_mode: "");
                }

                // 戦闘アニメ表示を使わない場合はかばったユニットを元の位置に戻しておく
                if (!SRC.BattleAnimation)
                {
                    if (su is object)
                    {
                        {
                            var withBlock5 = su;
                            withBlock5.x = prev_x;
                            withBlock5.y = prev_y;
                            withBlock5.Area = prev_area;
                        }
                    }
                }

                // ユニットを破壊
                t.Die();
            }

            Resurrect:
            ;
            // 復活した場合は破壊関連の処理を行わない

            EndAttack:
            ;
            if (Status == "出撃" && t.Status == "出撃" && Strings.InStr(attack_mode, "援護攻撃") == 0 && attack_mode != "マップ攻撃" && attack_mode != "反射" && !IsWeaponClassifiedAs(w, "合") && HP > 0 && t.HP > 0)
            {
                // 再攻撃
                if (!second_attack && IsWeaponAvailable(w, "ステータス") && IsTargetWithinRange(w, t))
                {
                    // スペシャルパワー効果「再攻撃」
                    if (IsUnderSpecialPowerEffect("再攻撃"))
                    {
                        second_attack = true;
                        RemoveSpecialPowerInEffect("攻撃");
                        goto begin;
                    }

                    // 再攻撃能力
                    if (MainPilot().IsSkillAvailable("再攻撃"))
                    {
                        if (this.MainPilot().Intuition >= t.MainPilot().Intuition)
                        {
                            slevel = (2d * MainPilot().SkillLevel("再攻撃", ref_mode: ""));
                        }
                        else
                        {
                            slevel = MainPilot().SkillLevel("再攻撃", ref_mode: "");
                        }

                        if (slevel >= GeneralLib.Dice(32))
                        {
                            second_attack = true;
                            RemoveSpecialPowerInEffect("攻撃");
                            goto begin;
                        }
                    }

                    // 再属性
                    if (WeaponLevel(w, "再") >= GeneralLib.Dice(16))
                    {
                        second_attack = true;
                        RemoveSpecialPowerInEffect("攻撃");
                        goto begin;
                    }
                }

                // 追加攻撃
                if (ReferenceEquals(su, t))
                {
                    CheckAdditionalAttack(w, t, be_quiet, attack_mode, "援護防御", dmg);
                }
                else
                {
                    CheckAdditionalAttack(w, t, be_quiet, attack_mode, "", dmg);
                }
            }

            // サポートガードを行ったユニットは破壊処理の前に以前の位置に復帰させる
            int sx, sy;
            if (su is object)
            {
                su = su.CurrentForm();
                {
                    var withBlock6 = su;
                    sx = withBlock6.x;
                    sy = withBlock6.y;

                    // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                    Map.MapDataForUnit[sx, sy] = null;
                    withBlock6.x = prev_x;
                    withBlock6.y = prev_y;
                    withBlock6.Area = prev_area;
                    if (withBlock6.Status == "出撃")
                    {
                        Map.MapDataForUnit[withBlock6.x, withBlock6.y] = su;
                        Map.MapDataForUnit[tx, ty] = orig_t;
                        if (SRC.BattleAnimation)
                        {
                            if (su.IsAnimationDefined("サポートガード終了", sub_situation: ""))
                            {
                                if (!GUI.IsRButtonPressed())
                                {
                                    su.PlayAnimation("サポートガード終了", sub_situation: "");
                                }
                            }
                            else if (!GUI.IsRButtonPressed())
                            {
                                GUI.PaintUnitBitmap(orig_t, "リフレッシュ無し");
                                if (use_support_guard)
                                {
                                    GUI.MoveUnitBitmap(su, sx, sy, withBlock6.x, withBlock6.y, 80, 4);
                                }
                                else
                                {
                                    GUI.MoveUnitBitmap(su, sx, sy, withBlock6.x, withBlock6.y, 50);
                                }
                            }
                            else
                            {
                                GUI.PaintUnitBitmap(su, "リフレッシュ無し");
                                GUI.PaintUnitBitmap(orig_t, "リフレッシュ無し");
                            }
                        }
                    }
                    else
                    {
                        // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                        Map.MapDataForUnit[withBlock6.x, withBlock6.y] = null;
                        Map.MapDataForUnit[tx, ty] = orig_t;
                        GUI.PaintUnitBitmap(orig_t, "リフレッシュ無し");
                    }
                }
            }

            if (is_hit)
            {
                // 攻撃を命中させたことによる気力増加
                if (attack_mode != "マップ攻撃" && attack_mode != "反射")
                {
                    {
                        var withBlock7 = CurrentForm();
                        if (withBlock7.MainPilot().IsSkillAvailable("命中時気力増加"))
                        {
                            withBlock7.Pilot(1).Morale = (withBlock7.Pilot(1).Morale + withBlock7.MainPilot().SkillLevel("命中時気力増加", ref_mode: ""));
                        }
                    }
                }

                // 攻撃を受けたことによる気力増加
                t.IncreaseMorale(1);
                if (t.MainPilot().IsSkillAvailable("損傷時気力増加"))
                {
                    t.Pilot(1).Morale = (t.Pilot(1).Morale + t.MainPilot().SkillLevel("損傷時気力増加", ref_mode: ""));
                }
            }
            else
            {
                // 攻撃を外したことによる気力増加
                if (attack_mode != "マップ攻撃" && attack_mode != "反射")
                {
                    {
                        var withBlock8 = CurrentForm();
                        if (withBlock8.MainPilot().IsSkillAvailable("失敗時気力増加"))
                        {
                            withBlock8.Pilot(1).Morale = (withBlock8.Pilot(1).Morale + withBlock8.MainPilot().SkillLevel("失敗時気力増加", ref_mode: ""));
                        }
                    }
                }

                // 攻撃を回避したことによる気力増加
                if (t.MainPilot().IsSkillAvailable("回避時気力増加"))
                {
                    t.Pilot(1).Morale = (t.Pilot(1).Morale + t.MainPilot().SkillLevel("回避時気力増加", ref_mode: ""));
                }
            }

            // スペシャルパワー効果の解除
            if (Strings.InStr(msg, "かばった") == 0)
            {
                t.RemoveSpecialPowerInEffect("防御");
            }

            if (is_hit)
            {
                t.RemoveSpecialPowerInEffect("被弾");
            }

            // 戦闘アニメで変更されたユニット画像を元に戻す
            if (t.IsConditionSatisfied("ユニット画像"))
            {
                t.DeleteCondition("ユニット画像");
                t.BitmapID = GUI.MakeUnitBitmap(t);
                if (t.Status == "出撃")
                {
                    GUI.PaintUnitBitmap(t, "リフレッシュ無し");
                }
            }

            if (t.IsConditionSatisfied("非表示付加"))
            {
                t.DeleteCondition("非表示付加");
                t.BitmapID = GUI.MakeUnitBitmap(t);
                if (t.Status == "出撃")
                {
                    GUI.PaintUnitBitmap(t, "リフレッシュ無し");
                }
            }

            // 戦闘に参加したユニットを識別
            {
                var withBlock9 = CurrentForm();
                if (Expression.IsOptionDefined("ユニット情報隠蔽"))
                {
                    if (withBlock9.Party0 == "敵" || withBlock9.Party0 == "中立")
                    {
                        withBlock9.AddCondition("識別済み", -1, 0d, "非表示");
                    }

                    if (t.Party0 == "敵" || t.Party0 == "中立")
                    {
                        t.AddCondition("識別済み", -1, 0d, "非表示");
                    }
                }
                else
                {
                    if (withBlock9.IsConditionSatisfied("ユニット情報隠蔽"))
                    {
                        withBlock9.DeleteCondition("ユニット情報隠蔽");
                    }

                    if (t.IsConditionSatisfied("ユニット情報隠蔽"))
                    {
                        t.DeleteCondition("ユニット情報隠蔽");
                    }
                }
            }

            // 情報を更新
            CurrentForm().Update();
            t.Update();

            // マップ攻撃や反射による攻撃の場合はここまで
            switch (attack_mode ?? "")
            {
                case "マップ攻撃":
                case "反射":
                    {
                        Commands.RestoreSelections();
                        return;
                    }
            }

            // ステルスが解ける？
            if (IsFeatureAvailable("ステルス"))
            {
                if (IsWeaponClassifiedAs(w, "忍"))
                {
                    // 暗殺武器の場合、相手を倒すか行動不能にすればステルス継続
                    if (t.CurrentForm().Status == "出撃" && t.CurrentForm().MaxAction() > 0)
                    {
                        AddCondition("ステルス無効", 1, cdata: "");
                    }
                }
                else
                {
                    AddCondition("ステルス無効", 1, cdata: "");
                }
            }

            // 合体技のパートナーの弾数＆ＥＮの消費
            var loopTo4 = Information.UBound(partners);
            for (i = 1; i <= loopTo4; i++)
            {
                {
                    var withBlock10 = partners[i].CurrentForm();
                    var loopTo5 = withBlock10.CountWeapon();
                    for (j = 1; j <= loopTo5; j++)
                    {
                        if ((withBlock10.Weapon(j).Name ?? "") == (wname ?? ""))
                        {
                            withBlock10.UseWeapon(j);
                            if (withBlock10.IsWeaponClassifiedAs(j, "自"))
                            {
                                if (withBlock10.IsFeatureAvailable("パーツ分離"))
                                {
                                    uname = GeneralLib.LIndex(withBlock10.FeatureData("パーツ分離"), 2);
                                    Unit localOtherForm3() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                    if (localOtherForm3().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                    {
                                        withBlock10.Transform(uname);
                                        {
                                            var withBlock11 = withBlock10.CurrentForm();
                                            withBlock11.HP = withBlock11.MaxHP;
                                            withBlock11.UsedAction = withBlock11.MaxAction();
                                        }
                                    }
                                    else
                                    {
                                        withBlock10.Die();
                                    }
                                }
                                else
                                {
                                    withBlock10.Die();
                                }
                            }
                            else if (withBlock10.IsWeaponClassifiedAs(j, "失") && withBlock10.HP == 0)
                            {
                                withBlock10.Die();
                            }
                            else if (withBlock10.IsWeaponClassifiedAs(j, "変"))
                            {
                                if (withBlock10.IsFeatureAvailable("変形技"))
                                {
                                    uname = "";
                                    var loopTo6 = withBlock10.CountFeature();
                                    for (k = 1; k <= loopTo6; k++)
                                    {
                                        string localFeature() { object argIndex1 = k; var ret = withBlock10.Feature(argIndex1); return ret; }

                                        string localFeatureData1() { object argIndex1 = k; var ret = withBlock10.FeatureData(argIndex1); return ret; }

                                        string localLIndex1() { string arglist = hs343c2cd9fcb6419f8281c931401bbbc0(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                                        if (localFeature() == "変形技" && (localLIndex1() ?? "") == (wname ?? ""))
                                        {
                                            string localFeatureData() { object argIndex1 = k; var ret = withBlock10.FeatureData(argIndex1); return ret; }

                                            uname = GeneralLib.LIndex(localFeatureData(), 2);
                                            Unit localOtherForm4() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                            if (localOtherForm4().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                            {
                                                withBlock10.Transform(uname);
                                            }

                                            break;
                                        }
                                    }

                                    if ((uname ?? "") != (withBlock10.CurrentForm().Name ?? ""))
                                    {
                                        if (withBlock10.IsFeatureAvailable("ノーマルモード"))
                                        {
                                            uname = GeneralLib.LIndex(withBlock10.FeatureData(argIndex57), 1);
                                            Unit localOtherForm5() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                            if (localOtherForm5().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                            {
                                                withBlock10.Transform(uname);
                                            }
                                        }
                                    }
                                }
                                else if (withBlock10.IsFeatureAvailable("ノーマルモード"))
                                {
                                    uname = GeneralLib.LIndex(withBlock10.FeatureData(argIndex58), 1);
                                    Unit localOtherForm6() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                    if (localOtherForm6().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                    {
                                        withBlock10.Transform(uname);
                                    }
                                }
                            }

                            break;
                        }
                    }

                    // 同名の武器がなかった場合は自分のデータを使って処理
                    if (j > withBlock10.CountWeapon())
                    {
                        if (this.Weapon(w).ENConsumption > 0)
                        {
                            withBlock10.EN = withBlock10.EN - WeaponENConsumption(w);
                        }

                        if (IsWeaponClassifiedAs(w, "消"))
                        {
                            withBlock10.AddCondition("消耗", 1, cdata: "");
                        }

                        if (IsWeaponClassifiedAs(w, "Ｃ") && withBlock10.IsConditionSatisfied("チャージ完了"))
                        {
                            withBlock10.DeleteCondition("チャージ完了");
                        }

                        if (IsWeaponClassifiedAs(w, "気"))
                        {
                            withBlock10.IncreaseMorale((-5 * WeaponLevel(w, "気")));
                        }

                        if (IsWeaponClassifiedAs(w, "霊"))
                        {
                            hp_ratio = 100 * withBlock10.HP / (double)withBlock10.MaxHP;
                            en_ratio = 100 * withBlock10.EN / (double)withBlock10.MaxEN;
                            withBlock10.MainPilot().Plana = (withBlock10.MainPilot().Plana - 5d * WeaponLevel(w, "霊"));
                            withBlock10.HP = (withBlock10.MaxHP * hp_ratio / 100d);
                            withBlock10.EN = (withBlock10.MaxEN * en_ratio / 100d);
                        }
                        else if (IsWeaponClassifiedAs(w, "プ"))
                        {
                            hp_ratio = 100 * withBlock10.HP / (double)withBlock10.MaxHP;
                            en_ratio = 100 * withBlock10.EN / (double)withBlock10.MaxEN;
                            withBlock10.MainPilot().Plana = (withBlock10.MainPilot().Plana - 5d * WeaponLevel(w, "プ"));
                            withBlock10.HP = (withBlock10.MaxHP * hp_ratio / 100d);
                            withBlock10.EN = (withBlock10.MaxEN * en_ratio / 100d);
                        }

                        if (IsWeaponClassifiedAs(w, "失"))
                        {
                            withBlock10.HP = GeneralLib.MaxLng((withBlock10.HP - (long)(withBlock10.MaxHP * WeaponLevel(w, "失")) / 10L), 0);
                        }

                        if (IsWeaponClassifiedAs(w, "自"))
                        {
                            if (withBlock10.IsFeatureAvailable("パーツ分離"))
                            {
                                uname = GeneralLib.LIndex(withBlock10.FeatureData(argIndex61), 2);
                                Unit localOtherForm7() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                if (localOtherForm7().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                {
                                    withBlock10.Transform(uname);
                                    {
                                        var withBlock12 = withBlock10.CurrentForm();
                                        withBlock12.HP = withBlock12.MaxHP;
                                        withBlock12.UsedAction = withBlock12.MaxAction();
                                    }
                                }
                                else
                                {
                                    withBlock10.Die();
                                }
                            }
                            else
                            {
                                withBlock10.Die();
                            }
                        }
                        else if (IsWeaponClassifiedAs(w, "失") && withBlock10.HP == 0)
                        {
                            withBlock10.Die();
                        }
                        else if (IsWeaponClassifiedAs(w, "変"))
                        {
                            if (withBlock10.IsFeatureAvailable("ノーマルモード"))
                            {
                                uname = GeneralLib.LIndex(withBlock10.FeatureData(argIndex62), 1);
                                Unit localOtherForm8() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                if (localOtherForm8().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                {
                                    withBlock10.Transform(uname);
                                }
                            }
                        }
                    }
                }
            }

            // 以下の特殊効果はは武器データの変化があるため、同時には適応されない

            // 反射等により破壊された場合はなにも出来ない

            // 自爆攻撃

            // ＨＰ消費攻撃による自殺

            // 変形技

            // 能力コピー
            if (CurrentForm().Status == "破壊")
            {
            }
            else if (IsWeaponClassifiedAs(w, "自"))
            {
                if (IsFeatureAvailable("パーツ分離"))
                {
                    uname = GeneralLib.LIndex(FeatureData(argIndex63), 2);
                    Unit localOtherForm9() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm9().IsAbleToEnter(x, y))
                    {
                        Transform(uname);
                        {
                            var withBlock13 = CurrentForm();
                            withBlock13.HP = withBlock13.MaxHP;
                            withBlock13.UsedAction = withBlock13.MaxAction();
                        }

                        fname = FeatureName("パーツ分離");
                        bool localIsSysMessageDefined3() { string argmain_situation = "破壊時分離(" + fname + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        bool localIsSysMessageDefined4() { string argmain_situation = "分離(" + Name + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        bool localIsSysMessageDefined5() { string argmain_situation = "分離(" + fname + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        if (IsSysMessageDefined("破壊時分離(" + Name + ")", sub_situation: ""))
                        {
                            SysMessage("破壊時分離(" + Name + ")", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined3())
                        {
                            SysMessage("破壊時分離(" + fname + ")", sub_situation: "", add_msg: "");
                        }
                        else if (IsSysMessageDefined("破壊時分離", sub_situation: ""))
                        {
                            SysMessage("破壊時分離", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined4())
                        {
                            SysMessage("分離(" + Name + ")", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined5())
                        {
                            SysMessage("分離(" + fname + ")", sub_situation: "", add_msg: "");
                        }
                        else if (IsSysMessageDefined("分離", sub_situation: ""))
                        {
                            SysMessage("分離", sub_situation: "", add_msg: "");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(Nickname + "は破壊されたパーツを分離させた。");
                        }
                    }
                    else
                    {
                        Die();
                    }
                }
                else
                {
                    Die();
                }
            }
            else if (IsWeaponClassifiedAs(w, "失") && HP == 0)
            {
                Die();
            }
            else if (IsWeaponClassifiedAs(w, "変"))
            {
                if (IsFeatureAvailable("変形技"))
                {
                    var loopTo7 = CountFeature();
                    for (i = 1; i <= loopTo7; i++)
                    {
                        string localFeature1() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                        string localFeatureData3() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        string localLIndex2() { string arglist = hsd78be329e21a495e9d12e8227830c1b1(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                        if (localFeature1() == "変形技" && (localLIndex2() ?? "") == (wname ?? ""))
                        {
                            string localFeatureData2() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            uname = GeneralLib.LIndex(localFeatureData2(), 2);
                            Unit localOtherForm10() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                            if (localOtherForm10().IsAbleToEnter(x, y))
                            {
                                Transform(uname);
                            }

                            break;
                        }
                    }

                    if ((uname ?? "") != (CurrentForm().Name ?? ""))
                    {
                        if (IsFeatureAvailable("ノーマルモード"))
                        {
                            uname = GeneralLib.LIndex(FeatureData(argIndex65), 1);
                            Unit localOtherForm11() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                            if (localOtherForm11().IsAbleToEnter(x, y))
                            {
                                Transform(uname);
                            }
                        }
                    }
                }
                else if (IsFeatureAvailable("ノーマルモード"))
                {
                    uname = GeneralLib.LIndex(FeatureData(argIndex66), 1);
                    Unit localOtherForm12() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm12().IsAbleToEnter(x, y))
                    {
                        Transform(uname);
                    }
                }
            }

            // アイテムを消費
            else if (Weapon(w).IsItem() && Bullet(w) == 0 && MaxBullet(w) > 0)
            {
                // アイテムを削除
                num = Data.CountWeapon();
                num = (num + MainPilot().Data.CountWeapon());
                var loopTo8 = CountPilot();
                for (i = 2; i <= loopTo8; i++)
                {
                    Pilot localPilot2() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    num = (num + localPilot2().Data.CountWeapon());
                }

                var loopTo9 = CountSupport();
                for (i = 2; i <= loopTo9; i++)
                {
                    Pilot localSupport2() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    num = (num + localSupport2().Data.CountWeapon());
                }

                if (IsFeatureAvailable("追加サポート"))
                {
                    num = (num + AdditionalSupport().Data.CountWeapon());
                }

                foreach (Item itm in colItem)
                {
                    num = (num + itm.CountWeapon());
                    if (w <= num)
                    {
                        itm.Exist = false;
                        DeleteItem((object)itm.ID);
                        break;
                    }
                }
            }
            else if (is_hit && (IsWeaponClassifiedAs(w, "写") || IsWeaponClassifiedAs(w, "化")) && (dmg > 0 || !IsWeaponClassifiedAs(w, "殺")))
            {
                CheckMetamorphAttack(w, t, def_mode);
            }

            {
                var withBlock14 = CurrentForm();
                // スペシャルパワーの効果を削除
                if (Strings.InStr(attack_mode, "援護攻撃") == 0)
                {
                    if (withBlock14.IsUnderSpecialPowerEffect("攻撃後消耗"))
                    {
                        withBlock14.AddCondition("消耗", 1, cdata: "");
                    }

                    withBlock14.RemoveSpecialPowerInEffect("攻撃");
                    if (is_hit)
                    {
                        withBlock14.RemoveSpecialPowerInEffect("命中");
                    }
                }

                // 戦闘アニメで変更されたユニット画像を元に戻す
                if (withBlock14.IsConditionSatisfied("ユニット画像"))
                {
                    withBlock14.DeleteCondition("ユニット画像");
                    withBlock14.BitmapID = GUI.MakeUnitBitmap(CurrentForm());
                    GUI.PaintUnitBitmap(CurrentForm());
                }

                if (withBlock14.IsConditionSatisfied("非表示付加"))
                {
                    withBlock14.DeleteCondition("非表示付加");
                    withBlock14.BitmapID = GUI.MakeUnitBitmap(CurrentForm());
                    GUI.PaintUnitBitmap(CurrentForm());
                }

                var loopTo10 = Information.UBound(partners);
                for (i = 1; i <= loopTo10; i++)
                {
                    {
                        var withBlock15 = partners[i].CurrentForm();
                        if (withBlock15.IsConditionSatisfied("ユニット画像"))
                        {
                            withBlock15.DeleteCondition("ユニット画像");
                            withBlock15.BitmapID = GUI.MakeUnitBitmap(partners[i].CurrentForm());
                            GUI.PaintUnitBitmap(partners[i].CurrentForm());
                        }

                        if (withBlock15.IsConditionSatisfied("非表示付加"))
                        {
                            withBlock15.DeleteCondition("非表示付加");
                            withBlock15.BitmapID = GUI.MakeUnitBitmap(partners[i].CurrentForm());
                            GUI.PaintUnitBitmap(partners[i].CurrentForm());
                        }
                    }
                }
            }

            // カットインは消去しておく
            if (!Expression.IsOptionDefined("戦闘中画面初期化無効") || attack_mode == "マップ攻撃")
            {
                if (GUI.IsPictureVisible)
                {
                    GUI.ClearPicture();
                    // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                    GUI.MainForm.picMain(0).Refresh();
                }
            }

            // ADD START MARGE
            // 戦闘アニメ終了処理
            if (IsAnimationDefined(wname + "(終了)", sub_situation: ""))
            {
                PlayAnimation(wname + "(終了)", sub_situation: "");
            }
            else if (IsAnimationDefined("終了", sub_situation: ""))
            {
                PlayAnimation("終了", sub_situation: "");
            }
            // ADD END MARGE

            // ユニット選択を解除
            Commands.RestoreSelections();
        }

        // 回避用特殊能力の判定
        public bool CheckDodgeFeature(int w, Unit t, int tx, int ty, string attack_mode, string def_mode, int dmg, bool be_quiet)
        {
            bool CheckDodgeFeatureRet = default;
            string wname;
            int ecost, nmorale;
            string fname, fdata;
            double flevel;
            int fid, frange;
            Unit u;
            int j, i, k;
            int prob;
            string buf;
            string team, uteam;

            // スペシャルパワーで回避能力が無効化されている？
            if ((IsUnderSpecialPowerEffect("絶対命中") || IsUnderSpecialPowerEffect("回避能力無効化")) && !t.IsUnderSpecialPowerEffect("特殊防御発動"))
            {
                return CheckDodgeFeatureRet;
            }

            // 能動防御は行動できなければ発動しない
            if (t.MaxAction() == 0 || t.IsUnderSpecialPowerEffect("無防備"))
            {
                return CheckDodgeFeatureRet;
            }

            wname = WeaponNickname(w);
            team = MainPilot().SkillData("チーム");

            // 阻止無効化
            if (IsWeaponClassifiedAs(w, "無") || IsUnderSpecialPowerEffect("防御能力無効化"))
            {
                goto SkipBlock;
            }

            // 広域阻止
            // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            u = null;
            flevel = 0d;
            fid = 0;
            // 阻止してくれるユニットを探す
            var loopTo = GeneralLib.MinLng(tx + 3, Map.MapWidth);
            for (i = GeneralLib.MaxLng(tx - 3, 1); i <= loopTo; i++)
            {
                var loopTo1 = GeneralLib.MinLng(ty + 3, Map.MapHeight);
                for (j = GeneralLib.MaxLng(ty - 3, 1); j <= loopTo1; j++)
                {
                    if (Map.MapDataForUnit[i, j] is null || Math.Abs((tx - i)) + Math.Abs((ty - j)) > 3)
                    {
                        goto NextPoint;
                    }

                    {
                        var withBlock = Map.MapDataForUnit[i, j];
                        if (withBlock.IsEnemy(t))
                        {
                            goto NextPoint;
                        }

                        if (withBlock.Area == "地中")
                        {
                            goto NextPoint;
                        }

                        if (!withBlock.IsFeatureAvailable("広域阻止"))
                        {
                            goto NextPoint;
                        }

                        // 同じチームに属している？
                        uteam = withBlock.MainPilot().SkillData("チーム");
                        if ((team ?? "") != (uteam ?? "") && !string.IsNullOrEmpty(uteam))
                        {
                            goto NextPoint;
                        }

                        var loopTo2 = withBlock.CountFeature();
                        for (k = 1; k <= loopTo2; k++)
                        {
                            if (withBlock.Feature(k) == "広域阻止")
                            {
                                fdata = withBlock.FeatureData(k);

                                // 有効範囲
                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 2)))
                                {
                                    frange = Conversions.Toint(GeneralLib.LIndex(fdata, 2));
                                }
                                else
                                {
                                    frange = 1;
                                }

                                // 使用条件
                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 5)))
                                {
                                    ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 5));
                                }
                                else
                                {
                                    ecost = 0;
                                }

                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 6)))
                                {
                                    nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 6));
                                }
                                else
                                {
                                    nmorale = 0;
                                }

                                // 発動条件を満たしている？
                                bool localIsAttributeClassified() { string argaclass1 = GeneralLib.LIndex(fdata, 3); string argaclass2 = WeaponClass(w); var ret = withBlock.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                                if (withBlock.EN >= ecost && withBlock.MainPilot().Morale >= nmorale && localIsAttributeClassified() && (Math.Abs((tx - i)) + Math.Abs((ty - j))) <= frange && (Math.Abs((x - i)) + Math.Abs((y - j))) > frange && (!ReferenceEquals(Map.MapDataForUnit[i, j], t) || !t.IsFeatureAvailable("阻止")))
                                {
                                    if (withBlock.FeatureLevel(k) > flevel)
                                    {
                                        u = Map.MapDataForUnit[i, j];
                                        flevel = withBlock.FeatureLevel(k);
                                        fid = k;
                                    }
                                }
                            }
                        }
                    }

                    NextPoint:
                    ;
                }
            }

            if (u is object)
            {
                // 阻止してくれるユニットがいる場合
                if (fid == 0)
                {
                    fname = u.FeatureName("広域阻止");
                    fdata = u.FeatureData("広域阻止");
                    flevel = u.FeatureLevel("広域阻止");
                }
                else
                {
                    fname = u.FeatureName(fid);
                    fdata = u.FeatureData(fid);
                    flevel = u.FeatureLevel(fid);
                }

                if (flevel == 1d)
                {
                    flevel = 10000d;
                }

                // 阻止確率の設定
                buf = GeneralLib.LIndex(fdata, 4);
                if (Information.IsNumeric(buf))
                {
                    prob = Conversions.Toint(buf);
                }
                else if (Strings.InStr(buf, "+") > 0 || Strings.InStr(buf, "-") > 0)
                {
                    i = GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
                    prob = (100d * (u.SkillLevel(Strings.Left(buf, i - 1)) + Conversions.Toint(Strings.Mid(buf, i))) / 16d);
                }
                else
                {
                    prob = (u.SkillLevel(buf) * 100d / 16d);
                }

                // 見切り
                if (u.IsUnderSpecialPowerEffect("特殊防御発動"))
                {
                    prob = 100;
                }

                // 必中がかかっていれば阻止は無効
                if (IsUnderSpecialPowerEffect("絶対命中") && !u.IsUnderSpecialPowerEffect("特殊防御発動"))
                {
                    prob = 0;
                }

                // ダメージが許容範囲外であれば阻止できない
                if (dmg > 500d * flevel)
                {
                    prob = 0;
                }

                // ＥＮ消費量
                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 5)))
                {
                    ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 5));
                }
                else
                {
                    ecost = 0;
                }

                // 攻撃を阻止
                if (prob >= GeneralLib.Dice(100))
                {
                    u.EN = u.EN - ecost;
                    if (!be_quiet)
                    {
                        if (u.IsMessageDefined("阻止(" + fname + ")"))
                        {
                            u.PilotMessage("阻止(" + fname + ")", msg_mode: "");
                        }
                        else
                        {
                            u.PilotMessage("阻止", msg_mode: "");
                        }
                    }

                    if (u.IsAnimationDefined("阻止", fname))
                    {
                        u.PlayAnimation("阻止", fname);
                    }
                    else
                    {
                        u.SpecialEffect("阻止", fname);
                    }

                    if (u.IsSysMessageDefined("阻止", fname))
                    {
                        u.SysMessage("阻止", fname, add_msg: "");
                    }
                    else
                    {
                        GUI.DisplaySysMessage(u.Nickname + "は[" + fname + "]で[" + wname + "]を防いだ。");
                    }

                    CheckDodgeFeatureRet = true;
                    return CheckDodgeFeatureRet;
                }
            }

            SkipBlock:
            ;


            // 分身(ユニット用特殊能力)
            if (t.IsFeatureAvailable("分身") && t.MainPilot().Morale >= 130 && !t.IsFeatureLevelSpecified("分身") && (GeneralLib.Dice(2) == 1 || t.IsUnderSpecialPowerEffect("特殊防御発動")))
            {
                fname = t.FeatureName("分身");

                // 特殊効果
                if (t.IsAnimationDefined("分身", fname))
                {
                    t.PlayAnimation("分身", fname);
                }
                else if (t.IsSpecialEffectDefined("分身", fname))
                {
                    t.SpecialEffect("分身", fname);
                }
                else if (SRC.BattleAnimation)
                {
                    if (fname == "分身")
                    {
                        Effect.ShowAnimation("分身発動");
                    }
                    else
                    {
                        Effect.ShowAnimation("分身発動 - " + fname);
                    }
                }

                // 回避音
                Effect.DodgeEffect(this, w);

                // メッセージ
                if (!be_quiet)
                {
                    if (t.IsMessageDefined("分身(" + fname + ")"))
                    {
                        t.PilotMessage("分身(" + fname + ")", msg_mode: "");
                    }
                    else
                    {
                        t.PilotMessage("分身", msg_mode: "");
                    }
                }

                if (t.IsSysMessageDefined("分身", fname))
                {
                    t.SysMessage("分身", fname, add_msg: "");
                }
                else if (fname != "分身")
                {
                    GUI.DisplaySysMessage(t.Nickname + "は[" + fname + "]を使って攻撃をかわした");
                }
                else
                {
                    GUI.DisplaySysMessage(t.Nickname + "は分身して攻撃をかわした。");
                }

                CheckDodgeFeatureRet = true;
                return CheckDodgeFeatureRet;
            }

            // 超回避
            if (t.IsFeatureAvailable("超回避"))
            {
                fname = t.FeatureName("超回避");
                fdata = t.FeatureData("超回避");
                flevel = t.FeatureLevel("超回避");

                // 発動率
                prob = flevel;
                if (t.IsUnderSpecialPowerEffect("特殊防御発動"))
                {
                    prob = 10;
                }

                // 必要条件
                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 2)))
                {
                    ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 2));
                }
                else
                {
                    ecost = 0;
                }

                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                {
                    nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                }
                else
                {
                    nmorale = 0;
                }

                if (GeneralLib.LIndex(fdata, 4) == "手動")
                {
                    if (def_mode != "回避")
                    {
                        prob = 0;
                    }
                }

                // 発動条件を満たしている？
                if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && prob >= GeneralLib.Dice(10))
                {
                    // ＥＮ消費
                    if (ecost != 0)
                    {
                        t.EN = t.EN - ecost;
                        if (attack_mode != "反射")
                        {
                            GUI.UpdateMessageForm(this, t);
                        }
                        else
                        {
                            GUI.UpdateMessageForm(this, null);
                        }
                    }

                    // 特殊効果
                    if (t.IsAnimationDefined("分身", fname))
                    {
                        t.PlayAnimation("分身", fname);
                    }
                    else if (t.IsSpecialEffectDefined("分身", fname))
                    {
                        t.SpecialEffect("分身", fname);
                    }
                    else if (SRC.BattleAnimation)
                    {
                        Effect.ShowAnimation("回避発動");
                    }
                    else
                    {
                        // 回避音
                        Effect.DodgeEffect(this, w);
                    }

                    // メッセージ
                    if (!be_quiet)
                    {
                        if (t.IsMessageDefined("分身(" + fname + ")"))
                        {
                            t.PilotMessage("分身(" + fname + ")", msg_mode: "");
                        }
                        else
                        {
                            t.PilotMessage("分身", msg_mode: "");
                        }
                    }

                    if (t.IsSysMessageDefined("分身", fname))
                    {
                        t.SysMessage("分身", fname, add_msg: "");
                    }
                    else
                    {
                        GUI.DisplaySysMessage(t.Nickname + "は[" + fname + "]を使って攻撃をかわした。");
                    }

                    CheckDodgeFeatureRet = true;
                    return CheckDodgeFeatureRet;
                }
            }

            // 緊急テレポート
            int new_x = default, new_y = default;
            if (t.IsFeatureAvailable("緊急テレポート"))
            {
                fname = t.FeatureName("緊急テレポート");
                fdata = t.FeatureData("緊急テレポート");
                flevel = t.FeatureLevel("緊急テレポート");

                // 発動率
                prob = flevel;
                if (t.IsUnderSpecialPowerEffect("特殊防御発動"))
                {
                    prob = 10;
                }

                // 必要条件
                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                {
                    ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                }
                else
                {
                    ecost = 0;
                }

                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                {
                    nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                }
                else
                {
                    nmorale = 0;
                }

                if (GeneralLib.LIndex(fdata, 5) == "手動")
                {
                    if (def_mode != "回避")
                    {
                        prob = 0;
                    }
                }

                // 発動条件を満たしている？
                if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && prob >= GeneralLib.Dice(10))
                {

                    // 逃げ場所がある？
                    int localStrToLng() { string argexpr = GeneralLib.LIndex(fdata, 2); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                    Map.AreaInTeleport(t, localStrToLng());
                    Map.SafetyPoint(t, new_x, new_y);
                    if ((t.x != new_x || t.y != new_y) && new_x != 0 && new_y != 0)
                    {
                        // ＥＮ消費
                        if (ecost != 0)
                        {
                            t.EN = t.EN - ecost;
                            if (attack_mode != "反射")
                            {
                                GUI.UpdateMessageForm(this, t);
                            }
                            else
                            {
                                GUI.UpdateMessageForm(this, null);
                            }
                        }

                        // 特殊効果
                        if (t.IsAnimationDefined("緊急テレポート", fname))
                        {
                            t.PlayAnimation("緊急テレポート", fname);
                        }
                        else if (t.IsSpecialEffectDefined("緊急テレポート", fname))
                        {
                            t.SpecialEffect("緊急テレポート", fname);
                        }
                        else if (SRC.BattleAnimation)
                        {
                            if (fname == "緊急テレポート")
                            {
                                Effect.ShowAnimation("緊急テレポート発動");
                            }
                            else
                            {
                                Effect.ShowAnimation("緊急テレポート発動 - " + fname);
                            }
                        }

                        // 回避音
                        Effect.DodgeEffect(this, w);

                        // 緊急テレポート発動！
                        t.Jump(new_x, new_y);

                        // メッセージ
                        if (!be_quiet)
                        {
                            if (t.IsMessageDefined("緊急テレポート(" + fname + ")"))
                            {
                                t.PilotMessage("緊急テレポート(" + fname + ")", msg_mode: "");
                            }
                            else
                            {
                                t.PilotMessage("緊急テレポート", msg_mode: "");
                            }
                        }

                        if (t.IsSysMessageDefined("緊急テレポート", fname))
                        {
                            t.SysMessage("緊急テレポート", fname, add_msg: "");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(t.Nickname + "は[" + fname + "]を使って攻撃をかわした。");
                        }

                        CheckDodgeFeatureRet = true;
                        return CheckDodgeFeatureRet;
                    }
                }
            }

            // 分身(パイロット用特殊能力)
            if (t.MainPilot().IsSkillAvailable("分身"))
            {
                prob = (2d * t.MainPilot().SkillLevel("分身", ref_mode: "") - MainPilot().SkillLevel("分身", ref_mode: ""));
                if (t.IsUnderSpecialPowerEffect("特殊防御発動"))
                {
                    prob = 32;
                }

                if (prob >= GeneralLib.Dice(32))
                {
                    fname = t.MainPilot().SkillName0("分身");

                    // 特殊効果
                    if (t.IsAnimationDefined("分身", fname))
                    {
                        t.PlayAnimation("分身", fname);
                    }
                    else if (t.IsSpecialEffectDefined("分身", fname))
                    {
                        t.SpecialEffect("分身", fname);
                    }
                    else if (SRC.BattleAnimation)
                    {
                        Effect.ShowAnimation("分身発動");
                    }
                    else
                    {
                        // 回避音
                        Effect.DodgeEffect(this, w);
                    }

                    // メッセージ
                    if (!be_quiet)
                    {
                        if (t.IsMessageDefined("分身(" + fname + ")"))
                        {
                            t.PilotMessage("分身(" + fname + ")", msg_mode: "");
                        }
                        else
                        {
                            t.PilotMessage("分身", msg_mode: "");
                        }
                    }

                    if (t.IsSysMessageDefined("分身", fname))
                    {
                        t.SysMessage("分身", fname, add_msg: "");
                    }
                    else
                    {
                        GUI.DisplaySysMessage(t.Nickname + "は分身して攻撃をかわした。");
                    }

                    CheckDodgeFeatureRet = true;
                    return CheckDodgeFeatureRet;
                }
            }

            return CheckDodgeFeatureRet;
        }

        // 切り払い＆反射のチェック
        // (命中時に発動し、発動すれば必ずダメージが0になる能力)
        public bool CheckParryFeature(int w, Unit t, int tx, int ty, string attack_mode, string def_mode, int dmg, string msg, bool be_quiet)
        {
            bool CheckParryFeatureRet = default;
            string wname, wname2;
            int w2;
            int ecost, nmorale;
            string fname = default, fdata;
            double flevel;
            double slevel, lv_mod;
            string opt;
            int j, i, idx;
            int prob;
            string buf;

            // スペシャルパワーで回避能力が無効化されている？
            if ((IsUnderSpecialPowerEffect("絶対命中") || IsUnderSpecialPowerEffect("回避能力無効化")) && !t.IsUnderSpecialPowerEffect("特殊防御発動"))
            {
                return CheckParryFeatureRet;
            }

            // 能動防御は行動できなければ発動しない
            if (t.MaxAction() == 0 || t.IsUnderSpecialPowerEffect("無防備"))
            {
                return CheckParryFeatureRet;
            }

            wname = WeaponNickname(w);

            // ターゲットの迎撃レベルをチェック
            slevel = t.SkillLevel("迎撃");

            // 切り払いに使用する武器を持っている？
            // (持っていれば切り払いの方を優先)
            wname2 = "";
            if (t.IsFeatureAvailable("格闘武器"))
            {
                wname2 = t.FeatureData("格闘武器");
            }
            else
            {
                var loopTo = t.CountWeapon();
                for (i = 1; i <= loopTo; i++)
                {
                    if (t.IsWeaponClassifiedAs(i, "武") && t.IsWeaponAvailable(i, "移動前"))
                    {
                        wname2 = t.WeaponNickname(i);
                        break;
                    }
                }
            }
            // 発動条件を満たしている？
            if (IsWeaponClassifiedAs(w, "実") && (slevel > t.MainPilot().SkillLevel("切り払い", ref_mode: "") || slevel > 0d && Strings.Len(wname2) == 0))
            {
                // 迎撃武器を検索
                i = 0;
                if (t.IsFeatureAvailable("迎撃武器"))
                {
                    var loopTo1 = t.CountWeapon();
                    for (i = 1; i <= loopTo1; i++)
                    {
                        if ((t.Weapon(i).Name ?? "") == (t.FeatureData("迎撃武器") ?? ""))
                        {
                            if (!t.IsWeaponAvailable(i, "移動前"))
                            {
                                i = 0;
                            }

                            break;
                        }
                    }
                }

                if (i == 0)
                {
                    // 迎撃武器がない場合は迎撃用の武器としての条件を満たす武器を検索
                    var loopTo2 = t.CountWeapon();
                    for (i = 1; i <= loopTo2; i++)
                    {
                        if (t.IsWeaponAvailable(i, "移動後") && t.IsWeaponClassifiedAs(i, "移動後攻撃可") && t.IsWeaponClassifiedAs(i, "射撃系") && (t.Weapon(i).Bullet >= 10 || t.Weapon(i).Bullet == 0 && t.Weapon(i).ENConsumption <= 5) && t.MainPilot().Morale >= t.Weapon(i).NecessaryMorale)
                        {
                            break;
                        }
                    }
                }

                // 迎撃用武器が弾切れ、ＥＮ不足の場合は迎撃不可
                if (0 < i && i <= t.CountWeapon())
                {
                    if (!t.IsWeaponAvailable(i, "ステータス"))
                    {
                        i = 0;
                    }
                }

                // 迎撃を実行
                if (0 < i && i <= t.CountWeapon() && (slevel >= GeneralLib.Dice(16) || t.IsUnderSpecialPowerEffect("特殊防御発動")))
                {
                    // メッセージ
                    if (!be_quiet)
                    {
                        if (t.IsMessageDefined("迎撃(" + t.Weapon(i).Name + ")"))
                        {
                            t.PilotMessage("迎撃(" + t.Weapon(i).Name + ")", msg_mode: "");
                        }
                        else
                        {
                            t.PilotMessage("迎撃", msg_mode: "");
                        }
                    }
                    else
                    {
                        Sound.IsWavePlayed = false;
                    }

                    // 効果音
                    if (!Sound.IsWavePlayed)
                    {
                        bool localIsSpecialEffectDefined() { string argmain_situation = wname + "(迎撃)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        if (IsAnimationDefined(wname + "(迎撃)", sub_situation: ""))
                        {
                            PlayAnimation(wname + "(迎撃)", sub_situation: "");
                        }
                        else if (localIsSpecialEffectDefined())
                        {
                            SpecialEffect(wname + "(迎撃)", sub_situation: "");
                        }
                        else if (t.IsAnimationDefined("迎撃", fname))
                        {
                            t.PlayAnimation("迎撃", fname);
                        }
                        else if (t.IsSpecialEffectDefined("迎撃", fname))
                        {
                            t.SpecialEffect("迎撃", fname);
                        }
                        else if (t.IsSpecialEffectDefined(t.Weapon(i).Name, sub_situation: ""))
                        {
                            t.SpecialEffect(t.Weapon(i).Name, sub_situation: "");
                        }
                        else
                        {
                            Effect.AttackEffect(t, i);
                        }
                    }

                    GUI.DisplaySysMessage(t.Nickname + "は[" + t.WeaponNickname(i) + "]で[" + wname + "]を阻止した。");

                    // 迎撃された永続武器は使用回数を減らす
                    if (IsWeaponClassifiedAs(w, "永") && this.Weapon(w).Bullet > 0)
                    {
                        SetBullet(w, (Bullet(w) - 1));
                        SyncBullet();
                        IsMapAttackCanceled = true;
                    }

                    // 迎撃武器の弾数を消費
                    t.UseWeapon(i);
                    CheckParryFeatureRet = true;
                    return CheckParryFeatureRet;
                }
            }

            // 無属性武器には阻止が効かない
            if (IsWeaponClassifiedAs(w, "無") || IsUnderSpecialPowerEffect("防御能力無効化"))
            {
                goto SkipBlock;
            }

            // 阻止
            var loopTo3 = t.CountFeature();
            for (i = 1; i <= loopTo3; i++)
            {
                if (t.Feature(i) == "阻止")
                {
                    fname = t.FeatureName0(i);
                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);
                    if (flevel == 1d)
                    {
                        flevel = 10000d;
                    }

                    // 阻止確率の設定
                    buf = GeneralLib.LIndex(fdata, 3);
                    if (Information.IsNumeric(buf))
                    {
                        prob = Conversions.Toint(buf);
                    }
                    else if (Strings.InStr(buf, "+") > 0 || Strings.InStr(buf, "-") > 0)
                    {
                        j = GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
                        prob = (100d * (t.SkillLevel(Strings.Left(buf, j - 1)) + Conversions.Toint(Strings.Mid(buf, j))) / 16d);
                    }
                    else
                    {
                        prob = (100d * t.SkillLevel(buf) / 16d);
                    }

                    // 見切り
                    if (t.IsUnderSpecialPowerEffect("特殊防御発動"))
                    {
                        prob = 100;
                    }

                    // 必中がかかっていれば阻止は無効
                    if (IsUnderSpecialPowerEffect("絶対命中") && !t.IsUnderSpecialPowerEffect("特殊防御発動"))
                    {
                        prob = 0;
                    }

                    // 対象属性の判定
                    bool localIsAttributeClassified() { string argaclass1 = GeneralLib.LIndex(fdata, 2); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (!localIsAttributeClassified())
                    {
                        prob = 0;
                    }

                    // 使用条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        ecost = 0;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 5)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 5));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    if (t.EN < ecost || t.MainPilot().Morale < nmorale)
                    {
                        prob = 0;
                    }

                    // オプション
                    slevel = 0d;
                    var loopTo4 = GeneralLib.LLength(fdata);
                    for (j = 6; j <= loopTo4; j++)
                    {
                        if (prob == 0)
                        {
                            break;
                        }

                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (t.MainPilot().SkillType(opt) ?? "")
                        {
                            case "相殺":
                                {
                                    string localLIndex() { object argIndex1 = "阻止"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                                    if ((GeneralLib.LIndex(fdata, 1) ?? "") == (localLIndex() ?? "") && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    string localLIndex1() { object argIndex1 = "阻止"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                                    if ((GeneralLib.LIndex(fdata, 1) ?? "") == (localLIndex1() ?? "") && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("阻止");
                                        if (flevel <= 0d)
                                        {
                                            msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                    {
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    if (def_mode != "防御")
                                    {
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "能力必要":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 20d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            prob = 0;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 10d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // ダメージが許容範囲外であれば阻止できない
                    if (dmg > 500d * flevel + slevel)
                    {
                        prob = 0;
                    }

                    // 攻撃を阻止
                    if (prob >= GeneralLib.Dice(100))
                    {
                        if (ecost != 0)
                        {
                            t.EN = t.EN - ecost;
                            if (attack_mode != "反射")
                            {
                                GUI.UpdateMessageForm(this, t);
                            }
                            else
                            {
                                GUI.UpdateMessageForm(this, null);
                            }
                        }

                        if (!be_quiet)
                        {
                            if (t.IsMessageDefined("阻止(" + fname + ")"))
                            {
                                t.PilotMessage("阻止(" + fname + ")", msg_mode: "");
                            }
                            else
                            {
                                t.PilotMessage("阻止", msg_mode: "");
                            }
                        }

                        bool localIsSpecialEffectDefined1() { string argmain_situation = wname + "(阻止)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        if (IsAnimationDefined(wname + "(阻止)", sub_situation: ""))
                        {
                            PlayAnimation(wname + "(阻止)", sub_situation: "");
                        }
                        else if (localIsSpecialEffectDefined1())
                        {
                            SpecialEffect(wname + "(阻止)", sub_situation: "");
                        }
                        else if (t.IsAnimationDefined("阻止", fname))
                        {
                            t.PlayAnimation("阻止", fname);
                        }
                        else
                        {
                            t.SpecialEffect("阻止", fname);
                        }

                        if (t.IsSysMessageDefined("阻止", fname))
                        {
                            t.SysMessage("阻止", fname, add_msg: "");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(t.Nickname + "は[" + fname + "]で[" + wname + "]を防いだ。");
                        }

                        CheckParryFeatureRet = true;
                        return CheckParryFeatureRet;
                    }
                }
            }

            SkipBlock:
            ;


            // マップ攻撃や無属性武器には当て身技は効かない
            if (IsWeaponClassifiedAs(w, "Ｍ") || IsWeaponClassifiedAs(w, "無") || IsUnderSpecialPowerEffect("防御能力無効化"))
            {
                goto SkipParryAttack;
            }

            // 当て身技
            var loopTo5 = t.CountFeature();
            for (i = 1; i <= loopTo5; i++)
            {
                // 封印されている？
                if (t.Feature(i) == "当て身技")
                {
                    fname = t.FeatureName0(i);
                    if (string.IsNullOrEmpty(fname))
                    {
                        fname = "当て身技";
                    }

                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);
                    if (flevel == 1d)
                    {
                        flevel = 10000d;
                    }

                    // 当て身確率の設定
                    buf = GeneralLib.LIndex(fdata, 4);
                    if (Information.IsNumeric(buf))
                    {
                        prob = Conversions.Toint(buf);
                    }
                    else if (Strings.InStr(buf, "+") > 0 || Strings.InStr(buf, "-") > 0)
                    {
                        j = GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
                        prob = (100d * (t.SkillLevel(Strings.Left(buf, j - 1)) + Conversions.Toint(Strings.Mid(buf, j))) / 16d);
                    }
                    else
                    {
                        prob = (100d * t.SkillLevel(buf) / 16d);
                    }

                    // 見切り
                    if (t.IsUnderSpecialPowerEffect("特殊防御発動"))
                    {
                        prob = 100;
                    }

                    // 必中がかかっていれば当て身技は無効
                    if (IsUnderSpecialPowerEffect("絶対命中") && !t.IsUnderSpecialPowerEffect("特殊防御発動"))
                    {
                        break;
                    }

                    // 自分の反射や当て身技に対して当て身技は出来ない
                    if (attack_mode == "反射" || attack_mode == "当て身技")
                    {
                        break;
                    }

                    // 対象属性の判定
                    bool localIsAttributeClassified1() { string argaclass1 = GeneralLib.LIndex(fdata, 3); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (!localIsAttributeClassified1())
                    {
                        prob = 0;
                    }

                    // 使用条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 5)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 5));
                    }
                    else
                    {
                        ecost = 0;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 6)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 6));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    if (t.EN < ecost || t.MainPilot().Morale < nmorale)
                    {
                        prob = 0;
                    }

                    // オプション
                    slevel = 0d;
                    var loopTo6 = GeneralLib.LLength(fdata);
                    for (j = 7; j <= loopTo6; j++)
                    {
                        if (prob == 0)
                        {
                            break;
                        }

                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (t.MainPilot().SkillType(opt) ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData("当て身技")) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData("当て身技")) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("当て身技");
                                        if (flevel <= 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                    {
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    if (def_mode != "防御")
                                    {
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "能力必要":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 20d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            prob = 0;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 10d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // ダメージが許容範囲外であれば当て身技を使えない
                    if (dmg > 500d * flevel + slevel)
                    {
                        prob = 0;
                    }

                    // 使用する当て身技を検索
                    wname2 = GeneralLib.LIndex(fdata, 2);
                    w2 = 0;
                    var loopTo7 = t.CountWeapon();
                    for (j = 1; j <= loopTo7; j++)
                    {
                        if ((t.Weapon(j).Name ?? "") == (wname2 ?? ""))
                        {
                            if (t.IsWeaponAvailable(j, "必要技能無視"))
                            {
                                w2 = j;
                            }

                            break;
                        }
                    }

                    // 当て身技発動
                    if (prob >= GeneralLib.Dice(100) && w2 > 0)
                    {
                        if (ecost != 0)
                        {
                            t.EN = t.EN - ecost;
                            GUI.UpdateMessageForm(this, t);
                        }

                        // メッセージ
                        if (!be_quiet)
                        {
                            if (t.IsMessageDefined("当て身技(" + fname + ")"))
                            {
                                t.PilotMessage("当て身技(" + fname + ")", msg_mode: "");
                            }
                            else
                            {
                                t.PilotMessage("当て身技", msg_mode: "");
                            }
                        }
                        else
                        {
                            Sound.IsWavePlayed = false;
                        }

                        // 効果音
                        if (!Sound.IsWavePlayed)
                        {
                            bool localIsSpecialEffectDefined2() { string argmain_situation = wname + "(当て身技)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                            if (IsAnimationDefined(wname + "(当て身技)", sub_situation: ""))
                            {
                                PlayAnimation(wname + "(当て身技)", sub_situation: "");
                            }
                            else if (localIsSpecialEffectDefined2())
                            {
                                SpecialEffect(wname + "(当て身技)", sub_situation: "");
                            }
                            else if (t.IsAnimationDefined("当て身技", fname))
                            {
                                t.PlayAnimation("当て身技", fname);
                            }
                            else if (t.IsSpecialEffectDefined("当て身技", fname))
                            {
                                t.SpecialEffect("当て身技", fname);
                            }
                            else if (SRC.BattleAnimation)
                            {
                                Effect.ShowAnimation("打突命中");
                            }
                            else if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接") || IsWeaponClassifiedAs(w, "実"))
                            {
                                Sound.PlayWave("Sword.wav");
                            }
                            else
                            {
                                Sound.PlayWave("BeamCoat.wav");
                            }
                        }

                        if (t.IsSysMessageDefined("当て身技", fname))
                        {
                            t.SysMessage("当て身技", fname, add_msg: "");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(t.Nickname + "は[" + fname + "]で[" + wname + "]を受け止めた。");
                        }

                        // 当て身技で攻撃をかける
                        t.Attack(w2, this, "当て身技", "");
                        t = t.CurrentForm();
                        CheckParryFeatureRet = true;
                        return CheckParryFeatureRet;
                    }
                }
            }

            SkipParryAttack:
            ;


            // 切り払いに使用する武器を調べる
            wname2 = "";
            if (t.IsFeatureAvailable("格闘武器"))
            {
                wname2 = t.FeatureData("格闘武器");
            }
            else
            {
                var loopTo8 = t.CountWeapon();
                for (i = 1; i <= loopTo8; i++)
                {
                    if (t.IsWeaponClassifiedAs(i, "武") && !t.IsWeaponClassifiedAs(i, "合") && t.IsWeaponMastered(i) && t.MainPilot().Morale >= t.Weapon(i).NecessaryMorale && !t.IsDisabled(t.Weapon(i).Name))
                    {
                        wname2 = t.WeaponNickname(i);
                        break;
                    }
                }
            }

            // 切り払い出来る？
            if (t.MainPilot().SkillLevel("切り払い", ref_mode: "") > 0d && Strings.Len(wname2) > 0)
            {
                // 武属性や突属性を持っていても切り払いの対象外になります
                if (IsWeaponClassifiedAs(w, "実"))
                {
                    prob = 0;

                    // 思念誘導はＮＴレベルに応じて切り払いにくくなる
                    if (IsWeaponClassifiedAs(w, "サ"))
                    {
                        prob = (t.MainPilot().SkillLevel("超感覚", ref_mode: "") + t.MainPilot().SkillLevel("知覚強化", ref_mode: ""));
                        prob = (prob - MainPilot().SkillLevel("超感覚", ref_mode: "") - MainPilot().SkillLevel("知覚強化", ref_mode: ""));
                        if (prob > 0)
                        {
                            prob = 0;
                        }
                    }
                    else
                    {
                        prob = 0;
                    }

                    prob = (prob + 2d * t.MainPilot().SkillLevel("切り払い", ref_mode: ""));

                    // 見切りがあれば必ず発動
                    if (t.IsUnderSpecialPowerEffect("特殊防御発動"))
                    {
                        prob = 32;
                    }

                    if (prob >= GeneralLib.Dice(32))
                    {
                        // メッセージ
                        if (!be_quiet)
                        {
                            if (t.IsMessageDefined("切り払い(" + wname2 + ")"))
                            {
                                t.PilotMessage("切り払い(" + wname2 + ")", msg_mode: "");
                            }
                            else
                            {
                                t.PilotMessage("切り払い", msg_mode: "");
                            }
                        }
                        else
                        {
                            Sound.IsWavePlayed = false;
                        }

                        // 効果音
                        if (!Sound.IsWavePlayed)
                        {
                            bool localIsSpecialEffectDefined3() { string argmain_situation = wname + "(切り払い)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                            if (IsAnimationDefined(wname + "(切り払い)", sub_situation: ""))
                            {
                                PlayAnimation(wname + "(切り払い)", sub_situation: "");
                            }
                            else if (localIsSpecialEffectDefined3())
                            {
                                SpecialEffect(wname + "(切り払い)", sub_situation: "");
                            }
                            else if (t.IsAnimationDefined("切り払い", wname2))
                            {
                                t.PlayAnimation("切り払い", wname2);
                            }
                            else if (t.IsSpecialEffectDefined("切り払い", wname2))
                            {
                                t.SpecialEffect("切り払い", wname2);
                            }
                            else
                            {
                                Effect.ParryEffect(this, w, t);
                            }
                        }

                        GUI.DisplaySysMessage(t.Nickname + "は[" + wname2 + "]で[" + wname + "]を叩き落とした。");

                        // 切り払われた永続武器は使用回数を減らす
                        if (IsWeaponClassifiedAs(w, "永") && this.Weapon(w).Bullet > 0)
                        {
                            SetBullet(w, (Bullet(w) - 1));
                            SyncBullet();
                            IsMapAttackCanceled = true;
                        }

                        CheckParryFeatureRet = true;
                        return CheckParryFeatureRet;
                    }
                }
                else if (IsWeaponClassifiedAs(w, "接"))
                {
                }
                else if (IsWeaponClassifiedAs(w, "突"))
                {
                    // 相手も切り払い出来れば切り払い確率は下がる
                    prob = (2d * t.MainPilot().SkillLevel("切り払い", ref_mode: "") - MainPilot().SkillLevel("切り払い", ref_mode: ""));

                    // 見切りがあれば必ず発動
                    if (t.IsUnderSpecialPowerEffect("特殊防御発動"))
                    {
                        prob = 32;
                    }

                    if (prob >= GeneralLib.Dice(32))
                    {
                        // メッセージ
                        if (!be_quiet)
                        {
                            if (t.IsMessageDefined("切り払い(" + wname2 + ")"))
                            {
                                t.PilotMessage("切り払い(" + wname2 + ")", msg_mode: "");
                            }
                            else
                            {
                                t.PilotMessage("切り払い", msg_mode: "");
                            }
                        }
                        else
                        {
                            Sound.IsWavePlayed = false;
                        }

                        // 効果音
                        if (!Sound.IsWavePlayed)
                        {
                            bool localIsSpecialEffectDefined4() { string argmain_situation = wname + "(切り払い)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                            if (IsAnimationDefined(wname + "(切り払い)", sub_situation: ""))
                            {
                                PlayAnimation(wname + "(切り払い)", sub_situation: "");
                            }
                            else if (localIsSpecialEffectDefined4())
                            {
                                SpecialEffect(wname + "(切り払い)", sub_situation: "");
                            }
                            else if (t.IsAnimationDefined("切り払い", wname2))
                            {
                                t.PlayAnimation("切り払い", wname2);
                            }
                            else if (t.IsSpecialEffectDefined("切り払い", wname2))
                            {
                                t.SpecialEffect("切り払い", wname2);
                            }
                            else
                            {
                                Effect.DodgeEffect(this, w);
                                GUI.Sleep(190);
                                Sound.PlayWave("Sword.wav");
                            }
                        }

                        GUI.DisplaySysMessage(t.Nickname + "は[" + wname2 + "]で[" + wname + "]を受け流した。");

                        // 切り払われた永続武器は使用回数を減らす
                        if (IsWeaponClassifiedAs(w, "永") && this.Weapon(w).Bullet > 0)
                        {
                            SetBullet(w, (Bullet(w) - 1));
                            SyncBullet();
                            IsMapAttackCanceled = true;
                        }

                        CheckParryFeatureRet = true;
                        return CheckParryFeatureRet;
                    }
                }
                else if (IsWeaponClassifiedAs(w, "武"))
                {
                    // 相手も切り払い出来れば切り払い確率は下がる
                    prob = (2d * t.MainPilot().SkillLevel("切り払い", ref_mode: "") - MainPilot().SkillLevel("切り払い", ref_mode: ""));

                    // 見切りがあれば必ず発動
                    if (t.IsUnderSpecialPowerEffect("特殊防御発動"))
                    {
                        prob = 32;
                    }

                    if (prob >= GeneralLib.Dice(32))
                    {
                        // メッセージ
                        if (!be_quiet)
                        {
                            if (t.IsMessageDefined("切り払い(" + wname2 + ")"))
                            {
                                t.PilotMessage("切り払い(" + wname2 + ")", msg_mode: "");
                            }
                            else
                            {
                                t.PilotMessage("切り払い", msg_mode: "");
                            }
                        }
                        else
                        {
                            Sound.IsWavePlayed = false;
                        }

                        // 効果音
                        if (!Sound.IsWavePlayed)
                        {
                            bool localIsSpecialEffectDefined5() { string argmain_situation = wname + "(切り払い)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                            if (IsAnimationDefined(wname + "(切り払い)", sub_situation: ""))
                            {
                                PlayAnimation(wname + "(切り払い)", sub_situation: "");
                            }
                            else if (localIsSpecialEffectDefined5())
                            {
                                SpecialEffect(wname + "(切り払い)", sub_situation: "");
                            }
                            else if (t.IsAnimationDefined("切り払い", wname2))
                            {
                                t.PlayAnimation("切り払い", wname2);
                            }
                            else if (t.IsSpecialEffectDefined("切り払い", wname2))
                            {
                                t.SpecialEffect("切り払い", wname2);
                            }
                            else
                            {
                                Effect.DodgeEffect(this, w);
                                GUI.Sleep(190);
                                Sound.PlayWave("Sword.wav");
                            }
                        }

                        GUI.DisplaySysMessage(t.Nickname + "は[" + wname2 + "]で[" + wname + "]を受けとめた。");

                        // 切り払われた永続武器は使用回数を減らす
                        if (IsWeaponClassifiedAs(w, "永") && this.Weapon(w).Bullet > 0)
                        {
                            SetBullet(w, (Bullet(w) - 1));
                            SyncBullet();
                            IsMapAttackCanceled = true;
                        }

                        CheckParryFeatureRet = true;
                        return CheckParryFeatureRet;
                    }
                }
            }

            // 反射無効化
            if (IsWeaponClassifiedAs(w, "無") || IsUnderSpecialPowerEffect("防御能力無効化"))
            {
                return CheckParryFeatureRet;
            }

            // 攻撃反射の処理
            var loopTo9 = t.CountFeature();
            for (i = 1; i <= loopTo9; i++)
            {
                if (t.Feature(i) == "反射")
                {
                    fname = t.FeatureName0(i);
                    if (string.IsNullOrEmpty(fname))
                    {
                        if (t.IsFeatureAvailable("バリアシールド"))
                        {
                            fname = t.FeatureName0("バリアシールド");
                        }
                        else
                        {
                            fname = "反射";
                        }
                    }

                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);
                    if (flevel == 1d)
                    {
                        flevel = 10000d;
                    }

                    // 反射確率の設定
                    buf = GeneralLib.LIndex(fdata, 3);
                    if (Information.IsNumeric(buf))
                    {
                        prob = Conversions.Toint(buf);
                    }
                    else if (Strings.InStr(buf, "+") > 0 || Strings.InStr(buf, "-") > 0)
                    {
                        j = GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
                        prob = (100d * (t.SkillLevel(Strings.Left(buf, j - 1)) + Conversions.Toint(Strings.Mid(buf, j))) / 16d);
                    }
                    else
                    {
                        prob = (100d * t.SkillLevel(buf) / 16d);
                    }

                    // 反射された攻撃を反射する場合は確率を下げる
                    if (attack_mode == "反射")
                    {
                        prob = prob / 2;
                    }

                    // 見切り
                    if (t.IsUnderSpecialPowerEffect("特殊防御発動"))
                    {
                        prob = 100;
                    }

                    // 当て身技は反射出来ない
                    if (attack_mode == "当て身技")
                    {
                        break;
                    }

                    // 必中がかかっていれば反射は無効
                    if (IsUnderSpecialPowerEffect("絶対命中") && !t.IsUnderSpecialPowerEffect("特殊防御発動"))
                    {
                        break;
                    }

                    // 対象属性の判定
                    bool localIsAttributeClassified2() { string argaclass1 = GeneralLib.LIndex(fdata, 2); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (!localIsAttributeClassified2())
                    {
                        prob = 0;
                    }

                    // 使用条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        ecost = 0;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 5)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 5));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    if (t.EN < ecost || t.MainPilot().Morale < nmorale)
                    {
                        prob = 0;
                    }

                    // オプション
                    slevel = 0d;
                    var loopTo10 = GeneralLib.LLength(fdata);
                    for (j = 6; j <= loopTo10; j++)
                    {
                        if (prob == 0)
                        {
                            break;
                        }

                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (t.MainPilot().SkillType(opt) ?? "")
                        {
                            case "相殺":
                                {
                                    string localLIndex2() { object argIndex1 = "阻止"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                                    if ((GeneralLib.LIndex(fdata, 1) ?? "") == (localLIndex2() ?? "") && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    string localLIndex3() { object argIndex1 = "阻止"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                                    if ((GeneralLib.LIndex(fdata, 1) ?? "") == (localLIndex3() ?? "") && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("阻止");
                                        if (flevel <= 0d)
                                        {
                                            msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                    {
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    if (def_mode != "防御")
                                    {
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "能力必要":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 20d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            prob = 0;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 10d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // ダメージが許容範囲外であれば反射できない
                    if (dmg > 500d * flevel + slevel)
                    {
                        prob = 0;
                    }

                    // 攻撃を反射
                    if (prob >= GeneralLib.Dice(100))
                    {
                        if (ecost != 0)
                        {
                            t.EN = t.EN - ecost;
                            GUI.UpdateMessageForm(this, t);
                        }

                        // メッセージ
                        if (!be_quiet)
                        {
                            if (t.IsMessageDefined("反射(" + fname + ")"))
                            {
                                t.PilotMessage("反射(" + fname + ")", msg_mode: "");
                            }
                            else
                            {
                                t.PilotMessage("反射", msg_mode: "");
                            }
                        }
                        else
                        {
                            Sound.IsWavePlayed = false;
                        }

                        // 効果音
                        if (!Sound.IsWavePlayed)
                        {
                            bool localIsSpecialEffectDefined6() { string argmain_situation = wname + "(反射)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                            if (IsAnimationDefined(wname + "(反射)", sub_situation: ""))
                            {
                                PlayAnimation(wname + "(反射)", sub_situation: "");
                            }
                            else if (localIsSpecialEffectDefined6())
                            {
                                SpecialEffect(wname + "(反射)", sub_situation: "");
                            }
                            else if (t.IsAnimationDefined("反射", fname))
                            {
                                t.PlayAnimation("反射", fname);
                            }
                            else if (t.IsSpecialEffectDefined("反射", fname))
                            {
                                t.SpecialEffect("反射", fname);
                            }
                            else if (SRC.BattleAnimation)
                            {
                                if (fname == "反射")
                                {
                                    Effect.ShowAnimation("反射発動");
                                }
                                else
                                {
                                    Effect.ShowAnimation("反射発動 - " + fname);
                                }
                            }
                            else if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接") || IsWeaponClassifiedAs(w, "実"))
                            {
                                Sound.PlayWave("Sword.wav");
                            }
                            else
                            {
                                Sound.PlayWave("BeamCoat.wav");
                            }
                        }

                        if (t.IsSysMessageDefined("反射", fname))
                        {
                            t.SysMessage("反射", fname, add_msg: "");
                        }
                        else if (fname != "反射")
                        {
                            GUI.DisplaySysMessage(t.Nickname + "は[" + fname + "]で[" + wname + "]を弾き返した。");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(t.Nickname + "は[" + wname + "]を弾き返した。");
                        }

                        // 攻撃を反射
                        if (!IsWeaponClassifiedAs(w, "Ｍ") && attack_mode != "反射")
                        {
                            Attack(w, this, "反射", "");
                        }

                        CheckParryFeatureRet = true;
                        return CheckParryFeatureRet;
                    }
                }
            }

            return CheckParryFeatureRet;
        }

        // ダミー能力のチェック
        private bool CheckDummyFeature(int w, Unit t, bool be_quiet)
        {
            bool CheckDummyFeatureRet = default;
            string wname;
            string fname;
            wname = WeaponNickname(w);
            if (t.IsConditionSatisfied("ダミー付加"))
            {
                // 命中時の特殊効果
                Sound.IsWavePlayed = false;
                if (!be_quiet)
                {
                    PilotMessage(wname + "(命中)", msg_mode: "");
                }

                bool localIsSpecialEffectDefined() { string argmain_situation = wname + "(命中)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                if (IsAnimationDefined(wname + "(命中)", sub_situation: "") || IsAnimationDefined(wname, sub_situation: ""))
                {
                    PlayAnimation(wname + "(命中)", sub_situation: "");
                }
                else if (localIsSpecialEffectDefined())
                {
                    SpecialEffect(wname + "(命中)", sub_situation: "");
                }
                else if (!Sound.IsWavePlayed)
                {
                    Effect.HitEffect(this, w, t);
                }

                fname = t.FeatureName("ダミー");
                if (Strings.Len(fname) > 0)
                {
                    if (Strings.InStr(fname, "Lv") > 0)
                    {
                        fname = Strings.Left(fname, Strings.InStr(fname, "Lv") - 1);
                    }
                }
                else
                {
                    fname = "ダミー";
                }

                if (!be_quiet)
                {
                    if (t.IsMessageDefined("ダミー(" + fname + ")"))
                    {
                        t.PilotMessage("ダミー(" + fname + ")", msg_mode: "");
                    }
                    else
                    {
                        t.PilotMessage("ダミー", msg_mode: "");
                    }
                }

                if (t.IsAnimationDefined("ダミー", fname))
                {
                    t.PlayAnimation("ダミー", fname);
                }
                else
                {
                    t.SpecialEffect("ダミー", fname);
                }

                if (t.IsSysMessageDefined("ダミー", fname))
                {
                    t.SysMessage("ダミー", fname, add_msg: "");
                }
                else
                {
                    GUI.DisplaySysMessage(t.Nickname + "は[" + fname + "]を身代わりにして攻撃をかわした。");
                }

                t.SetConditionLevel("ダミー付加", t.ConditionLevel("ダミー付加") - 1d);
                if (t.ConditionLevel("ダミー付加") == 0d)
                {
                    t.DeleteCondition("ダミー付加");
                }

                CheckDummyFeatureRet = true;
            }
            else if (t.IsFeatureAvailable("ダミー"))
            {
                if (t.ConditionLevel("ダミー破壊") < t.FeatureLevel("ダミー"))
                {
                    // 命中時の特殊効果
                    Sound.IsWavePlayed = false;
                    if (!be_quiet)
                    {
                        PilotMessage(wname + "(命中)", msg_mode: "");
                    }

                    bool localIsSpecialEffectDefined1() { string argmain_situation = wname + "(命中)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    if (IsAnimationDefined(wname + "(命中)", sub_situation: "") || IsAnimationDefined(wname, sub_situation: ""))
                    {
                        PlayAnimation(wname + "(命中)", sub_situation: "");
                    }
                    else if (localIsSpecialEffectDefined1())
                    {
                        SpecialEffect(wname + "(命中)", sub_situation: "");
                    }
                    else if (!Sound.IsWavePlayed)
                    {
                        Effect.HitEffect(this, w, t);
                    }

                    fname = t.FeatureName("ダミー");
                    if (Strings.Len(fname) > 0)
                    {
                        if (Strings.InStr(fname, "Lv") > 0)
                        {
                            fname = Strings.Left(fname, Strings.InStr(fname, "Lv") - 1);
                        }
                    }
                    else
                    {
                        fname = "ダミー";
                    }

                    if (!be_quiet)
                    {
                        if (t.IsMessageDefined("ダミー(" + fname + ")"))
                        {
                            t.PilotMessage("ダミー(" + fname + ")", msg_mode: "");
                        }
                        else
                        {
                            t.PilotMessage("ダミー", msg_mode: "");
                        }
                    }

                    if (t.IsAnimationDefined("ダミー", fname))
                    {
                        t.PlayAnimation("ダミー", fname);
                    }
                    else
                    {
                        t.SpecialEffect("ダミー", fname);
                    }

                    if (IsSysMessageDefined("ダミー", fname))
                    {
                        SysMessage("ダミー", fname, add_msg: "");
                    }
                    else
                    {
                        GUI.DisplaySysMessage(t.Nickname + "は[" + fname + "]を身代わりにして攻撃をかわした。");
                    }

                    if (t.IsConditionSatisfied("ダミー破壊"))
                    {
                        t.SetConditionLevel("ダミー破壊", t.ConditionLevel("ダミー破壊") + 1d);
                    }
                    else
                    {
                        t.AddCondition("ダミー破壊", -1, 1d, cdata: "");
                    }

                    CheckDummyFeatureRet = true;
                }
            }

            return CheckDummyFeatureRet;
        }

        // シールド防御能力のチェック
        private bool CheckShieldFeature(int w, Unit t, int dmg, bool be_quiet, bool use_shield, bool use_shield_msg)
        {
            int prob;
            string fname;

            // ダメージが0以下ならシールド防御しても意味がない
            if (dmg <= 0)
            {
                return default;
            }

            // Ｓ防御技能を持っている？
            if (t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") <= 0d)
            {
                return default;
            }

            // 行動可能？
            if (t.IsConditionSatisfied("行動不能") || t.IsConditionSatisfied("麻痺") || t.IsConditionSatisfied("石化") || t.IsConditionSatisfied("凍結") || t.IsConditionSatisfied("睡眠") || t.IsUnderSpecialPowerEffect("行動不能") || t.IsUnderSpecialPowerEffect("行動不能"1))
            {
                return default;
            }

            // シールド防御出来ない武器？
            if (IsWeaponClassifiedAs(w, "精") || IsWeaponClassifiedAs(w, "殺") || IsWeaponClassifiedAs(w, "浸"))
            {
                return default;
            }

            // スペシャルパワーで無効化される？
            if (IsUnderSpecialPowerEffect("シールド防御無効化"))
            {
                return default;
            }

            // シールド系防御能力を検索
            if (t.IsFeatureAvailable("シールド"))
            {
                prob = t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "");
                fname = t.FeatureName("シールド");
            }
            else if (t.IsFeatureAvailable("小型シールド"))
            {
                prob = t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "");
                fname = t.FeatureName("小型シールド");
            }
            else if (t.IsFeatureAvailable("エネルギーシールド") && t.EN > 5 && !IsWeaponClassifiedAs(w, "無") && !IsUnderSpecialPowerEffect("防御能力無効化"))
            {
                prob = t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "");
                fname = t.FeatureName("エネルギーシールド");
            }
            else if (t.IsFeatureAvailable("大型シールド"))
            {
                prob = (t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") + 1d);
                fname = t.FeatureName("大型シールド");
            }
            else if (t.IsFeatureAvailable("アクティブシールド"))
            {
                prob = (t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") + 2d);
                fname = t.FeatureName("アクティブシールド");
            }
            else
            {
                // 使用可能なシールド系防御能力が無かった
                return default;
            }

            // シールド発動確率を満たしている？
            if (prob >= GeneralLib.Dice(16) || t.IsUnderSpecialPowerEffect("特殊防御発動"))
            {
                use_shield = true;
                if (IsWeaponClassifiedAs(w, "破"))
                {
                    if (t.IsFeatureAvailable("小型シールド"))
                    {
                        dmg = 5 * dmg / 6;
                    }
                    else
                    {
                        dmg = 3 * dmg / 4;
                    }
                }
                else
                {
                    if (t.IsFeatureAvailable("小型シールド"))
                    {
                        dmg = 2 * dmg / 3;
                    }
                    else
                    {
                        dmg = dmg / 2;
                    }
                }

                if (dmg > 0 && dmg < 10)
                {
                    dmg = 10;
                }

                if (dmg < t.HP && !be_quiet)
                {
                    if (t.IsMessageDefined("シールド防御(" + fname + ")"))
                    {
                        t.PilotMessage("シールド防御(" + fname + ")", msg_mode: "");
                        use_shield_msg = true;
                    }
                    else if (t.IsMessageDefined("シールド防御"))
                    {
                        t.PilotMessage("シールド防御", msg_mode: "");
                        use_shield_msg = true;
                    }
                }

                if (t.IsAnimationDefined("シールド防御", fname))
                {
                    t.PlayAnimation("シールド防御", fname);
                }
                else if (t.IsSpecialEffectDefined("シールド防御", fname))
                {
                    t.SpecialEffect("シールド防御", fname);
                }
                else
                {
                    Effect.ShieldEffect(t);
                }
            }

            return default;
        }

        // バリアなどの防御能力のチェック
        private bool CheckDefenseFeature(int w, Unit t, int tx, int ty, string attack_mode, string def_mode, int dmg, string msg, bool be_quiet, bool is_penetrated)
        {
            bool CheckDefenseFeatureRet = default;
            string wname;
            int ecost, nmorale;
            string fname, fdata;
            double flevel;
            int fid, frange;
            string opt;
            double lv_mod;
            Unit u;
            double slevel;
            int k, i, j, idx;
            bool neautralize;
            string team, uteam;
            double dmg_mod;
            bool defined;
            wname = WeaponNickname(w);
            team = MainPilot().SkillData("チーム");

            // 攻撃吸収
            if (dmg < 0)
            {
                t.HP = t.HP - dmg;
                if (attack_mode != "反射")
                {
                    GUI.UpdateMessageForm(this, t);
                }
                else
                {
                    GUI.UpdateMessageForm(this, null);
                }

                Effect.NegateEffect(this, t, w, wname, dmg, "吸収", "", 0, msg, be_quiet);
                CheckDefenseFeatureRet = true;
                return CheckDefenseFeatureRet;
            }

            // 攻撃無効化
            if (dmg == 0 && this.Weapon(w).Power > 0)
            {
                if (IsWeaponClassifiedAs(w, "封") || IsWeaponClassifiedAs(w, "限"))
                {
                    GUI.DisplaySysMessage(msg + t.Nickname + "には[" + wname + "]は通用しない。");
                }
                else
                {
                    Effect.NegateEffect(this, t, w, wname, dmg, "", "", 0, msg, be_quiet);
                }

                CheckDefenseFeatureRet = true;
                return CheckDefenseFeatureRet;
            }

            // 特殊効果がない場合にはクリティカル発生の可能性がある
            if (!IsNormalWeapon(w))
            {
                // 特殊効果を伴う武器
                if (CriticalProbability(w, t, def_mode) == 0 && this.Weapon(w).Power == 0)
                {
                    // 攻撃力が0の攻撃は、クリティカル発生率が0の場合も無効化されていると見なす
                    Effect.NegateEffect(this, t, w, wname, dmg, "", "", 0, msg, be_quiet);
                    CheckDefenseFeatureRet = true;
                    return CheckDefenseFeatureRet;
                }
            }

            // バリア無効化
            if (IsWeaponClassifiedAs(w, "無") || IsUnderSpecialPowerEffect("防御能力無効化"))
            {
                goto SkipBarrier;
            }

            // 広域バリア
            // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            u = null;
            flevel = 0d;
            fid = 0;
            // バリアをはってくれるユニットを探す
            var loopTo = GeneralLib.MinLng(tx + 3, Map.MapWidth);
            for (i = GeneralLib.MaxLng(tx - 3, 1); i <= loopTo; i++)
            {
                var loopTo1 = GeneralLib.MinLng(ty + 3, Map.MapHeight);
                for (j = GeneralLib.MaxLng(ty - 3, 1); j <= loopTo1; j++)
                {
                    if (Map.MapDataForUnit[i, j] is null || Math.Abs((tx - i)) + Math.Abs((ty - j)) > 3)
                    {
                        goto NextPoint;
                    }

                    {
                        var withBlock = Map.MapDataForUnit[i, j];
                        // 敵？
                        if (withBlock.IsEnemy(t))
                        {
                            goto NextPoint;
                        }

                        // 行動不能？
                        if (withBlock.MaxAction() == 0)
                        {
                            goto NextPoint;
                        }

                        // 地中にいる？
                        if (withBlock.Area == "地中")
                        {
                            goto NextPoint;
                        }

                        // 広域バリアを持っている？
                        if (!withBlock.IsFeatureAvailable("広域バリア"))
                        {
                            goto NextPoint;
                        }

                        // 同じチームに属している？
                        uteam = withBlock.MainPilot().SkillData("チーム");
                        if ((team ?? "") != (uteam ?? "") && !string.IsNullOrEmpty(uteam))
                        {
                            goto NextPoint;
                        }

                        var loopTo2 = withBlock.CountFeature();
                        for (k = 1; k <= loopTo2; k++)
                        {
                            if (withBlock.Feature(k) == "広域バリア")
                            {
                                fdata = withBlock.FeatureData(k);

                                // 効果範囲
                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 2)))
                                {
                                    frange = Conversions.Toint(GeneralLib.LIndex(fdata, 2));
                                }
                                else
                                {
                                    frange = 1;
                                }

                                // 使用条件
                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                                {
                                    ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                                }
                                else
                                {
                                    ecost = (20 * frange);
                                }

                                if (withBlock.IsConditionSatisfied("バリア発動"))
                                {
                                    // すでに発動済み
                                    ecost = 0;
                                }

                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 5)))
                                {
                                    nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 5));
                                }
                                else
                                {
                                    nmorale = 0;
                                }

                                // 発動可能かチェック
                                bool localIsAttributeClassified() { string argaclass1 = GeneralLib.LIndex(fdata, 3); string argaclass2 = WeaponClass(w); var ret = withBlock.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                                if (withBlock.EN >= ecost && withBlock.MainPilot().Morale >= nmorale && localIsAttributeClassified() && (Math.Abs((tx - i)) + Math.Abs((ty - j))) <= frange && (Math.Abs((x - i)) + Math.Abs((y - j))) > frange && (!ReferenceEquals(Map.MapDataForUnit[i, j], t) || !t.IsFeatureAvailable("バリア")) && !withBlock.IsConditionSatisfied("バリア無効化"))
                                {
                                    if (withBlock.FeatureLevel(k) > flevel)
                                    {
                                        u = Map.MapDataForUnit[i, j];
                                        flevel = withBlock.FeatureLevel(k);
                                        fid = k;
                                    }
                                }
                            }
                        }
                    }

                    NextPoint:
                    ;
                }
            }

            if (u is object)
            {
                // バリアをはってくれるユニットがいる場合
                if (fid == 0)
                {
                    fname = u.FeatureName0("広域バリア");
                    fdata = u.FeatureData("広域バリア");
                }
                else
                {
                    fname = u.FeatureName0(fid);
                    fdata = u.FeatureData(fid);
                }

                if (string.IsNullOrEmpty(fname))
                {
                    if (u.IsFeatureAvailable("バリア"))
                    {
                        fname = u.FeatureName0("バリア");
                    }
                    else
                    {
                        fname = "広域バリア";
                    }
                }

                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                {
                    ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                }
                else
                {
                    ecost = 20;
                }

                if (!u.IsConditionSatisfied("バリア発動"))
                {
                    // バリア発動はターン中に一度のみ
                    u.EN = u.EN - ecost;
                    if (u.IsMessageDefined("バリア発動(" + fname + ")"))
                    {
                        u.PilotMessage("バリア発動(" + fname + ")", msg_mode: "");
                    }
                    else
                    {
                        u.PilotMessage("バリア発動", msg_mode: "");
                    }

                    if (u.IsAnimationDefined("バリア発動", fname))
                    {
                        u.PlayAnimation("バリア発動", fname);
                    }
                    else
                    {
                        u.SpecialEffect("バリア発動", fname);
                    }

                    if (u.IsSysMessageDefined("バリア発動", fname))
                    {
                        u.SysMessage("バリア発動", fname, add_msg: "");
                    }
                    else
                    {
                        GUI.DisplaySysMessage(u.Nickname + "は[" + fname + "]を発動させた。");
                    }

                    if (fname == "広域バリア" || fname == "バリア")
                    {
                        u.AddCondition("バリア発動", 1, cdata: "");
                    }
                    else
                    {
                        u.AddCondition("バリア発動", 1, 0d, fname + "発動");
                    }
                }

                if (1000d * flevel >= dmg)
                {
                    Effect.NegateEffect(this, t, w, wname, dmg, fname, fdata, 10, msg, be_quiet);
                    CheckDefenseFeatureRet = true;
                    return CheckDefenseFeatureRet;
                }
                else if (flevel > 0d)
                {
                    msg = msg + wname + "が[" + fname + "]を貫いた。;";
                }
            }

            // 広域フィールド
            // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            u = null;
            flevel = 0d;
            fid = 0;
            // フィールドをはってくれるユニットを探す
            var loopTo3 = GeneralLib.MinLng(tx + 3, Map.MapWidth);
            for (i = GeneralLib.MaxLng(tx - 3, 1); i <= loopTo3; i++)
            {
                var loopTo4 = GeneralLib.MinLng(ty + 3, Map.MapHeight);
                for (j = GeneralLib.MaxLng(ty - 3, 1); j <= loopTo4; j++)
                {
                    if (Map.MapDataForUnit[i, j] is null || Math.Abs((tx - i)) + Math.Abs((ty - j)) > 3)
                    {
                        goto NextPoint2;
                    }

                    {
                        var withBlock1 = Map.MapDataForUnit[i, j];
                        // 敵？
                        if (withBlock1.IsEnemy(t))
                        {
                            goto NextPoint2;
                        }

                        // 行動不能？
                        if (withBlock1.MaxAction() == 0)
                        {
                            goto NextPoint2;
                        }

                        // 地中にいる？
                        if (withBlock1.Area == "地中")
                        {
                            goto NextPoint2;
                        }

                        // 広域フィールドを持っている？
                        if (!withBlock1.IsFeatureAvailable("広域フィールド"))
                        {
                            goto NextPoint2;
                        }

                        // 同じチームに属している？
                        uteam = withBlock1.MainPilot().SkillData("チーム");
                        if ((team ?? "") != (uteam ?? "") && !string.IsNullOrEmpty(uteam))
                        {
                            goto NextPoint2;
                        }

                        var loopTo5 = withBlock1.CountFeature();
                        for (k = 1; k <= loopTo5; k++)
                        {
                            if (withBlock1.Feature(k) == "広域フィールド")
                            {
                                fdata = withBlock1.FeatureData(k);

                                // 効果範囲
                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 2)))
                                {
                                    frange = Conversions.Toint(GeneralLib.LIndex(fdata, 2));
                                }
                                else
                                {
                                    frange = 1;
                                }

                                // 使用条件
                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                                {
                                    ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                                }
                                else
                                {
                                    ecost = (20 * frange);
                                }

                                if (withBlock1.IsConditionSatisfied("フィールド発動"))
                                {
                                    // すでに発動済み
                                    ecost = 0;
                                }

                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 5)))
                                {
                                    nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 5));
                                }
                                else
                                {
                                    nmorale = 0;
                                }

                                // 発動可能かチェック
                                bool localIsAttributeClassified1() { string argaclass1 = GeneralLib.LIndex(fdata, 3); string argaclass2 = WeaponClass(w); var ret = withBlock1.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                                if (withBlock1.EN >= ecost && withBlock1.MainPilot().Morale >= nmorale && localIsAttributeClassified1() && (Math.Abs((tx - i)) + Math.Abs((ty - j))) <= frange && (Math.Abs((x - i)) + Math.Abs((y - j))) > frange && (!ReferenceEquals(Map.MapDataForUnit[i, j], t) || !t.IsFeatureAvailable("フィールド")) && !withBlock1.IsConditionSatisfied("バリア無効化"))
                                {
                                    if (withBlock1.FeatureLevel(k) > flevel)
                                    {
                                        u = Map.MapDataForUnit[i, j];
                                        flevel = withBlock1.FeatureLevel(k);
                                        fid = k;
                                    }
                                }
                            }
                        }
                    }

                    NextPoint2:
                    ;
                }
            }

            if (u is object)
            {
                // フィールドをはってくれるユニットがいる場合
                if (fid == 0)
                {
                    fname = u.FeatureName0("広域フィールド");
                    fdata = u.FeatureData("広域フィールド");
                }
                else
                {
                    fname = u.FeatureName0(fid);
                    fdata = u.FeatureData(fid);
                }

                if (string.IsNullOrEmpty(fname))
                {
                    if (u.IsFeatureAvailable("フィールド"))
                    {
                        fname = u.FeatureName0("フィールド");
                    }
                    else
                    {
                        fname = "広域フィールド";
                    }
                }

                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                {
                    ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                }
                else
                {
                    ecost = 20;
                }

                if (!u.IsConditionSatisfied("フィールド発動"))
                {
                    // フィールド発動はターン中に一度のみ
                    u.EN = u.EN - ecost;
                    if (u.IsMessageDefined("フィールド発動(" + fname + ")"))
                    {
                        u.PilotMessage("フィールド発動(" + fname + ")", msg_mode: "");
                    }
                    else
                    {
                        u.PilotMessage("フィールド発動", msg_mode: "");
                    }

                    if (u.IsAnimationDefined("フィールド発動", fname))
                    {
                        u.PlayAnimation("フィールド発動", fname);
                    }
                    else
                    {
                        u.SpecialEffect("フィールド発動", fname);
                    }

                    if (u.IsSysMessageDefined("フィールド発動", fname))
                    {
                        u.SysMessage("フィールド発動", fname, add_msg: "");
                    }
                    else
                    {
                        GUI.DisplaySysMessage(u.Nickname + "は[" + fname + "]を発動させた。");
                    }

                    if (fname == "広域フィールド" || fname == "フィールド")
                    {
                        u.AddCondition("フィールド発動", 1, cdata: "");
                    }
                    else
                    {
                        u.AddCondition("フィールド発動", 1, 0d, fname + "発動");
                    }
                }

                if (500d * flevel >= dmg)
                {
                    Effect.NegateEffect(this, t, w, wname, dmg, fname, fdata, 10, msg, be_quiet);
                    CheckDefenseFeatureRet = true;
                    return CheckDefenseFeatureRet;
                }
                else if (flevel > 0d)
                {
                    dmg = (dmg - 500d * flevel);
                    msg = msg + wname + "が[" + fname + "]を貫いた。;";
                }
            }

            // 広域プロテクション
            // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            u = null;
            flevel = 0d;
            fid = 0;
            // プロテクションをはってくれるユニットを探す
            var loopTo6 = GeneralLib.MinLng(tx + 3, Map.MapWidth);
            for (i = GeneralLib.MaxLng(tx - 3, 1); i <= loopTo6; i++)
            {
                var loopTo7 = GeneralLib.MinLng(ty + 3, Map.MapHeight);
                for (j = GeneralLib.MaxLng(ty - 3, 1); j <= loopTo7; j++)
                {
                    if (Map.MapDataForUnit[i, j] is null || Math.Abs((tx - i)) + Math.Abs((ty - j)) > 3)
                    {
                        goto NextPoint3;
                    }

                    {
                        var withBlock2 = Map.MapDataForUnit[i, j];
                        // 敵？
                        if (withBlock2.IsEnemy(t))
                        {
                            goto NextPoint3;
                        }

                        // 行動不能？
                        if (withBlock2.MaxAction() == 0)
                        {
                            goto NextPoint3;
                        }

                        // 地中にいる？
                        if (withBlock2.Area == "地中")
                        {
                            goto NextPoint3;
                        }

                        // 広域プロテクションを持っている？
                        if (!withBlock2.IsFeatureAvailable("広域プロテクション"))
                        {
                            goto NextPoint3;
                        }

                        // 同じチームに属している？
                        uteam = withBlock2.MainPilot().SkillData("チーム");
                        if ((team ?? "") != (uteam ?? "") && !string.IsNullOrEmpty(uteam))
                        {
                            goto NextPoint3;
                        }

                        var loopTo8 = withBlock2.CountFeature();
                        for (k = 1; k <= loopTo8; k++)
                        {
                            if (withBlock2.Feature(k) == "広域プロテクション")
                            {
                                fdata = withBlock2.FeatureData(k);

                                // 効果範囲
                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 2)))
                                {
                                    frange = Conversions.Toint(GeneralLib.LIndex(fdata, 2));
                                }
                                else
                                {
                                    frange = 1;
                                }

                                // 使用条件
                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                                {
                                    ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                                }
                                else
                                {
                                    ecost = (20 * frange);
                                }

                                if (withBlock2.IsConditionSatisfied("プロテクション発動"))
                                {
                                    // すでに発動済み
                                    ecost = 0;
                                }

                                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 5)))
                                {
                                    nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 5));
                                }
                                else
                                {
                                    nmorale = 0;
                                }

                                // 発動可能かチェック
                                bool localIsAttributeClassified2() { string argaclass1 = GeneralLib.LIndex(fdata, 3); string argaclass2 = WeaponClass(w); var ret = withBlock2.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                                if (withBlock2.EN >= ecost && withBlock2.MainPilot().Morale >= nmorale && localIsAttributeClassified2() && (Math.Abs((tx - i)) + Math.Abs((ty - j))) <= frange && (Math.Abs((x - i)) + Math.Abs((y - j))) > frange && (!ReferenceEquals(Map.MapDataForUnit[i, j], t) || !t.IsFeatureAvailable("プロテクション")) && !withBlock2.IsConditionSatisfied("バリア無効化"))
                                {
                                    if (withBlock2.FeatureLevel(k) > flevel)
                                    {
                                        u = Map.MapDataForUnit[i, j];
                                        flevel = withBlock2.FeatureLevel(k);
                                        fid = k;
                                    }
                                }
                            }
                        }
                    }

                    NextPoint3:
                    ;
                }
            }

            if (u is object)
            {
                // プロテクションをはってくれるユニットがいる場合
                if (fid == 0)
                {
                    fname = u.FeatureName0("広域プロテクション");
                    fdata = u.FeatureData("広域プロテクション");
                }
                else
                {
                    fname = u.FeatureName0(fid);
                    fdata = u.FeatureData(fid);
                }

                if (string.IsNullOrEmpty(fname))
                {
                    if (u.IsFeatureAvailable("プロテクション"))
                    {
                        fname = u.FeatureName0("プロテクション");
                    }
                    else
                    {
                        fname = "広域プロテクション";
                    }
                }

                if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                {
                    ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                }
                else
                {
                    ecost = 20;
                }

                if (!u.IsConditionSatisfied("プロテクション発動"))
                {
                    // プロテクション発動はターン中に一度のみ
                    u.EN = u.EN - ecost;
                    if (u.IsMessageDefined("プロテクション発動(" + fname + ")"))
                    {
                        u.PilotMessage("プロテクション発動(" + fname + ")", msg_mode: "");
                    }
                    else
                    {
                        u.PilotMessage("プロテクション発動", msg_mode: "");
                    }

                    if (u.IsAnimationDefined("プロテクション発動", fname))
                    {
                        u.PlayAnimation("プロテクション発動", fname);
                    }
                    else
                    {
                        u.SpecialEffect("プロテクション発動", fname);
                    }

                    if (u.IsSysMessageDefined("プロテクション発動", fname))
                    {
                        u.SysMessage("プロテクション発動", fname, add_msg: "");
                    }
                    else
                    {
                        GUI.DisplaySysMessage(u.Nickname + "は[" + fname + "]を発動させた。");
                    }

                    if (fname == "広域プロテクション" || fname == "プロテクション")
                    {
                        u.AddCondition("プロテクション発動", 1, cdata: "");
                    }
                    else
                    {
                        u.AddCondition("プロテクション発動", 1, 0d, fname + "発動");
                    }
                }

                dmg = ((long)(dmg * (10d - flevel)) / 10L);
                if (dmg < 0)
                {
                    msg = msg + u.Nickname + "がダメージを吸収した。;";
                    u.HP = u.HP - dmg;
                    CheckDefenseFeatureRet = true;
                    return CheckDefenseFeatureRet;
                }
                else if (flevel > 0d)
                {
                    msg = msg + u.Nickname + "の[" + fname + "]がダメージを減少させた。;";
                }
            }

            // バリア能力
            var loopTo9 = t.CountFeature();
            for (i = 1; i <= loopTo9; i++)
            {
                if (t.Feature(i) == "バリア")
                {
                    fname = t.FeatureName0(i);
                    if (string.IsNullOrEmpty(fname))
                    {
                        if (t.IsFeatureAvailable("広域バリア"))
                        {
                            fname = t.FeatureName0("広域バリア");
                        }
                        else
                        {
                            fname = "バリア";
                        }
                    }

                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 必要条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        ecost = 10;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo10 = GeneralLib.LLength(fdata);
                    for (j = 5; j <= loopTo10; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (t.MainPilot().SkillType(opt) ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData("バリア")) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        string localFeatureName() { object argIndex1 = i; var ret = t.FeatureName(argIndex1); return ret; }

                                        msg = msg + Nickname + "は[" + localFeatureName() + "]を中和した。;";
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData("バリア")) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("バリア");
                                        if (flevel <= 0d)
                                        {
                                            msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    if (def_mode != "防御")
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "能力必要":
                            case "バリア無効化無効":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 20d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 10d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // バリア無効化で無効化されている？
                    if (t.IsConditionSatisfied("バリア無効化"))
                    {
                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
                        {
                            neautralize = true;
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified3() { string argaclass1 = GeneralLib.LIndex(fdata, 2); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && localIsAttributeClassified3() && !neautralize)
                    {
                        // バリア発動
                        t.EN = t.EN - ecost;
                        if (dmg <= 1000d * flevel + slevel)
                        {
                            if (ecost != 0)
                            {
                                if (attack_mode != "反射")
                                {
                                    GUI.UpdateMessageForm(this, t);
                                }
                                else
                                {
                                    GUI.UpdateMessageForm(this, null);
                                }
                            }

                            Effect.NegateEffect(this, t, w, wname, dmg, fname, fdata, ecost, msg, be_quiet);
                            CheckDefenseFeatureRet = true;
                            return CheckDefenseFeatureRet;
                        }
                        else if (flevel > 0d || slevel > 0d)
                        {
                            if (Strings.InStr(msg, "[" + fname + "]を貫いた") == 0)
                            {
                                is_penetrated = true;
                                msg = msg + wname + "が[" + fname + "]を貫いた。;";
                                if (t.IsAnimationDefined("バリア貫通", fname))
                                {
                                    t.PlayAnimation("バリア貫通", fname);
                                }
                                else
                                {
                                    t.SpecialEffect("バリア貫通", fname);
                                }
                            }
                        }
                    }
                }
            }

            // フィールド能力
            var loopTo11 = t.CountFeature();
            for (i = 1; i <= loopTo11; i++)
            {
                if (t.Feature(i) == "フィールド")
                {
                    fname = t.FeatureName0(i);
                    if (string.IsNullOrEmpty(fname))
                    {
                        if (t.IsFeatureAvailable("バリア"))
                        {
                            fname = t.FeatureName("バリア");
                        }
                        else
                        {
                            fname = "フィールド";
                        }
                    }

                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 必要条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        ecost = 0;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo12 = GeneralLib.LLength(fdata);
                    for (j = 5; j <= loopTo12; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (t.MainPilot().SkillType(opt) ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData(argIndex54)) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData("フィールド")) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("フィールド");
                                        if (flevel <= 0d)
                                        {
                                            msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    if (def_mode != "防御")
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "能力必要":
                            case "バリア無効化無効":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 20d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 10d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // バリア無効化で無効化されている？
                    if (t.IsConditionSatisfied("バリア無効化"))
                    {
                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
                        {
                            neautralize = true;
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified4() { string argaclass1 = GeneralLib.LIndex(fdata, 2); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && localIsAttributeClassified4() && !neautralize)
                    {
                        // フィールド発動
                        t.EN = t.EN - ecost;
                        if (dmg <= 500d * flevel + slevel)
                        {
                            if (ecost != 0)
                            {
                                if (attack_mode != "反射")
                                {
                                    GUI.UpdateMessageForm(this, t);
                                }
                                else
                                {
                                    GUI.UpdateMessageForm(this, null);
                                }
                            }

                            Effect.NegateEffect(this, t, w, wname, dmg, fname, fdata, ecost, msg, be_quiet);
                            CheckDefenseFeatureRet = true;
                            return CheckDefenseFeatureRet;
                        }
                        else if (flevel > 0d || slevel > 0d)
                        {
                            dmg = (dmg - 500d * flevel - slevel);
                            if (Strings.InStr(msg, "[" + fname + "]を貫いた") == 0)
                            {
                                msg = msg + wname + "が[" + fname + "]を貫いた。;";
                            }
                        }
                    }
                }
            }

            // プロテクション能力
            var loopTo13 = t.CountFeature();
            for (i = 1; i <= loopTo13; i++)
            {
                if (t.Feature(i) == "プロテクション")
                {
                    fname = t.FeatureName0(i);
                    if (string.IsNullOrEmpty(fname))
                    {
                        if (t.IsFeatureAvailable("バリア"))
                        {
                            fname = t.FeatureName("バリア");
                        }
                        else
                        {
                            fname = "プロテクション";
                        }
                    }

                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 必要条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        ecost = 10;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo14 = GeneralLib.LLength(fdata);
                    for (j = 5; j <= loopTo14; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (t.MainPilot().SkillType(opt) ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData("プロテクション")) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData(argIndex65)) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("プロテクション");
                                        if (flevel <= 0d)
                                        {
                                            msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    if (def_mode != "防御")
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "能力必要":
                            case "バリア無効化無効":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 0.5d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 0.2d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // バリア無効化で無効化されている？
                    if (t.IsConditionSatisfied("バリア無効化"))
                    {
                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
                        {
                            neautralize = true;
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified5() { string argaclass1 = GeneralLib.LIndex(fdata, 2); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && localIsAttributeClassified5() && !neautralize && dmg > 0)
                    {
                        // プロテクション発動
                        dmg = ((long)(dmg * (100d - 10d * flevel - slevel)) / 100L);
                        if (ecost != 0)
                        {
                            t.EN = t.EN - ecost;
                            if (attack_mode != "反射")
                            {
                                GUI.UpdateMessageForm(this, t);
                            }
                            else
                            {
                                GUI.UpdateMessageForm(this, null);
                            }
                        }

                        if (dmg <= 0)
                        {
                            Effect.NegateEffect(this, t, w, wname, dmg, fname, fdata, ecost, msg, be_quiet);
                            t.HP = t.HP - dmg;
                            GUI.UpdateMessageForm(this, t);
                            CheckDefenseFeatureRet = true;
                            return CheckDefenseFeatureRet;
                        }
                        else if (flevel > 0d || slevel > 0d)
                        {
                            if (Strings.InStr(msg, "[" + fname + "]") == 0)
                            {
                                msg = msg + "[" + fname + "]がダメージを減少させた。;";
                            }
                        }
                    }
                }
            }

            // バリアシールド、アクティブフィールド、アクティブプロテクションは能動防御
            if (t.MaxAction() == 0 || t.IsUnderSpecialPowerEffect("無防備"))
            {
                goto SkipActiveBarrier;
            }

            // バリアシールド能力
            var loopTo15 = t.CountFeature();
            for (i = 1; i <= loopTo15; i++)
            {
                if (t.Feature(i) == "バリアシールド")
                {
                    fname = t.FeatureName0(i);
                    if (string.IsNullOrEmpty(fname))
                    {
                        if (t.IsFeatureAvailable("反射"))
                        {
                            fname = t.FeatureName0("反射");
                        }
                        else
                        {
                            fname = "バリアシールド";
                        }
                    }

                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 使用条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        ecost = 10;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo16 = GeneralLib.LLength(fdata);
                    for (j = 5; j <= loopTo16; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (t.MainPilot().SkillType(opt) ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData("バリアシールド")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        string localFeatureName1() { object argIndex1 = i; var ret = t.FeatureName(argIndex1); return ret; }

                                        msg = msg + Nickname + "は[" + localFeatureName1() + "]を中和した。;";
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData("バリアシールド")) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("バリアシールド");
                                        if (flevel <= 0d)
                                        {
                                            msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    if (def_mode != "防御")
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "能力必要":
                            case "バリア無効化無効":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 20d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 10d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // バリア無効化で無効化されている？
                    if (t.IsConditionSatisfied("バリア無効化"))
                    {
                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
                        {
                            neautralize = true;
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified6() { string argaclass1 = GeneralLib.LIndex(fdata, 2); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && localIsAttributeClassified6() && t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") > 0d && !neautralize)
                    {
                        // バリアシールド発動
                        if (t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") >= GeneralLib.Dice(16) || t.IsUnderSpecialPowerEffect("特殊防御発動"))
                        {
                            t.EN = t.EN - ecost;
                            if (dmg <= 1000d * flevel + slevel)
                            {
                                if (ecost != 0)
                                {
                                    if (attack_mode != "反射")
                                    {
                                        GUI.UpdateMessageForm(this, t);
                                    }
                                    else
                                    {
                                        GUI.UpdateMessageForm(this, null);
                                    }
                                }

                                Effect.NegateEffect(this, t, w, wname, dmg, fname, fdata, ecost, msg, be_quiet);
                                CheckDefenseFeatureRet = true;
                                return CheckDefenseFeatureRet;
                            }
                            else if (flevel > 0d || slevel > 0d)
                            {
                                if (Strings.InStr(msg, "[" + fname + "]を貫いた") == 0)
                                {
                                    is_penetrated = true;
                                    msg = msg + wname + "が[" + fname + "]を貫いた。;";
                                    if (t.IsAnimationDefined("バリア貫通", fname))
                                    {
                                        t.PlayAnimation("バリア貫通", fname);
                                    }
                                    else
                                    {
                                        t.SpecialEffect("バリア貫通", fname);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // アクティブフィールド能力
            var loopTo17 = t.CountFeature();
            for (i = 1; i <= loopTo17; i++)
            {
                if (t.Feature(i) == "アクティブフィールド")
                {
                    fname = t.FeatureName0(i);
                    if (string.IsNullOrEmpty(fname))
                    {
                        if (t.IsFeatureAvailable("反射"))
                        {
                            fname = t.FeatureName0("反射");
                        }
                        else
                        {
                            fname = "アクティブフィールド";
                        }
                    }

                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 使用条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        ecost = 0;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo18 = GeneralLib.LLength(fdata);
                    for (j = 5; j <= loopTo18; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (t.MainPilot().SkillType(opt) ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData("アクティブフィールド")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        string localFeatureName2() { object argIndex1 = i; var ret = t.FeatureName(argIndex1); return ret; }

                                        msg = msg + Nickname + "は[" + localFeatureName2() + "]を中和した。;";
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData("アクティブフィールド")) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("アクティブフィールド");
                                        if (flevel <= 0d)
                                        {
                                            msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    if (def_mode != "防御")
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "能力必要":
                            case "バリア無効化無効":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 20d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 10d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // バリア無効化で無効化されている？
                    if (t.IsConditionSatisfied("バリア無効化"))
                    {
                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
                        {
                            neautralize = true;
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified7() { string argaclass1 = GeneralLib.LIndex(fdata, 2); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && localIsAttributeClassified7() && t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") > 0d && !neautralize)
                    {
                        // アクティブフィールド発動
                        if (t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") >= GeneralLib.Dice(16) || t.IsUnderSpecialPowerEffect("特殊防御発動"))
                        {
                            t.EN = t.EN - ecost;
                            if (dmg <= 500d * flevel + slevel)
                            {
                                if (ecost != 0)
                                {
                                    if (attack_mode != "反射")
                                    {
                                        GUI.UpdateMessageForm(this, t);
                                    }
                                    else
                                    {
                                        GUI.UpdateMessageForm(this, null);
                                    }
                                }

                                Effect.NegateEffect(this, t, w, wname, dmg, fname, fdata, ecost, msg, be_quiet);
                                CheckDefenseFeatureRet = true;
                                return CheckDefenseFeatureRet;
                            }
                            else if (flevel > 0d || slevel > 0d)
                            {
                                dmg = (dmg - 500d * flevel - slevel);
                                if (Strings.InStr(msg, "[" + fname + "]を貫いた") == 0)
                                {
                                    msg = msg + wname + "が[" + fname + "]を貫いた。;";
                                }
                            }
                        }
                    }
                }
            }

            // アクティブプロテクション能力
            var loopTo19 = t.CountFeature();
            for (i = 1; i <= loopTo19; i++)
            {
                if (t.Feature(i) == "アクティブプロテクション")
                {
                    fname = t.FeatureName0(i);
                    if (string.IsNullOrEmpty(fname))
                    {
                        if (t.IsFeatureAvailable("反射"))
                        {
                            fname = t.FeatureName0("反射");
                        }
                        else
                        {
                            fname = "アクティブプロテクション";
                        }
                    }

                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 使用条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        ecost = 10;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 4)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 4));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // オプション
                    neautralize = false;
                    slevel = 0d;
                    var loopTo20 = GeneralLib.LLength(fdata);
                    for (j = 5; j <= loopTo20; j++)
                    {
                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (t.MainPilot().SkillType(opt) ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData("アクティブプロテクション")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        string localFeatureName3() { object argIndex1 = i; var ret = t.FeatureName(argIndex1); return ret; }

                                        msg = msg + Nickname + "は[" + localFeatureName3() + "]を中和した。;";
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData("アクティブプロテクション")) && Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("アクティブプロテクション");
                                        if (flevel <= 0d)
                                        {
                                            msg = msg + Nickname + "は[" + fname + "]を中和した。;";
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    if (def_mode != "防御")
                                    {
                                        neautralize = true;
                                    }

                                    break;
                                }

                            case "能力必要":
                            case "バリア無効化無効":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 0.5d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            neautralize = true;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 0.2d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 5d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            neautralize = true;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // バリア無効化で無効化されている？
                    if (t.IsConditionSatisfied("バリア無効化"))
                    {
                        if (Strings.InStr(fdata, "バリア無効化無効") == 0)
                        {
                            neautralize = true;
                        }
                    }

                    // 発動可能？
                    bool localIsAttributeClassified8() { string argaclass1 = GeneralLib.LIndex(fdata, 2); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (t.EN >= ecost && t.MainPilot().Morale >= nmorale && localIsAttributeClassified8() && t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") > 0d && !neautralize && dmg > 0)
                    {
                        // アクティブプロテクション発動
                        if (t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") >= GeneralLib.Dice(16) || t.IsUnderSpecialPowerEffect("特殊防御発動"))
                        {
                            dmg = ((long)(dmg * (100d - 10d * flevel - slevel)) / 100L);
                            if (ecost != 0)
                            {
                                t.EN = t.EN - ecost;
                                if (attack_mode != "反射")
                                {
                                    GUI.UpdateMessageForm(this, t);
                                }
                                else
                                {
                                    GUI.UpdateMessageForm(this, null);
                                }
                            }

                            if (dmg <= 0)
                            {
                                Effect.NegateEffect(this, t, w, wname, dmg, fname, fdata, ecost, msg, be_quiet);
                                t.HP = t.HP - dmg;
                                GUI.UpdateMessageForm(this, t);
                                CheckDefenseFeatureRet = true;
                                return CheckDefenseFeatureRet;
                            }
                            else if (flevel > 0d || slevel > 0d)
                            {
                                if (Strings.InStr(msg, "[" + fname + "]") == 0)
                                {
                                    msg = msg + "[" + fname + "]がダメージを減少させた。;";
                                }
                            }
                        }
                    }
                }
            }

            SkipActiveBarrier:
            ;


            // 相手の攻撃をＥＮに変換
            var loopTo21 = t.CountFeature();
            for (i = 1; i <= loopTo21; i++)
            {
                if (t.Feature(i) == "変換")
                {
                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);

                    // 必要気力
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 3)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 3));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    // 発動可能？
                    bool localIsAttributeClassified9() { string argaclass1 = GeneralLib.LIndex(fdata, 2); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (t.MainPilot().Morale >= nmorale && localIsAttributeClassified9())
                    {
                        t.EN = (t.EN + 0.01d * flevel * dmg);
                    }
                }
            }

            // 対ビーム用防御能力
            if (IsWeaponClassifiedAs(w, "Ｂ"))
            {
                // ビーム吸収
                if (t.IsFeatureAvailable("ビーム吸収"))
                {
                    fname = t.FeatureName("ビーム吸収");
                    t.HP = t.HP + dmg;
                    Effect.NegateEffect(this, t, w, wname, dmg, fname, "Ｂ", 0, msg, be_quiet);
                    CheckDefenseFeatureRet = true;
                    return CheckDefenseFeatureRet;
                }
            }

            SkipBarrier:
            ;


            // 攻撃力が0の場合は盾や融合を無視
            if (this.Weapon(w).Power == 0)
            {
                return CheckDefenseFeatureRet;
            }

            // 盾防御
            if (t.IsFeatureAvailable("盾") && t.MainPilot().IsSkillAvailable("Ｓ防御") && t.MaxAction() > 0 && !IsWeaponClassifiedAs(w, "精") && !IsWeaponClassifiedAs(w, "浸") && !IsWeaponClassifiedAs(w, "殺") && !IsUnderSpecialPowerEffect("シールド防御無効化") && !t.IsUnderSpecialPowerEffect("無防備") && (t.IsConditionSatisfied("盾付加") || t.FeatureLevel("盾") > t.ConditionLevel("盾ダメージ")))
            {
                fname = t.FeatureName0("盾");
                if (!be_quiet)
                {
                    t.PilotMessage("シールド防御", fname);
                }

                if (t.IsAnimationDefined("シールド防御", fname))
                {
                    t.PlayAnimation("シールド防御", fname);
                }
                else if (t.IsSpecialEffectDefined("シールド防御", fname))
                {
                    t.SpecialEffect("シールド防御", fname);
                }
                else
                {
                    Effect.ShowAnimation("ミドルシールド発動");
                }

                if (IsWeaponClassifiedAs(w, "破"))
                {
                    dmg = GeneralLib.MaxLng((dmg - 50d * (t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") + 4d)), 0);
                }
                else
                {
                    dmg = GeneralLib.MaxLng((dmg - 100d * (t.MainPilot().SkillLevel("Ｓ防御", ref_mode: "") + 4d)), 0);
                }

                if (t.IsSysMessageDefined("シールド防御", fname))
                {
                    t.SysMessage("シールド防御", fname, add_msg: "");
                }
                else if (dmg == 0)
                {
                    GUI.DisplaySysMessage(t.Nickname + "は[" + fname + "]を使って攻撃を防いだ。");
                }
                else
                {
                    GUI.DisplaySysMessage(t.Nickname + "は[" + fname + "]を使ってダメージを軽減させた。");
                }

                if (dmg == 0)
                {
                    // 攻撃を盾で完全に防いだ場合

                    // 命中時の特殊効果
                    Sound.IsWavePlayed = false;
                    if (!be_quiet)
                    {
                        PilotMessage(wname + "(命中)", msg_mode: "");
                    }

                    bool localIsSpecialEffectDefined() { string argmain_situation = wname + "(命中)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    if (IsAnimationDefined(wname + "(命中)", sub_situation: "") || IsAnimationDefined(wname, sub_situation: ""))
                    {
                        PlayAnimation(wname + "(命中)", sub_situation: "");
                    }
                    else if (localIsSpecialEffectDefined())
                    {
                        SpecialEffect(wname + "(命中)", sub_situation: "");
                    }
                    else if (!Sound.IsWavePlayed)
                    {
                        Effect.HitEffect(this, w, t);
                    }

                    CheckDefenseFeatureRet = true;
                    return CheckDefenseFeatureRet;
                }
                else
                {
                    // 攻撃が盾を貫通した場合
                    if (t.IsConditionSatisfied("盾付加"))
                    {
                        if (IsWeaponClassifiedAs(w, "破"))
                        {
                            t.SetConditionLevel("盾付加", t.ConditionLevel("盾付加") - 2d);
                        }
                        else
                        {
                            t.SetConditionLevel("盾付加", t.ConditionLevel("盾付加") - 1d);
                        }

                        if (t.ConditionLevel("盾付加") <= 0d)
                        {
                            t.DeleteCondition("盾付加");
                        }
                    }
                    else
                    {
                        if (IsWeaponClassifiedAs(w, "破"))
                        {
                            if (t.IsConditionSatisfied("盾ダメージ"))
                            {
                                t.SetConditionLevel("盾ダメージ", t.ConditionLevel("盾ダメージ") + 2d);
                            }
                            else
                            {
                                t.AddCondition("盾ダメージ", -1, 2d, cdata: "");
                            }
                        }
                        else
                        {
                            if (t.IsConditionSatisfied("盾ダメージ"))
                            {
                                t.SetConditionLevel("盾ダメージ", t.ConditionLevel("盾ダメージ") + 1d);
                            }
                            else
                            {
                                t.AddCondition("盾ダメージ", -1, 1d, cdata: "");
                            }
                        }
                    }
                }
            }

            // 融合能力
            if (t.IsFeatureAvailable("融合"))
            {
                // 融合可能？
                if (!IsWeaponClassifiedAs(w, "武") && !IsWeaponClassifiedAs(w, "突") && !IsWeaponClassifiedAs(w, "接") && (t.FeatureLevel("融合") >= GeneralLib.Dice(16) || t.IsUnderSpecialPowerEffect("特殊防御発動")))
                {
                    // 融合発動
                    t.HP = t.HP + dmg;
                    if (attack_mode != "反射")
                    {
                        GUI.UpdateMessageForm(this, t);
                    }
                    else
                    {
                        GUI.UpdateMessageForm(this, null);
                    }

                    fname = t.FeatureName("融合");
                    if (!be_quiet)
                    {
                        if (t.IsMessageDefined("攻撃無効化(" + fname + ")"))
                        {
                            t.PilotMessage("攻撃無効化(" + fname + ")", msg_mode: "");
                        }
                        else
                        {
                            t.PilotMessage("攻撃無効化", msg_mode: "");
                        }
                    }

                    if (t.IsAnimationDefined("攻撃無効化", fname))
                    {
                        t.PlayAnimation("攻撃無効化", fname);
                    }
                    else if (t.IsSpecialEffectDefined("攻撃無効化", fname))
                    {
                        t.SpecialEffect("攻撃無効化", fname);
                    }
                    else
                    {
                        Effect.AbsorbEffect(this, w, t);
                    }

                    bool localIsSpecialEffectDefined1() { string argmain_situation = wname + "(攻撃無効化)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    if (IsAnimationDefined(wname + "(攻撃無効化)", sub_situation: ""))
                    {
                        PlayAnimation(wname + "(攻撃無効化)", sub_situation: "");
                    }
                    else if (localIsSpecialEffectDefined1())
                    {
                        SpecialEffect(wname + "(攻撃無効化)", sub_situation: "");
                    }

                    if (t.IsSysMessageDefined("攻撃無効化", fname))
                    {
                        t.SysMessage("攻撃無効化", fname, add_msg: "");
                    }
                    else
                    {
                        if (IsWeaponClassifiedAs(w, "実"))
                        {
                            GUI.DisplaySysMessage(msg + t.Nickname + "は[" + wname + "]を取り込んだ。");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(msg + t.Nickname + "は[" + wname + "]の攻撃を吸収した。");
                        }
                    }

                    CheckDefenseFeatureRet = true;
                    return CheckDefenseFeatureRet;
                }
            }

            return CheckDefenseFeatureRet;
        }

        // 自動反撃のチェック
        public void CheckAutoAttack(int w, Unit t, string attack_mode, string def_mode, int dmg, bool be_quiet)
        {
            string wname2;
            int w2;
            int ecost, nmorale;
            string fname, fdata;
            double flevel;
            double slevel, lv_mod;
            string opt;
            int j, i, idx;
            int prob;
            string buf;

            // 反撃系の攻撃に対しては自動反撃を行わない
            if (attack_mode == "自動反撃" || attack_mode == "反射" || attack_mode == "当て身技")
            {
                return;
            }

            // マップ攻撃、間接攻撃、無属性武器には自動反撃出来ない
            if (IsWeaponClassifiedAs(w, "Ｍ") || IsWeaponClassifiedAs(w, "間") || IsWeaponClassifiedAs(w, "無") || IsUnderSpecialPowerEffect("防御能力無効化"))
            {
                return;
            }

            // 自動反撃の結果形態が変化して特殊能力数が変わることがあるのでFor文は使わない
            i = 1;
            while (i <= t.CountFeature())
            {
                if (t.Feature(i) == "自動反撃")
                {
                    fname = t.FeatureName0(i);
                    if (string.IsNullOrEmpty(fname))
                    {
                        fname = "自動反撃";
                    }

                    fdata = t.FeatureData(i);
                    flevel = t.FeatureLevel(i);
                    if (flevel == 1d)
                    {
                        flevel = 10000d;
                    }

                    // 自動反撃確率の設定
                    buf = GeneralLib.LIndex(fdata, 4);
                    if (Information.IsNumeric(buf))
                    {
                        prob = Conversions.Toint(buf);
                    }
                    else if (Strings.InStr(buf, "+") > 0 || Strings.InStr(buf, "-") > 0)
                    {
                        j = GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
                        prob = (100d * (t.SkillLevel(Strings.Left(buf, j - 1)) + Conversions.Toint(Strings.Mid(buf, j))) / 16d);
                    }
                    else
                    {
                        prob = (100d * t.SkillLevel(buf) / 16d);
                    }

                    // 見切り
                    if (t.IsUnderSpecialPowerEffect("特殊防御発動"))
                    {
                        prob = 100;
                    }

                    // 対象属性の判定
                    bool localIsAttributeClassified() { string argaclass1 = GeneralLib.LIndex(fdata, 3); string argaclass2 = WeaponClass(w); var ret = t.IsAttributeClassified(argaclass1, argaclass2); return ret; }

                    if (!localIsAttributeClassified())
                    {
                        prob = 0;
                    }

                    // 使用条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 5)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 5));
                    }
                    else
                    {
                        ecost = 0;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 6)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 6));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    if (t.EN < ecost || t.MainPilot().Morale < nmorale)
                    {
                        prob = 0;
                    }

                    // 能動防御は行動できなければ発動しない
                    if (t.MaxAction() == 0)
                    {
                        if (Strings.InStr(fdata, "完全自動") == 0)
                        {
                            prob = 0;
                        }
                    }

                    // オプション
                    slevel = 0d;
                    var loopTo = GeneralLib.LLength(fdata);
                    for (j = 7; j <= loopTo; j++)
                    {
                        if (prob == 0)
                        {
                            break;
                        }

                        opt = GeneralLib.LIndex(fdata, j);
                        idx = Strings.InStr(opt, "*");
                        if (idx > 0)
                        {
                            lv_mod = GeneralLib.StrToDbl(Strings.Mid(opt, idx + 1));
                            opt = Strings.Left(opt, idx - 1);
                        }
                        else
                        {
                            lv_mod = -1;
                        }

                        switch (t.MainPilot().SkillType(opt) ?? "")
                        {
                            case "相殺":
                                {
                                    if (IsSameCategory(fdata, FeatureData("自動反撃")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "中和":
                                {
                                    if (IsSameCategory(fdata, FeatureData("自動反撃")) && Math.Abs((x - t.x)) + Math.Abs((y - t.y)) == 1)
                                    {
                                        flevel = flevel - FeatureLevel("自動反撃");
                                        if (flevel <= 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "近接無効":
                                {
                                    if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                    {
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "手動":
                                {
                                    if (def_mode != "防御")
                                    {
                                        prob = 0;
                                    }

                                    break;
                                }

                            case "能力必要":
                                {
                                    break;
                                }
                            // スキップ
                            case "同調率":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 20d;
                                    }

                                    slevel = lv_mod * (t.SyncLevel() - 30d);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == -30 * lv_mod)
                                        {
                                            prob = 0;
                                        }
                                    }
                                    else if (slevel == -30 * lv_mod)
                                    {
                                        slevel = 0d;
                                    }

                                    break;
                                }

                            case "霊力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 10d;
                                    }

                                    slevel = lv_mod * t.PlanaLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "オーラ":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.AuraLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            case "超能力":
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.PsychicLevel();
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (lv_mod == -1)
                                    {
                                        lv_mod = 200d;
                                    }

                                    slevel = lv_mod * t.SkillLevel(opt);
                                    if (Strings.InStr(fdata, "能力必要") > 0)
                                    {
                                        if (slevel == 0d)
                                        {
                                            prob = 0;
                                        }
                                    }

                                    break;
                                }
                        }
                    }

                    // ダメージが許容範囲外であれば自動反撃を使えない
                    if (dmg > 500d * flevel + slevel)
                    {
                        prob = 0;
                    }

                    // 使用する武器を検索
                    wname2 = GeneralLib.LIndex(fdata, 2);
                    w2 = 0;
                    var loopTo1 = t.CountWeapon();
                    for (j = 1; j <= loopTo1; j++)
                    {
                        if ((t.Weapon(j).Name ?? "") == (wname2 ?? ""))
                        {
                            if (t.IsWeaponAvailable(j, "必要技能無視"))
                            {
                                if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "突") || IsWeaponClassifiedAs(w, "接"))
                                {
                                    w2 = j;
                                }
                                else
                                {
                                    if (t.IsTargetWithinRange(j, this))
                                    {
                                        w2 = j;
                                    }
                                }
                            }

                            break;
                        }
                    }

                    // 自動反撃発動
                    if (prob >= GeneralLib.Dice(100) && w2 > 0)
                    {
                        if (ecost != 0)
                        {
                            t.EN = t.EN - ecost;
                            GUI.UpdateMessageForm(this, t);
                        }

                        // メッセージ
                        if (!be_quiet)
                        {
                            if (t.IsMessageDefined("自動反撃(" + fname + ")"))
                            {
                                t.PilotMessage("自動反撃(" + fname + ")", msg_mode: "");
                            }
                            else
                            {
                                t.PilotMessage("自動反撃", msg_mode: "");
                            }
                        }
                        else
                        {
                            Sound.IsWavePlayed = false;
                        }

                        // 効果音
                        if (!Sound.IsWavePlayed)
                        {
                            if (t.IsAnimationDefined("自動反撃", fname))
                            {
                                t.PlayAnimation("自動反撃", fname);
                            }
                            else if (t.IsSpecialEffectDefined("自動反撃", fname))
                            {
                                t.SpecialEffect("自動反撃", fname);
                            }
                        }

                        if (t.IsSysMessageDefined("自動反撃", fname))
                        {
                            t.SysMessage("自動反撃", fname, add_msg: "");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(t.Nickname + "は" + t.WeaponNickname(w2) + "で反撃した。");
                        }

                        // 自動反撃で攻撃をかける
                        t.Attack(w2, this, "自動反撃", "");
                        t = t.CurrentForm();
                        if (Status != "出撃" || t.Status != "出撃")
                        {
                            return;
                        }
                    }
                }

                i = (i + 1);
            }
        }

        // 追加攻撃のチェック
        public void CheckAdditionalAttack(int w, Unit t, bool be_quiet, string attack_mode, string def_mode, int dmg)
        {
            string wnskill, wname, wnickname, wclass;
            string wtype, sname;
            string wname2;
            int w2;
            int ecost, nmorale;
            string fname, fdata;
            double flevel;
            int i, j;
            int prob;
            string buf;
            bool found;
            var attack_count = default;
            wname = Weapon(w).Name;
            wnickname = WeaponNickname(w);
            wclass = WeaponClass(w);
            wnskill = Weapon(w).NecessarySkill;

            // 追加攻撃の結果形態が変化して特殊能力数が変わることがあるのでFor文は使わない
            i = 1;
            while (i <= CountFeature())
            {
                if (Feature(i) == "追加攻撃")
                {
                    fname = FeatureName0(i);
                    if (string.IsNullOrEmpty(fname))
                    {
                        fname = "追加攻撃";
                    }

                    fdata = FeatureData(i);
                    flevel = FeatureLevel(i);
                    if (flevel == 1d)
                    {
                        flevel = 10000d;
                    }

                    // 追加攻撃確率の設定
                    buf = GeneralLib.LIndex(fdata, 4);
                    if (Information.IsNumeric(buf))
                    {
                        prob = Conversions.Toint(buf);
                    }
                    else if (Strings.InStr(buf, "+") > 0 || Strings.InStr(buf, "-") > 0)
                    {
                        j = GeneralLib.MaxLng(Strings.InStr(buf, "+"), Strings.InStr(buf, "-"));
                        prob = (100d * (SkillLevel(Strings.Left(buf, j - 1)) + Conversions.Toint(Strings.Mid(buf, j))) / 16d);
                    }
                    else
                    {
                        prob = (SkillLevel(buf) * 100d / 16d);
                    }

                    // 対象武器の判定
                    wtype = GeneralLib.LIndex(fdata, 3);
                    found = false;
                    if (Strings.Left(wtype, 1) == "@")
                    {
                        // 武器名または必要技能による指定
                        wtype = Strings.Mid(wtype, 2);
                        if ((wname ?? "") == (wtype ?? "") || (wnickname ?? "") == (wtype ?? ""))
                        {
                            found = true;
                        }
                        else
                        {
                            var loopTo = GeneralLib.LLength(wnskill);
                            for (j = 1; j <= loopTo; j++)
                            {
                                sname = GeneralLib.LIndex(wnskill, j);
                                if (Strings.InStr(sname, "Lv") > 0)
                                {
                                    sname = Strings.Left(sname, Strings.InStr(sname, "Lv") - 1);
                                }

                                if ((sname ?? "") == (wtype ?? ""))
                                {
                                    found = true;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // 属性による指定
                        switch (wtype ?? "")
                        {
                            case "全":
                                {
                                    found = true;
                                    break;
                                }

                            case "物":
                                {
                                    if (GeneralLib.InStrNotNest(wclass, "魔") == 0 || GeneralLib.InStrNotNest(wclass, "魔武") > 0 || GeneralLib.InStrNotNest(wclass, "魔突") > 0 || GeneralLib.InStrNotNest(wclass, "魔接") > 0 || GeneralLib.InStrNotNest(wclass, "魔銃") > 0 || GeneralLib.InStrNotNest(wclass, "魔実") > 0)
                                    {
                                        found = true;
                                    }

                                    break;
                                }

                            default:
                                {
                                    if (IsAttributeClassified(wtype, wclass))
                                    {
                                        found = true;
                                    }

                                    break;
                                }
                        }
                    }

                    if (!found)
                    {
                        prob = 0;
                    }

                    // 使用条件
                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 5)))
                    {
                        ecost = Conversions.Toint(GeneralLib.LIndex(fdata, 5));
                    }
                    else
                    {
                        ecost = 0;
                    }

                    if (Information.IsNumeric(GeneralLib.LIndex(fdata, 6)))
                    {
                        nmorale = Conversions.Toint(GeneralLib.LIndex(fdata, 6));
                    }
                    else
                    {
                        nmorale = 0;
                    }

                    if (EN < ecost || this.MainPilot().Morale < nmorale)
                    {
                        prob = 0;
                    }

                    // 連鎖不可
                    if (Strings.InStr(fdata, "連鎖不可") > 0)
                    {
                        if (attack_count > 0 || attack_mode == "追加攻撃")
                        {
                            prob = 0;
                        }
                    }

                    // 命中時限定
                    if (Strings.InStr(fdata, "命中時限定") > 0)
                    {
                        if (dmg <= 0)
                        {
                            prob = 0;
                        }
                    }

                    // 使用する武器を検索
                    wname2 = GeneralLib.LIndex(fdata, 2);
                    w2 = 0;
                    var loopTo1 = CountWeapon();
                    for (j = 1; j <= loopTo1; j++)
                    {
                        if ((Weapon(j).Name ?? "") == (wname2 ?? ""))
                        {
                            if (IsWeaponAvailable(j, "必要技能無視"))
                            {
                                if (IsTargetWithinRange(j, t))
                                {
                                    w2 = j;
                                    break;
                                }
                            }
                        }
                    }

                    // 追加攻撃反撃発動
                    if (prob >= GeneralLib.Dice(100) && w2 > 0)
                    {
                        if (ecost != 0)
                        {
                            EN = EN - ecost;
                            GUI.UpdateMessageForm(this, t);
                        }

                        // メッセージ
                        if (!be_quiet)
                        {
                            if (IsMessageDefined("追加攻撃(" + fname + ")"))
                            {
                                PilotMessage("追加攻撃(" + fname + ")", msg_mode: "");
                            }
                            else
                            {
                                PilotMessage("追加攻撃", msg_mode: "");
                            }
                        }

                        // 効果音
                        if (IsAnimationDefined("追加攻撃", fname))
                        {
                            PlayAnimation("追加攻撃", fname);
                        }
                        else if (IsSpecialEffectDefined("追加攻撃", fname))
                        {
                            SpecialEffect("追加攻撃", fname);
                        }

                        if (IsSysMessageDefined("追加攻撃", fname))
                        {
                            SysMessage("追加攻撃", fname, add_msg: "");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(Nickname + "はさらに[" + WeaponNickname(w2) + "]で攻撃を加えた。");
                        }

                        // 追加攻撃をかける
                        Attack(w2, t, "追加攻撃", def_mode);
                        t = t.CurrentForm();
                        if (Status != "出撃" || t.Status != "出撃")
                        {
                            return;
                        }

                        // 追加攻撃を実施したことを記録
                        attack_count = (attack_count + 1);
                    }
                }

                i = (i + 1);
            }
        }

        // クリティカルによる特殊効果
        public bool CauseEffect(int w, Unit t, string msg, string critical_type, string def_mode, bool will_die)
        {
            bool CauseEffectRet = default;
            int i, prob, j;
            string fname, wname, ch;
            string[] Skill;
            wname = WeaponNickname(w);

            // 特殊効果発生確率
            if (IsUnderSpecialPowerEffect("特殊効果発動"))
            {
                prob = 100;
            }
            else
            {
                prob = CriticalProbability(w, t, def_mode);
            }

            if (will_die)
            {
                // メッセージ等がうっとうしいので破壊が確定している場合は
                // 通常の特殊効果をスキップ
                goto SkipNormalEffect;
            }

            // 各種効果の発動チェック

            // 捕縛攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "縛") && !t.SpecialEffectImmune("縛"))
                {
                    msg = msg + "[" + t.Nickname + "]の自由を奪った。;";
                    if (IsWeaponLevelSpecified(w, "縛"))
                    {
                        t.AddCondition("行動不能", WeaponLevel(w, "縛"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("行動不能", 2, cdata: "");
                    }

                    critical_type = critical_type + " 捕縛";
                    CauseEffectRet = true;
                }
            }

            // ショック攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "Ｓ") && !t.SpecialEffectImmune("Ｓ"))
                {
                    msg = msg + "[" + t.Nickname + "]を一時的に行動不能にした。;";
                    if (IsWeaponLevelSpecified(w, "Ｓ"))
                    {
                        t.AddCondition("行動不能", WeaponLevel(w, "Ｓ"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("行動不能", 1, cdata: "");
                    }

                    critical_type = critical_type + " ショック";
                    CauseEffectRet = true;
                }
            }

            // 装甲劣化攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "劣") && !t.SpecialEffectImmune("劣"))
                {
                    msg = msg + "[" + t.Nickname + "]の" + Expression.Term("装甲", t) + "を劣化させた。;";
                    if (IsWeaponLevelSpecified(w, "劣"))
                    {
                        t.AddCondition("装甲劣化", WeaponLevel(w, "劣"), SRC.DEFAULT_LEVEL, Expression.Term("装甲", t) + "劣化");
                    }
                    else
                    {
                        t.AddCondition("装甲劣化", 10000, SRC.DEFAULT_LEVEL, Expression.Term("装甲", t) + "劣化");
                    }

                    critical_type = critical_type + " 劣化";
                    CauseEffectRet = true;
                }
            }

            // バリア中和攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "中") && !t.SpecialEffectImmune("中") && (t.IsFeatureAvailable("バリア") || t.IsFeatureAvailable("バリアシールド") || t.IsFeatureAvailable("広域バリア") || t.IsFeatureAvailable("フィールド") || t.IsFeatureAvailable("アクティブフィールド") || t.IsFeatureAvailable("広域フィールド") || t.IsFeatureAvailable("プロテクション") || t.IsFeatureAvailable("アクティプロテクション") || t.IsFeatureAvailable("広域プロテクション")))
                {
                    fname = "バリア";
                    if (t.IsFeatureAvailable("バリア") && Strings.InStr(t.FeatureData("バリア"), "バリア無効化無効") == 0)
                    {
                        fname = t.FeatureName0("バリア");
                        if (Strings.Len(fname) == 0)
                        {
                            fname = "バリア";
                        }
                    }
                    else if (t.IsFeatureAvailable("バリアシールド") && Strings.InStr(t.FeatureData("バリアシールド"), "バリア無効化無効") == 0)
                    {
                        fname = t.FeatureName0("バリアシールド");
                        if (Strings.Len(fname) == 0)
                        {
                            fname = "バリアシールド";
                        }
                    }
                    else if (t.IsFeatureAvailable("広域バリア"))
                    {
                        fname = t.FeatureName0("広域バリア");
                        if (Strings.Len(fname) == 0)
                        {
                            fname = "広域バリア";
                        }
                    }
                    else if (t.IsFeatureAvailable("フィールド") && Strings.InStr(t.FeatureData("フィールド"), "バリア無効化無効") == 0)
                    {
                        fname = t.FeatureName0("フィールド");
                        if (Strings.Len(fname) == 0)
                        {
                            fname = "フィールド";
                        }
                    }
                    else if (t.IsFeatureAvailable("アクティブフィールド") && Strings.InStr(t.FeatureData("アクティブフィールド"), "バリア無効化無効") == 0)
                    {
                        fname = t.FeatureName0("アクティブフィールド");
                        if (Strings.Len(fname) == 0)
                        {
                            fname = "アクティブフィールド";
                        }
                    }
                    else if (t.IsFeatureAvailable("広域フィールド"))
                    {
                        fname = t.FeatureName0("広域フィールド");
                        if (Strings.Len(fname) == 0)
                        {
                            fname = "広域フィールド";
                        }
                    }
                    else if (t.IsFeatureAvailable("プロテクション") && Strings.InStr(t.FeatureData("プロテクション"), "バリア無効化無効") == 0)
                    {
                        fname = t.FeatureName0("プロテクション");
                        if (Strings.Len(fname) == 0)
                        {
                            fname = "プロテクション";
                        }
                    }
                    else if (t.IsFeatureAvailable("アクティブプロテクション") && Strings.InStr(t.FeatureData("アクティブプロテクション"), "バリア無効化無効") == 0)
                    {
                        fname = t.FeatureName0("アクティブプロテクション");
                        if (Strings.Len(fname) == 0)
                        {
                            fname = "アクティブプロテクション";
                        }
                    }
                    else if (t.IsFeatureAvailable("広域プロテクション"))
                    {
                        fname = t.FeatureName0("広域プロテクション");
                        if (Strings.Len(fname) == 0)
                        {
                            fname = "広域プロテクション";
                        }
                    }

                    msg = msg + "[" + t.Nickname + "]の" + fname + "を無効化した。;";
                    if (IsWeaponLevelSpecified(w, "中"))
                    {
                        t.AddCondition("バリア無効化", WeaponLevel(w, "中"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("バリア無効化", 1, cdata: "");
                    }

                    critical_type = critical_type + " バリア中和";
                    CauseEffectRet = true;
                }
            }

            // 石化攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "石") && !t.SpecialEffectImmune("石") && t.BossRank < 0)
                {
                    msg = msg + "[" + t.Nickname + "]を石化させた。;";
                    if (IsWeaponLevelSpecified(w, "石"))
                    {
                        t.AddCondition("石化", WeaponLevel(w, "石"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("石化", 10000, cdata: "");
                    }

                    critical_type = critical_type + " 石化";
                    CauseEffectRet = true;
                }
            }

            // 凍結攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "凍") && !t.SpecialEffectImmune("凍"))
                {
                    msg = msg + "[" + t.Nickname + "]を凍らせた。;";
                    if (IsWeaponLevelSpecified(w, "凍"))
                    {
                        t.AddCondition("凍結", WeaponLevel(w, "凍"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("凍結", 3, cdata: "");
                    }

                    critical_type = critical_type + " 凍結";
                    CauseEffectRet = true;
                }
            }

            // 麻痺攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "痺") && !t.SpecialEffectImmune("痺"))
                {
                    msg = msg + "[" + t.Nickname + "]を麻痺させた。;";
                    if (IsWeaponLevelSpecified(w, "痺"))
                    {
                        t.AddCondition("麻痺", WeaponLevel(w, "痺"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("麻痺", 3, cdata: "");
                    }

                    critical_type = critical_type + " 麻痺";
                    CauseEffectRet = true;
                }
            }

            // 催眠攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "眠") && !t.SpecialEffectImmune("眠") && !(t.MainPilot().Personality == "機械"))
                {
                    msg = msg + "[" + t.MainPilot().get_Nickname(false) + "]を眠らせた。;";
                    if (IsWeaponLevelSpecified(w, "眠"))
                    {
                        t.AddCondition("睡眠", WeaponLevel(w, "眠"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("睡眠", 3, cdata: "");
                    }

                    critical_type = critical_type + " 睡眠";
                    CauseEffectRet = true;
                }
            }

            // 混乱攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "乱") && !t.SpecialEffectImmune("乱"))
                {
                    msg = msg + "[" + t.MainPilot().get_Nickname(false) + "]を混乱させた。;";
                    if (IsWeaponLevelSpecified(w, "乱"))
                    {
                        t.AddCondition("混乱", WeaponLevel(w, "乱"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("混乱", 3, cdata: "");
                    }

                    critical_type = critical_type + " 混乱";
                    CauseEffectRet = true;
                }
            }

            if (!ReferenceEquals(t, this))
            {
                // 魅了攻撃
                if (prob >= GeneralLib.Dice(100))
                {
                    if (IsWeaponClassifiedAs(w, "魅") && !t.SpecialEffectImmune("魅") && !t.IsConditionSatisfied("魅了") && !t.IsConditionSatisfied("憑依"))
                    {
                        msg = msg + MainPilot().get_Nickname(false) + "が[" + t.MainPilot().get_Nickname(false) + "]を魅了した。;";
                        if (IsWeaponLevelSpecified(w, "魅"))
                        {
                            t.AddCondition("魅了", WeaponLevel(w, "魅"), cdata: "");
                        }
                        else
                        {
                            t.AddCondition("魅了", 3, cdata: "");
                        }

                        if (t.Master is object)
                        {
                            t.Master.DeleteSlave((object)t.ID);
                        }

                        AddSlave(t);
                        t.Master = this;
                        t.Mode = MainPilot().ID;
                        SRC.PList.UpdateSupportMod(t);
                        critical_type = critical_type + " 魅了";
                        CauseEffectRet = true;
                    }
                }

                // 憑依攻撃
                if (prob >= GeneralLib.Dice(100))
                {
                    if (IsWeaponClassifiedAs(w, "憑") && !t.SpecialEffectImmune("憑") && !t.IsConditionSatisfied("憑依") && t.BossRank < 0)
                    {
                        msg = msg + MainPilot().get_Nickname(false) + "が[" + t.Nickname + "]を乗っ取った。;";
                        if (t.IsConditionSatisfied("魅了"))
                        {
                            // 憑依の方の効果を優先する
                            t.DeleteCondition("魅了");
                        }

                        if (IsWeaponLevelSpecified(w, "憑"))
                        {
                            t.AddCondition("憑依", WeaponLevel(w, "憑"), cdata: "");
                        }
                        else
                        {
                            t.AddCondition("憑依", 10000, cdata: "");
                        }

                        if (t.Master is object)
                        {
                            t.Master.DeleteSlave((object)t.ID);
                        }

                        AddSlave(t);
                        t.Master = this;
                        SRC.PList.UpdateSupportMod(t);
                        critical_type = critical_type + " 憑依";
                        CauseEffectRet = true;
                    }
                }
            }

            // 撹乱攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "撹") && !t.SpecialEffectImmune("撹"))
                {
                    msg = msg + "[" + t.Nickname + "]を撹乱した。;";
                    if (IsWeaponLevelSpecified(w, "撹"))
                    {
                        t.AddCondition("撹乱", WeaponLevel(w, "撹"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("撹乱", 2, cdata: "");
                    }

                    critical_type = critical_type + " 撹乱";
                    CauseEffectRet = true;
                }
            }

            // 恐怖攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "恐") && !t.SpecialEffectImmune("恐"))
                {
                    msg = msg + t.MainPilot().get_Nickname(false) + "は恐怖に陥った。;";
                    if (IsWeaponLevelSpecified(w, "恐"))
                    {
                        t.AddCondition("恐怖", WeaponLevel(w, "恐"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("恐怖", 3, cdata: "");
                    }

                    critical_type = critical_type + " 恐怖";
                    CauseEffectRet = true;
                }
            }

            // 目潰し攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "盲") && !t.SpecialEffectImmune("盲"))
                {
                    msg = msg + "[" + t.MainPilot().get_Nickname(false) + "]の視力を奪った。;";
                    if (IsWeaponLevelSpecified(w, "盲"))
                    {
                        t.AddCondition("盲目", WeaponLevel(w, "盲"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("盲目", 3, cdata: "");
                    }

                    critical_type = critical_type + " 盲目";
                    CauseEffectRet = true;
                }
            }

            // 毒攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "毒") && !t.SpecialEffectImmune("毒"))
                {
                    msg = msg + t.Nickname + "は毒を受けた。;";
                    if (IsWeaponLevelSpecified(w, "毒"))
                    {
                        t.AddCondition("毒", WeaponLevel(w, "毒"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("毒", 3, cdata: "");
                    }

                    critical_type = critical_type + " 毒";
                    CauseEffectRet = true;
                }
            }

            // 攻撃封印攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "不") && !t.SpecialEffectImmune("不"))
                {
                    msg = msg + "[" + t.Nickname + "]の攻撃能力を奪った。;";
                    if (IsWeaponLevelSpecified(w, "不"))
                    {
                        t.AddCondition("攻撃不能", WeaponLevel(w, "不"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("攻撃不能", 1, cdata: "");
                    }

                    critical_type = critical_type + " 攻撃不能";
                    CauseEffectRet = true;
                }
            }

            // 足止め攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "止") && !t.SpecialEffectImmune("止"))
                {
                    msg = msg + "[" + t.Nickname + "]の動きを止めた。;";
                    if ((t.Party ?? "") != (SRC.Stage ?? ""))
                    {
                        if (IsWeaponLevelSpecified(w, "止"))
                        {
                            t.AddCondition("移動不能", (WeaponLevel(w, "止") + 1d), cdata: "");
                        }
                        else
                        {
                            t.AddCondition("移動不能", 2, cdata: "");
                        }
                    }
                    else
                    {
                        if (IsWeaponLevelSpecified(w, "止"))
                        {
                            t.AddCondition("移動不能", WeaponLevel(w, "止"), cdata: "");
                        }
                        else
                        {
                            t.AddCondition("移動不能", 1, cdata: "");
                        }
                    }

                    critical_type = critical_type + " 移動不能";
                    CauseEffectRet = true;
                }
            }

            // 沈黙攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "黙") && !t.SpecialEffectImmune("黙"))
                {
                    msg = msg + "[" + t.MainPilot().get_Nickname(false) + "]を沈黙させた。;";
                    if (IsWeaponLevelSpecified(w, "黙"))
                    {
                        t.AddCondition("沈黙", WeaponLevel(w, "黙"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("沈黙", 3, cdata: "");
                    }

                    critical_type = critical_type + " 沈黙";
                    CauseEffectRet = true;
                }
            }

            // 踊らせ攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "踊") && !t.SpecialEffectImmune("踊"))
                {
                    msg = msg + "[" + t.Nickname + "]は突然踊りだした。;";
                    if (IsWeaponLevelSpecified(w, "踊"))
                    {
                        t.AddCondition("踊り", WeaponLevel(w, "踊"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("踊り", 3, cdata: "");
                    }

                    critical_type = critical_type + " 踊り";
                    CauseEffectRet = true;
                }
            }

            // 狂戦士化攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "狂") && !t.SpecialEffectImmune("狂"))
                {
                    msg = msg + "[" + t.MainPilot().get_Nickname(false) + "]は狂戦士と化した。;";
                    if (IsWeaponLevelSpecified(w, "狂"))
                    {
                        t.AddCondition("狂戦士", WeaponLevel(w, "狂"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("狂戦士", 3, cdata: "");
                    }

                    critical_type = critical_type + " 狂戦士";
                    CauseEffectRet = true;
                }
            }

            // ゾンビ化攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "ゾ") && !t.SpecialEffectImmune("ゾ"))
                {
                    msg = msg + "[" + t.Nickname + "]はゾンビと化した。;";
                    if (IsWeaponLevelSpecified(w, "ゾ"))
                    {
                        t.AddCondition("ゾンビ", WeaponLevel(w, "ゾ"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("ゾンビ", 10000, cdata: "");
                    }

                    critical_type = critical_type + " ゾンビ";
                    CauseEffectRet = true;
                }
            }

            // 回復能力阻害攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "害") && !t.SpecialEffectImmune("害"))
                {
                    msg = msg + "[" + t.Nickname + "]の自己回復能力は封じられた。;";
                    if (IsWeaponLevelSpecified(w, "害"))
                    {
                        t.AddCondition("回復不能", WeaponLevel(w, "害"), cdata: "");
                    }
                    else
                    {
                        t.AddCondition("回復不能", 10000, cdata: "");
                    }

                    critical_type = critical_type + " 回復不能";
                    CauseEffectRet = true;
                }
            }

            // 特殊効果除去攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "除") && !t.SpecialEffectImmune("除"))
                {
                    var loopTo = t.CountCondition();
                    for (i = 1; i <= loopTo; i++)
                    {
                        string localCondition() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                        string localCondition1() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                        string localCondition2() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                        string localCondition3() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                        int localConditionLifetime() { object argIndex1 = i; var ret = t.ConditionLifetime(argIndex1); return ret; }

                        if ((Strings.InStr(localCondition(), "付加") > 0 || Strings.InStr(localCondition1(), "強化") > 0 || Strings.InStr(localCondition2(), "ＵＰ") > 0) && localCondition3() != "ノーマルモード付加" && localConditionLifetime() > 0)
                        {
                            break;
                        }
                    }

                    if (i <= t.CountCondition())
                    {
                        msg = msg + "[" + t.Nickname + "]にかけられた特殊効果を打ち消した。;";
                        do
                        {
                            string localCondition4() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                            string localCondition5() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                            string localCondition6() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                            string localCondition7() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                            int localConditionLifetime1() { object argIndex1 = i; var ret = t.ConditionLifetime(argIndex1); return ret; }

                            if ((Strings.InStr(localCondition4(), "付加") > 0 || Strings.InStr(localCondition5(), "強化") > 0 || Strings.InStr(localCondition6(), "ＵＰ") > 0) && localCondition7() != "ノーマルモード付加" && localConditionLifetime1() > 0)
                            {
                                t.DeleteCondition(i);
                            }
                            else
                            {
                                i = (i + 1);
                            }
                        }
                        while (i <= t.CountCondition());
                        critical_type = critical_type + " 解除";
                        CauseEffectRet = true;
                    }
                }
            }

            // 即死攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                bool localWeakness() { string arganame = WeaponClass(w); var ret = t.Weakness(arganame); return ret; }

                bool localEffective() { string arganame = WeaponClass(w); var ret = t.Effective(arganame); return ret; }

                if (IsWeaponClassifiedAs(w, "即") && (!t.SpecialEffectImmune("即") || localWeakness() || localEffective()) && t.BossRank < 0 && (!IsUnderSpecialPowerEffect("てかげん") || this.MainPilot().Technique <= t.MainPilot().Technique) && !t.IsConditionSatisfied("不死身"))
                {
                    critical_type = critical_type + " 即死";
                    CauseEffectRet = true;
                    return CauseEffectRet;
                }
            }

            // 死の宣告
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "告") && !t.SpecialEffectImmune("告") && t.BossRank < 0)
                {
                    msg = msg + "[" + t.MainPilot().get_Nickname(false) + "]に死の宣告が下された。;";
                    if (Strings.InStr(WeaponClass(w), "告L") > 0)
                    {
                        if (WeaponLevel(w, "告") > 0d)
                        {
                            t.AddCondition("死の宣告", WeaponLevel(w, "告"), cdata: "");
                        }
                        else
                        {
                            t.HP = 1;
                        }
                    }
                    else
                    {
                        t.AddCondition("死の宣告", 1, cdata: "");
                    }

                    critical_type = critical_type + " 死の宣告";
                    CauseEffectRet = true;
                }
            }

            if (t.MainPilot().Personality != "機械")
            {
                // 気力減少攻撃
                if (prob >= GeneralLib.Dice(100))
                {
                    if (IsWeaponClassifiedAs(w, "脱") && !t.SpecialEffectImmune("脱"))
                    {
                        msg = msg + "[" + t.MainPilot().get_Nickname(false) + "]の" + Expression.Term("気力", t) + "を低下させた。;";
                        if (IsWeaponLevelSpecified(w, "脱"))
                        {
                            t.IncreaseMorale((-5 * WeaponLevel(w, "脱")));
                        }
                        else
                        {
                            t.IncreaseMorale(-10);
                        }

                        critical_type = critical_type + " 脱力";
                        CauseEffectRet = true;
                    }
                }

                // 気力吸収攻撃
                if (prob >= GeneralLib.Dice(100))
                {
                    if (IsWeaponClassifiedAs(w, "Ｄ") && !t.SpecialEffectImmune("Ｄ"))
                    {
                        msg = msg + MainPilot().get_Nickname(false) + "は[" + t.MainPilot().get_Nickname(false) + "]の" + Expression.Term("気力", t) + "を吸い取った。;";
                        if (IsWeaponLevelSpecified(w, "Ｄ"))
                        {
                            t.IncreaseMorale((-5 * WeaponLevel(w, "Ｄ")));
                            IncreaseMorale((2.5d * WeaponLevel(w, "Ｄ")));
                        }
                        else
                        {
                            t.IncreaseMorale(-10);
                            IncreaseMorale(5);
                        }

                        critical_type = critical_type + " 気力吸収";
                        CauseEffectRet = true;
                    }
                }
            }

            // 攻撃力低下攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "低攻") && !t.SpecialEffectImmune("低攻"))
                {
                    msg = msg + "[" + t.Nickname + "]の攻撃力を低下させた。;";
                    if (t.IsConditionSatisfied("攻撃力ＵＰ"))
                    {
                        t.DeleteCondition("攻撃力ＵＰ");
                    }
                    else
                    {
                        if (IsWeaponLevelSpecified(w, "低攻"))
                        {
                            t.AddCondition("攻撃力ＤＯＷＮ", WeaponLevel(w, "低攻"), cdata: "");
                        }
                        else
                        {
                            t.AddCondition("攻撃力ＤＯＷＮ", 3, cdata: "");
                        }
                    }

                    critical_type = critical_type + " 攻撃力ＤＯＷＮ";
                    CauseEffectRet = true;
                }
            }

            // 防御力低下攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "低防") && !t.SpecialEffectImmune("低防"))
                {
                    msg = msg + "[" + t.Nickname + "]の防御力を低下させた。;";
                    if (t.IsConditionSatisfied("防御力ＵＰ"))
                    {
                        t.DeleteCondition("防御力ＵＰ");
                    }
                    else
                    {
                        if (IsWeaponLevelSpecified(w, "低防"))
                        {
                            t.AddCondition("防御力ＤＯＷＮ", WeaponLevel(w, "低防"), cdata: "");
                        }
                        else
                        {
                            t.AddCondition("防御力ＤＯＷＮ", 3, cdata: "");
                        }
                    }

                    critical_type = critical_type + " 防御力ＤＯＷＮ";
                    CauseEffectRet = true;
                }
            }

            // 運動性低下攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "低運") && !t.SpecialEffectImmune("低運"))
                {
                    msg = msg + "[" + t.Nickname + "]の" + Expression.Term("運動性", t) + "を低下させた。;";
                    if (t.IsConditionSatisfied("運動性ＵＰ"))
                    {
                        t.DeleteCondition("運動性ＵＰ");
                    }
                    else
                    {
                        if (IsWeaponLevelSpecified(w, "低運"))
                        {
                            t.AddCondition("運動性ＤＯＷＮ", WeaponLevel(w, "低運"), SRC.DEFAULT_LEVEL, Expression.Term("運動性", t) + "ＤＯＷＮ");
                        }
                        else
                        {
                            t.AddCondition("運動性ＤＯＷＮ", 3, SRC.DEFAULT_LEVEL, Expression.Term("運動性", t) + "ＤＯＷＮ");
                        }
                    }

                    critical_type = critical_type + " 運動性ＤＯＷＮ";
                    CauseEffectRet = true;
                }
            }

            // 移動力低下攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "低移") && !t.SpecialEffectImmune("低移"))
                {
                    msg = msg + "[" + t.Nickname + "]の" + Expression.Term("移動力", t) + "を低下させた。;";
                    if (t.IsConditionSatisfied("移動力ＵＰ"))
                    {
                        t.DeleteCondition("移動力ＵＰ");
                    }
                    else
                    {
                        if (IsWeaponLevelSpecified(w, "低移"))
                        {
                            t.AddCondition("移動力ＤＯＷＮ", WeaponLevel(w, "低移"), SRC.DEFAULT_LEVEL, Expression.Term("移動力", t) + "ＤＯＷＮ");
                        }
                        else
                        {
                            t.AddCondition("移動力ＤＯＷＮ", 3, SRC.DEFAULT_LEVEL, Expression.Term("移動力", t) + "ＤＯＷＮ");
                        }
                    }

                    critical_type = critical_type + " 移動力ＤＯＷＮ";
                    CauseEffectRet = true;
                }
            }

            // ＨＰ減衰攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "衰") && !t.SpecialEffectImmune("衰"))
                {
                    msg = msg + "[" + t.Nickname + "]の" + Expression.Term("ＨＰ", t) + "を";
                    if (t.BossRank >= 0)
                    {
                        switch (WeaponLevel(w, "衰"))
                        {
                            case 1:
                                {
                                    t.HP = t.HP * 7 / 8;
                                    msg = msg + "12.5%";
                                    break;
                                }

                            case 2:
                                {
                                    t.HP = t.HP * 3 / 4;
                                    msg = msg + "25%";
                                    break;
                                }

                            case 3:
                                {
                                    t.HP = t.HP / 2;
                                    msg = msg + "50%";
                                    break;
                                }
                        }
                    }
                    else
                    {
                        switch (WeaponLevel(w, "衰"))
                        {
                            case 1:
                                {
                                    t.HP = t.HP * 3 / 4;
                                    msg = msg + "25%";
                                    break;
                                }

                            case 2:
                                {
                                    t.HP = t.HP / 2;
                                    msg = msg + "50%";
                                    break;
                                }

                            case 3:
                                {
                                    t.HP = t.HP / 4;
                                    msg = msg + "75%";
                                    break;
                                }
                        }
                    }

                    msg = msg + "減少させた。;";
                    critical_type = critical_type + " 減衰";
                    CauseEffectRet = true;
                }
            }

            // ＥＮ減衰攻撃
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "滅") && !t.SpecialEffectImmune("滅"))
                {
                    msg = msg + "[" + t.Nickname + "]の" + Expression.Term("ＥＮ", t) + "を";
                    if (t.BossRank >= 0)
                    {
                        switch (WeaponLevel(w, "滅"))
                        {
                            case 1:
                                {
                                    t.EN = t.EN * 7 / 8;
                                    msg = msg + "12.5%";
                                    break;
                                }

                            case 2:
                                {
                                    t.EN = t.EN * 3 / 4;
                                    msg = msg + "25%";
                                    break;
                                }

                            case 3:
                                {
                                    t.EN = t.EN / 2;
                                    msg = msg + "50%";
                                    break;
                                }
                        }
                    }
                    else
                    {
                        switch (WeaponLevel(w, "滅"))
                        {
                            case 1:
                                {
                                    t.EN = t.EN * 3 / 4;
                                    msg = msg + "25%";
                                    break;
                                }

                            case 2:
                                {
                                    t.EN = t.EN / 2;
                                    msg = msg + "50%";
                                    break;
                                }

                            case 3:
                                {
                                    t.EN = t.EN / 4;
                                    msg = msg + "75%";
                                    break;
                                }
                        }
                    }

                    msg = msg + "減少させた。;";
                    critical_type = critical_type + " 減衰";
                    CauseEffectRet = true;
                }
            }

            // 弱点付加属性（弱が存在するだけループ）
            i = GeneralLib.InStrNotNest(strWeaponClass[w], "弱");
            while (i > 0)
            {
                ch = Strings.Mid(GeneralLib.GetClassBundle(strWeaponClass[w], i), 2);
                if (prob >= GeneralLib.Dice(100))
                {
                    if (!t.SpecialEffectImmune(ch))
                    {
                        msg = msg + "[" + t.Nickname + "]は[" + ch + "]属性に弱くなった。;";
                        if (IsWeaponLevelSpecified(w, "弱" + ch))
                        {
                            double localWeaponLevel() { string argattr = "弱" + ch; var ret = WeaponLevel(w, argattr); return ret; }

                            t.AddCondition(ch + "属性弱点付加", localWeaponLevel(), cdata: "");
                        }
                        else
                        {
                            t.AddCondition(ch + "属性弱点付加", 3, cdata: "");
                        }

                        critical_type = critical_type + " " + ch + "属性弱点付加";
                        CauseEffectRet = true;
                    }
                }

                i = GeneralLib.InStrNotNest(strWeaponClass[w], "弱", (i + 1));
            }

            // 有効付加属性
            i = GeneralLib.InStrNotNest(strWeaponClass[w], "効");
            while (i > 0)
            {
                ch = Strings.Mid(GeneralLib.GetClassBundle(strWeaponClass[w], i), 2);
                if (prob >= GeneralLib.Dice(100))
                {
                    // 既に相手が指定属性を弱点として持っている場合無効
                    if (!t.Weakness(ch) && !t.SpecialEffectImmune(ch))
                    {
                        msg = msg + "[" + t.Nickname + "]に[" + ch + "]属性が有効になった。;";
                        if (IsWeaponLevelSpecified(w, "効" + ch))
                        {
                            double localWeaponLevel1() { string argattr = "効" + ch; var ret = WeaponLevel(w, argattr); return ret; }

                            t.AddCondition(ch + "属性有効付加", localWeaponLevel1(), cdata: "");
                        }
                        else
                        {
                            t.AddCondition(ch + "属性有効付加", 3, cdata: "");
                        }

                        critical_type = critical_type + " " + ch + "属性有効付加";
                        CauseEffectRet = true;
                    }
                }

                i = GeneralLib.InStrNotNest(strWeaponClass[w], "効", (i + 1));
            }

            // 属性使用禁止攻撃
            i = GeneralLib.InStrNotNest(strWeaponClass[w], "剋");
            while (i > 0)
            {
                ch = Strings.Mid(GeneralLib.GetClassBundle(strWeaponClass[w], i), 2);
                if (prob >= GeneralLib.Dice(100))
                {
                    if (!t.SpecialEffectImmune(ch))
                    {
                        Skill = new string[1];
                        switch (ch ?? "")
                        {
                            case "オ":
                                {
                                    Skill[0] = "オーラ";
                                    break;
                                }

                            case "超":
                                {
                                    Skill[0] = "超能力";
                                    break;
                                }

                            case "シ":
                                {
                                    Skill[0] = "同調率";
                                    break;
                                }

                            case "サ":
                                {
                                    if (t.MainPilot().IsSkillAvailable("超感覚") && t.MainPilot(Conversions.ToBoolean(0)).IsSkillAvailable("知覚強化"))
                                    {
                                        Skill = new string[2];
                                        Skill[0] = "超感覚";
                                        Skill[1] = "知覚強化";
                                    }
                                    else if (t.MainPilot().IsSkillAvailable("超感覚"))
                                    {
                                        Skill[0] = "超感覚";
                                    }
                                    else if (t.MainPilot().IsSkillAvailable("知覚強化"))
                                    {
                                        Skill[0] = "知覚強化";
                                    }
                                    else
                                    {
                                        Skill = new string[2];
                                        Skill[0] = "超感覚";
                                        Skill[1] = "知覚強化";
                                    }

                                    break;
                                }

                            case "霊":
                                {
                                    Skill[0] = "霊力";
                                    break;
                                }

                            case "術":
                                {
                                    Skill[0] = "術";
                                    break;
                                }

                            case "技":
                                {
                                    Skill[0] = "技";
                                    break;
                                }

                            default:
                                {
                                    Skill[0] = "";
                                    break;
                                }
                        }

                        var loopTo1 = Information.UBound(Skill);
                        for (j = 0; j <= loopTo1; j++)
                        {
                            if (Strings.Len(Skill[j]) > 0)
                            {
                                var tmp = Skill;
                                fname = t.MainPilot().SkillName0(tmp[j]);
                                if (fname == "非表示")
                                {
                                    fname = Skill[j];
                                }
                            }
                            else
                            {
                                Skill[0] = ch + "属性";
                                fname = ch + "属性";
                            }

                            msg = msg + "[" + t.Nickname + "]は" + fname + "が使用出来なくなった。;";
                            if (IsWeaponLevelSpecified(w, "剋" + ch))
                            {
                                double localWeaponLevel2() { string argattr = "剋" + ch; var ret = WeaponLevel(w, argattr); return ret; }

                                t.AddCondition(Skill[j] + "使用不能", localWeaponLevel2(), cdata: "");
                            }
                            else
                            {
                                t.AddCondition(Skill[j] + "使用不能", 3, cdata: "");
                            }

                            critical_type = critical_type + " " + Skill[j] + "使用不能";
                        }

                        CauseEffectRet = true;
                    }
                }

                i = GeneralLib.InStrNotNest(strWeaponClass[w], "剋", (i + 1));
            }

            SkipNormalEffect:
            ;


            // これ以降の効果は敵が破壊される場合も発動する

            // 盗み
            int prev_money;
            string iname;
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "盗") && !t.SpecialEffectImmune("盗") && !t.IsConditionSatisfied("すかんぴん") && (Party == "味方" && t.Party0 != "味方" || Party != "味方" && t.Party0 == "味方"))
                {
                    if (t.Party0 == "味方")
                    {
                        // 味方の場合は必ず資金が減少する
                        prev_money = SRC.Money;
                        SRC.IncrMoney(-t.Value / 2);
                        if (this.Weapon(w).Power > 0)
                        {
                            msg = msg + "[" + t.Nickname + "]は" + Expression.Term("資金", t) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_money - SRC.Money) + "を奪い取られた。;";
                        }
                        else
                        {
                            msg = msg + "[" + t.Nickname + "]は" + Expression.Term("資金", t) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_money - SRC.Money) + "を盗まれた。;";
                        }

                        critical_type = critical_type + " 盗み";
                        CauseEffectRet = true;
                    }
                    else if (GeneralLib.Dice(8) == 1 && t.IsFeatureAvailable("レアアイテム所有"))
                    {
                        // レアアイテムを盗んだ場合
                        iname = t.FeatureData("レアアイテム所有");
                        if (SRC.IDList.IsDefined(iname))
                        {
                            SRC.IList.Add(iname);
                            if (this.Weapon(w).Power > 0)
                            {
                                ItemData localItem() { object argIndex1 = iname; var ret = SRC.IDList.Item(argIndex1); return ret; }

                                msg = msg + "[" + t.Nickname + "]から" + localItem().Nickname + "を奪い取った。;";
                            }
                            else
                            {
                                ItemData localItem1() { object argIndex1 = iname; var ret = SRC.IDList.Item(argIndex1); return ret; }

                                msg = msg + "[" + t.Nickname + "]から" + localItem1().Nickname + "を盗んだ。;";
                            }
                        }
                        else
                        {
                            GUI.ErrorMessage(t.Name + "の所有アイテム「" + iname + "」のデータが見つかりません");
                        }

                        critical_type = critical_type + " 盗み";
                        CauseEffectRet = true;
                    }
                    else if (t.IsFeatureAvailable("アイテム所有"))
                    {
                        // アイテムを盗んだ場合
                        iname = t.FeatureData("アイテム所有");
                        if (SRC.IDList.IsDefined(iname))
                        {
                            SRC.IList.Add(iname);
                            if (this.Weapon(w).Power > 0)
                            {
                                ItemData localItem2() { object argIndex1 = iname; var ret = SRC.IDList.Item(argIndex1); return ret; }

                                msg = msg + "[" + t.Nickname + "]から" + localItem2().Nickname + "を奪い取った。;";
                            }
                            else
                            {
                                ItemData localItem3() { object argIndex1 = iname; var ret = SRC.IDList.Item(argIndex1); return ret; }

                                msg = msg + "[" + t.Nickname + "]から" + localItem3().Nickname + "を盗んだ。;";
                            }
                        }
                        else
                        {
                            GUI.ErrorMessage(t.Name + "の所有アイテム「" + iname + "」のデータが見つかりません");
                        }

                        critical_type = critical_type + " 盗み";
                        CauseEffectRet = true;
                    }
                    else if (t.Value > 0)
                    {
                        // 資金を盗んだ場合
                        SRC.IncrMoney(t.Value / 4);
                        if (this.Weapon(w).Power > 0)
                        {
                            msg = msg + "[" + t.Nickname + "]から" + Expression.Term("資金", t) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(t.Value / 4) + "を奪い取った。;";
                        }
                        else
                        {
                            msg = msg + "[" + t.Nickname + "]から" + Expression.Term("資金", t) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(t.Value / 4) + "を盗んだ。;";
                        }

                        critical_type = critical_type + " 盗み";
                        CauseEffectRet = true;
                    }

                    // 一度盗んだユニットからは再度盗むことは出来ない
                    if (t.Party0 != "味方")
                    {
                        t.AddCondition("すかんぴん", -1, 0d, "非表示");
                    }
                }
            }

            // ラーニング
            string sname, stype, vname;
            if (prob >= GeneralLib.Dice(100))
            {
                if (IsWeaponClassifiedAs(w, "習") && t.IsFeatureAvailable("ラーニング可能技") && Party0 == "味方")
                {
                    stype = GeneralLib.LIndex(t.FeatureData("ラーニング可能技"), 1);
                    switch (GeneralLib.LIndex(t.FeatureData("ラーニング可能技"), 2) ?? "")
                    {
                        case "表示":
                        case var @case when @case == "":
                            {
                                sname = stype;
                                break;
                            }

                        default:
                            {
                                sname = GeneralLib.LIndex(t.FeatureData("ラーニング可能技"), 2);
                                break;
                            }
                    }

                    if (!MainPilot().IsSkillAvailable(stype))
                    {
                        msg = msg + "[" + MainPilot().get_Nickname(false) + "]は「" + sname + "」を習得した。;";
                        vname = "Ability(" + MainPilot().ID + ")";
                        if (!Expression.IsGlobalVariableDefined(vname))
                        {
                            Expression.DefineGlobalVariable(vname);
                            // UPGRADE_WARNING: オブジェクト GlobalVariableList.Item().StringValue の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                            Event.GlobalVariableList[vname].StringValue = stype;
                        }
                        else
                        {
                            {
                                var withBlock = Event.GlobalVariableList[vname];
                                // UPGRADE_WARNING: オブジェクト GlobalVariableList.Item(vname).StringValue の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                                // UPGRADE_WARNING: オブジェクト GlobalVariableList.Item().StringValue の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                                withBlock.StringValue = Operators.ConcatenateObject(Operators.ConcatenateObject(withBlock.StringValue, " "), stype);
                            }
                        }

                        vname = "Ability(" + MainPilot().ID + "," + stype + ")";
                        if (!Expression.IsGlobalVariableDefined(vname))
                        {
                            Expression.DefineGlobalVariable(vname);
                        }

                        if (GeneralLib.LLength(t.FeatureData("ラーニング可能技")) == 1)
                        {
                            Expression.SetVariableAsString(vname, "-1 非表示");
                        }
                        else if ((stype ?? "") != (sname ?? ""))
                        {
                            Expression.SetVariableAsString(vname, "-1 " + sname);
                        }
                        else
                        {
                            Expression.SetVariableAsString(vname, "-1");
                        }

                        critical_type = critical_type + " ラーニング";
                        CauseEffectRet = true;
                    }
                }
            }

            return CauseEffectRet;
        }

        // 吹き飛ばしチェック
        public bool CheckBlowAttack(int w, Unit t, int dmg, string msg, string attack_mode, string def_mode, string critical_type)
        {
            bool CheckBlowAttackRet = default;
            int tx, ty;
            int sx, sy;
            int nx, ny;
            int dx = default, dy = default;
            var is_crashed = default(bool);
            var t2 = default(Unit);
            int dmg2, orig_dmg;
            int wlevel;
            int i, prob;
            var is_critical = default(bool);
            TerrainData td;

            // 特殊効果無効？
            if (IsWeaponClassifiedAs(w, "吹") && t.SpecialEffectImmune("吹"))
            {
                return CheckBlowAttackRet;
            }

            if (IsWeaponClassifiedAs(w, "Ｋ") && t.SpecialEffectImmune("Ｋ"))
            {
                return CheckBlowAttackRet;
            }

            wlevel = GeneralLib.MaxLng(WeaponLevel(w, "吹"), WeaponLevel(w, "Ｋ"));

            // 特殊効果発生確率
            if (IsUnderSpecialPowerEffect("特殊効果発動"))
            {
                prob = 100;
            }
            else
            {
                prob = CriticalProbability(w, t, def_mode);
            }

            // 吹き飛ばし距離の算出
            if (prob >= GeneralLib.Dice(100))
            {
                wlevel = (wlevel + 1);
                is_critical = true;
            }

            // 吹き飛ばし距離が０であればここで終わり
            if (wlevel == 0)
            {
                return CheckBlowAttackRet;
            }

            // サイズによる制限
            if (t.Size == "XL")
            {
                return CheckBlowAttackRet;
            }

            if (IsWeaponClassifiedAs(w, "Ｋ"))
            {
                switch (Size ?? "")
                {
                    case "SS":
                        {
                            if (t.Size != "SS" && t.Size != "S")
                            {
                                return CheckBlowAttackRet;
                            }

                            break;
                        }

                    case "S":
                        {
                            if (t.Size == "L" || t.Size == "LL")
                            {
                                return CheckBlowAttackRet;
                            }

                            break;
                        }

                    case "M":
                        {
                            if (t.Size == "LL")
                            {
                                return CheckBlowAttackRet;
                            }

                            break;
                        }
                }
            }

            // 固定物は動かせない
            if (t.IsFeatureAvailable("地形ユニット"))
            {
                return CheckBlowAttackRet;
            }

            if (t.Data.Speed == 0 && t.Speed == 0)
            {
                return CheckBlowAttackRet;
            }

            // 自分自身は吹き飛ばせない
            if (ReferenceEquals(t, this))
            {
                return CheckBlowAttackRet;
            }

            // 吹き飛ばしの中心座標を設定
            if (WeaponLevel(w, "Ｍ投") > 0d)
            {
                sx = Commands.SelectedX;
                sy = Commands.SelectedY;
            }
            else
            {
                sx = x;
                sy = y;
            }

            // 吹き飛ばされる場所を設定
            tx = t.x;
            ty = t.y;
            if (!IsWeaponClassifiedAs(w, "Ｍ移"))
            {
                if (Math.Abs((sx - tx)) > Math.Abs((sy - ty)))
                {
                    if (sx > tx)
                    {
                        dx = -1;
                    }
                    else
                    {
                        dx = 1;
                    }
                }
                else if (Math.Abs((sx - tx)) < Math.Abs((sy - ty)))
                {
                    if (sy > ty)
                    {
                        dy = -1;
                    }
                    else
                    {
                        dy = 1;
                    }
                }
                else if (GeneralLib.Dice(2) == 1)
                {
                    if (sx > tx)
                    {
                        dx = -1;
                    }
                    else
                    {
                        dx = 1;
                    }
                }
                else if (sy > ty)
                {
                    dy = -1;
                }
                else
                {
                    dy = 1;
                }
            }
            // Ｍ移の場合は横に弾き飛ばす形になる
            else if (Math.Abs((sx - tx)) > Math.Abs((sy - ty)))
            {
                if (GeneralLib.Dice(2) == 1)
                {
                    dy = 1;
                }
                else
                {
                    dy = -1;
                }
            }
            else if (Math.Abs((sx - tx)) < Math.Abs((sy - ty)))
            {
                if (GeneralLib.Dice(2) == 1)
                {
                    dx = 1;
                }
                else
                {
                    dx = -1;
                }
            }
            else if (sx == tx && sx == ty)
            {
                switch (GeneralLib.Dice(4))
                {
                    case 1:
                        {
                            dx = -1;
                            break;
                        }

                    case 2:
                        {
                            dx = 1;
                            break;
                        }

                    case 3:
                        {
                            dy = -1;
                            break;
                        }

                    case 4:
                        {
                            dy = 1;
                            break;
                        }
                }
            }
            else if (GeneralLib.Dice(2) == 1)
            {
                if (sx > tx)
                {
                    dx = 1;
                }
                else
                {
                    dx = -1;
                }
            }
            else if (sy > ty)
            {
                dy = 1;
            }
            else
            {
                dy = -1;
            }

            // 吹き飛ばし後の位置の計算と、衝突の判定
            nx = tx;
            ny = ty;
            i = 1;
            while (i <= wlevel)
            {
                nx = (nx + dx);
                ny = (ny + dy);

                // 吹き飛ばしコストに地形効果【摩擦】の補正を加える
                // MOD START 240a
                // Set td = TDList.Item(MapData(X, Y, 0))
                switch (Map.MapData[x, y, Map.MapDataIndex.BoxType])
                {
                    case Map.BoxTypes.Under:
                    case Map.BoxTypes.UpperBmpOnly:
                        {
                            td = SRC.TDList.Item(Map.MapData[x, y, Map.MapDataIndex.TerrainType]);
                            break;
                        }

                    default:
                        {
                            td = SRC.TDList.Item(Map.MapData[x, y, Map.MapDataIndex.LayerType]);
                            break;
                        }
                }
                // MOD START 240a
                if (t.Area == "地上" && (td.Class == "陸" || td.Class == "屋内" || td.Class == "月面") || t.Area == "水中" && (td.Class == "水" || td.Class == "深水") || (t.Area ?? "") == (Class ?? ""))
                {
                    if (td.IsFeatureAvailable("摩擦"))
                    {
                        i = (i + td.FeatureLevel("摩擦"));
                    }
                }

                // マップ端
                if (nx < 1 || Map.MapWidth < nx || ny < 1 || Map.MapHeight < ny)
                {
                    nx = (nx - dx);
                    ny = (ny - dy);
                    break;
                }

                // 進入不能？
                if (!t.IsAbleToEnter(nx, ny) || Map.MapDataForUnit[nx, ny] is object)
                {
                    is_crashed = true;
                    if (Map.MapDataForUnit[nx, ny] is object)
                    {
                        t2 = Map.MapDataForUnit[nx, ny];
                    }

                    nx = (nx - dx);
                    ny = (ny - dy);
                    break;
                }

                // 障害物あり？
                if (t.Area != "空中")
                {
                    if (Map.TerrainHasObstacle(nx, ny))
                    {
                        is_crashed = true;
                    }
                }

                i = (i + 1);
            }

            // ユニットを強制移動
            if (tx != nx || ty != ny)
            {
                GUI.EraseUnitBitmap(tx, ty);
                if (IsAnimationDefined("吹き飛ばし", sub_situation: ""))
                {
                    PlayAnimation("吹き飛ばし", sub_situation: "");
                }
                else
                {
                    GUI.MoveUnitBitmap(t, tx, ty, nx, ny, 20);
                }

                t.Jump(nx, ny, false);
            }

            // 激突
            orig_dmg = dmg;
            if (is_crashed)
            {
                dmg = orig_dmg + GeneralLib.MaxLng((orig_dmg - t.get_Armor("") * t.MainPilot().Morale / 100) / 2, 0);

                // 最低ダメージ
                if (def_mode == "防御")
                {
                    dmg = GeneralLib.MaxLng(dmg, 5);
                }
                else
                {
                    dmg = GeneralLib.MaxLng(dmg, 10);
                }

                Sound.PlayWave("Crash.wav");
            }

            // 巻き添え
            if (t2 is object && !ReferenceEquals(t2, t))
            {
                dmg2 = (orig_dmg - t2.get_Armor("") * t2.MainPilot().Morale / 100) / 2;

                // 最低ダメージ
                if (dmg2 < 10)
                {
                    dmg2 = 10;
                }

                // 無敵の場合はダメージを受けない
                if (t2.IsConditionSatisfied("無敵"))
                {
                    dmg2 = 0;
                }

                // 各種処理がややこしくなるので巻き添えではユニットを破壊しない
                if (t2.HP - dmg2 < 10)
                {
                    dmg2 = t2.HP - 10;
                }

                // ダメージ適用
                if (dmg2 > 0)
                {
                    t2.HP = t2.HP - dmg2;
                }
                else
                {
                    dmg2 = 0;
                }

                // ダメージ量表示
                if (!Expression.IsOptionDefined("ダメージ表示無効") || attack_mode == "マップ攻撃")
                {
                    GUI.DrawSysString(t2.x, t2.y, Microsoft.VisualBasic.Compatibility.VB6.Support.Format(dmg2), true);
                }

                // 特殊能力「不安定」による暴走チェック
                if (t2.IsFeatureAvailable("不安定"))
                {
                    if (t2.HP <= t2.MaxHP / 4 && !t2.IsConditionSatisfied("暴走"))
                    {
                        t2.AddCondition("暴走", -1, cdata: "");
                        t2.Update();
                    }
                }

                // ダメージを受ければ眠りからさめる
                if (t2.IsConditionSatisfied("睡眠") && !IsWeaponClassifiedAs(w, "眠"))
                {
                    t2.DeleteCondition("睡眠");
                }
            }

            msg = t.Nickname + "を吹き飛ばした。;" + msg;
            if (is_critical)
            {
                msg = "クリティカル！ " + msg;
            }

            // 吹き飛ばしが発生したことを伝える
            critical_type = critical_type + " 吹き飛ばし";
            CheckBlowAttackRet = true;
            return CheckBlowAttackRet;
        }

        // 引き寄せチェック
        public bool CheckDrawAttack(int w, Unit t, string msg, string def_mode, string critical_type)
        {
            bool CheckDrawAttackRet = default;
            int tx = default, ty = default;
            int sx, sy;
            int nx, ny;
            int prob;

            // 特殊効果無効？
            if (t.SpecialEffectImmune("引"))
            {
                return CheckDrawAttackRet;
            }

            // 既に隣接している？
            if (Math.Abs((x - tx)) + Math.Abs((y - ty)) == 1)
            {
                return CheckDrawAttackRet;
            }

            // サイズによる制限
            if (t.Size == "XL")
            {
                return CheckDrawAttackRet;
            }

            // 固定物は動かせない
            if (t.IsFeatureAvailable("地形ユニット"))
            {
                return CheckDrawAttackRet;
            }

            if (t.Data.Speed == 0 && t.Speed == 0)
            {
                return CheckDrawAttackRet;
            }

            // 自分自身は引き寄せない
            if (ReferenceEquals(t, this))
            {
                return CheckDrawAttackRet;
            }

            // 特殊効果発生確率
            if (IsUnderSpecialPowerEffect("特殊効果発動"))
            {
                prob = 100;
            }
            else
            {
                prob = CriticalProbability(w, t, def_mode);
            }

            // 引き寄せ発生？
            if (GeneralLib.Dice(100) > prob)
            {
                return CheckDrawAttackRet;
            }

            // 引き寄せの中心座標を設定
            if (WeaponLevel(w, "Ｍ投") > 0d)
            {
                sx = Commands.SelectedX;
                sy = Commands.SelectedY;
            }
            else
            {
                sx = x;
                sy = y;
            }

            // ターゲットの座標
            tx = t.x;
            ty = t.y;

            // 既に引き寄せの中心位置にいる？
            if (sx == tx && sy == ty)
            {
                return CheckDrawAttackRet;
            }

            // 引き寄せられる場所を設定
            if (Map.MapDataForUnit[sx, sy] is null)
            {
                nx = sx;
                ny = sy;
            }
            else if (Math.Abs((sx - tx)) > Math.Abs((sy - ty)))
            {
                if (sx > tx)
                {
                    nx = (sx - 1);
                }
                else
                {
                    nx = (sx + 1);
                }

                ny = y;
                if (Map.MapDataForUnit[nx, ny] is object)
                {
                    if (sy != ty)
                    {
                        if (sy > ty)
                        {
                            if (Map.MapDataForUnit[sx, sy - 1] is null)
                            {
                                nx = sx;
                                ny = (sy - 1);
                            }
                            else if (Map.MapDataForUnit[nx, sy - 1] is null)
                            {
                                ny = (sy - 1);
                            }
                        }
                        else if (Map.MapDataForUnit[sx, sy + 1] is null)
                        {
                            nx = sx;
                            ny = (sy + 1);
                        }
                        else if (Map.MapDataForUnit[nx, sy + 1] is null)
                        {
                            ny = (sy + 1);
                        }
                    }
                }
            }
            else if (Math.Abs((sx - tx)) < Math.Abs((sy - ty)))
            {
                nx = sx;
                if (sy > ty)
                {
                    ny = (sy - 1);
                }
                else
                {
                    ny = (sy + 1);
                }

                if (Map.MapDataForUnit[nx, ny] is object)
                {
                    if (sx != tx)
                    {
                        if (sx > tx)
                        {
                            if (Map.MapDataForUnit[sx - 1, sy] is null)
                            {
                                nx = (sx - 1);
                                ny = sy;
                            }
                            else if (Map.MapDataForUnit[sx - 1, ny] is null)
                            {
                                nx = (sx - 1);
                            }
                        }
                        else if (Map.MapDataForUnit[sx + 1, sy] is null)
                        {
                            nx = (sx + 1);
                            ny = sy;
                        }
                        else if (Map.MapDataForUnit[sx + 1, ny] is null)
                        {
                            nx = (sx + 1);
                        }
                    }
                }
            }
            else
            {
                if (GeneralLib.Dice(2) == 1)
                {
                    if (sx > tx)
                    {
                        nx = (sx - 1);
                    }
                    else
                    {
                        nx = (sx + 1);
                    }

                    ny = sy;
                    if (Map.MapDataForUnit[nx, ny] is object)
                    {
                        nx = sx;
                        if (sy > ty)
                        {
                            ny = (sy - 1);
                        }
                        else
                        {
                            ny = (sy + 1);
                        }
                    }
                }
                else
                {
                    nx = sx;
                    if (sy > ty)
                    {
                        ny = (sy - 1);
                    }
                    else
                    {
                        ny = (sy + 1);
                    }

                    if (Map.MapDataForUnit[nx, ny] is object)
                    {
                        if (sx > tx)
                        {
                            nx = (sx - 1);
                        }
                        else
                        {
                            nx = (sx + 1);
                        }

                        ny = sy;
                    }
                }

                if (Map.MapDataForUnit[nx, ny] is object)
                {
                    if (sx > tx)
                    {
                        nx = (sx - 1);
                    }
                    else
                    {
                        nx = (sx + 1);
                    }

                    if (sy > ty)
                    {
                        ny = (sy - 1);
                    }
                    else
                    {
                        ny = (sy + 1);
                    }
                }
            }

            // 結局動いてない？
            if (nx == tx && ny == ty)
            {
                return CheckDrawAttackRet;
            }

            // ユニットを強制移動
            t.Jump(nx, ny);

            // 本当に動いた？
            if (t.x == tx && t.y == ty)
            {
                return CheckDrawAttackRet;
            }

            msg = t.Nickname + "を引き寄せた。;" + msg;

            // 引き寄せが発生したことを伝える
            critical_type = critical_type + " 引き寄せ";
            CheckDrawAttackRet = true;
            return CheckDrawAttackRet;
        }

        // 強制転移チェック
        public bool CheckTeleportAwayAttack(int w, Unit t, string msg, string def_mode, string critical_type)
        {
            bool CheckTeleportAwayAttackRet = default;
            int tx, ty;
            int nx = default, ny = default;
            int d, prob, i;

            // 特殊効果無効？
            if (t.SpecialEffectImmune("転"))
            {
                return CheckTeleportAwayAttackRet;
            }

            // サイズによる制限
            if (t.Size == "XL")
            {
                return CheckTeleportAwayAttackRet;
            }

            // 固定物は動かせない
            if (t.IsFeatureAvailable("地形ユニット"))
            {
                return CheckTeleportAwayAttackRet;
            }

            if (t.Data.Speed == 0 && t.Speed == 0)
            {
                return CheckTeleportAwayAttackRet;
            }

            // 自分自身は強制転移出来ない
            if (ReferenceEquals(t, this))
            {
                return CheckTeleportAwayAttackRet;
            }

            // 特殊効果発生確率
            if (IsUnderSpecialPowerEffect("特殊効果発動"))
            {
                prob = 100;
            }
            else
            {
                prob = CriticalProbability(w, t, def_mode);
            }

            // 強制転移発生？
            if (GeneralLib.Dice(100) > prob)
            {
                return CheckTeleportAwayAttackRet;
            }

            // 強制転移先を設定
            tx = t.x;
            ty = t.y;
            for (i = 1; i <= 10; i++)
            {
                d = GeneralLib.Dice(WeaponLevel(w, "転"));
                if (GeneralLib.Dice(2) == 1)
                {
                    nx = (tx + d);
                }
                else
                {
                    nx = (tx - d);
                }

                d = (WeaponLevel(w, "転") - d);
                if (GeneralLib.Dice(2) == 1)
                {
                    ny = (ty + d);
                }
                else
                {
                    ny = (ty - d);
                }

                if (1 <= nx && nx <= Map.MapWidth && 1 <= ny && ny <= Map.MapHeight)
                {
                    break;
                }
            }

            // 転院先がない？
            if (i > 10)
            {
                return CheckTeleportAwayAttackRet;
            }

            // ユニットを強制移動
            t.Jump(nx, ny);

            // 本当に動いた？
            if (t.x == tx && t.y == ty)
            {
                return CheckTeleportAwayAttackRet;
            }

            msg = t.Nickname + "をテレポートさせた。;" + msg;

            // 強制転移が発生したことを伝える
            critical_type = critical_type + " 強制転移";
            CheckTeleportAwayAttackRet = true;
            return CheckTeleportAwayAttackRet;
        }

        // 能力コピーチェック
        public bool CheckMetamorphAttack(int w, Unit t, string def_mode)
        {
            bool CheckMetamorphAttackRet = default;
            int prob, wlv;
            string uname;

            // 既にコピー済み？
            if (IsFeatureAvailable("ノーマルモード"))
            {
                return CheckMetamorphAttackRet;
            }

            // 特殊効果無効？
            if (t.SpecialEffectImmune("写"))
            {
                return CheckMetamorphAttackRet;
            }

            // ボスユニットはコピー出来ない
            if (t.BossRank >= 0)
            {
                return CheckMetamorphAttackRet;
            }

            // 自分自身はコピー出来ない
            if (ReferenceEquals(t, this))
            {
                return CheckMetamorphAttackRet;
            }

            // サイズ制限
            if (IsWeaponClassifiedAs(w, "写"))
            {
                switch (Size ?? "")
                {
                    case "SS":
                        {
                            switch (t.Size ?? "")
                            {
                                case "M":
                                case "L":
                                case "LL":
                                case "XL":
                                    {
                                        return CheckMetamorphAttackRet;
                                    }
                            }

                            break;
                        }

                    case "S":
                        {
                            switch (t.Size ?? "")
                            {
                                case "L":
                                case "LL":
                                case "XL":
                                    {
                                        return CheckMetamorphAttackRet;
                                    }
                            }

                            break;
                        }

                    case "M":
                        {
                            switch (t.Size ?? "")
                            {
                                case "SS":
                                case "LL":
                                case "XL":
                                    {
                                        return CheckMetamorphAttackRet;
                                    }
                            }

                            break;
                        }

                    case "L":
                        {
                            switch (t.Size ?? "")
                            {
                                case "SS":
                                case "S":
                                case "XL":
                                    {
                                        return CheckMetamorphAttackRet;
                                    }
                            }

                            break;
                        }

                    case "LL":
                        {
                            switch (t.Size ?? "")
                            {
                                case "SS":
                                case "S":
                                case "M":
                                    {
                                        return CheckMetamorphAttackRet;
                                    }
                            }

                            break;
                        }

                    case "XL":
                        {
                            switch (t.Size ?? "")
                            {
                                case "SS":
                                case "S":
                                case "M":
                                case "L":
                                    {
                                        return CheckMetamorphAttackRet;
                                    }
                            }

                            break;
                        }
                }
            }

            // 特殊効果発生確率
            if (IsUnderSpecialPowerEffect("特殊効果発動"))
            {
                prob = 100;
            }
            else
            {
                prob = CriticalProbability(w, t, def_mode);
            }

            // コピー成功？
            if (GeneralLib.Dice(100) > prob)
            {
                return CheckMetamorphAttackRet;
            }

            // コピーしてしまうとその場にいれなくなってしまう？
            Unit localOtherForm() { object argIndex1 = t.Name; var ret = OtherForm(argIndex1); t.Name = Conversions.ToString(argIndex1); return ret; }

            if (!localOtherForm().IsAbleToEnter(x, y))
            {
                return CheckMetamorphAttackRet;
            }

            // 変身前に情報を記録しておく
            uname = Nickname;
            wlv = GeneralLib.MaxLng(WeaponLevel(w, "写"), WeaponLevel(w, "化"));

            // 変身
            Transform(t.Name);
            t.Name = argnew_form;
            {
                var withBlock = CurrentForm();
                // 元に戻れるように設定
                if (wlv > 0)
                {
                    withBlock.AddCondition("残り時間", wlv, cdata: "");
                }

                withBlock.AddCondition("ノーマルモード付加", -1, 1d, Name + " 手動解除可");
                withBlock.AddCondition("能力コピー", -1, cdata: "");

                // コピー元のパイロット画像とメッセージを使うように設定
                withBlock.AddCondition("パイロット画像", -1, 0d, "非表示 " + t.MainPilot().get_Bitmap(false));
                withBlock.AddCondition("メッセージ", -1, 0d, "非表示 " + t.MainPilot().MessageType);
            }

            GUI.DisplaySysMessage(uname + "は" + t.Nickname + "に変身した。");

            // 能力コピーが発生したことを伝える
            CheckMetamorphAttackRet = true;
            return CheckMetamorphAttackRet;
        }

        // 特殊能力 fdata1 と fdata2 が同じ名称か判定
        // 「中和」「相殺」用
        private bool IsSameCategory(string fdata1, string fdata2)
        {
            bool IsSameCategoryRet = default;
            string fc1, fc2;
            fc1 = GeneralLib.LIndex(fdata1, 1);
            // レベル指定を除く
            if (Strings.InStr(fc1, "Lv") > 0)
            {
                fc1 = Strings.Left(fc1, Strings.InStr(fc1, "Lv") - 1);
            }

            fc2 = GeneralLib.LIndex(fdata2, 1);
            // レベル指定を除く
            if (Strings.InStr(fc2, "Lv") > 0)
            {
                fc2 = Strings.Left(fc2, Strings.InStr(fc2, "Lv") - 1);
            }

            if ((fc1 ?? "") == (fc2 ?? ""))
            {
                IsSameCategoryRet = true;
            }

            return IsSameCategoryRet;
        }

        // マップ攻撃 w で (tx,ty) を攻撃
        public void MapAttack(int w, int tx, int ty, bool is_event = false)
        {
            int k, i, j, num;
            Unit t = default, u;
            int prev_level;
            var earned_exp = default;
            int prev_money, earnings = default;
            string[] prev_stype;
            string[] prev_sname;
            double[] prev_slevel;
            string sname;
            string[] prev_special_power;
            string msg;
            var partners = default(Unit[]);
            string wname, wnickname;
            Unit[] targets;
            double[] targets_hp_ratio;
            int[] targets_x;
            int[] targets_y;
            int rx, ry;
            int min_range, max_range;
            string uname = default, fname;
            double hp_ratio, en_ratio;
            wname = Weapon(w).Name;
            Commands.SelectedWeaponName = wname;
            wnickname = WeaponNickname(w);

            // 効果範囲を設定
            min_range = Weapon(w).MinRange;
            max_range = WeaponMaxRange(w);
            if (IsWeaponClassifiedAs(w, "Ｍ直"))
            {
                if (ty < y)
                {
                    Map.AreaInLine(x, y, min_range, max_range, "N");
                }
                else if (ty > y)
                {
                    Map.AreaInLine(x, y, min_range, max_range, "S");
                }
                else if (tx < x)
                {
                    Map.AreaInLine(x, y, min_range, max_range, "W");
                }
                else
                {
                    Map.AreaInLine(x, y, min_range, max_range, "E");
                }
            }
            else if (IsWeaponClassifiedAs(w, "Ｍ拡"))
            {
                if (ty < y && Math.Abs((y - ty)) > Math.Abs((x - tx)))
                {
                    Map.AreaInCone(x, y, min_range, max_range, "N");
                }
                else if (ty > y && Math.Abs((y - ty)) > Math.Abs((x - tx)))
                {
                    Map.AreaInCone(x, y, min_range, max_range, "S");
                }
                else if (tx < x && Math.Abs((x - tx)) > Math.Abs((y - ty)))
                {
                    Map.AreaInCone(x, y, min_range, max_range, "W");
                }
                else
                {
                    Map.AreaInCone(x, y, min_range, max_range, "E");
                }
            }
            else if (IsWeaponClassifiedAs(w, "Ｍ扇"))
            {
                if (ty < y && Math.Abs((y - ty)) >= Math.Abs((x - tx)))
                {
                    Map.AreaInSector(x, y, min_range, max_range, "N", WeaponLevel(w, "Ｍ扇"));
                }
                else if (ty > y && Math.Abs((y - ty)) >= Math.Abs((x - tx)))
                {
                    Map.AreaInSector(x, y, min_range, max_range, "S", WeaponLevel(w, "Ｍ扇"));
                }
                else if (tx < x && Math.Abs((x - tx)) >= Math.Abs((y - ty)))
                {
                    Map.AreaInSector(x, y, min_range, max_range, "W", WeaponLevel(w, "Ｍ扇"));
                }
                else
                {
                    Map.AreaInSector(x, y, min_range, max_range, "E", WeaponLevel(w, "Ｍ扇"));
                }
            }
            else if (IsWeaponClassifiedAs(w, "Ｍ投"))
            {
                Map.AreaInRange(tx, ty, WeaponLevel(w, "Ｍ投"), 1, "すべて");
            }
            else if (IsWeaponClassifiedAs(w, "Ｍ全"))
            {
                Map.AreaInRange(x, y, max_range, min_range, "すべて");
            }
            else if (IsWeaponClassifiedAs(w, "Ｍ移") || IsWeaponClassifiedAs(w, "Ｍ線"))
            {
                Map.AreaInPointToPoint(x, y, tx, ty);
            }

            Map.MaskData[x, y] = false;

            // 識別型マップ攻撃
            if (IsWeaponClassifiedAs(w, "識") || IsUnderSpecialPowerEffect("識別攻撃"))
            {
                foreach (Unit currentU in SRC.UList)
                {
                    u = currentU;
                    {
                        var withBlock = u;
                        if (withBlock.Status == "出撃")
                        {
                            if (IsAlly(u) || WeaponAdaption(w, withBlock.Area) == 0d)
                            {
                                Map.MaskData[withBlock.x, withBlock.y] = true;
                            }
                        }
                    }
                }

                Map.MaskData[x, y] = false;
            }

            // 合体技の処理
            bool[] TmpMaskData;
            if (IsWeaponClassifiedAs(w, "合"))
            {

                // 合体技のパートナーのハイライト表示
                // MaskDataを保存して使用している
                TmpMaskData = new bool[(Map.MapWidth + 1), (Map.MapHeight + 1)];
                var loopTo = Map.MapWidth;
                for (i = 1; i <= loopTo; i++)
                {
                    var loopTo1 = Map.MapHeight;
                    for (j = 1; j <= loopTo1; j++)
                        TmpMaskData[i, j] = Map.MaskData[i, j];
                }

                CombinationPartner("武装", w, partners);
                var loopTo2 = Information.UBound(partners);
                for (i = 1; i <= loopTo2; i++)
                {
                    {
                        var withBlock1 = partners[i];
                        Map.MaskData[withBlock1.x, withBlock1.y] = false;
                        TmpMaskData[withBlock1.x, withBlock1.y] = true;
                    }
                }

                GUI.MaskScreen();
                var loopTo3 = Map.MapWidth;
                for (i = 1; i <= loopTo3; i++)
                {
                    var loopTo4 = Map.MapHeight;
                    for (j = 1; j <= loopTo4; j++)
                        Map.MaskData[i, j] = TmpMaskData[i, j];
                }
            }
            else
            {
                partners = new Unit[1];
                Commands.SelectedPartners = new Unit[1];
                GUI.MaskScreen();
            }

            // 自分自身には攻撃しない
            Map.MaskData[x, y] = true;

            // マップ攻撃の影響を受けるユニットのリストを作成
            targets = new Unit[1];
            var loopTo5 = Map.MapWidth;
            for (i = 1; i <= loopTo5; i++)
            {
                var loopTo6 = Map.MapHeight;
                for (j = 1; j <= loopTo6; j++)
                {
                    // マップ攻撃の影響をうけるかチェック
                    if (Map.MaskData[i, j])
                    {
                        goto NextLoop;
                    }

                    if (Map.MapDataForUnit[i, j] is null)
                    {
                        goto NextLoop;
                    }

                    t = Map.MapDataForUnit[i, j];
                    {
                        var withBlock2 = t;
                        if (WeaponAdaption(w, withBlock2.Area) == 0d)
                        {
                            goto NextLoop;
                        }

                        if (IsWeaponClassifiedAs(w, "識") || IsUnderSpecialPowerEffect("識別攻撃"))
                        {
                            if (IsAlly(t))
                            {
                                goto NextLoop;
                            }
                        }

                        if (withBlock2.IsUnderSpecialPowerEffect("隠れ身"))
                        {
                            goto NextLoop;
                        }

                        Array.Resize(targets, Information.UBound(targets) + 1 + 1);
                        targets[Information.UBound(targets)] = t;
                    }

                    NextLoop:
                    ;
                }
            }

            // 攻撃の起点を設定
            if (IsWeaponClassifiedAs(w, "Ｍ投"))
            {
                rx = tx;
                ry = ty;
            }
            else
            {
                rx = x;
                ry = y;
            }

            // 起点からの距離に応じて並べ替え
            int min_item, min_value;
            var loopTo7 = (Information.UBound(targets) - 1);
            for (i = 1; i <= loopTo7; i++)
            {
                min_item = i;
                {
                    var withBlock3 = targets[i];
                    min_value = (Math.Abs((withBlock3.x - rx)) + Math.Abs((withBlock3.y - ry)));
                }

                var loopTo8 = Information.UBound(targets);
                for (j = (i + 1); j <= loopTo8; j++)
                {
                    {
                        var withBlock4 = targets[j];
                        if ((Math.Abs((withBlock4.x - rx)) + Math.Abs((withBlock4.y - ry))) < min_value)
                        {
                            min_item = j;
                            min_value = (Math.Abs((withBlock4.x - rx)) + Math.Abs((withBlock4.y - ry)));
                        }
                    }
                }

                if (min_item != i)
                {
                    u = targets[i];
                    targets[i] = targets[min_item];
                    targets[min_item] = u;
                }
            }

            // 戦闘前に一旦クリア
            // UPGRADE_NOTE: オブジェクト SupportAttackUnit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Commands.SupportAttackUnit = null;
            // UPGRADE_NOTE: オブジェクト SupportGuardUnit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Commands.SupportGuardUnit = null;
            // UPGRADE_NOTE: オブジェクト SupportGuardUnit2 をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Commands.SupportGuardUnit2 = null;

            // イベントの処理
            if (!is_event)
            {
                // 使用イベント
                Event.HandleEvent("使用", MainPilot().ID, wname);
                if (SRC.IsScenarioFinished)
                {
                    SRC.IsScenarioFinished = false;
                    return;
                }

                if (SRC.IsCanceled)
                {
                    SRC.IsCanceled = false;
                    return;
                }

                // マップ攻撃開始前にあらかじめ攻撃イベントを発生させる
                var loopTo9 = Information.UBound(targets);
                for (i = 1; i <= loopTo9; i++)
                {
                    t = targets[i];
                    Commands.SaveSelections();
                    Commands.SelectedTarget = t;
                    Event.HandleEvent("攻撃", MainPilot().ID, t.MainPilot().ID);
                    Commands.RestoreSelections();
                    if (SRC.IsScenarioFinished || SRC.IsCanceled)
                    {
                        return;
                    }
                }
            }

            // まだ攻撃可能？
            if (!is_event)
            {
                if (Status != "出撃" || MaxAction(true) == 0 || IsConditionSatisfied("攻撃不能"))
                {
                    return;
                }
            }

            // ターゲットに関する情報を記録
            targets_hp_ratio = new double[Information.UBound(targets) + 1];
            targets_x = new int[Information.UBound(targets) + 1];
            targets_y = new int[Information.UBound(targets) + 1];
            var loopTo10 = Information.UBound(targets);
            for (i = 1; i <= loopTo10; i++)
            {
                t = targets[i].CurrentForm();
                targets[i] = t;
                {
                    var withBlock5 = t;
                    targets_hp_ratio[i] = withBlock5.HP / (double)withBlock5.MaxHP;
                    targets_x[i] = withBlock5.x;
                    targets_y[i] = withBlock5.y;
                }
            }

            GUI.OpenMessageForm(this, u2: null);

            // 現在の選択状況をセーブ
            Commands.SaveSelections();

            // 選択内容を切り替え
            Commands.SelectedUnit = this;
            Event.SelectedUnitForEvent = this;
            Commands.SelectedWeapon = w;
            Commands.SelectedX = tx;
            Commands.SelectedY = ty;

            // 変な「対～」メッセージが表示されないようにターゲットをオフ
            // UPGRADE_NOTE: オブジェクト SelectedTarget をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Commands.SelectedTarget = null;
            // UPGRADE_NOTE: オブジェクト SelectedTargetForEvent をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Event.SelectedTargetForEvent = null;

            // 攻撃準備の効果音
            bool localIsSpecialEffectDefined() { string argmain_situation = wname + "(準備)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            if (IsAnimationDefined(wname + "(準備)", sub_situation: ""))
            {
                PlayAnimation(wname + "(準備)", sub_situation: "");
            }
            else if (IsAnimationDefined(wname, sub_situation: "") && !Expression.IsOptionDefined("武器準備アニメ非表示") && SRC.WeaponAnimation)
            {
                PlayAnimation(wname + "(準備)", sub_situation: "");
            }
            else if (localIsSpecialEffectDefined())
            {
                SpecialEffect(wname + "(準備)", sub_situation: "");
            }

            // マップ攻撃攻撃開始のメッセージ
            if (IsMessageDefined(wname))
            {
                if (IsMessageDefined("かけ声(" + wname + ")"))
                {
                    PilotMessage("かけ声(" + wname + ")", msg_mode: "");
                }
                else
                {
                    PilotMessage("かけ声", msg_mode: "");
                }
            }

            // 攻撃メッセージ
            PilotMessage(wname, "攻撃");

            // 戦闘アニメ or 効果音
            if (IsAnimationDefined(wname + "(攻撃)", sub_situation: "") || IsAnimationDefined(wname, sub_situation: ""))
            {
                PlayAnimation(wname + "(攻撃)", sub_situation: "");
            }
            else if (IsSpecialEffectDefined(wname, sub_situation: ""))
            {
                SpecialEffect(wname, sub_situation: "");
            }
            else
            {
                Effect.AttackEffect(this, w);
            }

            // 攻撃中の攻撃力変動を避けるため、あらかじめ攻撃力を保存しておく
            SelectedMapAttackPower = 0;
            SelectedMapAttackPower = WeaponPower(w, "初期値");

            // 「永」属性武器が破壊されることによるマップ攻撃キャンセル処理の初期化
            IsMapAttackCanceled = false;

            // 武器使用による弾数＆ＥＮ消費
            UseWeapon(w);
            GUI.UpdateMessageForm(this, u2: null);

            // 攻撃時のシステムメッセージ
            if (IsSysMessageDefined(wname, sub_situation: ""))
            {
                // 「武器名(解説)」のメッセージを使用
                SysMessage(wname, sub_situation: "", add_msg: "");
            }
            else if (IsSysMessageDefined("攻撃", sub_situation: ""))
            {
                // 「攻撃(解説)」のメッセージを使用
                SysMessage(wname, sub_situation: "", add_msg: "");
            }
            else
            {
                switch (Information.UBound(partners))
                {
                    case 0:
                        {
                            // 通常攻撃
                            msg = Nickname + "は";
                            break;
                        }

                    case 1:
                        {
                            // ２体合体攻撃
                            if ((Nickname ?? "") != (partners[1].Nickname ?? ""))
                            {
                                msg = Nickname + "は[" + partners[1].Nickname + "]と共に";
                            }
                            else if ((MainPilot().get_Nickname(false) ?? "") != (partners[1].MainPilot().get_Nickname(false) ?? ""))
                            {
                                msg = MainPilot().get_Nickname(false) + "と[" + partners[1].MainPilot().get_Nickname(false) + "]の[" + Nickname + "]は";
                            }
                            else
                            {
                                msg = Nickname + "達は";
                            }

                            break;
                        }

                    case 2:
                        {
                            // ３体合体攻撃
                            if ((Nickname ?? "") != (partners[1].Nickname ?? ""))
                            {
                                msg = Nickname + "は[" + partners[1].Nickname + "]、[" + partners[2].Nickname + "]と共に";
                            }
                            else if ((MainPilot().get_Nickname(false) ?? "") != (partners[1].MainPilot().get_Nickname(false) ?? ""))
                            {
                                msg = MainPilot().get_Nickname(false) + "、[" + partners[1].MainPilot().get_Nickname(false) + "]、[" + partners[2].MainPilot().get_Nickname(false) + "]の[" + Nickname + "]は";
                            }
                            else
                            {
                                msg = Nickname + "達は";
                            }

                            break;
                        }

                    default:
                        {
                            // ３体以上による合体攻撃
                            msg = Nickname + "達は";
                            break;
                        }
                }

                // 攻撃の種類によってメッセージを切り替え
                if (Strings.Right(wnickname, 2) == "攻撃" || Strings.Right(wnickname, 4) == "アタック" || wnickname == "突撃")
                {
                    msg = msg + "[" + wnickname + "]をかけた。";
                }
                else if (IsSpellWeapon(w))
                {
                    if (Strings.Right(wnickname, 2) == "呪文")
                    {
                        msg = msg + "[" + wnickname + "]を唱えた。";
                    }
                    else if (Strings.Right(wnickname, 2) == "の杖")
                    {
                        msg = msg + "[" + Strings.Left(wnickname, Strings.Len(wnickname) - 2) + "]の呪文を唱えた。";
                    }
                    else
                    {
                        msg = msg + "[" + wnickname + "]の呪文を唱えた。";
                    }
                }
                else if (IsWeaponClassifiedAs(w, "実") && (Strings.InStr(wnickname, "ミサイル") > 0 || Strings.InStr(wnickname, "ロケット") > 0))
                {
                    msg = msg + "[" + wnickname + "]を発射した。";
                }
                else if (Strings.Right(wnickname, 1) == "息" || Strings.Right(wnickname, 3) == "ブレス" || Strings.Right(wnickname, 2) == "光線" || Strings.Right(wnickname, 1) == "光" || Strings.Right(wnickname, 3) == "ビーム" || Strings.Right(wnickname, 4) == "レーザー")
                {
                    msg = msg + "[" + wnickname + "]を放った。";
                }
                else if (Strings.Right(wnickname, 1) == "歌")
                {
                    msg = msg + "[" + wnickname + "]を歌った。";
                }
                else if (Strings.Right(wnickname, 2) == "踊り")
                {
                    msg = msg + "[" + wnickname + "]を踊った。";
                }
                else
                {
                    msg = msg + "[" + wnickname + "]で攻撃をかけた。";
                }

                // メッセージを表示
                GUI.DisplaySysMessage(msg);
            }

            // 命中後メッセージ
            PilotMessage(wname + "(命中)", msg_mode: "");

            // 選択状況を復元
            Commands.RestoreSelections();

            // 経験値＆資金獲得のメッセージ表示用に各種データを保存
            {
                var withBlock6 = MainPilot();
                prev_level = withBlock6.Level;
                prev_special_power = new string[(withBlock6.CountSpecialPower + 1)];
                var loopTo11 = withBlock6.CountSpecialPower;
                for (i = 1; i <= loopTo11; i++)
                    prev_special_power[i] = withBlock6.get_SpecialPower(i);
                prev_stype = new string[(withBlock6.CountSkill() + 1)];
                prev_slevel = new double[(withBlock6.CountSkill() + 1)];
                prev_sname = new string[(withBlock6.CountSkill() + 1)];
                var loopTo12 = withBlock6.CountSkill();
                for (i = 1; i <= loopTo12; i++)
                {
                    prev_stype[i] = withBlock6.Skill(i);
                    prev_slevel[i] = withBlock6.SkillLevel(i, "基本値");
                    prev_sname[i] = withBlock6.SkillName(i);
                }
            }

            prev_money = SRC.Money;

            // 攻撃元ユニットは SelectedTarget に設定していないといけない
            Commands.SelectedTarget = this;

            // 移動型マップ攻撃による移動を行う
            if (IsWeaponClassifiedAs(w, "Ｍ移"))
            {
                Jump(tx, ty);
            }

            // 個々のユニットに対して攻撃
            var loopTo13 = Information.UBound(targets);
            for (i = 1; i <= loopTo13; i++)
            {
                t = targets[i].CurrentForm();
                if (t.Status == "出撃")
                {
                    if (Party == "味方" || Party == "ＮＰＣ")
                    {
                        GUI.UpdateMessageForm(t, this);
                    }
                    else
                    {
                        GUI.UpdateMessageForm(this, t);
                    }

                    // 攻撃を行う
                    Attack(w, t, "マップ攻撃", "", is_event);

                    // かばうによりターゲットが変化している？
                    if (Commands.SupportGuardUnit is object)
                    {
                        targets[i] = Commands.SupportGuardUnit.CurrentForm();
                        targets_hp_ratio[i] = Commands.SupportGuardUnitHPRatio;
                        targets_x[i] = targets[i].x;
                        targets_y[i] = targets[i].y;
                    }

                    // これ以上攻撃を続けられない場合
                    if (Status != "出撃" || CountPilot() == 0 || IsMapAttackCanceled)
                    {
                        GUI.CloseMessageForm();
                        SelectedMapAttackPower = 0;
                        goto DoEvent;
                    }

                    GUI.ClearMessageForm();
                }
            }

            // とどめメッセージ
            if (IsMessageDefined(wname + "(とどめ)"))
            {
                PilotMessage(wname + "(とどめ)", msg_mode: "");
            }

            bool localIsSpecialEffectDefined1() { string argmain_situation = wname + "(とどめ)"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            if (IsAnimationDefined(wname + "(とどめ)", sub_situation: ""))
            {
                PlayAnimation(wname + "(とどめ)", sub_situation: "");
            }
            else if (localIsSpecialEffectDefined1())
            {
                SpecialEffect(wname + "(とどめ)", sub_situation: "");
            }

            // カットインは消去しておく
            if (GUI.IsPictureVisible)
            {
                GUI.ClearPicture();
                // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                GUI.MainForm.picMain(0).Refresh();
            }

            // 保存した攻撃力の使用を止める
            SelectedMapAttackPower = 0;

            // ADD START MARGE
            // 戦闘アニメ終了処理
            if (IsAnimationDefined(wname + "(終了)", sub_situation: ""))
            {
                PlayAnimation(wname + "(終了)", sub_situation: "");
            }
            else if (IsAnimationDefined("終了", sub_situation: ""))
            {
                PlayAnimation("終了", sub_situation: "");
            }
            // ADD END MARGE

            // 戦闘アニメで変更されたユニット画像を元に戻す
            if (IsConditionSatisfied("ユニット画像"))
            {
                DeleteCondition("ユニット画像");
                BitmapID = GUI.MakeUnitBitmap(this);
                if (GUI.IsPictureVisible)
                {
                    GUI.PaintUnitBitmap(this, "リフレッシュ無し");
                }
                else
                {
                    GUI.PaintUnitBitmap(this);
                }
            }

            if (IsConditionSatisfied("非表示付加"))
            {
                DeleteCondition("非表示付加");
                BitmapID = GUI.MakeUnitBitmap(this);
                if (GUI.IsPictureVisible)
                {
                    GUI.PaintUnitBitmap(this, "リフレッシュ無し");
                }
                else
                {
                    GUI.PaintUnitBitmap(this);
                }
            }

            var loopTo14 = Information.UBound(partners);
            for (i = 1; i <= loopTo14; i++)
            {
                {
                    var withBlock7 = partners[i].CurrentForm();
                    if (withBlock7.IsConditionSatisfied("ユニット画像"))
                    {
                        withBlock7.DeleteCondition("ユニット画像");
                        withBlock7.BitmapID = GUI.MakeUnitBitmap(partners[i].CurrentForm());
                        GUI.PaintUnitBitmap(partners[i].CurrentForm());
                    }

                    if (withBlock7.IsConditionSatisfied("非表示付加"))
                    {
                        withBlock7.DeleteCondition("非表示付加");
                        withBlock7.BitmapID = GUI.MakeUnitBitmap(partners[i].CurrentForm());
                        GUI.PaintUnitBitmap(partners[i].CurrentForm());
                    }
                }
            }

            if (Party == "味方" && !is_event)
            {
                // 経験値＆資金の獲得
                var loopTo15 = Information.UBound(targets);
                for (i = 1; i <= loopTo15; i++)
                {
                    t = targets[i].CurrentForm();
                    if (!IsEnemy(t))
                    {
                    }
                    // 味方からは経験値＆資金は得られない
                    else if (t.Status == "破壊")
                    {
                        // 経験値の獲得
                        earned_exp = earned_exp + GetExp(t, "破壊", "マップ");

                        // 合体技のパートナーへの経験値
                        if (!Expression.IsOptionDefined("合体技パートナー経験値無効"))
                        {
                            var loopTo17 = Information.UBound(partners);
                            for (j = 1; j <= loopTo17; j++)
                            {
                                partners[j].CurrentForm().GetExp(t, "破壊", "パートナー");
                            }
                        }

                        // 獲得する資金を算出
                        earnings = t.Value / 2;

                        // スペシャルパワーによる獲得資金増加
                        if (IsUnderSpecialPowerEffect("獲得資金増加"))
                        {
                            earnings = GeneralLib.MinDbl(earnings * (1d + 0.1d * SpecialPowerEffectLevel("獲得資金増加")), 999999999d);
                        }

                        // パイロット能力による獲得資金増加
                        if (IsSkillAvailable("資金獲得"))
                        {
                            if (!IsUnderSpecialPowerEffect("獲得資金増加") || Expression.IsOptionDefined("収得効果重複"))
                            {
                                earnings = GeneralLib.MinDbl(earnings * ((10d + SkillLevel("資金獲得", 5d)) / 10d), 999999999d);
                            }
                        }

                        // 資金を獲得
                        SRC.IncrMoney(earnings);
                    }
                    else
                    {
                        // 経験値の獲得
                        earned_exp = earned_exp + GetExp(t, "攻撃", "マップ");

                        // 合体技のパートナーへの経験値
                        if (!Expression.IsOptionDefined("合体技パートナー経験値無効"))
                        {
                            var loopTo16 = Information.UBound(partners);
                            for (j = 1; j <= loopTo16; j++)
                            {
                                partners[j].CurrentForm().GetExp(t, "攻撃", "パートナー");
                            }
                        }
                    }
                }

                // 獲得した経験値＆資金の表示
                if (SRC.Money > prev_money)
                {
                    GUI.DisplaySysMessage(Microsoft.VisualBasic.Compatibility.VB6.Support.Format(SRC.Money - prev_money) + "の" + Expression.Term("資金", t) + "を得た。");
                }

                {
                    var withBlock8 = MainPilot();
                    // レベルアップの処理
                    if (withBlock8.Level > prev_level)
                    {
                        if (IsAnimationDefined("レベルアップ", sub_situation: ""))
                        {
                            PlayAnimation("レベルアップ", sub_situation: "");
                        }
                        else if (IsSpecialEffectDefined("レベルアップ", sub_situation: ""))
                        {
                            SpecialEffect("レベルアップ", sub_situation: "");
                        }

                        if (IsMessageDefined("レベルアップ"))
                        {
                            PilotMessage("レベルアップ", msg_mode: "");
                        }

                        msg = withBlock8.get_Nickname(false) + "は" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(earned_exp) + "の経験値を獲得し、" + "レベル[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock8.Level) + "]にレベルアップ。";

                        // 特殊能力の習得
                        var loopTo18 = withBlock8.CountSkill();
                        for (i = 1; i <= loopTo18; i++)
                        {
                            sname = withBlock8.Skill(i);
                            string localSkillName2() { object argIndex1 = i; var ret = withBlock8.SkillName(argIndex1); return ret; }

                            if (Strings.InStr(localSkillName2(), "非表示") == 0)
                            {
                                switch (sname ?? "")
                                {
                                    case "同調率":
                                    case "霊力":
                                    case "追加レベル":
                                    case "魔力所有":
                                        {
                                            break;
                                        }

                                    default:
                                        {
                                            var loopTo19 = Information.UBound(prev_stype);
                                            for (j = 1; j <= loopTo19; j++)
                                            {
                                                if ((sname ?? "") == (prev_stype[j] ?? ""))
                                                {
                                                    break;
                                                }
                                            }

                                            double localSkillLevel() { object argIndex1 = sname; string argref_mode = "基本値"; var ret = withBlock8.SkillLevel(argIndex1, argref_mode); return ret; }

                                            if (j > Information.UBound(prev_stype))
                                            {
                                                string localSkillName() { object argIndex1 = i; var ret = withBlock8.SkillName(argIndex1); return ret; }

                                                msg = msg + ";" + localSkillName() + "を習得。";
                                            }
                                            else if (localSkillLevel() > prev_slevel[j])
                                            {
                                                string localSkillName1() { object argIndex1 = i; var ret = withBlock8.SkillName(argIndex1); return ret; }

                                                msg = msg + ";" + prev_sname[j] + " => " + localSkillName1() + "。";
                                            }

                                            break;
                                        }
                                }
                            }
                        }

                        // スペシャルパワーの習得
                        if (withBlock8.CountSpecialPower > Information.UBound(prev_special_power))
                        {
                            msg = msg + ";スペシャルパワー";
                            var loopTo20 = withBlock8.CountSpecialPower;
                            for (i = 1; i <= loopTo20; i++)
                            {
                                sname = withBlock8.get_SpecialPower(i);
                                var loopTo21 = Information.UBound(prev_special_power);
                                for (j = 1; j <= loopTo21; j++)
                                {
                                    if ((sname ?? "") == (prev_special_power[j] ?? ""))
                                    {
                                        break;
                                    }
                                }

                                if (j > Information.UBound(prev_special_power))
                                {
                                    msg = msg + "「" + sname + "」";
                                }
                            }

                            msg = msg + "を習得。";
                        }

                        GUI.DisplaySysMessage(msg);
                        Event.HandleEvent("レベルアップ", withBlock8.ID);
                        SRC.PList.UpdateSupportMod(this);
                    }
                    else if (earned_exp > 0)
                    {
                        GUI.DisplaySysMessage(withBlock8.get_Nickname(false) + "は" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(earned_exp) + "の経験値を得た。");
                    }
                }
            }

            // スペシャルパワー効果の解除
            if (IsUnderSpecialPowerEffect("攻撃後消耗"))
            {
                AddCondition("消耗", 1, cdata: "");
            }

            RemoveSpecialPowerInEffect("攻撃");
            RemoveSpecialPowerInEffect("戦闘終了");
            if (earnings > 0)
            {
                RemoveSpecialPowerInEffect("敵破壊");
            }

            var loopTo22 = Information.UBound(targets);
            for (i = 1; i <= loopTo22; i++)
            {
                targets[i].CurrentForm().RemoveSpecialPowerInEffect("戦闘終了");
            }

            // 状態の解除
            var loopTo23 = Information.UBound(targets);
            for (i = 1; i <= loopTo23; i++)
                targets[i].CurrentForm().UpdateCondition();

            // ステルスが解ける？
            if (IsFeatureAvailable("ステルス"))
            {
                if (IsWeaponClassifiedAs(w, "忍"))
                {
                    var loopTo24 = Information.UBound(targets);
                    for (i = 1; i <= loopTo24; i++)
                    {
                        {
                            var withBlock9 = targets[i].CurrentForm();
                            if (withBlock9.Status == "出撃" && withBlock9.MaxAction() > 0)
                            {
                                AddCondition("ステルス無効", 1, cdata: "");
                                break;
                            }
                        }
                    }
                }
                else
                {
                    AddCondition("ステルス無効", 1, cdata: "");
                }
            }

            // 合体技のパートナーの弾数＆ＥＮを消費
            var loopTo25 = Information.UBound(partners);
            for (i = 1; i <= loopTo25; i++)
            {
                {
                    var withBlock10 = partners[i].CurrentForm();
                    var loopTo26 = withBlock10.CountWeapon();
                    for (j = 1; j <= loopTo26; j++)
                    {
                        if ((withBlock10.Weapon(j).Name ?? "") == (wname ?? ""))
                        {
                            withBlock10.UseWeapon(j);
                            if (withBlock10.IsWeaponClassifiedAs(j, "自"))
                            {
                                if (withBlock10.IsFeatureAvailable("パーツ分離"))
                                {
                                    uname = GeneralLib.LIndex(withBlock10.FeatureData("パーツ分離"), 2);
                                    Unit localOtherForm() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                    if (localOtherForm().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                    {
                                        withBlock10.Transform(uname);
                                        {
                                            var withBlock11 = withBlock10.CurrentForm();
                                            withBlock11.HP = withBlock11.MaxHP;
                                            withBlock11.UsedAction = withBlock11.MaxAction();
                                        }
                                    }
                                    else
                                    {
                                        withBlock10.Die();
                                    }
                                }
                                else
                                {
                                    withBlock10.Die();
                                }
                            }
                            else if (withBlock10.IsWeaponClassifiedAs(j, "失") && withBlock10.HP == 0)
                            {
                                withBlock10.Die();
                            }
                            else if (withBlock10.IsWeaponClassifiedAs(j, "変"))
                            {
                                if (withBlock10.IsFeatureAvailable("変形技"))
                                {
                                    var loopTo27 = withBlock10.CountFeature();
                                    for (k = 1; k <= loopTo27; k++)
                                    {
                                        string localFeature() { object argIndex1 = k; var ret = withBlock10.Feature(argIndex1); return ret; }

                                        string localFeatureData1() { object argIndex1 = k; var ret = withBlock10.FeatureData(argIndex1); return ret; }

                                        string localLIndex() { string arglist = hs681d62aaff664a9daf19517e6120dc9d(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                                        if (localFeature() == "変形技" && (localLIndex() ?? "") == (wname ?? ""))
                                        {
                                            string localFeatureData() { object argIndex1 = k; var ret = withBlock10.FeatureData(argIndex1); return ret; }

                                            uname = GeneralLib.LIndex(localFeatureData(), 2);
                                            Unit localOtherForm1() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                            if (localOtherForm1().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                            {
                                                withBlock10.Transform(uname);
                                            }

                                            break;
                                        }
                                    }

                                    if ((uname ?? "") != (withBlock10.CurrentForm().Name ?? ""))
                                    {
                                        if (withBlock10.IsFeatureAvailable("ノーマルモード"))
                                        {
                                            uname = GeneralLib.LIndex(withBlock10.FeatureData("ノーマルモード"), 1);
                                            Unit localOtherForm2() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                            if (localOtherForm2().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                            {
                                                withBlock10.Transform(uname);
                                            }
                                        }
                                    }
                                }
                                else if (withBlock10.IsFeatureAvailable("ノーマルモード"))
                                {
                                    uname = GeneralLib.LIndex(withBlock10.FeatureData(argIndex16), 1);
                                    Unit localOtherForm3() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                    if (localOtherForm3().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                    {
                                        withBlock10.Transform(uname);
                                    }
                                }
                            }

                            break;
                        }
                    }

                    // 同名の武器がなかった場合は自分のデータを使って処理
                    if (j > withBlock10.CountWeapon())
                    {
                        if (this.Weapon(w).ENConsumption > 0)
                        {
                            withBlock10.EN = withBlock10.EN - WeaponENConsumption(w);
                        }

                        if (IsWeaponClassifiedAs(w, "消"))
                        {
                            withBlock10.AddCondition("消耗", 1, cdata: "");
                        }

                        if (IsWeaponClassifiedAs(w, "Ｃ") && withBlock10.IsConditionSatisfied("チャージ完了"))
                        {
                            withBlock10.DeleteCondition("チャージ完了");
                        }

                        if (IsWeaponClassifiedAs(w, "気"))
                        {
                            withBlock10.IncreaseMorale((-5 * WeaponLevel(w, "気")));
                        }

                        if (IsWeaponClassifiedAs(w, "霊"))
                        {
                            hp_ratio = 100 * withBlock10.HP / (double)withBlock10.MaxHP;
                            en_ratio = 100 * withBlock10.EN / (double)withBlock10.MaxEN;
                            withBlock10.MainPilot().Plana = (withBlock10.MainPilot().Plana - 5d * WeaponLevel(w, "霊"));
                            withBlock10.HP = (withBlock10.MaxHP * hp_ratio / 100d);
                            withBlock10.EN = (withBlock10.MaxEN * en_ratio / 100d);
                        }
                        else if (IsWeaponClassifiedAs(w, "プ"))
                        {
                            hp_ratio = 100 * withBlock10.HP / (double)withBlock10.MaxHP;
                            en_ratio = 100 * withBlock10.EN / (double)withBlock10.MaxEN;
                            withBlock10.MainPilot().Plana = (withBlock10.MainPilot().Plana - 5d * WeaponLevel(w, "プ"));
                            withBlock10.HP = (withBlock10.MaxHP * hp_ratio / 100d);
                            withBlock10.EN = (withBlock10.MaxEN * en_ratio / 100d);
                        }

                        if (IsWeaponClassifiedAs(w, "失"))
                        {
                            withBlock10.HP = GeneralLib.MaxLng((withBlock10.HP - (long)(withBlock10.MaxHP * WeaponLevel(w, "失")) / 10L), 0);
                        }

                        if (IsWeaponClassifiedAs(w, "自"))
                        {
                            if (withBlock10.IsFeatureAvailable("パーツ分離"))
                            {
                                uname = GeneralLib.LIndex(withBlock10.FeatureData("パーツ分離"), 2);
                                Unit localOtherForm4() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                if (localOtherForm4().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                {
                                    withBlock10.Transform(uname);
                                    {
                                        var withBlock12 = withBlock10.CurrentForm();
                                        withBlock12.HP = withBlock12.MaxHP;
                                        withBlock12.UsedAction = withBlock12.MaxAction();
                                    }
                                }
                                else
                                {
                                    withBlock10.Die();
                                }
                            }
                            else
                            {
                                withBlock10.Die();
                            }
                        }
                        else if (IsWeaponClassifiedAs(w, "失") && withBlock10.HP == 0)
                        {
                            withBlock10.Die();
                        }
                        else if (IsWeaponClassifiedAs(w, "変"))
                        {
                            if (withBlock10.IsFeatureAvailable("ノーマルモード"))
                            {
                                uname = GeneralLib.LIndex(withBlock10.FeatureData(argIndex20), 1);
                                Unit localOtherForm5() { object argIndex1 = uname; var ret = withBlock10.OtherForm(argIndex1); return ret; }

                                if (localOtherForm5().IsAbleToEnter(withBlock10.x, withBlock10.y))
                                {
                                    withBlock10.Transform(uname);
                                }
                            }
                        }
                    }
                }
            }

            // 以下の特殊効果は武器データが変化する可能性があるため、同時には適用されない

            // 自爆の処理

            // ＨＰ消費攻撃による自殺

            // 変形技
            if (IsWeaponClassifiedAs(w, "自"))
            {
                if (IsFeatureAvailable("パーツ分離"))
                {
                    uname = GeneralLib.LIndex(FeatureData("パーツ分離"), 2);
                    Unit localOtherForm6() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm6().IsAbleToEnter(x, y))
                    {
                        Transform(uname);
                        {
                            var withBlock13 = CurrentForm();
                            withBlock13.HP = withBlock13.MaxHP;
                            withBlock13.UsedAction = withBlock13.MaxAction();
                        }

                        fname = FeatureName("パーツ分離");
                        bool localIsSysMessageDefined() { string argmain_situation = "破壊時分離(" + fname + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        bool localIsSysMessageDefined1() { string argmain_situation = "分離(" + Name + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        bool localIsSysMessageDefined2() { string argmain_situation = "分離(" + fname + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        if (IsSysMessageDefined("破壊時分離(" + Name + ")", sub_situation: ""))
                        {
                            SysMessage("破壊時分離(" + Name + ")", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined())
                        {
                            SysMessage("破壊時分離(" + fname + ")", sub_situation: "", add_msg: "");
                        }
                        else if (IsSysMessageDefined("破壊時分離", sub_situation: ""))
                        {
                            SysMessage("破壊時分離", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined1())
                        {
                            SysMessage("分離(" + Name + ")", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined2())
                        {
                            SysMessage("分離(" + fname + ")", sub_situation: "", add_msg: "");
                        }
                        else if (IsSysMessageDefined("分離", sub_situation: ""))
                        {
                            SysMessage("分離", sub_situation: "", add_msg: "");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(Nickname + "は破壊されたパーツを分離させた。");
                        }
                    }
                    else
                    {
                        Die();
                        GUI.CloseMessageForm();
                        if (!is_event)
                        {
                            Event.HandleEvent("破壊", MainPilot().ID);
                            if (SRC.IsScenarioFinished)
                            {
                                return;
                            }
                        }
                    }
                }
                else
                {
                    Die();
                    GUI.CloseMessageForm();
                    if (!is_event)
                    {
                        Event.HandleEvent("破壊", MainPilot().ID);
                        if (SRC.IsScenarioFinished)
                        {
                            return;
                        }
                    }
                }
            }
            else if (IsWeaponClassifiedAs(w, "失") && HP == 0)
            {
                Die();
                GUI.CloseMessageForm();
                if (!is_event)
                {
                    Event.HandleEvent("破壊", MainPilot().ID);
                    if (SRC.IsScenarioFinished)
                    {
                        return;
                    }
                }
            }
            else if (IsWeaponClassifiedAs(w, "変"))
            {
                if (IsFeatureAvailable("変形技"))
                {
                    var loopTo28 = CountFeature();
                    for (i = 1; i <= loopTo28; i++)
                    {
                        string localFeature1() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                        string localFeatureData3() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        string localLIndex1() { string arglist = hs367294acea73430b9129abf82f13a58e(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                        if (localFeature1() == "変形技" && (localLIndex1() ?? "") == (wname ?? ""))
                        {
                            string localFeatureData2() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            uname = GeneralLib.LIndex(localFeatureData2(), 2);
                            Unit localOtherForm7() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                            if (localOtherForm7().IsAbleToEnter(x, y))
                            {
                                Transform(uname);
                            }

                            break;
                        }
                    }

                    if ((uname ?? "") != (CurrentForm().Name ?? ""))
                    {
                        if (IsFeatureAvailable("ノーマルモード"))
                        {
                            uname = GeneralLib.LIndex(FeatureData(argIndex23), 1);
                            Unit localOtherForm8() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                            if (localOtherForm8().IsAbleToEnter(x, y))
                            {
                                Transform(uname);
                            }
                        }
                    }
                }
                else if (IsFeatureAvailable("ノーマルモード"))
                {
                    uname = GeneralLib.LIndex(FeatureData(argIndex24), 1);
                    Unit localOtherForm9() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm9().IsAbleToEnter(x, y))
                    {
                        Transform(uname);
                    }
                }
            }

            // アイテムを消費
            else if (Weapon(w).IsItem() && Bullet(w) == 0 && MaxBullet(w) > 0)
            {
                // アイテムを削除
                num = Data.CountWeapon();
                num = (num + MainPilot().Data.CountWeapon());
                var loopTo29 = CountPilot();
                for (i = 2; i <= loopTo29; i++)
                {
                    Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    num = (num + localPilot().Data.CountWeapon());
                }

                var loopTo30 = CountSupport();
                for (i = 2; i <= loopTo30; i++)
                {
                    Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    num = (num + localSupport().Data.CountWeapon());
                }

                if (IsFeatureAvailable("追加サポート"))
                {
                    num = (num + AdditionalSupport().Data.CountWeapon());
                }

                foreach (Item itm in colItem)
                {
                    num = (num + itm.CountWeapon());
                    if (w <= num)
                    {
                        itm.Exist = false;
                        DeleteItem((object)itm.ID);
                        break;
                    }
                }
            }

            GUI.CloseMessageForm();
            DoEvent:
            ;


            // イベント処理
            var uparty = default(string);
            bool found;
            if (!is_event)
            {
                var loopTo31 = Information.UBound(targets);
                for (i = 1; i <= loopTo31; i++)
                {
                    t = targets[i].CurrentForm();
                    if (t.Status == "破壊")
                    {
                        // 破壊イベントを発生
                        Commands.SaveSelections();
                        Commands.SwapSelections();
                        Event.HandleEvent("マップ攻撃破壊", t.MainPilot().ID);
                        Commands.RestoreSelections();
                        if (SRC.IsScenarioFinished || SRC.IsCanceled)
                        {
                            return;
                        }
                    }
                    else if (t.Status == "出撃")
                    {
                        if (t.HP / (double)t.MaxHP < targets_hp_ratio[i])
                        {
                            // 損傷率イベント
                            Commands.SaveSelections();
                            Commands.SwapSelections();
                            Event.HandleEvent("損傷率", t.MainPilot().ID, 100 * (t.MaxHP - t.HP) / t.MaxHP);
                            Commands.RestoreSelections();
                            if (SRC.IsScenarioFinished || SRC.IsCanceled)
                            {
                                return;
                            }
                        }

                        // ターゲットが動いていたら進入イベントを発生
                        {
                            var withBlock14 = t.CurrentForm();
                            if (withBlock14.Status == "出撃" && (withBlock14.x != targets_x[i] || withBlock14.y != targets_y[i]))
                            {
                                Event.HandleEvent("進入", withBlock14.MainPilot().ID, withBlock14.x, withBlock14.y);
                                if (SRC.IsScenarioFinished || SRC.IsCanceled)
                                {
                                    return;
                                }
                            }
                        }
                    }
                }

                // 全滅イベント
                for (i = 1; i <= 4; i++)
                {
                    switch (i)
                    {
                        case 1:
                            {
                                uparty = "味方";
                                break;
                            }

                        case 2:
                            {
                                uparty = "ＮＰＣ";
                                break;
                            }

                        case 3:
                            {
                                uparty = "敵";
                                break;
                            }

                        case 4:
                            {
                                uparty = "中立";
                                break;
                            }
                    }

                    found = false;
                    var loopTo32 = Information.UBound(targets);
                    for (j = 1; j <= loopTo32; j++)
                    {
                        {
                            var withBlock15 = targets[j].CurrentForm();
                            if ((withBlock15.Party0 ?? "") == (uparty ?? "") && withBlock15.Status != "出撃")
                            {
                                found = true;
                                break;
                            }
                        }
                    }

                    if (found)
                    {
                        found = false;
                        foreach (Unit currentU1 in SRC.UList)
                        {
                            u = currentU1;
                            if ((u.Party0 ?? "") == (uparty ?? "") && u.Status == "出撃" && !u.IsConditionSatisfied("憑依"))
                            {
                                found = true;
                                break;
                            }
                        }

                        if (!found)
                        {
                            Event.HandleEvent("全滅", uparty);
                            if (SRC.IsScenarioFinished || SRC.IsCanceled)
                            {
                                return;
                            }
                        }
                    }
                }

                // 使用後イベント
                if (CurrentForm().Status == "出撃")
                {
                    Event.HandleEvent("使用後", CurrentForm().MainPilot().ID, wname);
                    if (SRC.IsScenarioFinished || SRC.IsCanceled)
                    {
                        return;
                    }
                }

                // 攻撃後イベント
                if (CurrentForm().Status == "出撃")
                {
                    Commands.SaveSelections();
                    var loopTo33 = Information.UBound(targets);
                    for (i = 1; i <= loopTo33; i++)
                    {
                        Commands.SelectedTarget = targets[i].CurrentForm();
                        {
                            var withBlock16 = Commands.SelectedTarget;
                            if (withBlock16.Status == "出撃")
                            {
                                Event.HandleEvent("攻撃後", CurrentForm().MainPilot().ID, withBlock16.MainPilot().ID);
                                if (SRC.IsScenarioFinished)
                                {
                                    Commands.RestoreSelections();
                                    return;
                                }
                            }
                        }
                    }

                    Commands.RestoreSelections();
                }
            }

            // ハイパーモード＆ノーマルモードの自動発動をチェック
            SRC.UList.CheckAutoHyperMode();
            SRC.UList.CheckAutoNormalMode();
        }

        // 武器の使用によるＥＮ、弾薬の消費等を行う
        public void UseWeapon(int w)
        {
            int i, lv;
            double hp_ratio, en_ratio;

            // ＥＮ消費
            if (this.Weapon(w).ENConsumption > 0)
            {
                EN = EN - WeaponENConsumption(w);
            }

            // 弾数消費
            if (this.Weapon(w).Bullet > 0 && !IsWeaponClassifiedAs(w, "永"))
            {
                SetBullet(w, (Bullet(w) - 1));

                // 全弾一斉発射
                if (IsWeaponClassifiedAs(w, "斉"))
                {
                    var loopTo = Information.UBound(dblBullet);
                    for (i = 1; i <= loopTo; i++)
                        SetBullet(i, GeneralLib.MinLng((MaxBullet(i) * dblBullet[w]), Bullet(i)));
                }
                else
                {
                    var loopTo1 = Information.UBound(dblBullet);
                    for (i = 1; i <= loopTo1; i++)
                    {
                        if (IsWeaponClassifiedAs(i, "斉"))
                        {
                            SetBullet(i, GeneralLib.MinLng((MaxBullet(i) * dblBullet[w] + 0.49999d), Bullet(i)));
                        }
                    }
                }

                // 弾数・使用回数共有の処理
                SyncBullet();
            }

            if (IsWeaponClassifiedAs(w, "消"))
            {
                AddCondition("消耗", 1, cdata: "");
            }

            if (IsWeaponClassifiedAs(w, "尽"))
            {
                EN = 0;
            }

            if (IsWeaponClassifiedAs(w, "Ｃ") && IsConditionSatisfied("チャージ完了"))
            {
                DeleteCondition("チャージ完了");
            }

            if (WeaponLevel(w, "Ａ") > 0d)
            {
                AddCondition(WeaponNickname(w) + "充填中", WeaponLevel(w, "Ａ"), cdata: "");
            }

            if (IsWeaponClassifiedAs(w, "気"))
            {
                IncreaseMorale((-5 * WeaponLevel(w, "気")));
            }

            if (IsWeaponClassifiedAs(w, "霊"))
            {
                hp_ratio = 100 * HP / (double)MaxHP;
                en_ratio = 100 * EN / (double)MaxEN;
                MainPilot().Plana = (this.MainPilot().Plana - 5d * WeaponLevel(w, "霊"));
                HP = (MaxHP * hp_ratio / 100d);
                EN = (MaxEN * en_ratio / 100d);
            }
            else if (IsWeaponClassifiedAs(w, "プ"))
            {
                hp_ratio = 100 * HP / (double)MaxHP;
                en_ratio = 100 * EN / (double)MaxEN;
                MainPilot().Plana = (this.MainPilot().Plana - 5d * WeaponLevel(w, "プ"));
                HP = (MaxHP * hp_ratio / 100d);
                EN = (MaxEN * en_ratio / 100d);
            }

            if (Party == "味方")
            {
                if (IsWeaponClassifiedAs(w, "銭"))
                {
                    SRC.IncrMoney(-GeneralLib.MaxLng(WeaponLevel(w, "銭"), 1) * Value / 10);
                }
            }

            if (IsWeaponClassifiedAs(w, "失"))
            {
                HP = GeneralLib.MaxLng((HP - (long)(MaxHP * WeaponLevel(w, "失")) / 10L), 0);
            }

            // '合体技は１ターンに１回だけ使用可能
            // If IsWeaponClassifiedAs(w, "合") Then
            // AddCondition "合体技使用不可", 1, 0, "非表示"
            // End If
        }

        // 弾数
        public int Bullet(int w)
        {
            int BulletRet = default;
            BulletRet = (dblBullet[w] * intMaxBullet[w]);
            return BulletRet;
        }

        // 最大弾数
        public int MaxBullet(int w)
        {
            int MaxBulletRet = default;
            MaxBulletRet = intMaxBullet[w];
            return MaxBulletRet;
        }

        // 弾数を設定
        public void SetBullet(int w, int new_bullet)
        {
            if (new_bullet < 0)
            {
                dblBullet[w] = 0d;
            }
            else if (intMaxBullet[w] > 0)
            {
                dblBullet[w] = new_bullet / (double)intMaxBullet[w];
            }
            else
            {
                dblBullet[w] = 1d;
            }
        }

        // 弾数・使用回数共有の処理
        public void SyncBullet()
        {
            int j, a, w, i, k;
            int lv, idx;

            // 共属性武器の処理
            var loopTo = CountWeapon();
            for (w = 1; w <= loopTo; w++)
            {
                if (IsWeaponClassifiedAs(w, "共"))
                {
                    lv = WeaponLevel(w, "共");
                    // 弾数を合わせる
                    var loopTo1 = CountWeapon();
                    for (i = 1; i <= loopTo1; i++)
                    {
                        if (w != i && IsWeaponClassifiedAs(i, "共") && lv == WeaponLevel(i, "共") && MaxBullet(w) > 0)
                        {
                            if (MaxBullet(i) > MaxBullet(w))
                            {
                                SetBullet(i, GeneralLib.MinLng(Bullet(i), (MaxBullet(i) * Bullet(w)) / MaxBullet(w)));
                            }
                            else
                            {
                                SetBullet(i, GeneralLib.MinLng(Bullet(i), (MaxBullet(i) * Bullet(w) / (double)MaxBullet(w) + 0.49999d)));
                            }
                        }
                    }
                    // アビリティの使用回数を合わせる
                    var loopTo2 = CountAbility();
                    for (i = 1; i <= loopTo2; i++)
                    {
                        if (IsAbilityClassifiedAs(i, "共") && lv == AbilityLevel(i, "共") && MaxBullet(w) > 0)
                        {
                            if (MaxStock(i) > MaxBullet(w))
                            {
                                SetStock(i, GeneralLib.MinLng(Stock(i), (MaxStock(i) * Bullet(w)) / MaxBullet(w)));
                            }
                            else
                            {
                                SetStock(i, GeneralLib.MinLng(Stock(i), (MaxStock(i) * Bullet(w) / (double)MaxBullet(w) + 0.49999d)));
                            }
                        }
                    }
                }
            }

            // 共属性アビリティの処理
            var loopTo3 = CountAbility();
            for (a = 1; a <= loopTo3; a++)
            {
                if (IsAbilityClassifiedAs(a, "共"))
                {
                    lv = AbilityLevel(a, "共");
                    // 使用回数を合わせる
                    var loopTo4 = CountAbility();
                    for (i = 1; i <= loopTo4; i++)
                    {
                        if (a != i && IsAbilityClassifiedAs(i, "共") && lv == AbilityLevel(i, "共") && MaxStock(a) > 0)
                        {
                            if (MaxStock(i) > MaxStock(a))
                            {
                                SetStock(i, GeneralLib.MinLng(Stock(i), (MaxStock(i) * Stock(a)) / MaxStock(a)));
                            }
                            else
                            {
                                SetStock(i, GeneralLib.MinLng(Stock(i), (MaxStock(i) * Stock(a) / (double)MaxStock(a) + 0.49999d)));
                            }
                        }
                    }
                    // 弾数を合わせる
                    var loopTo5 = CountWeapon();
                    for (i = 1; i <= loopTo5; i++)
                    {
                        if (IsWeaponClassifiedAs(i, "共") && lv == WeaponLevel(i, "共") && MaxStock(a) > 0)
                        {
                            if (MaxBullet(i) > MaxStock(a))
                            {
                                SetBullet(i, GeneralLib.MinLng(Bullet(i), (MaxBullet(i) * Stock(a)) / MaxStock(a)));
                            }
                            else
                            {
                                SetBullet(i, GeneralLib.MinLng(Bullet(i), (MaxBullet(i) * Stock(a) / (double)MaxStock(a) + 0.49999d)));
                            }
                        }
                    }
                }
            }

            // 斉属性武器の処理
            var loopTo6 = CountWeapon();
            for (w = 1; w <= loopTo6; w++)
            {
                if (IsWeaponClassifiedAs(w, "斉"))
                {
                    // 弾数を合わせる
                    var loopTo7 = CountWeapon();
                    for (i = 1; i <= loopTo7; i++)
                    {
                        if (w != i && MaxBullet(i) > 0)
                        {
                            SetBullet(w, GeneralLib.MinLng(Bullet(w), (MaxBullet(w) * Bullet(i) / (double)MaxBullet(i) + 0.49999d)));
                        }
                    }
                }
            }

            // 他の形態の弾数も変更
            int counter;
            var loopTo8 = CountOtherForm();
            for (i = 1; i <= loopTo8; i++)
            {
                {
                    var withBlock = OtherForm(i);
                    idx = 1;
                    var loopTo9 = CountWeapon();
                    for (j = 1; j <= loopTo9; j++)
                    {
                        counter = idx;
                        var loopTo10 = withBlock.CountWeapon();
                        for (k = counter; k <= loopTo10; k++)
                        {
                            if ((Weapon(j).Name ?? "") == (withBlock.Weapon(k).Name ?? "") && MaxBullet(j) > 0 && withBlock.MaxBullet(k) > 0)
                            {
                                withBlock.SetBullet(k, ((withBlock.MaxBullet(k) * Bullet(j)) / MaxBullet(j)));
                                idx = (k + 1);
                                break;
                            }
                        }
                    }

                    idx = 1;
                    var loopTo11 = CountAbility();
                    for (j = 1; j <= loopTo11; j++)
                    {
                        counter = idx;
                        var loopTo12 = withBlock.CountAbility();
                        for (k = counter; k <= loopTo12; k++)
                        {
                            if ((Ability(j).Name ?? "") == (withBlock.Ability(k).Name ?? "") && MaxStock(j) > 0 && withBlock.MaxStock(k) > 0)
                            {
                                withBlock.SetStock(k, ((withBlock.MaxStock(k) * Stock(j)) / MaxStock(j)));
                                idx = (k + 1);
                                break;
                            }
                        }
                    }
                }
            }
        }



        // === アビリティ関連処理 ===

        // アビリティ
        public AbilityData Ability(int a)
        {
            AbilityData AbilityRet = default;
            AbilityRet = adata[a];
            return AbilityRet;
        }

        // アビリティ総数
        public int CountAbility()
        {
            int CountAbilityRet = default;
            CountAbilityRet = Information.UBound(adata);
            return CountAbilityRet;
        }

        // アビリティの愛称
        public string AbilityNickname(int a)
        {
            string AbilityNicknameRet = default;
            Unit u;

            // 愛称内の式置換のため、デフォルトユニットを一時的に変更する
            u = Event.SelectedUnitForEvent;
            Event.SelectedUnitForEvent = this;
            AbilityNicknameRet = adata[a].Nickname();
            Event.SelectedUnitForEvent = u;
            return AbilityNicknameRet;
        }

        // アビリティ a の最小射程
        public int AbilityMinRange(int a)
        {
            int AbilityMinRangeRet = default;
            AbilityMinRangeRet = Ability(a).MinRange;
            if (IsAbilityClassifiedAs(a, "小"))
            {
                AbilityMinRangeRet = GeneralLib.MinLng((AbilityMinRangeRet + AbilityLevel(a, "小")), Ability(a).MaxRange);
            }

            return AbilityMinRangeRet;
        }

        // アビリティ a の最大射程
        public int AbilityMaxRange(int a)
        {
            int AbilityMaxRangeRet = default;
            AbilityMaxRangeRet = Ability(a).MaxRange;
            return AbilityMaxRangeRet;
        }

        // アビリティ a の消費ＥＮ
        public int AbilityENConsumption(int a)
        {
            int AbilityENConsumptionRet = default;
            // UPGRADE_NOTE: rate は rate にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
            double rate;
            Pilot p;
            int i;
            {
                var withBlock = Ability(a);
                AbilityENConsumptionRet = withBlock.ENConsumption;

                // パイロットの能力によって術及び技の消費ＥＮは減少する
                if (CountPilot() > 0)
                {
                    p = MainPilot();

                    // 術に該当するか？
                    if (IsSpellAbility(a))
                    {
                        // 術に該当する場合は術技能によってＥＮ消費量を変える
                        switch (p.SkillLevel("術", ref_mode: ""))
                        {
                            case 1d:
                                {
                                    break;
                                }

                            case 2d:
                                {
                                    AbilityENConsumptionRet = (0.9d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 3d:
                                {
                                    AbilityENConsumptionRet = (0.8d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 4d:
                                {
                                    AbilityENConsumptionRet = (0.7d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 5d:
                                {
                                    AbilityENConsumptionRet = (0.6d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 6d:
                                {
                                    AbilityENConsumptionRet = (0.5d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 7d:
                                {
                                    AbilityENConsumptionRet = (0.45d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 8d:
                                {
                                    AbilityENConsumptionRet = (0.4d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 9d:
                                {
                                    AbilityENConsumptionRet = (0.35d * AbilityENConsumptionRet);
                                    break;
                                }

                            case var @case when @case >= 10d:
                                {
                                    AbilityENConsumptionRet = (0.3d * AbilityENConsumptionRet);
                                    break;
                                }
                        }

                        AbilityENConsumptionRet = GeneralLib.MinLng(GeneralLib.MaxLng(AbilityENConsumptionRet, 5), withBlock.ENConsumption);
                    }

                    // 技に該当するか？
                    if (IsFeatAbility(a))
                    {
                        // 技に該当する場合は技技能によってＥＮ消費量を変える
                        switch (p.SkillLevel("技", ref_mode: ""))
                        {
                            case 1d:
                                {
                                    break;
                                }

                            case 2d:
                                {
                                    AbilityENConsumptionRet = (0.9d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 3d:
                                {
                                    AbilityENConsumptionRet = (0.8d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 4d:
                                {
                                    AbilityENConsumptionRet = (0.7d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 5d:
                                {
                                    AbilityENConsumptionRet = (0.6d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 6d:
                                {
                                    AbilityENConsumptionRet = (0.5d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 7d:
                                {
                                    AbilityENConsumptionRet = (0.45d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 8d:
                                {
                                    AbilityENConsumptionRet = (0.4d * AbilityENConsumptionRet);
                                    break;
                                }

                            case 9d:
                                {
                                    AbilityENConsumptionRet = (0.35d * AbilityENConsumptionRet);
                                    break;
                                }

                            case var case1 when case1 >= 10d:
                                {
                                    AbilityENConsumptionRet = (0.3d * AbilityENConsumptionRet);
                                    break;
                                }
                        }

                        AbilityENConsumptionRet = GeneralLib.MinLng(GeneralLib.MaxLng(AbilityENConsumptionRet, 5), withBlock.ENConsumption);
                    }
                }

                // ＥＮ消費減少能力による修正
                rate = 1d;
                if (IsFeatureAvailable("ＥＮ消費減少"))
                {
                    var loopTo = CountFeature();
                    for (i = 1; i <= loopTo; i++)
                    {
                        if (Feature(i) == "ＥＮ消費減少")
                        {
                            double localFeatureLevel() { object argIndex1 = i; var ret = FeatureLevel(argIndex1); return ret; }

                            rate = rate - 0.1d * localFeatureLevel();
                        }
                    }
                }

                if (rate < 0.1d)
                {
                    rate = 0.1d;
                }

                AbilityENConsumptionRet = (rate * AbilityENConsumptionRet);
            }

            return AbilityENConsumptionRet;
        }

        // アビリティ a が属性 attr を持つかどうか
        public bool IsAbilityClassifiedAs(int a, string attr)
        {
            bool IsAbilityClassifiedAsRet = default;
            if (GeneralLib.InStrNotNest(Ability(a).Class, attr) > 0)
            {
                IsAbilityClassifiedAsRet = true;
            }
            else
            {
                IsAbilityClassifiedAsRet = false;
            }

            return IsAbilityClassifiedAsRet;
        }

        // アビリティ a の属性 atrr のレベル
        public double AbilityLevel(int a, string attr)
        {
            double AbilityLevelRet = default;
            string attrlv, aclass;
            int start_idx, i;
            string c;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 535884


            Input:

                    On Error GoTo ErrorHandler

             */
            attrlv = attr + "L";

            // アビリティ属性を調べてみる
            aclass = Ability(a).Class;

            // レベル指定があるか？
            start_idx = Strings.InStr(aclass, attrlv);
            if (start_idx == 0)
            {
                return AbilityLevelRet;
            }

            // レベル指定部分の切り出し
            start_idx = (start_idx + Strings.Len(attrlv));
            i = start_idx;
            while (true)
            {
                c = Strings.Mid(aclass, i, 1);
                if (string.IsNullOrEmpty(c))
                {
                    break;
                }

                switch (Strings.Asc(c))
                {
                    case var @case when 45 <= @case && @case <= 46:
                    case var case1 when 48 <= case1 && case1 <= 57: // "-", ".", 0-9
                        {
                            break;
                        }

                    default:
                        {
                            break;
                        }
                }

                i = (i + 1);
            }

            AbilityLevelRet = Conversions.ToDouble(Strings.Mid(aclass, start_idx, i - start_idx));
            return AbilityLevelRet;
            ErrorHandler:
            ;
            GUI.ErrorMessage(Name + "の" + "アビリティ「" + Ability(a).Name + "」の" + "属性「" + attr + "」のレベル指定が不正です");
        }

        // アビリティ a が術かどうか
        public bool IsSpellAbility(int a)
        {
            bool IsSpellAbilityRet = default;
            int i;
            string nskill;
            if (IsAbilityClassifiedAs(a, "術"))
            {
                IsSpellAbilityRet = true;
                return IsSpellAbilityRet;
            }

            {
                var withBlock = MainPilot();
                var loopTo = GeneralLib.LLength(Ability(a).NecessarySkill);
                for (i = 1; i <= loopTo; i++)
                {
                    nskill = GeneralLib.LIndex(Ability(a).NecessarySkill, i);
                    if (Strings.InStr(nskill, "Lv") > 0)
                    {
                        nskill = Strings.Left(nskill, Strings.InStr(nskill, "Lv") - 1);
                    }

                    if (withBlock.SkillType(nskill) == "術")
                    {
                        IsSpellAbilityRet = true;
                        return IsSpellAbilityRet;
                    }
                }
            }

            return IsSpellAbilityRet;
        }

        // アビリティ a が技かどうか
        public bool IsFeatAbility(int a)
        {
            bool IsFeatAbilityRet = default;
            int i;
            string nskill;
            if (IsAbilityClassifiedAs(a, "技"))
            {
                IsFeatAbilityRet = true;
                return IsFeatAbilityRet;
            }

            {
                var withBlock = MainPilot();
                var loopTo = GeneralLib.LLength(Ability(a).NecessarySkill);
                for (i = 1; i <= loopTo; i++)
                {
                    nskill = GeneralLib.LIndex(Ability(a).NecessarySkill, i);
                    if (Strings.InStr(nskill, "Lv") > 0)
                    {
                        nskill = Strings.Left(nskill, Strings.InStr(nskill, "Lv") - 1);
                    }

                    if (withBlock.SkillType(nskill) == "技")
                    {
                        IsFeatAbilityRet = true;
                        return IsFeatAbilityRet;
                    }
                }
            }

            return IsFeatAbilityRet;
        }

        // アビリティ a が使用可能かどうか
        // ref_mode はユニットの状態（移動前、移動後）を示す
        public bool IsAbilityAvailable(int a, string ref_mode)
        {
            bool IsAbilityAvailableRet = default;
            int j, i, k;
            AbilityData ad;
            string uname, pname;
            Unit u;
            IsAbilityAvailableRet = false;
            ad = Ability(a);

            // イベントコマンド「Disable」
            if (IsDisabled(ad.Name))
            {
                return IsAbilityAvailableRet;
            }

            // パイロットが乗っていなければ常に使用可能と判定
            if (CountPilot() == 0)
            {
                IsAbilityAvailableRet = true;
                return IsAbilityAvailableRet;
            }

            // 必要技能
            if (!IsAbilityMastered(a))
            {
                return IsAbilityAvailableRet;
            }

            // 必要条件
            if (!IsAbilityEnabled(a))
            {
                return IsAbilityAvailableRet;
            }

            // ステータス表示では必要技能だけ満たしていればＯＫ
            if (ref_mode == "インターミッション" || string.IsNullOrEmpty(ref_mode))
            {
                IsAbilityAvailableRet = true;
                return IsAbilityAvailableRet;
            }

            {
                var withBlock = MainPilot();
                // 必要気力
                if (ad.NecessaryMorale > 0)
                {
                    if (withBlock.Morale < ad.NecessaryMorale)
                    {
                        return IsAbilityAvailableRet;
                    }
                }

                // 霊力消費アビリティ
                if (IsAbilityClassifiedAs(a, "霊"))
                {
                    if (withBlock.Plana < AbilityLevel(a, "霊") * 5d)
                    {
                        return IsAbilityAvailableRet;
                    }
                }
                else if (IsAbilityClassifiedAs(a, "プ"))
                {
                    if (withBlock.Plana < AbilityLevel(a, "プ") * 5d)
                    {
                        return IsAbilityAvailableRet;
                    }
                }
            }

            // 属性使用不能状態
            if (ConditionLifetime("オーラ使用不能") > 0)
            {
                if (IsAbilityClassifiedAs(a, "オ"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            if (ConditionLifetime("超能力使用不能") > 0)
            {
                if (IsAbilityClassifiedAs(a, "超"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            if (ConditionLifetime("同調率使用不能") > 0)
            {
                if (IsAbilityClassifiedAs(a, "シ"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            if (ConditionLifetime("超感覚使用不能") > 0)
            {
                if (IsAbilityClassifiedAs(a, "サ"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            if (ConditionLifetime("知覚強化使用不能") > 0)
            {
                if (IsAbilityClassifiedAs(a, "サ"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            if (ConditionLifetime("霊力使用不能") > 0)
            {
                if (IsAbilityClassifiedAs(a, "霊"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            if (ConditionLifetime("術使用不能") > 0)
            {
                if (IsAbilityClassifiedAs(a, "術"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            if (ConditionLifetime("技使用不能") > 0)
            {
                if (IsAbilityClassifiedAs(a, "技"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            var loopTo = CountCondition();
            for (i = 1; i <= loopTo; i++)
            {
                string localCondition3() { object argIndex1 = i; var ret = Condition(argIndex1); return ret; }

                if (Strings.Len(localCondition3()) > 6)
                {
                    string localCondition2() { object argIndex1 = i; var ret = Condition(argIndex1); return ret; }

                    if (Strings.Right(localCondition2(), 6) == "属性使用不能")
                    {
                        string localCondition() { object argIndex1 = i; var ret = Condition(argIndex1); return ret; }

                        string localCondition1() { object argIndex1 = i; var ret = Condition(argIndex1); return ret; }

                        if (GeneralLib.InStrNotNest(Ability(a).Class, Strings.Left(localCondition(), Strings.Len(localCondition1()) - 6)) > 0)
                        {
                            return IsAbilityAvailableRet;
                        }
                    }
                }
            }

            // 弾数が足りるか
            if (MaxStock(a) > 0)
            {
                if (Stock(a) < 1)
                {
                    return IsAbilityAvailableRet;
                }
            }

            // ＥＮが足りるか
            if (ad.ENConsumption > 0)
            {
                if (EN < AbilityENConsumption(a))
                {
                    return IsAbilityAvailableRet;
                }
            }

            // お金が足りるか……
            if (Party == "味方")
            {
                if (IsAbilityClassifiedAs(a, "銭"))
                {
                    if (SRC.Money < GeneralLib.MaxLng(AbilityLevel(a, "銭"), 1) * Value / 10)
                    {
                        return IsAbilityAvailableRet;
                    }
                }
            }

            // 移動不能時には移動型マップアビリティは使用不能
            if (IsConditionSatisfied("移動不能"))
            {
                if (IsAbilityClassifiedAs(a, "Ｍ移"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            // 術及び音声技は沈黙状態では使用不能
            if (IsConditionSatisfied("沈黙"))
            {
                {
                    var withBlock1 = MainPilot();
                    if (IsSpellAbility(a) || IsAbilityClassifiedAs(a, "音"))
                    {
                        return IsAbilityAvailableRet;
                    }
                }
            }

            // 術は狂戦士状態では使用不能
            if (IsConditionSatisfied("狂戦士"))
            {
                {
                    var withBlock2 = MainPilot();
                    if (IsSpellAbility(a))
                    {
                        return IsAbilityAvailableRet;
                    }
                }
            }

            // 合体技の処理
            if (IsAbilityClassifiedAs(a, "合"))
            {
                if (!IsCombinationAbilityAvailable(a))
                {
                    return IsAbilityAvailableRet;
                }
            }

            // この地形で変形できるか？
            if (IsAbilityClassifiedAs(a, "変"))
            {
                if (IsFeatureAvailable("変形技"))
                {
                    var loopTo1 = CountFeature();
                    for (i = 1; i <= loopTo1; i++)
                    {
                        string localFeature() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                        string localFeatureData1() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        string localLIndex1() { string arglist = hsc19c10c9cae54732ac7c9c2e90257bd2(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                        if (localFeature() == "変形技" && (localLIndex1() ?? "") == (ad.Name ?? ""))
                        {
                            string localFeatureData() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            string localLIndex() { string arglist = hs999a427db36f427e9868be6a72c4f4c0(); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                            Unit localOtherForm() { object argIndex1 = (object)hsb208b29f50af4a41be714b7083a85c98(); var ret = OtherForm(argIndex1); return ret; }

                            if (!localOtherForm().IsAbleToEnter(x, y))
                            {
                                return IsAbilityAvailableRet;
                            }
                        }
                    }
                }
                else if (IsFeatureAvailable("ノーマルモード"))
                {
                    string localLIndex2() { object argIndex1 = "ノーマルモード"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                    Unit localOtherForm1() { object argIndex1 = (object)hs89e8cc23250142a2b15ab7b087ddcbd2(); var ret = OtherForm(argIndex1); return ret; }

                    if (!localOtherForm1().IsAbleToEnter(x, y))
                    {
                        return IsAbilityAvailableRet;
                    }
                }

                if (IsConditionSatisfied("形態固定"))
                {
                    return IsAbilityAvailableRet;
                }

                if (IsConditionSatisfied("機体固定"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            // 瀕死時限定
            if (IsAbilityClassifiedAs(a, "瀕"))
            {
                if (HP > MaxHP / 4)
                {
                    return IsAbilityAvailableRet;
                }
            }

            // 自動チャージアビリティを充填中
            if (IsConditionSatisfied(AbilityNickname(a) + "充填中"))
            {
                return IsAbilityAvailableRet;
            }
            // 共有武器＆アビリティが充填中の場合も使用不可
            int lv;
            if (IsAbilityClassifiedAs(a, "共"))
            {
                lv = AbilityLevel(a, "共");
                var loopTo2 = CountAbility();
                for (i = 1; i <= loopTo2; i++)
                {
                    if (IsAbilityClassifiedAs(i, "共"))
                    {
                        if (lv == AbilityLevel(i, "共"))
                        {
                            if (IsConditionSatisfied(AbilityNickname(i) + "充填中"))
                            {
                                return IsAbilityAvailableRet;
                            }
                        }
                    }
                }

                var loopTo3 = CountAbility();
                for (i = 1; i <= loopTo3; i++)
                {
                    if (IsAbilityClassifiedAs(i, "共"))
                    {
                        if (lv == AbilityLevel(i, "共"))
                        {
                            if (IsConditionSatisfied(AbilityNickname(i) + "充填中"))
                            {
                                return IsAbilityAvailableRet;
                            }
                        }
                    }
                }
            }

            // 使用禁止
            if (Conversions.ToInteger(IsAbilityClassifiedAs(a, "禁")) > 0)
            {
                return IsAbilityAvailableRet;
            }

            // チャージ判定であればここまででＯＫ
            if (ref_mode == "チャージ")
            {
                IsAbilityAvailableRet = true;
                return IsAbilityAvailableRet;
            }

            // チャージ式アビリティ
            if (IsAbilityClassifiedAs(a, "Ｃ"))
            {
                if (!IsConditionSatisfied("チャージ完了"))
                {
                    return IsAbilityAvailableRet;
                }
            }

            var loopTo4 = ad.CountEffect();
            for (i = 1; i <= loopTo4; i++)
            {
                if (ad.EffectType(i) == "召喚")
                {
                    // 召喚は既に召喚を行っている場合には不可能
                    var loopTo5 = CountServant();
                    for (j = 1; j <= loopTo5; j++)
                    {
                        Unit localServant() { object argIndex1 = j; var ret = Servant(argIndex1); return ret; }

                        {
                            var withBlock3 = localServant().CurrentForm();
                            switch (withBlock3.Status ?? "")
                            {
                                case "出撃":
                                case "格納":
                                    {
                                        // 使用不可
                                        return IsAbilityAvailableRet;
                                    }

                                case "旧主形態":
                                case "旧形態":
                                    {
                                        // 合体後の形態が出撃中なら使用不可
                                        var loopTo6 = withBlock3.CountFeature();
                                        for (k = 1; k <= loopTo6; k++)
                                        {
                                            if (withBlock3.Feature(k) == "合体")
                                            {
                                                string localFeatureData2() { object argIndex1 = k; var ret = withBlock3.FeatureData(argIndex1); return ret; }

                                                uname = GeneralLib.LIndex(localFeatureData2(), 2);
                                                if (SRC.UList.IsDefined(uname))
                                                {
                                                    Unit localItem() { object argIndex1 = uname; var ret = SRC.UList.Item(argIndex1); return ret; }

                                                    {
                                                        var withBlock4 = localItem().CurrentForm();
                                                        if (withBlock4.Status == "出撃" || withBlock4.Status == "格納")
                                                        {
                                                            return IsAbilityAvailableRet;
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        break;
                                    }
                            }
                        }
                    }

                    // 召喚ユニットのデータがちゃんと定義されているかチェック
                    string localEffectData() { object argIndex1 = i; var ret = ad.EffectData(argIndex1); return ret; }

                    bool localIsDefined() { object argIndex1 = (object)hsdeb28db1320b43f3b566123058fdd2af(); var ret = SRC.UDList.IsDefined(argIndex1); return ret; }

                    if (!localIsDefined())
                    {
                        return IsAbilityAvailableRet;
                    }

                    string localEffectData1() { object argIndex1 = i; var ret = ad.EffectData(argIndex1); return ret; }

                    UnitData localItem1() { object argIndex1 = (object)hsdcada415e8eb41c68f44c81ef2bb94c6(); var ret = SRC.UDList.Item(argIndex1); return ret; }

                    pname = localItem1().FeatureData("追加パイロット");
                    bool localIsDefined1() { object argIndex1 = pname; var ret = SRC.PDList.IsDefined(argIndex1); return ret; }

                    if (!localIsDefined1())
                    {
                        return IsAbilityAvailableRet;
                    }

                    // 召喚するユニットに乗るパイロットが汎用パイロットでもザコパイロットでも
                    // ない場合、そのユニットが既に出撃中であれば使用不可
                    if (Strings.InStr(pname, "(汎用)") == 0 && Strings.InStr(pname, "(ザコ)") == 0)
                    {
                        if (SRC.PList.IsDefined(pname))
                        {
                            Pilot localItem2() { object argIndex1 = pname; var ret = SRC.PList.Item(argIndex1); return ret; }

                            u = localItem2().Unit;
                            if (u is object)
                            {
                                if (u.Status == "出撃" || u.Status == "格納")
                                {
                                    return IsAbilityAvailableRet;
                                }
                            }
                        }
                    }
                }
            }

            if (ref_mode == "ステータス")
            {
                IsAbilityAvailableRet = true;
                return IsAbilityAvailableRet;
            }

            var loopTo7 = ad.CountEffect();
            for (i = 1; i <= loopTo7; i++)
            {
                if (ad.EffectType(i) == "変身")
                {
                    // 自分を変身させる場合
                    if (this.Ability(a).MaxRange == 0)
                    {
                        // ノーマルモードを持つユニットは変身できない
                        // (変身からの復帰が出来ないため)
                        if (IsFeatureAvailable("ノーマルモード"))
                        {
                            return IsAbilityAvailableRet;
                        }

                        // その場所で変身可能か？
                        string localEffectData2() { object argIndex1 = i; var ret = Ability(a).EffectData(argIndex1); return ret; }

                        string localLIndex3() { string arglist = hsc2f37474313640f6843767ac6d51a5dd(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                        {
                            var withBlock5 = OtherForm(localLIndex3());
                            if (!withBlock5.IsAbleToEnter(x, y))
                            {
                                return IsAbilityAvailableRet;
                            }
                        }
                    }
                }
            }

            if (ref_mode == "移動前")
            {
                IsAbilityAvailableRet = true;
                return IsAbilityAvailableRet;
            }

            if (AbilityMaxRange(a) > 1 || AbilityMaxRange(a) == 0)
            {
                if (IsAbilityClassifiedAs(a, "Ｐ"))
                {
                    IsAbilityAvailableRet = true;
                }
                else
                {
                    IsAbilityAvailableRet = false;
                }
            }
            else
            {
                if (IsAbilityClassifiedAs(a, "Ｑ"))
                {
                    IsAbilityAvailableRet = false;
                }
                else
                {
                    IsAbilityAvailableRet = true;
                }
            }

            return IsAbilityAvailableRet;
        }

        // アビリティ a の必要技能を満たしているか。
        public bool IsAbilityMastered(int a)
        {
            bool IsAbilityMasteredRet = default;
            IsAbilityMasteredRet = IsNecessarySkillSatisfied(Ability(a).NecessarySkill, p: null);
            return IsAbilityMasteredRet;
        }

        // アビリティ a の必要条件を満たしているか。
        public bool IsAbilityEnabled(int a)
        {
            bool IsAbilityEnabledRet = default;
            IsAbilityEnabledRet = IsNecessarySkillSatisfied(Ability(a).NecessaryCondition, p: null);
            return IsAbilityEnabledRet;
        }

        // アビリティが使用可能であり、かつ射程内に有効なターゲットがいるかどうか
        public bool IsAbilityUseful(int a, string ref_mode)
        {
            bool IsAbilityUsefulRet = default;
            int i, j;
            int max_range, min_range;

            // アビリティが使用可能か？
            if (!IsAbilityAvailable(a, ref_mode))
            {
                IsAbilityUsefulRet = false;
                return IsAbilityUsefulRet;
            }

            // 投下型マップアビリティと扇型マップアビリティは特殊なので判定ができない
            // 移動型マップアビリティは移動手段として使うことを考慮
            if (IsAbilityClassifiedAs(a, "Ｍ投") || IsAbilityClassifiedAs(a, "Ｍ投"1) || IsAbilityClassifiedAs(a, "Ｍ投"2))
            {
                IsAbilityUsefulRet = true;
                return IsAbilityUsefulRet;
            }

            // 召喚は常に有用
            var loopTo = Ability(a).CountEffect();
            for (i = 1; i <= loopTo; i++)
            {
                if (Ability(a).EffectType(i) == "召喚")
                {
                    IsAbilityUsefulRet = true;
                    return IsAbilityUsefulRet;
                }
            }

            min_range = AbilityMinRange(a);
            max_range = AbilityMaxRange(a);

            // 使用する相手がいるか検索
            var loopTo1 = GeneralLib.MinLng(x + max_range, Map.MapWidth);
            for (i = GeneralLib.MaxLng(x - max_range, 1); i <= loopTo1; i++)
            {
                var loopTo2 = GeneralLib.MinLng(y + max_range, Map.MapHeight);
                for (j = GeneralLib.MaxLng(y - max_range, 1); j <= loopTo2; j++)
                {
                    if ((Math.Abs((x - i)) + Math.Abs((y - j))) > max_range)
                    {
                        goto NextLoop;
                    }

                    if (Map.MapDataForUnit[i, j] is null)
                    {
                        goto NextLoop;
                    }

                    if (IsAbilityEffective(a, Map.MapDataForUnit[i, j]))
                    {
                        IsAbilityUsefulRet = true;
                        return IsAbilityUsefulRet;
                    }

                    NextLoop:
                    ;
                }
            }

            IsAbilityUsefulRet = false;
            return IsAbilityUsefulRet;
        }

        // アビリティがターゲットtに対して有効(役に立つ)かどうか
        public bool IsAbilityEffective(int a, Unit t)
        {
            bool IsAbilityEffectiveRet = default;
            int i, j;
            string edata;
            double elevel;
            bool flag;
            {
                var withBlock = t;
                // 敵には使用できない。
                // IsEnemyでは魅了等がかかった味方ユニットを敵と認識してしまうので
                // ここでは独自の判定基準を使う
                switch (Party ?? "")
                {
                    case "味方":
                    case "ＮＰＣ":
                        {
                            if (withBlock.Party != "味方" && withBlock.Party0 != "味方" && withBlock.Party != "ＮＰＣ" && withBlock.Party0 != "ＮＰＣ")
                            {
                                return IsAbilityEffectiveRet;
                            }

                            break;
                        }

                    default:
                        {
                            if ((withBlock.Party ?? "") != (Party ?? "") && (withBlock.Party0 ?? "") != (Party ?? ""))
                            {
                                return IsAbilityEffectiveRet;
                            }

                            break;
                        }
                }

                // アビリティがそのユニットに対して適用可能か？
                if (!IsAbilityApplicable(a, t))
                {
                    return IsAbilityEffectiveRet;
                }

                IsAbilityEffectiveRet = true;
                var loopTo = Ability(a).CountEffect();
                for (i = 1; i <= loopTo; i++)
                {
                    edata = Ability(a).EffectData(i);
                    elevel = Ability(a).EffectLevel(i);
                    switch (Ability(a).EffectType(i) ?? "")
                    {
                        case "回復":
                            {
                                if (elevel > 0d)
                                {
                                    if (withBlock.HP < withBlock.MaxHP)
                                    {
                                        if (!withBlock.IsConditionSatisfied("ゾンビ"))
                                        {
                                            IsAbilityEffectiveRet = true;
                                            return IsAbilityEffectiveRet;
                                        }
                                    }

                                    IsAbilityEffectiveRet = false;
                                }
                                else
                                {
                                    // ＨＰを減少させるためのアビリティというのは有り得るので
                                    IsAbilityEffectiveRet = true;
                                    return IsAbilityEffectiveRet;
                                }

                                break;
                            }

                        case "治癒":
                            {
                                if (string.IsNullOrEmpty(edata))
                                {
                                    if (withBlock.ConditionLifetime("攻撃不能") > 0 || withBlock.ConditionLifetime("移動不能") > 0 || withBlock.ConditionLifetime("装甲劣化") > 0 || withBlock.ConditionLifetime("混乱") > 0 || withBlock.ConditionLifetime("恐怖") > 0 || withBlock.ConditionLifetime("踊り") > 0 || withBlock.ConditionLifetime("狂戦士") > 0 || withBlock.ConditionLifetime("ゾンビ") > 0 || withBlock.ConditionLifetime("回復不能") > 0 || withBlock.ConditionLifetime("石化") > 0 || withBlock.ConditionLifetime("凍結") > 0 || withBlock.ConditionLifetime("麻痺") > 0 || withBlock.ConditionLifetime("睡眠") > 0 || withBlock.ConditionLifetime("毒") > 0 || withBlock.ConditionLifetime("盲目") > 0 || withBlock.ConditionLifetime("沈黙") > 0 || withBlock.ConditionLifetime("魅了") > 0 || withBlock.ConditionLifetime("憑依") > 0 || withBlock.ConditionLifetime("オーラ使用不能") > 0 || withBlock.ConditionLifetime("超能力使用不能") > 0 || withBlock.ConditionLifetime("同調率使用不能") > 0 || withBlock.ConditionLifetime("超感覚使用不能") > 0 || withBlock.ConditionLifetime("知覚強化使用不能") > 0 || withBlock.ConditionLifetime("霊力使用不能") > 0 || withBlock.ConditionLifetime("術使用不能") > 0 || withBlock.ConditionLifetime("技使用不能") > 0)
                                    {
                                        IsAbilityEffectiveRet = true;
                                        return IsAbilityEffectiveRet;
                                    }

                                    var loopTo1 = withBlock.CountCondition();
                                    for (j = 1; j <= loopTo1; j++)
                                    {
                                        string localCondition2() { object argIndex1 = j; var ret = withBlock.Condition(argIndex1); return ret; }

                                        if (Strings.Len(localCondition2()) > 6)
                                        {
                                            // 前回書き忘れたのですが、
                                            // 弱点はともかく有効は一概にデメリットのみでもないので
                                            // 状態回復から除外してみました。
                                            string localCondition1() { object argIndex1 = j; var ret = withBlock.Condition(argIndex1); return ret; }

                                            if (Strings.Right(localCondition1(), 6) == "属性使用不能")
                                            {
                                                string localCondition() { object argIndex1 = j; var ret = withBlock.Condition(argIndex1); return ret; }

                                                if (withBlock.ConditionLifetime(localCondition()) > 0)
                                                {
                                                    IsAbilityEffectiveRet = true;
                                                    return IsAbilityEffectiveRet;
                                                }
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    var loopTo2 = GeneralLib.LLength(edata);
                                    for (j = 1; j <= loopTo2; j++)
                                    {
                                        if (withBlock.ConditionLifetime(GeneralLib.LIndex(edata, j)) > 0)
                                        {
                                            IsAbilityEffectiveRet = true;
                                            return IsAbilityEffectiveRet;
                                        }
                                    }
                                }

                                IsAbilityEffectiveRet = false;
                                break;
                            }

                        case "補給":
                            {
                                if (elevel > 0d)
                                {
                                    if (withBlock.EN < withBlock.MaxEN)
                                    {
                                        if (!withBlock.IsConditionSatisfied("ゾンビ"))
                                        {
                                            IsAbilityEffectiveRet = true;
                                            return IsAbilityEffectiveRet;
                                        }
                                    }

                                    IsAbilityEffectiveRet = false;
                                }

                                break;
                            }

                        case "霊力回復":
                        case "プラーナ回復":
                            {
                                if (elevel > 0d)
                                {
                                    if (withBlock.MainPilot().Plana < withBlock.MainPilot().MaxPlana())
                                    {
                                        IsAbilityEffectiveRet = true;
                                        return IsAbilityEffectiveRet;
                                    }

                                    IsAbilityEffectiveRet = false;
                                }

                                break;
                            }

                        case "ＳＰ回復":
                            {
                                if (elevel > 0d)
                                {
                                    if (withBlock.MainPilot().SP < withBlock.MainPilot().MaxSP)
                                    {
                                        IsAbilityEffectiveRet = true;
                                        return IsAbilityEffectiveRet;
                                    }

                                    var loopTo3 = withBlock.CountPilot();
                                    for (j = 2; j <= loopTo3; j++)
                                    {
                                        Pilot localPilot() { object argIndex1 = j; var ret = withBlock.Pilot(argIndex1); return ret; }

                                        Pilot localPilot1() { object argIndex1 = j; var ret = withBlock.Pilot(argIndex1); return ret; }

                                        if (localPilot().SP < localPilot1().MaxSP)
                                        {
                                            IsAbilityEffectiveRet = true;
                                            return IsAbilityEffectiveRet;
                                        }
                                    }

                                    var loopTo4 = withBlock.CountSupport();
                                    for (j = 1; j <= loopTo4; j++)
                                    {
                                        Pilot localSupport() { object argIndex1 = j; var ret = withBlock.Support(argIndex1); return ret; }

                                        Pilot localSupport1() { object argIndex1 = j; var ret = withBlock.Support(argIndex1); return ret; }

                                        if (localSupport().SP < localSupport1().MaxSP)
                                        {
                                            IsAbilityEffectiveRet = true;
                                            return IsAbilityEffectiveRet;
                                        }
                                    }

                                    if (withBlock.IsFeatureAvailable("追加サポート"))
                                    {
                                        if (withBlock.AdditionalSupport().SP < withBlock.AdditionalSupport().MaxSP)
                                        {
                                            IsAbilityEffectiveRet = true;
                                            return IsAbilityEffectiveRet;
                                        }
                                    }

                                    IsAbilityEffectiveRet = false;
                                }

                                break;
                            }

                        case "気力増加":
                            {
                                if (elevel > 0d)
                                {
                                    {
                                        var withBlock1 = withBlock.MainPilot();
                                        if (withBlock1.Morale < withBlock1.MaxMorale && withBlock1.Personality != "機械")
                                        {
                                            IsAbilityEffectiveRet = true;
                                            return IsAbilityEffectiveRet;
                                        }
                                    }

                                    var loopTo5 = withBlock.CountPilot();
                                    for (j = 2; j <= loopTo5; j++)
                                    {
                                        {
                                            var withBlock2 = withBlock.Pilot(j);
                                            if (withBlock2.Morale < withBlock2.MaxMorale && withBlock2.Personality != "機械")
                                            {
                                                IsAbilityEffectiveRet = true;
                                                return IsAbilityEffectiveRet;
                                            }
                                        }
                                    }

                                    var loopTo6 = withBlock.CountSupport();
                                    for (j = 1; j <= loopTo6; j++)
                                    {
                                        {
                                            var withBlock3 = withBlock.Support(j);
                                            if (withBlock3.Morale < withBlock3.MaxMorale && withBlock3.Personality != "機械")
                                            {
                                                IsAbilityEffectiveRet = true;
                                                return IsAbilityEffectiveRet;
                                            }
                                        }
                                    }

                                    if (withBlock.IsFeatureAvailable("追加サポート"))
                                    {
                                        {
                                            var withBlock4 = withBlock.AdditionalSupport();
                                            if (withBlock4.Morale < withBlock4.MaxMorale && withBlock4.Personality != "機械")
                                            {
                                                IsAbilityEffectiveRet = true;
                                                return IsAbilityEffectiveRet;
                                            }
                                        }
                                    }

                                    IsAbilityEffectiveRet = false;
                                }

                                break;
                            }

                        case "装填":
                            {
                                if (string.IsNullOrEmpty(edata))
                                {
                                    var loopTo7 = withBlock.CountWeapon();
                                    for (j = 1; j <= loopTo7; j++)
                                    {
                                        if (withBlock.Bullet(j) < withBlock.MaxBullet(j))
                                        {
                                            IsAbilityEffectiveRet = true;
                                            return IsAbilityEffectiveRet;
                                        }
                                    }
                                }
                                else
                                {
                                    var loopTo8 = withBlock.CountWeapon();
                                    for (j = 1; j <= loopTo8; j++)
                                    {
                                        if (withBlock.Bullet(j) < withBlock.MaxBullet(j))
                                        {
                                            if ((withBlock.WeaponNickname(j) ?? "") == (edata ?? "") || GeneralLib.InStrNotNest(withBlock.Weapon(j).Class, edata) > 0)
                                            {
                                                IsAbilityEffectiveRet = true;
                                                return IsAbilityEffectiveRet;
                                            }
                                        }
                                    }
                                }

                                IsAbilityEffectiveRet = false;
                                break;
                            }

                        case "付加":
                            {
                                bool localIsConditionSatisfied() { object argIndex1 = GeneralLib.LIndex(edata, 1) + "付加"; var ret = withBlock.IsConditionSatisfied(argIndex1); return ret; }

                                if (!localIsConditionSatisfied() || IsAbilityClassifiedAs(a, "除"))
                                {
                                    IsAbilityEffectiveRet = true;
                                    return IsAbilityEffectiveRet;
                                }

                                IsAbilityEffectiveRet = false;
                                break;
                            }

                        case "強化":
                            {
                                bool localIsConditionSatisfied1() { object argIndex1 = GeneralLib.LIndex(edata, 1) + "強化"; var ret = withBlock.IsConditionSatisfied(argIndex1); return ret; }

                                if (!localIsConditionSatisfied1() || IsAbilityClassifiedAs(a, "除"))
                                {
                                    IsAbilityEffectiveRet = true;
                                    return IsAbilityEffectiveRet;
                                }

                                IsAbilityEffectiveRet = false;
                                break;
                            }

                        case "状態":
                            {
                                bool localIsConditionSatisfied2() { object argIndex1 = edata; var ret = withBlock.IsConditionSatisfied(argIndex1); return ret; }

                                if (!localIsConditionSatisfied2())
                                {
                                    IsAbilityEffectiveRet = true;
                                    return IsAbilityEffectiveRet;
                                }

                                IsAbilityEffectiveRet = false;
                                break;
                            }

                        case "再行動":
                            {
                                if (this.Ability(a).MaxRange == 0)
                                {
                                    goto NextEffect;
                                }

                                if (withBlock.Action == 0 && withBlock.MaxAction() > 0)
                                {
                                    IsAbilityEffectiveRet = true;
                                    return IsAbilityEffectiveRet;
                                }

                                IsAbilityEffectiveRet = false;
                                break;
                            }

                        case "変身":
                            {
                                if (!withBlock.IsFeatureAvailable("ノーマルモード"))
                                {
                                    IsAbilityEffectiveRet = true;
                                    return IsAbilityEffectiveRet;
                                }

                                IsAbilityEffectiveRet = false;
                                break;
                            }

                        case "能力コピー":
                            {
                                if (ReferenceEquals(t, this) || IsFeatureAvailable("ノーマルモード") || Conversions.ToInteger(withBlock.IsConditionSatisfied("混乱")) > 0 || withBlock.IsEnemy(this) || IsEnemy(t))
                                {
                                    IsAbilityEffectiveRet = false;
                                    goto NextEffect;
                                }

                                if (Strings.InStr(edata, "サイズ制限強") > 0)
                                {
                                    if ((Size ?? "") != (withBlock.Size ?? ""))
                                    {
                                        IsAbilityEffectiveRet = false;
                                        goto NextEffect;
                                    }
                                }
                                else if (Strings.InStr(edata, "サイズ制限無し") == 0)
                                {
                                    switch (Size ?? "")
                                    {
                                        case "SS":
                                            {
                                                switch (withBlock.Size ?? "")
                                                {
                                                    case "M":
                                                    case "L":
                                                    case "LL":
                                                    case "XL":
                                                        {
                                                            IsAbilityEffectiveRet = false;
                                                            goto NextEffect;
                                                            break;
                                                        }
                                                }

                                                break;
                                            }

                                        case "S":
                                            {
                                                switch (withBlock.Size ?? "")
                                                {
                                                    case "L":
                                                    case "LL":
                                                    case "XL":
                                                        {
                                                            IsAbilityEffectiveRet = false;
                                                            goto NextEffect;
                                                            break;
                                                        }
                                                }

                                                break;
                                            }

                                        case "M":
                                            {
                                                switch (withBlock.Size ?? "")
                                                {
                                                    case "SS":
                                                    case "LL":
                                                    case "XL":
                                                        {
                                                            IsAbilityEffectiveRet = false;
                                                            goto NextEffect;
                                                            break;
                                                        }
                                                }

                                                break;
                                            }

                                        case "L":
                                            {
                                                switch (withBlock.Size ?? "")
                                                {
                                                    case "SS":
                                                    case "S":
                                                    case "XL":
                                                        {
                                                            IsAbilityEffectiveRet = false;
                                                            goto NextEffect;
                                                            break;
                                                        }
                                                }

                                                break;
                                            }

                                        case "LL":
                                            {
                                                switch (withBlock.Size ?? "")
                                                {
                                                    case "SS":
                                                    case "S":
                                                    case "M":
                                                        {
                                                            IsAbilityEffectiveRet = false;
                                                            goto NextEffect;
                                                            break;
                                                        }
                                                }

                                                break;
                                            }

                                        case "XL":
                                            {
                                                switch (withBlock.Size ?? "")
                                                {
                                                    case "SS":
                                                    case "S":
                                                    case "M":
                                                    case "L":
                                                        {
                                                            IsAbilityEffectiveRet = false;
                                                            goto NextEffect;
                                                            break;
                                                        }
                                                }

                                                break;
                                            }
                                    }
                                }

                                IsAbilityEffectiveRet = true;
                                return IsAbilityEffectiveRet;
                            }
                    }

                    NextEffect:
                    ;
                }

                // そもそも効果がないものは常に使用可能とみなす
                // (include等で特殊効果を定義していると仮定)
                if (IsAbilityEffectiveRet)
                {
                    return IsAbilityEffectiveRet;
                }
            }

            return IsAbilityEffectiveRet;
        }

        // アビリティがターゲットtに対して適用可能かどうか
        public bool IsAbilityApplicable(int a, Unit t)
        {
            bool IsAbilityApplicableRet = default;
            int i;
            string fname;
            if (IsAbilityClassifiedAs(a, "封"))
            {
                if (!t.Weakness(Ability(a).Class) && !t.Effective(Ability(a).Class))
                {
                    return IsAbilityApplicableRet;
                }
            }

            if (IsAbilityClassifiedAs(a, "限"))
            {
                bool localWeakness() { string argstring2 = "限"; string arganame = Strings.Mid(Ability(a).Class, GeneralLib.InStrNotNest(Ability(a).Class, argstring2) + 1); var ret = t.Weakness(arganame); return ret; }

                bool localEffective() { string argstring2 = "限"; string arganame = Strings.Mid(Ability(a).Class, GeneralLib.InStrNotNest(Ability(a).Class, argstring2) + 1); var ret = t.Effective(arganame); return ret; }

                if (!localWeakness() && !localEffective())
                {
                    return IsAbilityApplicableRet;
                }
            }

            if (ReferenceEquals(this, t))
            {
                // 支援専用アビリティは自分には使用できない
                if (!IsAbilityClassifiedAs(a, "援"))
                {
                    IsAbilityApplicableRet = true;
                }

                return IsAbilityApplicableRet;
            }

            // 無効化の対象になる場合は使用出来ない
            if (t.Immune(Ability(a).Class))
            {
                if (!t.Weakness(Ability(a).Class) && !t.Effective(Ability(a).Class))
                {
                    return IsAbilityApplicableRet;
                }
            }

            if (IsAbilityClassifiedAs(a, "視"))
            {
                if (t.IsConditionSatisfied("盲目"))
                {
                    return IsAbilityApplicableRet;
                }
            }

            {
                var withBlock = t.MainPilot();
                if (IsAbilityClassifiedAs(a, "対"))
                {
                    // UPGRADE_WARNING: Mod に新しい動作が指定されています。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="9B7D5ADD-D8FE-4819-A36C-6DEDAF088CC7"' をクリックしてください。
                    if (withBlock.Level % AbilityLevel(a, "対") != 0d)
                    {
                        return IsAbilityApplicableRet;
                    }
                }

                if (IsAbilityClassifiedAs(a, "精"))
                {
                    if (withBlock.Personality == "機械")
                    {
                        return IsAbilityApplicableRet;
                    }
                }

                if (IsAbilityClassifiedAs(a, "♂"))
                {
                    if (withBlock.Sex != "男性")
                    {
                        return IsAbilityApplicableRet;
                    }
                }

                if (IsAbilityClassifiedAs(a, "♀"))
                {
                    if (withBlock.Sex != "女性")
                    {
                        return IsAbilityApplicableRet;
                    }
                }
            }

            // 修理不可
            if (t.IsFeatureAvailable("修理不可"))
            {
                var loopTo = Ability(a).CountEffect();
                for (i = 1; i <= loopTo; i++)
                {
                    if (Ability(a).EffectType(i) == "回復")
                    {
                        break;
                    }
                }

                if (i <= Ability(a).CountEffect())
                {
                    var loopTo1 = Conversions.ToInteger(t.FeatureData("修理不可"));
                    for (i = 2; i <= loopTo1; i++)
                    {
                        fname = GeneralLib.LIndex(t.FeatureData("修理不可"), i);
                        if (Strings.Left(fname, 1) == "!")
                        {
                            fname = Strings.Mid(fname, 2);
                            if ((fname ?? "") != (AbilityNickname(a) ?? ""))
                            {
                                return IsAbilityApplicableRet;
                            }
                        }
                        else if ((fname ?? "") == (AbilityNickname(a) ?? ""))
                        {
                            return IsAbilityApplicableRet;
                        }
                    }
                }
            }

            IsAbilityApplicableRet = true;
            return IsAbilityApplicableRet;
        }

        // ユニット t がアビリティ a の射程範囲内にいるかをチェック
        public bool IsTargetWithinAbilityRange(int a, Unit t)
        {
            bool IsTargetWithinAbilityRangeRet = default;
            int distance;
            IsTargetWithinAbilityRangeRet = true;
            distance = (Math.Abs((x - t.x)) + Math.Abs((y - t.y)));

            // 最小射程チェック
            if (distance < AbilityMinRange(a))
            {
                IsTargetWithinAbilityRangeRet = false;
                return IsTargetWithinAbilityRangeRet;
            }

            // 最大射程チェック
            if (distance > AbilityMaxRange(a))
            {
                IsTargetWithinAbilityRangeRet = false;
                return IsTargetWithinAbilityRangeRet;
            }

            // 合体技で射程が１の場合は相手を囲んでいる必要がある
            var partners = default(Unit[]);
            if (IsAbilityClassifiedAs(a, "合") && !IsAbilityClassifiedAs(a, "Ｍ") && AbilityMaxRange(a) == 1)
            {
                CombinationPartner("アビリティ", a, partners, t.x, t.y);
                if (Information.UBound(partners) == 0)
                {
                    IsTargetWithinAbilityRangeRet = false;
                    return IsTargetWithinAbilityRangeRet;
                }
            }

            return IsTargetWithinAbilityRangeRet;
        }

        // 移動を併用した場合にユニット t がアビリティ a の射程範囲内にいるかをチェック
        public bool IsTargetReachableForAbility(int a, Unit t)
        {
            bool IsTargetReachableForAbilityRet = default;
            int i, j;
            int max_range;
            IsTargetReachableForAbilityRet = true;
            // 移動範囲から敵に攻撃が届くかをチェック
            max_range = AbilityMaxRange(a);
            var loopTo = GeneralLib.MinLng(t.x + max_range, Map.MapWidth);
            for (i = GeneralLib.MaxLng(t.x - max_range, 1); i <= loopTo; i++)
            {
                var loopTo1 = GeneralLib.MinLng(t.y + (max_range - Math.Abs((t.x - i))), Map.MapHeight);
                for (j = GeneralLib.MaxLng(t.y - (max_range - Math.Abs((t.x - i))), 1); j <= loopTo1; j++)
                {
                    if (!Map.MaskData[i, j])
                    {
                        return IsTargetReachableForAbilityRet;
                    }
                }
            }

            IsTargetReachableForAbilityRet = false;
            return IsTargetReachableForAbilityRet;
        }

        // アビリティの残り使用回数
        public int Stock(int a)
        {
            int StockRet = default;
            StockRet = (dblStock[a] * MaxStock(a));
            return StockRet;
        }

        // アビリティの最大使用回数
        public int MaxStock(int a)
        {
            int MaxStockRet = default;
            if (BossRank > 0)
            {
                MaxStockRet = (this.Ability(a).Stock * (5 + BossRank) / 5d);
            }
            else
            {
                MaxStockRet = Ability(a).Stock;
            }

            return MaxStockRet;
        }

        // アビリティの残り使用回数を設定
        public void SetStock(int a, int new_stock)
        {
            if (new_stock < 0)
            {
                dblStock[a] = 0d;
            }
            else if (MaxStock(a) > 0)
            {
                dblStock[a] = new_stock / (double)MaxStock(a);
            }
            else
            {
                dblStock[a] = 1d;
            }
        }



        // === アビリティ発動関連処理 ===

        // アビリティを使用
        public bool ExecuteAbility(int a, Unit t, bool is_map_ability = false, bool is_event = false)
        {
            bool ExecuteAbilityRet = default;
            var partners = default(Unit[]);
            int num, j, i, k, w = default;
            string aclass, aname, anickname, atype = default;
            string edata;
            double elevel, elevel2;
            double elv_mod, elv_mod2;
            int epower;
            int prev_value;
            bool is_useful = default, flag;
            Unit u;
            Pilot p;
            string buf, msg;
            string uname = default, pname, fname;
            string ftype, fdata;
            double flevel;
            string ftype2, fdata2;
            double flevel2;
            var is_anime_played = default(bool);
            double hp_ratio, en_ratio;
            int tx, ty;
            int tx2, ty2;
            string cname;
            aname = Ability(a).Name;
            anickname = AbilityNickname(a);
            aclass = Ability(a).Class;

            // 現在の選択状況をセーブ
            Commands.SaveSelections();

            // 選択内容を切り替え
            Commands.SelectedUnit = this;
            Event.SelectedUnitForEvent = this;
            Commands.SelectedTarget = t;
            Event.SelectedTargetForEvent = t;
            Commands.SelectedAbility = a;
            Commands.SelectedAbilityName = aname;
            if (!is_map_ability)
            {
                // 通常アビリティの場合
                if (SRC.BattleAnimation)
                {
                    GUI.RedrawScreen();
                }

                if (IsAbilityClassifiedAs(a, "合"))
                {
                    // 射程が0の場合はマスクをクリアしておく
                    if (AbilityMaxRange(a) == 0)
                    {
                        var loopTo = Map.MapWidth;
                        for (i = 1; i <= loopTo; i++)
                        {
                            var loopTo1 = Map.MapHeight;
                            for (j = 1; j <= loopTo1; j++)
                                Map.MaskData[i, j] = true;
                        }

                        Map.MaskData[x, y] = false;
                    }

                    // 合体技の場合にパートナーをハイライト表示
                    if (AbilityMaxRange(a) == 1)
                    {
                        CombinationPartner("アビリティ", a, partners, t.x, t.y);
                    }
                    else
                    {
                        CombinationPartner("アビリティ", a, partners);
                    }

                    var loopTo2 = Information.UBound(partners);
                    for (i = 1; i <= loopTo2; i++)
                    {
                        {
                            var withBlock = partners[i];
                            Map.MaskData[withBlock.x, withBlock.y] = false;
                        }
                    }

                    if (!SRC.BattleAnimation)
                    {
                        GUI.MaskScreen();
                    }
                }
                else
                {
                    partners = new Unit[1];
                    Commands.SelectedPartners = new Unit[1];
                }

                // ダイアログ用にあらかじめ追加パイロットを作成しておく
                var loopTo3 = Ability(a).CountEffect();
                for (i = 1; i <= loopTo3; i++)
                {
                    edata = Ability(a).EffectData(i);
                    switch (Ability(a).EffectType(i) ?? "")
                    {
                        case "変身":
                            {
                                bool localIsDefined() { object argIndex1 = GeneralLib.LIndex(edata, 1); var ret = SRC.UDList.IsDefined(argIndex1); return ret; }

                                if (!localIsDefined())
                                {
                                    GUI.ErrorMessage(GeneralLib.LIndex(edata, 1) + "のデータが定義されていません");
                                    return ExecuteAbilityRet;
                                }

                                {
                                    var withBlock1 = SRC.UDList.Item(GeneralLib.LIndex(edata, 1));
                                    if (withBlock1.IsFeatureAvailable("追加パイロット"))
                                    {
                                        bool localIsDefined1() { object argIndex1 = "追加パイロット"; object argIndex2 = withBlock1.FeatureData(argIndex1); var ret = SRC.PList.IsDefined(argIndex2); return ret; }

                                        if (!localIsDefined1())
                                        {
                                            SRC.PList.Add(withBlock1.FeatureData(argIndex2), MainPilot().Level, Party0, gid: "");
                                            this.Party0 = argpparty;
                                        }
                                    }
                                }

                                break;
                            }
                    }
                }

                // アビリティ使用時のメッセージ＆特殊効果
                if (IsAnimationDefined(aname + "(準備)", sub_situation: ""))
                {
                    PlayAnimation(aname + "(準備)", sub_situation: "");
                }

                if (IsMessageDefined("かけ声(" + aname + ")"))
                {
                    if (!My.MyProject.Forms.frmMessage.Visible)
                    {
                        if (ReferenceEquals(Commands.SelectedTarget, this))
                        {
                            GUI.OpenMessageForm(this, u2: null);
                        }
                        else
                        {
                            GUI.OpenMessageForm(Commands.SelectedTarget, this);
                        }
                    }

                    PilotMessage("かけ声(" + aname + ")", msg_mode: "");
                }

                if (IsMessageDefined(aname) || IsMessageDefined("アビリティ"))
                {
                    if (!My.MyProject.Forms.frmMessage.Visible)
                    {
                        if (ReferenceEquals(Commands.SelectedTarget, this))
                        {
                            GUI.OpenMessageForm(this, u2: null);
                        }
                        else
                        {
                            GUI.OpenMessageForm(Commands.SelectedTarget, this);
                        }
                    }

                    PilotMessage(aname, "アビリティ");
                }

                if (IsAnimationDefined(aname + "(使用)", sub_situation: ""))
                {
                    PlayAnimation(aname + "(使用)", "", true);
                }

                if (IsAnimationDefined(aname + "(発動)", sub_situation: "") || IsAnimationDefined(aname, sub_situation: ""))
                {
                    PlayAnimation(aname + "(発動)", "", true);
                    is_anime_played = true;
                }
                else
                {
                    SpecialEffect(aname, "", true);
                }

                // アビリティの種類は？
                var loopTo4 = Ability(a).CountEffect();
                for (i = 1; i <= loopTo4; i++)
                {
                    switch (Ability(a).EffectType(i) ?? "")
                    {
                        case "召喚":
                            {
                                aname = "";
                                break;
                            }

                        case "再行動":
                            {
                                if (this.Ability(a).MaxRange > 0)
                                {
                                    atype = Ability(a).EffectType(i);
                                }

                                break;
                            }

                        case "解説":
                            {
                                break;
                            }

                        default:
                            {
                                atype = Ability(a).EffectType(i);
                                break;
                            }
                    }
                }

                switch (Information.UBound(partners))
                {
                    case 0:
                        {
                            // 通常
                            msg = Nickname + "は";
                            break;
                        }

                    case 1:
                        {
                            // ２体合体
                            if ((Nickname ?? "") != (partners[1].Nickname ?? ""))
                            {
                                msg = Nickname + "は[" + partners[1].Nickname + "]と共に";
                            }
                            else if ((MainPilot().get_Nickname(false) ?? "") != (partners[1].MainPilot().get_Nickname(false) ?? ""))
                            {
                                msg = MainPilot().get_Nickname(false) + "と[" + partners[1].MainPilot().get_Nickname(false) + "]の[" + Nickname + "]は";
                            }
                            else
                            {
                                msg = Nickname + "達は";
                            }

                            break;
                        }

                    case 2:
                        {
                            // ３体合体
                            if ((Nickname ?? "") != (partners[1].Nickname ?? ""))
                            {
                                msg = Nickname + "は[" + partners[1].Nickname + "]、[" + partners[2].Nickname + "]と共に";
                            }
                            else if ((MainPilot().get_Nickname(false) ?? "") != (partners[1].MainPilot().get_Nickname(false) ?? ""))
                            {
                                msg = MainPilot().get_Nickname(false) + "、[" + partners[1].MainPilot().get_Nickname(false) + "]、[" + partners[2].MainPilot().get_Nickname(false) + "]の[" + Nickname + "]は";
                            }
                            else
                            {
                                msg = Nickname + "達は";
                            }

                            break;
                        }

                    default:
                        {
                            // ３体以上
                            msg = Nickname + "達は";
                            break;
                        }
                }

                if (IsSpellAbility(a))
                {
                    if (t is object && this.Ability(a).MaxRange != 0)
                    {
                        if (ReferenceEquals(this, t))
                        {
                            msg = msg + "自分に";
                        }
                        else
                        {
                            msg = msg + "[" + t.Nickname + "]に";
                        }
                    }

                    if (Strings.Right(anickname, 2) == "呪文")
                    {
                        msg = msg + "[" + anickname + "]を唱えた。";
                    }
                    else if (Strings.Right(anickname, 2) == "の杖")
                    {
                        msg = msg + "[" + Strings.Left(anickname, Strings.Len(anickname) - 2) + "]の呪文を唱えた。";
                    }
                    else
                    {
                        msg = msg + "[" + anickname + "]の呪文を唱えた。";
                    }
                }
                else if (Strings.Right(anickname, 1) == "歌")
                {
                    msg = msg + "[" + anickname + "]を歌った。";
                }
                else if (Strings.Right(anickname, 2) == "踊り")
                {
                    msg = msg + "[" + anickname + "]を踊った。";
                }
                else
                {
                    if (t is object && this.Ability(a).MaxRange != 0)
                    {
                        if (ReferenceEquals(this, t))
                        {
                            msg = msg + "自分に";
                        }
                        else
                        {
                            msg = msg + "[" + t.Nickname + "]に";
                        }
                    }

                    msg = msg + "[" + anickname + "]を使った。";
                }

                if (IsSysMessageDefined(aname, sub_situation: ""))
                {
                    // 「アビリティ名(解説)」のメッセージを使用
                    if (!My.MyProject.Forms.frmMessage.Visible)
                    {
                        if (ReferenceEquals(Commands.SelectedTarget, this))
                        {
                            GUI.OpenMessageForm(this, u2: null);
                        }
                        else
                        {
                            GUI.OpenMessageForm(Commands.SelectedTarget, this);
                        }
                    }

                    SysMessage(aname, sub_situation: "", add_msg: "");
                }
                else if (IsSysMessageDefined("アビリティ", sub_situation: ""))
                {
                    // 「アビリティ(解説)」のメッセージを使用
                    if (!My.MyProject.Forms.frmMessage.Visible)
                    {
                        if (ReferenceEquals(Commands.SelectedTarget, this))
                        {
                            GUI.OpenMessageForm(this, u2: null);
                        }
                        else
                        {
                            GUI.OpenMessageForm(Commands.SelectedTarget, this);
                        }
                    }

                    SysMessage("アビリティ", sub_situation: "", add_msg: "");
                }
                else if (atype == "変身" && this.Ability(a).MaxRange == 0)
                {
                }
                // 変身の場合はメッセージなし
                else if (!string.IsNullOrEmpty(atype))
                {
                    if (!My.MyProject.Forms.frmMessage.Visible)
                    {
                        if (ReferenceEquals(Commands.SelectedTarget, this))
                        {
                            GUI.OpenMessageForm(this, u2: null);
                        }
                        else
                        {
                            GUI.OpenMessageForm(Commands.SelectedTarget, this);
                        }
                    }

                    GUI.DisplaySysMessage(msg);
                }

                // ＥＮ消費＆使用回数減少
                UseAbility(a);

                // アビリティの使用に失敗？
                if (GeneralLib.Dice(10) <= AbilityLevel(a, "難"))
                {
                    GUI.DisplaySysMessage("しかし何もおきなかった…");
                    goto Finish;
                }
            }
            else
            {
                // マップアビリティの場合
                if (IsAnimationDefined(aname + "(発動)", sub_situation: "") || IsAnimationDefined(aname, sub_situation: ""))
                {
                    PlayAnimation(aname + "(発動)", sub_situation: "");
                    is_anime_played = true;
                }
            }

            // 相手がアビリティの属性に対して無効化属性を持っているならアビリティは
            // 効果なし
            if (!ReferenceEquals(this, t))
            {
                if (t.Immune(aclass))
                {
                    goto Finish;
                }
            }

            // 気力低下アビリティ
            if (IsAbilityClassifiedAs(a, "脱"))
            {
                t.IncreaseMorale(-10);
            }

            // 特殊効果除去アビリティ
            if (IsAbilityClassifiedAs(a, "除"))
            {
                i = 1;
                while (i <= t.CountCondition())
                {
                    string localCondition() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                    string localCondition1() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                    string localCondition2() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                    string localCondition3() { object argIndex1 = i; var ret = t.Condition(argIndex1); return ret; }

                    int localConditionLifetime() { object argIndex1 = i; var ret = t.ConditionLifetime(argIndex1); return ret; }

                    if ((Strings.InStr(localCondition(), "付加") > 0 || Strings.InStr(localCondition1(), "強化") > 0 || Strings.InStr(localCondition2(), "ＵＰ") > 0) && localCondition3() != "ノーマルモード付加" && localConditionLifetime() != 0)
                    {
                        t.DeleteCondition(i);
                    }
                    else
                    {
                        i = (i + 1);
                    }
                }
            }

            // 得意技・不得手によるアビリティ効果への修正値を計算
            elv_mod = 1d;
            elv_mod2 = 1d;
            {
                var withBlock2 = MainPilot();
                // 得意技
                if (withBlock2.IsSkillAvailable("得意技"))
                {
                    buf = withBlock2.SkillData("得意技");
                    var loopTo5 = Strings.Len(buf);
                    for (i = 1; i <= loopTo5; i++)
                    {
                        if (Strings.InStr(aclass, GeneralLib.GetClassBundle(buf, i)) > 0)
                        {
                            elv_mod = 1.2d * elv_mod;
                            elv_mod2 = 1.4d * elv_mod2;
                            break;
                        }
                    }
                }

                // 不得手
                if (withBlock2.IsSkillAvailable("不得手"))
                {
                    buf = withBlock2.SkillData("不得手");
                    var loopTo6 = Strings.Len(buf);
                    for (i = 1; i <= loopTo6; i++)
                    {
                        if (Strings.InStr(aclass, GeneralLib.GetClassBundle(buf, i)) > 0)
                        {
                            elv_mod = 0.8d * elv_mod;
                            elv_mod2 = 0.6d * elv_mod2;
                            break;
                        }
                    }
                }
            }

            // アビリティの効果を適用
            var loopTo7 = Ability(a).CountEffect();
            for (i = 1; i <= loopTo7; i++)
            {
                {
                    var withBlock3 = Ability(a);
                    edata = withBlock3.EffectData(i);
                    elevel = withBlock3.EffectLevel(i) * elv_mod;
                    elevel2 = withBlock3.EffectLevel(i) * elv_mod2;
                }

                switch (Ability(a).EffectType(i) ?? "")
                {
                    case "回復":
                        {
                            {
                                var withBlock4 = t;
                                if (elevel > 0d)
                                {
                                    // ＨＰは既に最大値？
                                    if (withBlock4.HP == withBlock4.MaxHP)
                                    {
                                        goto NextLoop;
                                    }

                                    // ゾンビ？
                                    if (withBlock4.IsConditionSatisfied("ゾンビ"))
                                    {
                                        goto NextLoop;
                                    }

                                    if (!is_anime_played)
                                    {
                                        if (IsSpellAbility(a) || IsAbilityClassifiedAs(a, "魔"))
                                        {
                                            Effect.ShowAnimation("回復魔法発動");
                                        }
                                        else
                                        {
                                            Effect.ShowAnimation("修理装置発動");
                                        }
                                    }

                                    prev_value = withBlock4.HP;
                                    {
                                        var withBlock5 = MainPilot();
                                        if (IsSpellAbility(a))
                                        {
                                            epower = (5d * elevel * withBlock5.Shooting);
                                        }
                                        else
                                        {
                                            epower = (500d * elevel);
                                        }

                                        epower = ((long)(epower * (10d + withBlock5.SkillLevel("修理", ref_mode: ""))) / 10L);
                                    }

                                    t.HP = t.HP + epower;
                                    GUI.DrawSysString(withBlock4.x, withBlock4.y, "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock4.HP - prev_value));
                                    if (ReferenceEquals(t, this))
                                    {
                                        GUI.UpdateMessageForm(this, u2: null);
                                    }
                                    else
                                    {
                                        GUI.UpdateMessageForm(t, this);
                                    }

                                    GUI.DisplaySysMessage(withBlock4.Nickname + "の" + Expression.Term("ＨＰ", t) + "が[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock4.HP - prev_value) + "]回復した;" + "残り" + Expression.Term("ＨＰ", t) + "は" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock4.HP) + "（損傷率 = " + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (withBlock4.MaxHP - withBlock4.HP) / withBlock4.MaxHP) + "％）");
                                    is_useful = true;
                                }
                                else if (elevel < 0d)
                                {
                                    prev_value = withBlock4.HP;
                                    {
                                        var withBlock6 = MainPilot();
                                        if (IsSpellAbility(a))
                                        {
                                            epower = (5d * elevel * withBlock6.Shooting);
                                        }
                                        else
                                        {
                                            epower = (500d * elevel);
                                        }
                                    }

                                    t.HP = t.HP + epower;
                                    GUI.DrawSysString(withBlock4.x, withBlock4.y, "-" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock4.HP));
                                    if (ReferenceEquals(t, this))
                                    {
                                        GUI.UpdateMessageForm(this, u2: null);
                                    }
                                    else
                                    {
                                        GUI.UpdateMessageForm(t, this);
                                    }

                                    GUI.DisplaySysMessage(withBlock4.Nickname + "の" + Expression.Term("ＨＰ", t) + "が[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock4.HP) + "]減少した;" + "残り" + Expression.Term("ＨＰ", t) + "は" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock4.HP) + "（損傷率 = " + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (withBlock4.MaxHP - withBlock4.HP) / withBlock4.MaxHP) + "％）");
                                }
                            }

                            break;
                        }

                    case "補給":
                        {
                            {
                                var withBlock7 = t;
                                if (elevel > 0d)
                                {
                                    // ＥＮは既に最大値？
                                    if (withBlock7.EN == withBlock7.MaxEN)
                                    {
                                        goto NextLoop;
                                    }

                                    // ゾンビ？
                                    if (withBlock7.IsConditionSatisfied("ゾンビ"))
                                    {
                                        goto NextLoop;
                                    }

                                    if (!is_anime_played)
                                    {
                                        if (IsSpellAbility(a) || IsAbilityClassifiedAs(a, "魔"))
                                        {
                                            Effect.ShowAnimation("回復魔法発動");
                                        }
                                        else
                                        {
                                            Effect.ShowAnimation("補給装置発動");
                                        }
                                    }

                                    prev_value = withBlock7.EN;
                                    {
                                        var withBlock8 = MainPilot();
                                        if (IsSpellAbility(a))
                                        {
                                            epower = ((long)(elevel * withBlock8.Shooting) / 2L);
                                        }
                                        else
                                        {
                                            epower = (50d * elevel);
                                        }

                                        epower = ((long)(epower * (10d + withBlock8.SkillLevel("補給", ref_mode: ""))) / 10L);
                                    }

                                    t.EN = t.EN + epower;
                                    GUI.DrawSysString(withBlock7.x, withBlock7.y, "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock7.EN - prev_value));
                                    if (ReferenceEquals(t, this))
                                    {
                                        GUI.UpdateMessageForm(this, u2: null);
                                    }
                                    else
                                    {
                                        GUI.UpdateMessageForm(t, this);
                                    }

                                    GUI.DisplaySysMessage(withBlock7.Nickname + "の" + Expression.Term("ＥＮ", t) + "が[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock7.EN - prev_value) + "]回復した;" + "残り" + Expression.Term("ＥＮ", t) + "は" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock7.EN));
                                    is_useful = true;
                                }
                                else if (elevel < 0d)
                                {
                                    // ＥＮは既に0？
                                    if (withBlock7.EN == 0)
                                    {
                                        goto NextLoop;
                                    }

                                    prev_value = withBlock7.EN;
                                    {
                                        var withBlock9 = MainPilot();
                                        if (IsSpellAbility(a))
                                        {
                                            epower = ((long)(elevel * withBlock9.Shooting) / 2L);
                                        }
                                        else
                                        {
                                            epower = (50d * elevel);
                                        }
                                    }

                                    t.EN = t.EN + epower;
                                    GUI.DrawSysString(withBlock7.x, withBlock7.y, "-" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock7.EN));
                                    if (ReferenceEquals(t, this))
                                    {
                                        GUI.UpdateMessageForm(this, u2: null);
                                    }
                                    else
                                    {
                                        GUI.UpdateMessageForm(t, this);
                                    }

                                    GUI.DisplaySysMessage(withBlock7.Nickname + "の" + Expression.Term("ＥＮ", t) + "が[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock7.EN) + "]減少した;" + "残り" + Expression.Term("ＥＮ", t) + "は" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock7.EN));
                                }
                            }

                            break;
                        }

                    case "霊力回復":
                    case "プラーナ回復":
                        {
                            {
                                var withBlock10 = t.MainPilot();
                                if (elevel > 0d)
                                {
                                    // 霊力は既に最大値？
                                    if (withBlock10.Plana == withBlock10.MaxPlana())
                                    {
                                        goto NextLoop;
                                    }

                                    prev_value = withBlock10.Plana;
                                    if (IsSpellAbility(a))
                                    {
                                        withBlock10.Plana = withBlock10.Plana + ((long)(elevel * this.MainPilot().Shooting) / 10L);
                                    }
                                    else
                                    {
                                        withBlock10.Plana = (withBlock10.Plana + 10d * elevel);
                                    }

                                    GUI.DrawSysString(t.x, t.y, "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock10.Plana - prev_value));
                                    if (ReferenceEquals(t, this))
                                    {
                                        GUI.UpdateMessageForm(this, u2: null);
                                    }
                                    else
                                    {
                                        GUI.UpdateMessageForm(t, this);
                                    }

                                    GUI.DisplaySysMessage(withBlock10.get_Nickname(false) + "の[" + withBlock10.SkillName0("霊力") + "]が[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock10.Plana - prev_value) + "]回復した。");
                                    is_useful = true;
                                }
                                else if (elevel < 0d)
                                {
                                    // 霊力は既に0？
                                    if (withBlock10.Plana == 0)
                                    {
                                        goto NextLoop;
                                    }

                                    prev_value = withBlock10.Plana;
                                    if (IsSpellAbility(a))
                                    {
                                        withBlock10.Plana = withBlock10.Plana + ((long)(elevel * this.MainPilot().Shooting) / 10L);
                                    }
                                    else
                                    {
                                        withBlock10.Plana = (withBlock10.Plana + 10d * elevel);
                                    }

                                    GUI.DrawSysString(t.x, t.y, "-" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock10.Plana));
                                    if (ReferenceEquals(t, this))
                                    {
                                        GUI.UpdateMessageForm(this, u2: null);
                                    }
                                    else
                                    {
                                        GUI.UpdateMessageForm(t, this);
                                    }

                                    GUI.DisplaySysMessage(withBlock10.get_Nickname(false) + "の[" + withBlock10.SkillName0("霊力") + "]が[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock10.Plana) + "]減少した。");
                                }
                            }

                            break;
                        }

                    case "ＳＰ回復":
                        {
                            if (IsSpellAbility(a))
                            {
                                epower = ((long)(elevel * this.MainPilot().Shooting) / 10L);
                            }
                            else
                            {
                                epower = (10d * elevel);
                            }

                            {
                                var withBlock11 = t;
                                // パイロット数を計算
                                num = (withBlock11.CountPilot() + withBlock11.CountSupport());
                                if (withBlock11.IsFeatureAvailable("追加サポート"))
                                {
                                    num = (num + 1);
                                }

                                if (elevel > 0d)
                                {
                                    if (num == 1)
                                    {
                                        // パイロットが１名のみ
                                        {
                                            var withBlock12 = withBlock11.MainPilot();
                                            prev_value = withBlock12.SP;
                                            withBlock12.SP = withBlock12.SP + epower;
                                            GUI.DrawSysString(t.x, t.y, "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock12.SP - prev_value));
                                            GUI.DisplaySysMessage(withBlock12.get_Nickname(false) + "の" + Expression.Term("ＳＰ", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock12.SP - prev_value) + "回復した。");
                                            if (withBlock12.SP > prev_value)
                                            {
                                                is_useful = true;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // 複数のパイロットが対象
                                        {
                                            var withBlock13 = withBlock11.MainPilot();
                                            prev_value = withBlock13.SP;
                                            withBlock13.SP = withBlock13.SP + epower / 5 + epower / num;
                                            GUI.DrawSysString(t.x, t.y, "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock13.SP - prev_value));
                                            GUI.DisplaySysMessage(withBlock13.get_Nickname(false) + "の" + Expression.Term("ＳＰ", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock13.SP - prev_value) + "回復した。");
                                            if (withBlock13.SP > prev_value)
                                            {
                                                is_useful = true;
                                            }
                                        }

                                        var loopTo8 = withBlock11.CountPilot();
                                        for (j = 2; j <= loopTo8; j++)
                                        {
                                            {
                                                var withBlock14 = withBlock11.Pilot("追加パイロット"0);
                                                prev_value = withBlock14.SP;
                                                withBlock14.SP = withBlock14.SP + epower / 5 + epower / num;
                                                GUI.DisplaySysMessage(withBlock14.get_Nickname(false) + "の" + Expression.Term("ＳＰ", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock14.SP - prev_value) + "回復した。");
                                                if (withBlock14.SP > prev_value)
                                                {
                                                    is_useful = true;
                                                }
                                            }
                                        }

                                        var loopTo9 = withBlock11.CountSupport();
                                        for (j = 1; j <= loopTo9; j++)
                                        {
                                            {
                                                var withBlock15 = withBlock11.Support(j);
                                                prev_value = withBlock15.SP;
                                                withBlock15.SP = withBlock15.SP + epower / 5 + epower / num;
                                                GUI.DisplaySysMessage(withBlock15.get_Nickname(false) + "の" + Expression.Term("ＳＰ", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock15.SP - prev_value) + "回復した。");
                                                if (withBlock15.SP > prev_value)
                                                {
                                                    is_useful = true;
                                                }
                                            }
                                        }

                                        if (withBlock11.IsFeatureAvailable("追加サポート"))
                                        {
                                            {
                                                var withBlock16 = withBlock11.AdditionalSupport();
                                                prev_value = withBlock16.SP;
                                                withBlock16.SP = withBlock16.SP + epower / 5 + epower / num;
                                                GUI.DisplaySysMessage(withBlock16.get_Nickname(false) + "の" + Expression.Term("ＳＰ", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock16.SP - prev_value) + "回復した。");
                                                if (withBlock16.SP > prev_value)
                                                {
                                                    is_useful = true;
                                                }
                                            }
                                        }
                                    }
                                }
                                else if (elevel < 0d)
                                {
                                    if (num == 1)
                                    {
                                        // パイロットが１名のみ
                                        {
                                            var withBlock17 = withBlock11.MainPilot();
                                            prev_value = withBlock17.SP;
                                            withBlock17.SP = withBlock17.SP + epower;
                                            GUI.DrawSysString(t.x, t.y, "-" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock17.SP));
                                            GUI.DisplaySysMessage(withBlock17.get_Nickname(false) + "の" + Expression.Term("ＳＰ", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock17.SP) + "減少した。");
                                        }
                                    }
                                    else
                                    {
                                        // 複数のパイロットが対象
                                        {
                                            var withBlock18 = withBlock11.MainPilot();
                                            prev_value = withBlock18.SP;
                                            withBlock18.SP = withBlock18.SP + epower / 5 + epower / num;
                                            GUI.DrawSysString(t.x, t.y, "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock18.SP));
                                            GUI.DisplaySysMessage(withBlock18.get_Nickname(false) + "の" + Expression.Term("ＳＰ", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock18.SP) + "減少した。");
                                        }

                                        var loopTo10 = withBlock11.CountPilot();
                                        for (j = 2; j <= loopTo10; j++)
                                        {
                                            {
                                                var withBlock19 = withBlock11.Pilot(j);
                                                prev_value = withBlock19.SP;
                                                withBlock19.SP = withBlock19.SP + epower / 5 + epower / num;
                                                GUI.DisplaySysMessage(withBlock19.get_Nickname(false) + "の" + Expression.Term("ＳＰ", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock19.SP) + "減少した。");
                                            }
                                        }

                                        var loopTo11 = withBlock11.CountSupport();
                                        for (j = 1; j <= loopTo11; j++)
                                        {
                                            {
                                                var withBlock20 = withBlock11.Support(j);
                                                prev_value = withBlock20.SP;
                                                withBlock20.SP = withBlock20.SP + epower / 5 + epower / num;
                                                GUI.DisplaySysMessage(withBlock20.get_Nickname(false) + "の" + Expression.Term("ＳＰ", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock20.SP) + "減少した。");
                                            }
                                        }

                                        if (withBlock11.IsFeatureAvailable("追加サポート"))
                                        {
                                            {
                                                var withBlock21 = withBlock11.AdditionalSupport();
                                                prev_value = withBlock21.SP;
                                                withBlock21.SP = withBlock21.SP + epower / 5 + epower / num;
                                                GUI.DisplaySysMessage(withBlock21.get_Nickname(false) + "の" + Expression.Term("ＳＰ", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock21.SP) + "減少した。");
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        }

                    case "気力増加":
                        {
                            if (IsSpellAbility(a))
                            {
                                epower = ((long)(elevel * this.MainPilot().Shooting) / 10L);
                            }
                            else
                            {
                                epower = (10d * elevel);
                            }

                            {
                                var withBlock22 = t;
                                prev_value = withBlock22.MainPilot().Morale;
                                withBlock22.IncreaseMorale(epower);
                                if (elevel > 0d)
                                {
                                    {
                                        var withBlock23 = withBlock22.MainPilot();
                                        GUI.DrawSysString(t.x, t.y, "+" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock23.Morale - prev_value));
                                        GUI.DisplaySysMessage(withBlock23.get_Nickname(false) + "の" + Expression.Term("気力", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock23.Morale - prev_value) + "増加した。");
                                    }
                                }
                                else if (elevel < 0d)
                                {
                                    {
                                        var withBlock24 = withBlock22.MainPilot();
                                        GUI.DrawSysString(t.x, t.y, "-" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock24.Morale));
                                        GUI.DisplaySysMessage(withBlock24.get_Nickname(false) + "の" + Expression.Term("気力", t) + "が" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(prev_value - withBlock24.Morale) + "減少した。");
                                    }
                                }

                                if (withBlock22.MainPilot().Morale > prev_value)
                                {
                                    is_useful = true;
                                }
                            }

                            break;
                        }

                    case "装填":
                        {
                            {
                                var withBlock25 = t;
                                flag = false;
                                if (string.IsNullOrEmpty(edata))
                                {
                                    // 全ての武器の弾数を回復
                                    var loopTo12 = withBlock25.CountWeapon();
                                    for (j = 1; j <= loopTo12; j++)
                                    {
                                        if (withBlock25.Bullet(j) < withBlock25.MaxBullet(j))
                                        {
                                            withBlock25.BulletSupply();
                                            flag = true;
                                            break;
                                        }
                                    }

                                    // 弾数とアビリティ使用回数の同期を取る
                                    if (flag)
                                    {
                                        var loopTo13 = withBlock25.CountAbility();
                                        for (j = 1; j <= loopTo13; j++)
                                        {
                                            if (withBlock25.IsAbilityClassifiedAs(j, "共"))
                                            {
                                                var loopTo14 = withBlock25.CountWeapon();
                                                for (k = 1; k <= loopTo14; k++)
                                                {
                                                    if (withBlock25.IsWeaponClassifiedAs(k, "共") && withBlock25.AbilityLevel(j, "共") == withBlock25.WeaponLevel(k, "共"))
                                                    {
                                                        withBlock25.SetStock(j, withBlock25.MaxStock(j));
                                                    }
                                                }
                                            }
                                        }

                                        // 弾数・使用回数の共有化処理
                                        withBlock25.SyncBullet();
                                    }
                                }
                                else
                                {
                                    // 特定の武器の弾数のみを回復
                                    var loopTo15 = withBlock25.CountWeapon();
                                    for (j = 1; j <= loopTo15; j++)
                                    {
                                        if (withBlock25.Bullet(j) < withBlock25.MaxBullet(j))
                                        {
                                            if ((withBlock25.WeaponNickname(j) ?? "") == (edata ?? "") || GeneralLib.InStrNotNest(withBlock25.Weapon(j).Class, edata) > 0)
                                            {
                                                withBlock25.SetBullet(j, withBlock25.MaxBullet(j));
                                                flag = true;
                                                w = j;
                                            }
                                        }
                                    }

                                    var loopTo16 = withBlock25.CountOtherForm();
                                    for (j = 1; j <= loopTo16; j++)
                                    {
                                        {
                                            var withBlock26 = withBlock25.OtherForm(j);
                                            var loopTo17 = withBlock26.CountWeapon();
                                            for (k = 1; k <= loopTo17; k++)
                                            {
                                                if (withBlock26.Bullet(k) < withBlock26.MaxBullet(k))
                                                {
                                                    if ((withBlock26.WeaponNickname(k) ?? "") == (edata ?? "") || GeneralLib.InStrNotNest(withBlock26.Weapon(k).Class, edata) > 0)
                                                    {
                                                        withBlock26.SetBullet(k, withBlock26.MaxBullet(k));
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    // 弾数の同期を取る
                                    if (flag)
                                    {
                                        if (withBlock25.IsWeaponClassifiedAs(w, "共"))
                                        {
                                            var loopTo18 = withBlock25.CountWeapon();
                                            for (j = 1; j <= loopTo18; j++)
                                            {
                                                if (withBlock25.IsWeaponClassifiedAs(j, "共") && withBlock25.WeaponLevel(j, "共") == withBlock25.WeaponLevel(w, "共"))
                                                {
                                                    withBlock25.SetBullet(j, withBlock25.MaxBullet(j));
                                                }
                                            }

                                            var loopTo19 = withBlock25.CountAbility();
                                            for (j = 1; j <= loopTo19; j++)
                                            {
                                                if (withBlock25.IsAbilityClassifiedAs(j, "共") && withBlock25.AbilityLevel(j, "共") == withBlock25.WeaponLevel(w, "共"))
                                                {
                                                    withBlock25.SetStock(j, withBlock25.MaxStock(j));
                                                }
                                            }
                                        }

                                        // 弾数・使用回数の共有化処理
                                        withBlock25.SyncBullet();
                                    }
                                }

                                if (flag)
                                {
                                    GUI.DisplaySysMessage(withBlock25.Nickname + "の武装の使用回数が回復した。");
                                    if (AbilityMaxRange(a) > 0)
                                    {
                                        is_useful = true;
                                    }
                                }
                            }

                            break;
                        }

                    case "治癒":
                        {
                            {
                                var withBlock27 = t;
                                if (!is_anime_played)
                                {
                                    if (IsSpellAbility(a) || IsAbilityClassifiedAs(a, "魔"))
                                    {
                                        Effect.ShowAnimation("回復魔法発動");
                                    }
                                }

                                if (string.IsNullOrEmpty(edata))
                                {
                                    // 全てのステータス異常を回復
                                    if (withBlock27.ConditionLifetime("攻撃不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("攻撃不能");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("移動不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("移動不能");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("装甲劣化") > 0)
                                    {
                                        withBlock27.DeleteCondition("装甲劣化");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("混乱") > 0)
                                    {
                                        withBlock27.DeleteCondition("混乱");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("恐怖") > 0)
                                    {
                                        withBlock27.DeleteCondition("恐怖");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("踊り") > 0)
                                    {
                                        withBlock27.DeleteCondition("踊り");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("狂戦士") > 0)
                                    {
                                        withBlock27.DeleteCondition("狂戦士");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("ゾンビ") > 0)
                                    {
                                        withBlock27.DeleteCondition("ゾンビ");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("回復不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("回復不能");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("石化") > 0)
                                    {
                                        withBlock27.DeleteCondition("石化");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("凍結") > 0)
                                    {
                                        withBlock27.DeleteCondition("凍結");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("麻痺") > 0)
                                    {
                                        withBlock27.DeleteCondition("麻痺");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("睡眠") > 0)
                                    {
                                        withBlock27.DeleteCondition("睡眠");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("毒") > 0)
                                    {
                                        withBlock27.DeleteCondition("毒");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("盲目") > 0)
                                    {
                                        withBlock27.DeleteCondition("盲目");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("沈黙") > 0)
                                    {
                                        withBlock27.DeleteCondition("沈黙");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("魅了") > 0)
                                    {
                                        withBlock27.DeleteCondition("魅了");
                                        is_useful = true;
                                    }

                                    if (withBlock27.ConditionLifetime("憑依") > 0)
                                    {
                                        withBlock27.DeleteCondition("憑依");
                                        is_useful = true;
                                    }
                                    // 剋属性
                                    if (withBlock27.ConditionLifetime("オーラ使用不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("オーラ使用不能");
                                    }

                                    if (withBlock27.ConditionLifetime("超能力使用不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("超能力使用不能");
                                    }

                                    if (withBlock27.ConditionLifetime("同調率使用不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("同調率使用不能");
                                    }

                                    if (withBlock27.ConditionLifetime("超感覚使用不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("超感覚使用不能");
                                    }

                                    if (withBlock27.ConditionLifetime("知覚強化使用不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("知覚強化使用不能");
                                    }

                                    if (withBlock27.ConditionLifetime("霊力使用不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("霊力使用不能");
                                    }

                                    if (withBlock27.ConditionLifetime("術使用不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("術使用不能");
                                    }

                                    if (withBlock27.ConditionLifetime("技使用不能") > 0)
                                    {
                                        withBlock27.DeleteCondition("技使用不能");
                                    }

                                    j = 1;
                                    while (j <= withBlock27.CountCondition())
                                    {
                                        // 弱点、有効付加はあえて外してあります。
                                        string localCondition5() { object argIndex1 = j; var ret = withBlock27.Condition(argIndex1); return ret; }

                                        string localCondition6() { object argIndex1 = j; var ret = withBlock27.Condition(argIndex1); return ret; }

                                        string localCondition7() { object argIndex1 = j; var ret = withBlock27.Condition(argIndex1); return ret; }

                                        int localConditionLifetime1() { object argIndex1 = (object)hs35eef8b33aab4975b1c788eecf306c48(); var ret = withBlock27.ConditionLifetime(argIndex1); return ret; }

                                        if (Strings.Len(localCondition5()) > 6 && Strings.Right(localCondition6(), 6) == "属性使用不能" && localConditionLifetime1() > 0)
                                        {
                                            string localCondition4() { object argIndex1 = j; var ret = withBlock27.Condition(argIndex1); return ret; }

                                            withBlock27.DeleteCondition(localCondition4());
                                            is_useful = true;
                                        }
                                        else
                                        {
                                            j = (j + 1);
                                        }
                                    }

                                    if (is_useful)
                                    {
                                        if (ReferenceEquals(t, CurrentForm()))
                                        {
                                            GUI.UpdateMessageForm(t, u2: null);
                                        }
                                        else
                                        {
                                            GUI.UpdateMessageForm(t, CurrentForm());
                                        }

                                        GUI.DisplaySysMessage(withBlock27.Nickname + "の状態が回復した。");
                                    }
                                }
                                else
                                {
                                    // 指定されたステータス異常のみを回復
                                    j = 1;
                                    while (j <= GeneralLib.LLength(edata))
                                    {
                                        cname = GeneralLib.LIndex(edata, j);
                                        if (withBlock27.ConditionLifetime(cname) > 0)
                                        {
                                            withBlock27.DeleteCondition(cname);
                                            if (ReferenceEquals(t, CurrentForm()))
                                            {
                                                GUI.UpdateMessageForm(t, u2: null);
                                            }
                                            else
                                            {
                                                GUI.UpdateMessageForm(t, CurrentForm());
                                            }

                                            if (cname == "装甲劣化")
                                            {
                                                cname = Expression.Term("装甲", t) + "劣化";
                                            }

                                            GUI.DisplaySysMessage(withBlock27.Nickname + "の[" + cname + "]が回復した。");
                                            is_useful = true;
                                        }
                                        else
                                        {
                                            j = (j + 1);
                                        }
                                    }
                                }
                            }

                            break;
                        }

                    case "付加":
                        {
                            {
                                var withBlock28 = t;
                                if (elevel2 == 0d)
                                {
                                    // レベル指定がない場合は付加が半永久的に持続
                                    elevel2 = 10000d;
                                }
                                else
                                {
                                    // そうでなければ最低１ターンは効果が持続
                                    elevel2 = GeneralLib.MaxLng(elevel2, 1);
                                }

                                // 効果時間が継続中？
                                if (withBlock28.IsConditionSatisfied(GeneralLib.LIndex(edata, 1) + "付加"))
                                {
                                    goto NextLoop;
                                }

                                ftype = GeneralLib.LIndex(edata, 1);
                                flevel = Conversions.ToDouble(GeneralLib.LIndex(edata, 2));
                                fdata = "";
                                var loopTo20 = GeneralLib.LLength(edata);
                                for (j = 3; j <= loopTo20; j++)
                                    fdata = fdata + GeneralLib.LIndex(edata, j) + " ";
                                fdata = Strings.Trim(fdata);
                                if (Strings.Left(fdata, 1) == "\"" && Strings.Right(fdata, 1) == "\"")
                                {
                                    fdata = Strings.Trim(Strings.Mid(fdata, 2, Strings.Len(fdata) - 2));
                                }

                                // エリアスが定義されている？
                                if (SRC.ALDList.IsDefined(ftype))
                                {
                                    {
                                        var withBlock29 = SRC.ALDList.Item(ftype);
                                        var loopTo21 = withBlock29.Count;
                                        for (j = 1; j <= loopTo21; j++)
                                        {
                                            // エリアスの定義に従って特殊能力定義を置き換える
                                            ftype2 = withBlock29.get_AliasType(j);
                                            string localLIndex() { string arglist = withBlock29.get_AliasData(j); var ret = GeneralLib.LIndex(arglist, 1); withBlock29.get_AliasData(j) = arglist; return ret; }

                                            if (localLIndex() == "解説")
                                            {
                                                // 特殊能力の解説
                                                if (!string.IsNullOrEmpty(fdata))
                                                {
                                                    ftype2 = GeneralLib.LIndex(fdata, 1);
                                                }

                                                flevel2 = SRC.DEFAULT_LEVEL;
                                                fdata2 = withBlock29.get_AliasData(j);
                                            }
                                            else
                                            {
                                                // 通常の特殊能力
                                                if (withBlock29.get_AliasLevelIsPlusMod(j))
                                                {
                                                    if (flevel == SRC.DEFAULT_LEVEL)
                                                    {
                                                        flevel = 1d;
                                                    }

                                                    flevel2 = flevel + withBlock29.get_AliasLevel(j);
                                                }
                                                else if (withBlock29.get_AliasLevelIsMultMod(j))
                                                {
                                                    if (flevel == SRC.DEFAULT_LEVEL)
                                                    {
                                                        flevel = 1d;
                                                    }

                                                    flevel2 = flevel * withBlock29.get_AliasLevel(j);
                                                }
                                                else if (flevel != SRC.DEFAULT_LEVEL)
                                                {
                                                    flevel2 = flevel;
                                                }
                                                else
                                                {
                                                    flevel2 = withBlock29.get_AliasLevel(j);
                                                }

                                                fdata2 = withBlock29.get_AliasData(j);
                                                if (!string.IsNullOrEmpty(fdata))
                                                {
                                                    if (Strings.InStr(fdata2, "非表示") != 1)
                                                    {
                                                        fdata2 = fdata + " " + GeneralLib.ListTail(fdata2, (GeneralLib.LLength(fdata) + 1));
                                                    }
                                                }
                                            }

                                            t.AddCondition(ftype2 + "付加", elevel2, flevel2, fdata2);
                                        }
                                    }
                                }
                                else
                                {
                                    withBlock28.AddCondition(ftype + "付加", elevel2, flevel, fdata);
                                }

                                withBlock28.Update();
                                if (ReferenceEquals(t, CurrentForm()))
                                {
                                    GUI.UpdateMessageForm(t, u2: null);
                                }
                                else
                                {
                                    GUI.UpdateMessageForm(t, CurrentForm());
                                }

                                switch (GeneralLib.LIndex(edata, 1) ?? "")
                                {
                                    case "耐性":
                                    case "無効化":
                                    case "吸収":
                                        {
                                            GUI.DisplaySysMessage(withBlock28.Nickname + "は[" + GeneralLib.LIndex(edata, 3) + "]属性に対する[" + GeneralLib.LIndex(edata, 1) + "]能力を得た。");
                                            break;
                                        }

                                    case "特殊効果無効化":
                                        {
                                            GUI.DisplaySysMessage(withBlock28.Nickname + "は[" + GeneralLib.LIndex(edata, 3) + "]属性に対する無効化能力を得た。");
                                            break;
                                        }

                                    case "攻撃属性":
                                        {
                                            GUI.DisplaySysMessage(withBlock28.Nickname + "は[" + GeneralLib.LIndex(edata, 3) + "]の攻撃属性を得た。");
                                            break;
                                        }

                                    case "武器強化":
                                        {
                                            GUI.DisplaySysMessage(withBlock28.Nickname + "の" + "武器の攻撃力が上がった。");
                                            break;
                                        }

                                    case "命中率強化":
                                        {
                                            GUI.DisplaySysMessage(withBlock28.Nickname + "の" + "武器の命中率が上がった。");
                                            break;
                                        }

                                    case "ＣＴ率強化":
                                        {
                                            GUI.DisplaySysMessage(withBlock28.Nickname + "の" + "武器のＣＴ率が上がった。");
                                            break;
                                        }

                                    case "特殊効果発動率強化":
                                        {
                                            GUI.DisplaySysMessage(withBlock28.Nickname + "の" + "武器の特殊効果発動率が上がった。");
                                            break;
                                        }

                                    case "射程延長":
                                        {
                                            GUI.DisplaySysMessage(withBlock28.Nickname + "の" + "武器の射程が伸びた。");
                                            break;
                                        }

                                    case "サイズ変更":
                                        {
                                            GUI.DisplaySysMessage(withBlock28.Nickname + "の" + "サイズが" + Strings.StrConv(GeneralLib.LIndex(edata, 3), VbStrConv.Wide) + "サイズに変化した。");
                                            break;
                                        }
                                    // メッセージを表示しない。
                                    case "パイロット愛称":
                                    case "パイロット画像":
                                    case "愛称変更":
                                    case "ユニット画像":
                                    case "ＢＧＭ":
                                        {
                                            break;
                                        }

                                    default:
                                        {
                                            // 付加する能力名
                                            fname = GeneralLib.ListIndex(fdata, 1);
                                            if (string.IsNullOrEmpty(fname) || fname == "非表示")
                                            {
                                                if ((GeneralLib.LIndex(edata, 2) ?? "") != (Microsoft.VisualBasic.Compatibility.VB6.Support.Format(SRC.DEFAULT_LEVEL) ?? ""))
                                                {
                                                    fname = GeneralLib.LIndex(edata, 1) + "Lv" + GeneralLib.LIndex(edata, 2);
                                                }
                                                else
                                                {
                                                    fname = GeneralLib.LIndex(edata, 1);
                                                }
                                            }

                                            GUI.DisplaySysMessage(withBlock28.Nickname + "は[" + fname + "]の能力を得た。");
                                            break;
                                        }
                                }

                                if (AbilityMaxRange(a) > 0)
                                {
                                    is_useful = true;
                                }
                            }

                            break;
                        }

                    case "強化":
                        {
                            {
                                var withBlock30 = t;
                                if (elevel2 == 0d)
                                {
                                    // レベル指定がない場合は付加が半永久的に持続
                                    elevel2 = 10000d;
                                }
                                else
                                {
                                    // そうでなければ最低１ターンは効果が持続
                                    elevel2 = GeneralLib.MaxLng(elevel2, 1);
                                }

                                // 効果時間が継続中？
                                if (withBlock30.IsConditionSatisfied(GeneralLib.LIndex(edata, 1) + "強化"))
                                {
                                    goto NextLoop;
                                }

                                ftype = GeneralLib.LIndex(edata, 1);
                                flevel = Conversions.ToDouble(GeneralLib.LIndex(edata, 2));
                                fdata = "";
                                var loopTo22 = GeneralLib.LLength(edata);
                                for (j = 3; j <= loopTo22; j++)
                                    fdata = fdata + GeneralLib.LIndex(edata, j) + " ";
                                fdata = Strings.Trim(fdata);

                                // エリアスが定義されている？
                                if (SRC.ALDList.IsDefined(ftype))
                                {
                                    {
                                        var withBlock31 = SRC.ALDList.Item(ftype);
                                        var loopTo23 = withBlock31.Count;
                                        for (j = 1; j <= loopTo23; j++)
                                        {
                                            // エリアスの定義に従って特殊能力定義を置き換える
                                            ftype2 = withBlock31.get_AliasType(i);
                                            string localLIndex1() { string arglist = withBlock31.get_AliasData(j); var ret = GeneralLib.LIndex(arglist, 1); withBlock31.get_AliasData(j) = arglist; return ret; }

                                            if (localLIndex1() == "解説")
                                            {
                                                // 特殊能力の解説
                                                if (!string.IsNullOrEmpty(fdata))
                                                {
                                                    ftype2 = GeneralLib.LIndex(fdata, 1);
                                                }

                                                flevel2 = SRC.DEFAULT_LEVEL;
                                                fdata2 = withBlock31.get_AliasData(j);
                                                t.AddCondition(ftype2 + "付加", elevel2, flevel2, fdata2);
                                            }
                                            else
                                            {
                                                // 通常の特殊能力
                                                if (withBlock31.get_AliasLevelIsMultMod(j))
                                                {
                                                    if (flevel == SRC.DEFAULT_LEVEL)
                                                    {
                                                        flevel = 1d;
                                                    }

                                                    flevel2 = flevel * withBlock31.get_AliasLevel(j);
                                                }
                                                else if (flevel != SRC.DEFAULT_LEVEL)
                                                {
                                                    flevel2 = flevel;
                                                }
                                                else
                                                {
                                                    flevel2 = withBlock31.get_AliasLevel(j);
                                                }

                                                fdata2 = withBlock31.get_AliasData(j);
                                                if (!string.IsNullOrEmpty(fdata))
                                                {
                                                    if (Strings.InStr(fdata2, "非表示") != 1)
                                                    {
                                                        fdata2 = fdata + " " + GeneralLib.ListTail(fdata2, (GeneralLib.LLength(fdata) + 1));
                                                    }
                                                }

                                                t.AddCondition(ftype2 + "強化", elevel2, flevel2, fdata2);
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    withBlock30.AddCondition(ftype + "強化", elevel2, flevel, fdata);
                                }

                                withBlock30.Update();
                                if (ReferenceEquals(t, CurrentForm()))
                                {
                                    GUI.UpdateMessageForm(t, u2: null);
                                }
                                else
                                {
                                    GUI.UpdateMessageForm(t, CurrentForm());
                                }

                                // 強化する能力名
                                fname = GeneralLib.LIndex(edata, 3);
                                if (string.IsNullOrEmpty(fname) || fname == "非表示")
                                {
                                    fname = GeneralLib.LIndex(edata, 1);
                                }

                                if (t.SkillName0(fname) != "非表示")
                                {
                                    fname = t.SkillName0(fname);
                                }

                                GUI.DisplaySysMessage(withBlock30.Nickname + "の[" + fname + "]レベルが" + GeneralLib.LIndex(edata, 2) + "上がった。");
                                if (AbilityMaxRange(a) > 0)
                                {
                                    is_useful = true;
                                }
                            }

                            break;
                        }

                    case "状態":
                        {
                            {
                                var withBlock32 = t;
                                if (elevel2 == 0d)
                                {
                                    // レベル指定がない場合は付加が半永久的に持続
                                    elevel2 = 10000d;
                                }
                                else
                                {
                                    // そうでなければ最低１ターンは状態が持続
                                    elevel = GeneralLib.MaxLng(elevel2, 1);
                                }

                                // 効果時間が継続中？
                                if (withBlock32.IsConditionSatisfied(edata))
                                {
                                    goto NextLoop;
                                }

                                withBlock32.AddCondition(edata, elevel2, cdata: "");

                                // 状態発動アニメーション表示
                                bool localIsAnimationDefined() { string argmain_situation = aname + "(発動)"; string argsub_situation = ""; var ret = IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                                if (!localIsAnimationDefined() && !IsAnimationDefined(aname, sub_situation: ""))
                                {
                                    switch (edata ?? "")
                                    {
                                        case "攻撃力ＵＰ":
                                        case "防御力ＵＰ":
                                        case "運動性ＵＰ":
                                        case "移動力ＵＰ":
                                        case "狂戦士":
                                            {
                                                Effect.ShowAnimation(edata + "発動");
                                                break;
                                            }
                                    }
                                }

                                switch (edata ?? "")
                                {
                                    case "装甲劣化":
                                        {
                                            cname = Expression.Term("装甲", t) + "劣化";
                                            break;
                                        }

                                    case "運動性ＵＰ":
                                        {
                                            cname = Expression.Term("運動性", t) + "ＵＰ";
                                            break;
                                        }

                                    case "運動性ＤＯＷＮ":
                                        {
                                            cname = Expression.Term("運動性", t) + "ＤＯＷＮ";
                                            break;
                                        }

                                    case "移動力ＵＰ":
                                        {
                                            cname = Expression.Term("移動力", t) + "ＵＰ";
                                            break;
                                        }

                                    case "移動力ＤＯＷＮ":
                                        {
                                            cname = Expression.Term("移動力", t) + "ＤＯＷＮ";
                                            break;
                                        }

                                    default:
                                        {
                                            cname = edata;
                                            break;
                                        }
                                }

                                GUI.DisplaySysMessage(withBlock32.Nickname + "は" + cname + "の状態になった。");
                                if (AbilityMaxRange(a) > 0)
                                {
                                    is_useful = true;
                                }
                            }

                            break;
                        }

                    case "召喚":
                        {
                            GUI.UpdateMessageForm(CurrentForm(), u2: null);
                            bool localIsDefined2() { object argIndex1 = edata; var ret = SRC.UDList.IsDefined(argIndex1); return ret; }

                            if (!localIsDefined2())
                            {
                                GUI.ErrorMessage(edata + "のデータが定義されていません");
                                return ExecuteAbilityRet;
                            }

                            UnitData localItem() { object argIndex1 = edata; var ret = SRC.UDList.Item(argIndex1); return ret; }

                            pname = localItem().FeatureData("追加パイロット");
                            bool localIsDefined3() { object argIndex1 = pname; var ret = SRC.PDList.IsDefined(argIndex1); return ret; }

                            if (!localIsDefined3())
                            {
                                GUI.ErrorMessage("追加パイロット「" + pname + "」のデータがありません");
                                return ExecuteAbilityRet;
                            }

                            // 召喚したユニットを配置する座標を決定する。
                            // 最も近い敵ユニットの方向にユニットを配置する。
                            u = COM.SearchNearestEnemy(this);
                            if (u is object)
                            {
                                if (Math.Abs((x - u.x)) > Math.Abs((y - u.y)))
                                {
                                    if (x < u.x)
                                    {
                                        tx = (x + 1);
                                    }
                                    else if (x > u.x)
                                    {
                                        tx = (x - 1);
                                    }
                                    else
                                    {
                                        tx = x;
                                    }

                                    ty = y;
                                    tx2 = x;
                                    if (y < u.y)
                                    {
                                        ty2 = (y + 1);
                                    }
                                    else if (y > u.y)
                                    {
                                        ty2 = (y - 1);
                                    }
                                    else if (y == 1)
                                    {
                                        if (Map.MapDataForUnit[x, 2] is null)
                                        {
                                            ty2 = 2;
                                        }
                                        else
                                        {
                                            ty2 = 1;
                                        }
                                    }
                                    else if (y == Map.MapHeight)
                                    {
                                        if (Map.MapDataForUnit[x, Map.MapHeight - 1] is null)
                                        {
                                            ty2 = (Map.MapHeight - 1);
                                        }
                                        else
                                        {
                                            ty2 = Map.MapHeight;
                                        }
                                    }
                                    else if (Map.MapDataForUnit[x, y - 1] is null)
                                    {
                                        ty2 = (y - 1);
                                    }
                                    else if (Map.MapDataForUnit[x, y + 1] is null)
                                    {
                                        ty2 = (y - 1);
                                    }
                                    else
                                    {
                                        ty2 = y;
                                    }
                                }
                                else
                                {
                                    tx = x;
                                    if (y < u.y)
                                    {
                                        ty = (y + 1);
                                    }
                                    else if (y > u.y)
                                    {
                                        ty = (y - 1);
                                    }
                                    else
                                    {
                                        ty = y;
                                    }

                                    if (x < u.x)
                                    {
                                        tx2 = (x + 1);
                                    }
                                    else if (x > u.x)
                                    {
                                        tx2 = (x - 1);
                                    }
                                    else if (x == 1)
                                    {
                                        if (Map.MapDataForUnit[2, y] is null)
                                        {
                                            tx2 = 2;
                                        }
                                        else
                                        {
                                            tx2 = 1;
                                        }
                                    }
                                    else if (x == Map.MapWidth)
                                    {
                                        if (Map.MapDataForUnit[Map.MapWidth - 1, y] is null)
                                        {
                                            tx2 = (Map.MapWidth - 1);
                                        }
                                        else
                                        {
                                            tx2 = Map.MapWidth;
                                        }
                                    }
                                    else if (Map.MapDataForUnit[x - 1, y] is null)
                                    {
                                        tx2 = (x - 1);
                                    }
                                    else if (Map.MapDataForUnit[x + 1, y] is null)
                                    {
                                        tx2 = (x + 1);
                                    }
                                    else
                                    {
                                        tx2 = x;
                                    }

                                    ty2 = y;
                                }
                            }
                            else
                            {
                                tx = x;
                                ty = y;
                                tx2 = x;
                                ty2 = y;
                            }

                            var loopTo24 = GeneralLib.MaxLng(elevel, 1);
                            for (j = 1; j <= loopTo24; j++)
                            {
                                PilotData localItem1() { object argIndex1 = pname; var ret = SRC.PDList.Item(argIndex1); return ret; }

                                PilotData localItem2() { object argIndex1 = pname; var ret = SRC.PDList.Item(argIndex1); return ret; }

                                if (Strings.InStr(localItem1().Name, "(ザコ)") > 0 || Strings.InStr(localItem2().Name, "(汎用)") > 0)
                                {
                                    p = SRC.PList.Add(pname, MainPilot().Level, Party, gid: "");
                                    Party = argpparty1;
                                    p.FullRecover();
                                    u = SRC.UList.Add(edata, Rank, Party);
                                    Party = arguparty;
                                }
                                else
                                {
                                    bool localIsDefined4() { object argIndex1 = pname; var ret = SRC.PList.IsDefined(argIndex1); return ret; }

                                    if (!localIsDefined4())
                                    {
                                        p = SRC.PList.Add(pname, MainPilot().Level, Party, gid: "");
                                        Party = argpparty2;
                                        p.FullRecover();
                                        u = SRC.UList.Add(edata, Rank, Party);
                                        Party = arguparty1;
                                    }
                                    else
                                    {
                                        p = SRC.PList.Item(pname);
                                        u = p.Unit;
                                        if (u is null)
                                        {
                                            if (SRC.UList.IsDefined(edata))
                                            {
                                                u = SRC.UList.Item(edata);
                                            }
                                            else
                                            {
                                                u = SRC.UList.Add(edata, Rank, Party);
                                                Party = arguparty2;
                                            }
                                        }
                                    }
                                }

                                p.Ride(u);
                                AddServant(u);
                                if (Party == "味方")
                                {
                                    if (GeneralLib.LIndex(u.FeatureData("召喚ユニット"), 2) == "ＮＰＣ")
                                    {
                                        u.ChangeParty("ＮＰＣ");
                                    }
                                }

                                u.Summoner = CurrentForm();
                                u.FullRecover();
                                u.Mode = MainPilot().ID;
                                u.UsedAction = 0;
                                if (u.IsFeatureAvailable("制限時間"))
                                {
                                    u.AddCondition("残り時間", Conversions.Toint(u.FeatureData("制限時間")), cdata: "");
                                }

                                if (u.IsMessageDefined("発進"))
                                {
                                    if (!My.MyProject.Forms.frmMessage.Visible)
                                    {
                                        GUI.OpenMessageForm(this, u2: null);
                                    }

                                    u.PilotMessage("発進", msg_mode: "");
                                }

                                // ユニットを配置
                                if (Map.MapDataForUnit[tx, ty] is null && u.IsAbleToEnter(tx, ty))
                                {
                                    u.StandBy(tx, ty, "出撃");
                                }
                                else if (Map.MapDataForUnit[tx2, ty2] is null && u.IsAbleToEnter(tx2, ty2))
                                {
                                    u.StandBy(tx2, ty2, "出撃");
                                }
                                else
                                {
                                    u.StandBy(x, y, "出撃");
                                }

                                // ちゃんと配置できた？
                                if (u.Status == "待機")
                                {
                                    // 空いた場所がなく出撃出来なかった場合
                                    GUI.DisplaySysMessage(Nickname + "は" + u.Nickname + "の召喚に失敗した。");
                                    DeleteServant(u.ID);
                                    u.Status = "破棄";
                                }
                            }

                            break;
                        }

                    case "変身":
                        {
                            // 既に変身している場合は変身出来ない
                            if (t.IsFeatureAvailable("ノーマルモード"))
                            {
                                goto NextLoop;
                            }

                            buf = t.Name;
                            t.Transform(GeneralLib.LIndex(edata, 1));
                            t = t.CurrentForm();
                            if (elevel2 > 0d)
                            {
                                t.AddCondition("残り時間", GeneralLib.MaxLng(elevel2, 1), cdata: "");
                            }

                            var loopTo25 = GeneralLib.LLength(edata);
                            for (j = 2; j <= loopTo25; j++)
                                buf = buf + " " + GeneralLib.LIndex(edata, j);
                            t.AddCondition("ノーマルモード付加", -1, 1d, buf);

                            // 変身した場合はそこで終わり
                            break;
                        }

                    case "能力コピー":
                        {
                            // 既に変身している場合は能力コピー出来ない
                            if (IsFeatureAvailable("ノーマルモード"))
                            {
                                goto NextLoop;
                            }

                            Transform(t.Name);
                            t.Name = argnew_form1;
                            {
                                var withBlock33 = CurrentForm();
                                if (elevel2 > 0d)
                                {
                                    withBlock33.AddCondition("残り時間", GeneralLib.MaxLng(elevel2, 1), cdata: "");
                                }

                                // 元の形態に戻れるように設定
                                buf = Name;
                                var loopTo26 = GeneralLib.LLength(edata);
                                for (j = 1; j <= loopTo26; j++)
                                    buf = buf + " " + GeneralLib.LIndex(edata, j);
                                withBlock33.AddCondition("ノーマルモード付加", -1, 1d, buf);
                                withBlock33.AddCondition("能力コピー", -1, cdata: "");

                                // コピー元のパイロット画像とメッセージを使うように設定
                                withBlock33.AddCondition("パイロット画像", -1, 0d, "非表示 " + t.MainPilot().get_Bitmap(false));
                                withBlock33.AddCondition("メッセージ", -1, 0d, "非表示 " + t.MainPilot().MessageType);
                            }

                            // 能力コピーした場合はそこで終わり
                            ExecuteAbilityRet = true;
                            Commands.RestoreSelections();
                            return ExecuteAbilityRet;
                        }

                    case "再行動":
                        {
                            if (!ReferenceEquals(t, CurrentForm()))
                            {
                                if (t.Action == 0 && t.MaxAction() > 0)
                                {
                                    if (t.UsedAction > t.MaxAction())
                                    {
                                        t.UsedAction = t.MaxAction();
                                    }

                                    t.UsedAction = (t.UsedAction - 1);
                                    GUI.DisplaySysMessage(t.Nickname + "を行動可能にした。");
                                    is_useful = true;
                                }
                            }
                            else
                            {
                                t.UsedAction = (t.UsedAction - 1);
                            }

                            break;
                        }
                }

                NextLoop:
                ;
            }

            t.CurrentForm().Update();
            t.CurrentForm().CheckAutoHyperMode();
            t.CurrentForm().CheckAutoNormalMode();
            ExecuteAbilityRet = is_useful;
            Finish:
            ;


            // 選択状況を復元
            Commands.RestoreSelections();

            // マップアビリティの場合、これ以降の処理は必要なし
            if (is_map_ability)
            {
                return ExecuteAbilityRet;
            }

            // 合体技のパートナーの弾数＆ＥＮの消費
            var loopTo27 = Information.UBound(partners);
            for (i = 1; i <= loopTo27; i++)
            {
                {
                    var withBlock34 = partners[i].CurrentForm();
                    var loopTo28 = withBlock34.CountAbility();
                    for (j = 1; j <= loopTo28; j++)
                    {
                        // パートナーが同名のアビリティを持っていればそのアビリティのデータを使う
                        if ((withBlock34.Ability(j).Name ?? "") == (aname ?? ""))
                        {
                            withBlock34.UseAbility(j);
                            if (withBlock34.IsAbilityClassifiedAs(j, "自"))
                            {
                                if (withBlock34.IsFeatureAvailable("パーツ分離"))
                                {
                                    uname = GeneralLib.LIndex(withBlock34.FeatureData("パーツ分離"), 2);
                                    Unit localOtherForm() { object argIndex1 = uname; var ret = withBlock34.OtherForm(argIndex1); return ret; }

                                    if (localOtherForm().IsAbleToEnter(withBlock34.x, withBlock34.y))
                                    {
                                        withBlock34.Transform(uname);
                                        {
                                            var withBlock35 = withBlock34.CurrentForm();
                                            withBlock35.HP = withBlock35.MaxHP;
                                            withBlock35.UsedAction = withBlock35.MaxAction();
                                        }
                                    }
                                    else
                                    {
                                        withBlock34.Die();
                                    }
                                }
                                else
                                {
                                    withBlock34.Die();
                                }
                            }
                            else if (withBlock34.IsAbilityClassifiedAs(j, "失") && withBlock34.HP == 0)
                            {
                                withBlock34.Die();
                            }
                            else if (withBlock34.IsAbilityClassifiedAs(j, "変"))
                            {
                                if (withBlock34.IsFeatureAvailable("変形技"))
                                {
                                    var loopTo29 = withBlock34.CountFeature();
                                    for (k = 1; k <= loopTo29; k++)
                                    {
                                        string localFeature() { object argIndex1 = k; var ret = withBlock34.Feature(argIndex1); return ret; }

                                        string localFeatureData1() { object argIndex1 = k; var ret = withBlock34.FeatureData(argIndex1); return ret; }

                                        string localLIndex2() { string arglist = hsd94f2b67de0b4586a4a3a3d57d84bb20(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                                        if (localFeature() == "変形技" && (localLIndex2() ?? "") == (aname ?? ""))
                                        {
                                            string localFeatureData() { object argIndex1 = k; var ret = withBlock34.FeatureData(argIndex1); return ret; }

                                            uname = GeneralLib.LIndex(localFeatureData(), 2);
                                            Unit localOtherForm1() { object argIndex1 = uname; var ret = withBlock34.OtherForm(argIndex1); return ret; }

                                            if (localOtherForm1().IsAbleToEnter(withBlock34.x, withBlock34.y))
                                            {
                                                withBlock34.Transform(uname);
                                            }

                                            break;
                                        }
                                    }

                                    if ((uname ?? "") != (withBlock34.CurrentForm().Name ?? ""))
                                    {
                                        if (withBlock34.IsFeatureAvailable("ノーマルモード"))
                                        {
                                            uname = GeneralLib.LIndex(withBlock34.FeatureData(argIndex97), 1);
                                            Unit localOtherForm2() { object argIndex1 = uname; var ret = withBlock34.OtherForm(argIndex1); return ret; }

                                            if (localOtherForm2().IsAbleToEnter(withBlock34.x, withBlock34.y))
                                            {
                                                withBlock34.Transform(uname);
                                            }
                                        }
                                    }
                                }
                                else if (withBlock34.IsFeatureAvailable("ノーマルモード"))
                                {
                                    uname = GeneralLib.LIndex(withBlock34.FeatureData(argIndex98), 1);
                                    Unit localOtherForm3() { object argIndex1 = uname; var ret = withBlock34.OtherForm(argIndex1); return ret; }

                                    if (localOtherForm3().IsAbleToEnter(withBlock34.x, withBlock34.y))
                                    {
                                        withBlock34.Transform(uname);
                                    }
                                }
                            }

                            break;
                        }
                    }

                    // 同名のアビリティがなかった場合は自分のデータを使って処理
                    if (j > withBlock34.CountAbility())
                    {
                        if (this.Ability(a).ENConsumption > 0)
                        {
                            withBlock34.EN = withBlock34.EN - AbilityENConsumption(a);
                        }

                        if (IsAbilityClassifiedAs(a, "消"))
                        {
                            withBlock34.AddCondition("消耗", 1, cdata: "");
                        }

                        if (IsAbilityClassifiedAs(a, "Ｃ") && withBlock34.IsConditionSatisfied("チャージ完了"))
                        {
                            withBlock34.DeleteCondition("チャージ完了");
                        }

                        if (IsAbilityClassifiedAs(a, "気"))
                        {
                            withBlock34.IncreaseMorale((-5 * AbilityLevel(a, "気")));
                        }

                        if (IsAbilityClassifiedAs(a, "霊"))
                        {
                            hp_ratio = 100 * withBlock34.HP / (double)withBlock34.MaxHP;
                            en_ratio = 100 * withBlock34.EN / (double)withBlock34.MaxEN;
                            withBlock34.MainPilot().Plana = (withBlock34.MainPilot().Plana - 5d * AbilityLevel(a, "霊"));
                            withBlock34.HP = (withBlock34.MaxHP * hp_ratio / 100d);
                            withBlock34.EN = (withBlock34.MaxEN * en_ratio / 100d);
                        }
                        else if (IsAbilityClassifiedAs(a, "プ"))
                        {
                            hp_ratio = 100 * withBlock34.HP / (double)withBlock34.MaxHP;
                            en_ratio = 100 * withBlock34.EN / (double)withBlock34.MaxEN;
                            withBlock34.MainPilot().Plana = (withBlock34.MainPilot().Plana - 5d * AbilityLevel(a, "プ"));
                            withBlock34.HP = (withBlock34.MaxHP * hp_ratio / 100d);
                            withBlock34.EN = (withBlock34.MaxEN * en_ratio / 100d);
                        }

                        if (IsAbilityClassifiedAs(a, "失"))
                        {
                            withBlock34.HP = GeneralLib.MaxLng((withBlock34.HP - (long)(withBlock34.MaxHP * AbilityLevel(a, "失")) / 10L), 0);
                        }

                        if (IsAbilityClassifiedAs(a, "自"))
                        {
                            if (withBlock34.IsFeatureAvailable("パーツ分離"))
                            {
                                uname = GeneralLib.LIndex(withBlock34.FeatureData(argIndex101), 2);
                                Unit localOtherForm4() { object argIndex1 = uname; var ret = withBlock34.OtherForm(argIndex1); return ret; }

                                if (localOtherForm4().IsAbleToEnter(withBlock34.x, withBlock34.y))
                                {
                                    withBlock34.Transform(uname);
                                    {
                                        var withBlock36 = withBlock34.CurrentForm();
                                        withBlock36.HP = withBlock36.MaxHP;
                                        withBlock36.UsedAction = withBlock36.MaxAction();
                                    }
                                }
                                else
                                {
                                    withBlock34.Die();
                                }
                            }
                            else
                            {
                                withBlock34.Die();
                            }
                        }
                        else if (IsAbilityClassifiedAs(a, "失") && withBlock34.HP == 0)
                        {
                            withBlock34.Die();
                        }
                        else if (IsAbilityClassifiedAs(a, "変"))
                        {
                            if (withBlock34.IsFeatureAvailable("ノーマルモード"))
                            {
                                uname = GeneralLib.LIndex(withBlock34.FeatureData(argIndex102), 1);
                                Unit localOtherForm5() { object argIndex1 = uname; var ret = withBlock34.OtherForm(argIndex1); return ret; }

                                if (localOtherForm5().IsAbleToEnter(withBlock34.x, withBlock34.y))
                                {
                                    withBlock34.Transform(uname);
                                }
                            }
                        }
                    }
                }
            }

            // 変身した場合
            if (Status == "他形態")
            {
                {
                    var withBlock37 = CurrentForm();
                    // 使い捨てアイテムによる変身の処理
                    var loopTo30 = withBlock37.CountAbility();
                    for (i = 1; i <= loopTo30; i++)
                    {
                        if ((withBlock37.Ability(i).Name ?? "") == (aname ?? ""))
                        {
                            // アイテムを消費
                            if (withBlock37.Ability(i).IsItem() && withBlock37.Stock(i) == 0 && withBlock37.MaxStock(i) > 0)
                            {
                                var loopTo31 = withBlock37.CountItem();
                                for (j = 1; j <= loopTo31; j++)
                                {
                                    Item localItem5() { object argIndex1 = j; var ret = withBlock37.Item(argIndex1); return ret; }

                                    var loopTo32 = localItem5().CountAbility();
                                    for (k = 1; k <= loopTo32; k++)
                                    {
                                        Item localItem4() { object argIndex1 = j; var ret = withBlock37.Item(argIndex1); return ret; }

                                        AbilityData localAbility() { object argIndex1 = k; var ret = hs8bdb16b7368640769bb5144024b221c0().Ability(argIndex1); return ret; }

                                        if ((localAbility().Name ?? "") == (aname ?? ""))
                                        {
                                            Item localItem3() { object argIndex1 = j; var ret = withBlock37.Item(argIndex1); return ret; }

                                            localItem3().Exist = false;
                                            withBlock37.DeleteItem(j);
                                            withBlock37.Update();
                                            goto ExitLoop;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    ExitLoop:
                    ;


                    // 自殺？
                    if (withBlock37.HP == 0)
                    {
                        withBlock37.Die();
                    }
                }

                // WaitCommandによる画面クリアが行われないので
                GUI.RedrawScreen();
                return ExecuteAbilityRet;
            }

            // 経験値の獲得
            if (is_useful && !is_event && !Expression.IsOptionDefined("アビリティ経験値無効"))
            {
                GetExp(t, "アビリティ", exp_mode: "");
                if (!Expression.IsOptionDefined("合体技パートナー経験値無効"))
                {
                    var loopTo33 = Information.UBound(partners);
                    for (i = 1; i <= loopTo33; i++)
                    {
                        partners[i].CurrentForm().GetExp(t, "アビリティ", "パートナー");
                    }
                }
            }

            // 以下の効果はアビリティデータが変化する場合があるため同時には適応されない

            // 自爆技

            // ＨＰ消費アビリティで自殺

            // 変形技
            if (IsAbilityClassifiedAs(a, "自"))
            {
                if (IsFeatureAvailable("パーツ分離"))
                {
                    uname = GeneralLib.LIndex(FeatureData("パーツ分離"), 2);
                    Unit localOtherForm6() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm6().IsAbleToEnter(x, y))
                    {
                        Transform(uname);
                        {
                            var withBlock38 = CurrentForm();
                            withBlock38.HP = withBlock38.MaxHP;
                            withBlock38.UsedAction = withBlock38.MaxAction();
                        }

                        fname = FeatureName("パーツ分離");
                        bool localIsSysMessageDefined() { string argmain_situation = "破壊時分離(" + fname + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        bool localIsSysMessageDefined1() { string argmain_situation = "分離(" + Name + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        bool localIsSysMessageDefined2() { string argmain_situation = "分離(" + fname + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        if (IsSysMessageDefined("破壊時分離(" + Name + ")", sub_situation: ""))
                        {
                            SysMessage("破壊時分離(" + Name + ")", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined())
                        {
                            SysMessage("破壊時分離(" + fname + ")", sub_situation: "", add_msg: "");
                        }
                        else if (IsSysMessageDefined("破壊時分離", sub_situation: ""))
                        {
                            SysMessage("破壊時分離", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined1())
                        {
                            SysMessage("分離(" + Name + ")", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined2())
                        {
                            SysMessage("分離(" + fname + ")", sub_situation: "", add_msg: "");
                        }
                        else if (IsSysMessageDefined("分離", sub_situation: ""))
                        {
                            SysMessage("分離", sub_situation: "", add_msg: "");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(Nickname + "は破壊されたパーツを分離させた。");
                        }
                    }
                    else
                    {
                        Die();
                    }
                }
                else
                {
                    Die();
                }
            }
            else if (IsAbilityClassifiedAs(a, "失") && HP == 0)
            {
                Die();
            }
            else if (IsAbilityClassifiedAs(a, "変"))
            {
                if (IsFeatureAvailable("変形技"))
                {
                    var loopTo34 = CountFeature();
                    for (i = 1; i <= loopTo34; i++)
                    {
                        string localFeature1() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                        string localFeatureData3() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        string localLIndex3() { string arglist = hs943d006232364b899ee9a8aea8dcca5a(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                        if (localFeature1() == "変形技" && (localLIndex3() ?? "") == (Ability(a).Name ?? ""))
                        {
                            string localFeatureData2() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            uname = GeneralLib.LIndex(localFeatureData2(), 2);
                            Unit localOtherForm7() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                            if (localOtherForm7().IsAbleToEnter(x, y))
                            {
                                Transform(uname);
                            }

                            break;
                        }
                    }

                    if ((uname ?? "") != (CurrentForm().Name ?? ""))
                    {
                        if (IsFeatureAvailable("ノーマルモード"))
                        {
                            uname = GeneralLib.LIndex(FeatureData(argIndex106), 1);
                            Unit localOtherForm8() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                            if (localOtherForm8().IsAbleToEnter(x, y))
                            {
                                Transform(uname);
                            }
                        }
                    }
                }
                else if (IsFeatureAvailable("ノーマルモード"))
                {
                    uname = GeneralLib.LIndex(FeatureData(argIndex107), 1);
                    Unit localOtherForm9() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm9().IsAbleToEnter(x, y))
                    {
                        Transform(uname);
                    }
                }
            }

            // アイテムを消費
            else if (Ability(a).IsItem() && Stock(a) == 0 && MaxStock(a) > 0)
            {
                // アイテムを削除
                num = Data.CountAbility();
                num = (num + MainPilot().Data.CountAbility());
                var loopTo35 = CountPilot();
                for (i = 2; i <= loopTo35; i++)
                {
                    Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    num = (num + localPilot().Data.CountAbility());
                }

                var loopTo36 = CountSupport();
                for (i = 2; i <= loopTo36; i++)
                {
                    Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    num = (num + localSupport().Data.CountAbility());
                }

                if (IsFeatureAvailable("追加サポート"))
                {
                    num = (num + AdditionalSupport().Data.CountAbility());
                }

                foreach (Item itm in colItem)
                {
                    num = (num + itm.CountAbility());
                    if (a <= num)
                    {
                        itm.Exist = false;
                        DeleteItem((object)itm.ID);
                        break;
                    }
                }
            }

            // ADD START MARGE
            // 戦闘アニメ終了処理
            if (IsAnimationDefined(aname + "(終了)", sub_situation: ""))
            {
                PlayAnimation(aname + "(終了)", sub_situation: "");
            }
            else if (IsAnimationDefined("終了", sub_situation: ""))
            {
                PlayAnimation("終了", sub_situation: "");
            }
            // ADD END MARGE

            {
                var withBlock39 = CurrentForm();
                // 戦闘アニメで変更されたユニット画像を元に戻す
                if (withBlock39.IsConditionSatisfied("ユニット画像"))
                {
                    withBlock39.DeleteCondition("ユニット画像");
                    withBlock39.BitmapID = GUI.MakeUnitBitmap(CurrentForm());
                    GUI.PaintUnitBitmap(CurrentForm());
                }

                if (withBlock39.IsConditionSatisfied("非表示付加"))
                {
                    withBlock39.DeleteCondition("非表示付加");
                    withBlock39.BitmapID = GUI.MakeUnitBitmap(CurrentForm());
                    GUI.PaintUnitBitmap(CurrentForm());
                }
            }

            var loopTo37 = Information.UBound(partners);
            for (i = 1; i <= loopTo37; i++)
            {
                {
                    var withBlock40 = partners[i].CurrentForm();
                    if (withBlock40.IsConditionSatisfied("ユニット画像"))
                    {
                        withBlock40.DeleteCondition("ユニット画像");
                        withBlock40.BitmapID = GUI.MakeUnitBitmap(partners[i].CurrentForm());
                        GUI.PaintUnitBitmap(partners[i].CurrentForm());
                    }

                    if (withBlock40.IsConditionSatisfied("非表示付加"))
                    {
                        withBlock40.DeleteCondition("非表示付加");
                        withBlock40.BitmapID = GUI.MakeUnitBitmap(partners[i].CurrentForm());
                        GUI.PaintUnitBitmap(partners[i].CurrentForm());
                    }
                }
            }

            return ExecuteAbilityRet;
        }

        // マップアビリティ a を (tx,ty) に使用
        public void ExecuteMapAbility(int a, int tx, int ty, bool is_event = false)
        {
            int k, i, j, num;
            Unit t, max_lv_t;
            Unit[] targets;
            var partners = default(Unit[]);
            var is_useful = default(bool);
            string anickname, aname, msg;
            int min_range, max_range;
            int rx, ry;
            string uname = default, fname;
            double hp_ratio, en_ratio;
            aname = Ability(a).Name;
            anickname = AbilityNickname(a);
            if (!is_event)
            {
                // マップ攻撃の使用イベント
                Event.HandleEvent("使用", MainPilot().ID, aname);
                if (SRC.IsScenarioFinished)
                {
                    return;
                }

                if (SRC.IsCanceled)
                {
                    SRC.IsCanceled = false;
                    return;
                }
            }

            // 効果範囲を設定
            min_range = AbilityMinRange(a);
            max_range = AbilityMaxRange(a);
            if (IsAbilityClassifiedAs(a, "Ｍ直"))
            {
                if (ty < y)
                {
                    Map.AreaInLine(x, y, min_range, max_range, "N");
                }
                else if (ty > y)
                {
                    Map.AreaInLine(x, y, min_range, max_range, "S");
                }
                else if (tx < x)
                {
                    Map.AreaInLine(x, y, min_range, max_range, "W");
                }
                else
                {
                    Map.AreaInLine(x, y, min_range, max_range, "E");
                }
            }
            else if (IsAbilityClassifiedAs(a, "Ｍ拡"))
            {
                if (ty < y && Math.Abs((y - ty)) > Math.Abs((x - tx)))
                {
                    Map.AreaInCone(x, y, min_range, max_range, "N");
                }
                else if (ty > y && Math.Abs((y - ty)) > Math.Abs((x - tx)))
                {
                    Map.AreaInCone(x, y, min_range, max_range, "S");
                }
                else if (tx < x && Math.Abs((x - tx)) > Math.Abs((y - ty)))
                {
                    Map.AreaInCone(x, y, min_range, max_range, "W");
                }
                else
                {
                    Map.AreaInCone(x, y, min_range, max_range, "E");
                }
            }
            else if (IsAbilityClassifiedAs(a, "Ｍ扇"))
            {
                if (ty < y && Math.Abs((y - ty)) >= Math.Abs((x - tx)))
                {
                    Map.AreaInSector(x, y, min_range, max_range, "N", AbilityLevel(a, "Ｍ扇"));
                }
                else if (ty > y && Math.Abs((y - ty)) >= Math.Abs((x - tx)))
                {
                    Map.AreaInSector(x, y, min_range, max_range, "S", AbilityLevel(a, "Ｍ扇"));
                }
                else if (tx < x && Math.Abs((x - tx)) >= Math.Abs((y - ty)))
                {
                    Map.AreaInSector(x, y, min_range, max_range, "W", AbilityLevel(a, "Ｍ扇"));
                }
                else
                {
                    Map.AreaInSector(x, y, min_range, max_range, "E", AbilityLevel(a, "Ｍ扇"));
                }
            }
            else if (IsAbilityClassifiedAs(a, "Ｍ投"))
            {
                Map.AreaInRange(tx, ty, AbilityLevel(a, "Ｍ投"), 1, "すべて");
            }
            else if (IsAbilityClassifiedAs(a, "Ｍ全"))
            {
                Map.AreaInRange(x, y, max_range, min_range, "すべて");
            }
            else if (IsAbilityClassifiedAs(a, "Ｍ移") || IsAbilityClassifiedAs(a, "Ｍ線"))
            {
                Map.AreaInPointToPoint(x, y, tx, ty);
            }

            // ユニットがいるマスの処理
            var loopTo = Map.MapWidth;
            for (i = 1; i <= loopTo; i++)
            {
                var loopTo1 = Map.MapHeight;
                for (j = 1; j <= loopTo1; j++)
                {
                    if (!Map.MaskData[i, j])
                    {
                        t = Map.MapDataForUnit[i, j];
                        if (t is object)
                        {
                            // 有効？
                            if (IsAbilityEffective(a, t))
                            {
                                Map.MaskData[i, j] = false;
                            }
                            else
                            {
                                Map.MaskData[i, j] = true;
                            }
                        }
                    }
                }
            }

            // 支援専用アビリティは自分には使用できない
            if (IsAbilityClassifiedAs(a, "援"))
            {
                Map.MaskData[x, y] = true;
            }

            // マップアビリティの影響を受けるユニットのリストを作成
            targets = new Unit[1];
            var loopTo2 = Map.MapWidth;
            for (i = 1; i <= loopTo2; i++)
            {
                var loopTo3 = Map.MapHeight;
                for (j = 1; j <= loopTo3; j++)
                {
                    // マップアビリティの影響をうけるかチェック
                    if (Map.MaskData[i, j])
                    {
                        goto NextLoop;
                    }

                    t = Map.MapDataForUnit[i, j];
                    if (t is null)
                    {
                        goto NextLoop;
                    }

                    if (!IsAbilityApplicable(a, t))
                    {
                        Map.MaskData[i, j] = true;
                        goto NextLoop;
                    }

                    Array.Resize(targets, Information.UBound(targets) + 1 + 1);
                    targets[Information.UBound(targets)] = t;
                    NextLoop:
                    ;
                }
            }

            // アビリティ実行の起点を設定
            if (IsAbilityClassifiedAs(a, "Ｍ投"))
            {
                rx = tx;
                ry = ty;
            }
            else
            {
                rx = x;
                ry = y;
            }

            // 起点からの距離に応じて並べ替え
            int min_item, min_value;
            var loopTo4 = (Information.UBound(targets) - 1);
            for (i = 1; i <= loopTo4; i++)
            {
                min_item = i;
                {
                    var withBlock = targets[i];
                    min_value = (Math.Abs((withBlock.x - rx)) + Math.Abs((withBlock.y - ry)));
                }

                var loopTo5 = Information.UBound(targets);
                for (j = (i + 1); j <= loopTo5; j++)
                {
                    {
                        var withBlock1 = targets[j];
                        if ((Math.Abs((withBlock1.x - rx)) + Math.Abs((withBlock1.y - ry))) < min_value)
                        {
                            min_item = j;
                            min_value = (Math.Abs((withBlock1.x - rx)) + Math.Abs((withBlock1.y - ry)));
                        }
                    }
                }

                if (min_item != i)
                {
                    t = targets[i];
                    targets[i] = targets[min_item];
                    targets[min_item] = t;
                }
            }

            // 合体技
            bool[] TmpMaskData;
            if (IsAbilityClassifiedAs(a, "合"))
            {

                // 合体技のパートナーのハイライト表示
                // MaskDataを保存して使用している
                TmpMaskData = new bool[(Map.MapWidth + 1), (Map.MapHeight + 1)];
                var loopTo6 = Map.MapWidth;
                for (i = 1; i <= loopTo6; i++)
                {
                    var loopTo7 = Map.MapHeight;
                    for (j = 1; j <= loopTo7; j++)
                        TmpMaskData[i, j] = Map.MaskData[i, j];
                }

                CombinationPartner("アビリティ", a, partners);

                // パートナーユニットはマスクを解除
                var loopTo8 = Information.UBound(partners);
                for (i = 1; i <= loopTo8; i++)
                {
                    {
                        var withBlock2 = partners[i];
                        Map.MaskData[withBlock2.x, withBlock2.y] = false;
                        TmpMaskData[withBlock2.x, withBlock2.y] = true;
                    }
                }

                GUI.MaskScreen();

                // マスクを復元
                var loopTo9 = Map.MapWidth;
                for (i = 1; i <= loopTo9; i++)
                {
                    var loopTo10 = Map.MapHeight;
                    for (j = 1; j <= loopTo10; j++)
                        Map.MaskData[i, j] = TmpMaskData[i, j];
                }
            }
            else
            {
                partners = new Unit[1];
                Commands.SelectedPartners = new Unit[1];
                GUI.MaskScreen();
            }

            GUI.OpenMessageForm(this, u2: null);

            // 現在の選択状況をセーブ
            Commands.SaveSelections();

            // 選択内容を切り替え
            Commands.SelectedUnit = this;
            Event.SelectedUnitForEvent = this;
            Commands.SelectedAbility = a;
            Commands.SelectedAbilityName = Ability(a).Name;
            Commands.SelectedX = tx;
            Commands.SelectedY = ty;

            // 変な「対～」メッセージが表示されないようにターゲットをオフ
            // UPGRADE_NOTE: オブジェクト SelectedTarget をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Commands.SelectedTarget = null;
            // UPGRADE_NOTE: オブジェクト SelectedTargetForEvent をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Event.SelectedTargetForEvent = null;

            // マップアビリティ開始のメッセージ＆特殊効果
            if (IsAnimationDefined(aname + "(準備)", sub_situation: ""))
            {
                PlayAnimation(aname + "(準備)", sub_situation: "");
            }

            if (IsMessageDefined("かけ声(" + aname + ")"))
            {
                PilotMessage("かけ声(" + aname + ")", msg_mode: "");
            }

            PilotMessage(aname, "アビリティ");
            if (IsAnimationDefined(aname + "(使用)", sub_situation: ""))
            {
                PlayAnimation(aname + "(使用)", "", true);
            }
            else
            {
                SpecialEffect(aname, "", true);
            }

            // ＥＮ消費＆使用回数減少
            UseAbility(a);
            GUI.UpdateMessageForm(this, u2: null);
            switch (Information.UBound(partners))
            {
                case 0:
                    {
                        // 通常
                        msg = Nickname + "は";
                        break;
                    }

                case 1:
                    {
                        // ２体合体
                        if ((Nickname ?? "") != (partners[1].Nickname ?? ""))
                        {
                            msg = Nickname + "は[" + partners[1].Nickname + "]と共に";
                        }
                        else if ((MainPilot().get_Nickname(false) ?? "") != (partners[1].MainPilot().get_Nickname(false) ?? ""))
                        {
                            msg = MainPilot().get_Nickname(false) + "と[" + partners[1].MainPilot().get_Nickname(false) + "]の[" + Nickname + "]は";
                        }
                        else
                        {
                            msg = Nickname + "達は";
                        }

                        break;
                    }

                case 2:
                    {
                        // ３体合体
                        if ((Nickname ?? "") != (partners[1].Nickname ?? ""))
                        {
                            msg = Nickname + "は[" + partners[1].Nickname + "]、[" + partners[2].Nickname + "]と共に";
                        }
                        else if ((MainPilot().get_Nickname(false) ?? "") != (partners[1].MainPilot().get_Nickname(false) ?? ""))
                        {
                            msg = MainPilot().get_Nickname(false) + "、[" + partners[1].MainPilot().get_Nickname(false) + "]、[" + partners[2].MainPilot().get_Nickname(false) + "]の[" + Nickname + "]は";
                        }
                        else
                        {
                            msg = Nickname + "達は";
                        }

                        break;
                    }

                default:
                    {
                        // ３体以上
                        msg = Nickname + "達は";
                        break;
                    }
            }

            if (IsSpellAbility(a))
            {
                if (Strings.Right(anickname, 2) == "呪文")
                {
                    msg = msg + "[" + anickname + "]を唱えた。";
                }
                else if (Strings.Right(anickname, 2) == "の杖")
                {
                    msg = msg + "[" + Strings.Left(anickname, Strings.Len(anickname) - 2) + "]の呪文を唱えた。";
                }
                else
                {
                    msg = msg + "[" + anickname + "]の呪文を唱えた。";
                }
            }
            else if (Strings.Right(anickname, 1) == "歌")
            {
                msg = msg + "[" + anickname + "]を歌った。";
            }
            else if (Strings.Right(anickname, 2) == "踊り")
            {
                msg = msg + "[" + anickname + "]を踊った。";
            }
            else
            {
                msg = msg + "[" + anickname + "]を使った。";
            }

            if (IsSysMessageDefined(aname, sub_situation: ""))
            {
                // 「アビリティ名(解説)」のメッセージを使用
                SysMessage(aname, sub_situation: "", add_msg: "");
            }
            else if (IsSysMessageDefined("アビリティ", sub_situation: ""))
            {
                // 「アビリティ(解説)」のメッセージを使用
                SysMessage("アビリティ", sub_situation: "", add_msg: "");
            }
            else
            {
                GUI.DisplaySysMessage(msg);
            }

            // 選択状況を復元
            Commands.RestoreSelections();

            // アビリティの使用に失敗？
            if (GeneralLib.Dice(10) <= AbilityLevel(a, "難"))
            {
                GUI.DisplaySysMessage("しかし何もおきなかった…");
                goto Finish;
            }

            // 使用元ユニットは SelectedTarget に設定していないといけない
            Commands.SelectedTarget = this;

            // 各ユニットにアビリティを使用
            // UPGRADE_NOTE: オブジェクト max_lv_t をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            max_lv_t = null;
            var loopTo11 = Information.UBound(targets);
            for (i = 1; i <= loopTo11; i++)
            {
                t = targets[i].CurrentForm();
                if (t.Status == "出撃")
                {
                    if (ReferenceEquals(t, this))
                    {
                        GUI.UpdateMessageForm(this, u2: null);
                    }
                    else
                    {
                        GUI.UpdateMessageForm(t, this);
                    }

                    if (ExecuteAbility(a, t, true))
                    {
                        t = t.CurrentForm();
                        is_useful = true;

                        // 獲得経験値算出用にメインパイロットのレベルが最も高い
                        // ユニットを求めておく
                        if (max_lv_t is null)
                        {
                            max_lv_t = t;
                        }
                        else if (t.MainPilot().Level > max_lv_t.MainPilot().Level)
                        {
                            max_lv_t = t;
                        }
                    }
                }
            }

            // ADD START MARGE
            // 戦闘アニメ終了処理
            if (IsAnimationDefined(aname + "(終了)", sub_situation: ""))
            {
                PlayAnimation(aname + "(終了)", sub_situation: "");
            }
            else if (IsAnimationDefined("終了", sub_situation: ""))
            {
                PlayAnimation("終了", sub_situation: "");
            }
            // ADD END MARGE

            {
                var withBlock3 = CurrentForm();
                // 戦闘アニメで変更されたユニット画像を元に戻す
                if (withBlock3.IsConditionSatisfied("ユニット画像"))
                {
                    withBlock3.DeleteCondition("ユニット画像");
                    withBlock3.BitmapID = GUI.MakeUnitBitmap(CurrentForm());
                    GUI.PaintUnitBitmap(CurrentForm());
                }

                if (withBlock3.IsConditionSatisfied("非表示付加"))
                {
                    withBlock3.DeleteCondition("非表示付加");
                    withBlock3.BitmapID = GUI.MakeUnitBitmap(CurrentForm());
                    GUI.PaintUnitBitmap(CurrentForm());
                }
            }

            var loopTo12 = Information.UBound(partners);
            for (i = 1; i <= loopTo12; i++)
            {
                {
                    var withBlock4 = partners[i].CurrentForm();
                    if (withBlock4.IsConditionSatisfied("ユニット画像"))
                    {
                        withBlock4.DeleteCondition("ユニット画像");
                        withBlock4.BitmapID = GUI.MakeUnitBitmap(partners[i].CurrentForm());
                        GUI.PaintUnitBitmap(partners[i].CurrentForm());
                    }

                    if (withBlock4.IsConditionSatisfied("非表示付加"))
                    {
                        withBlock4.DeleteCondition("非表示付加");
                        withBlock4.BitmapID = GUI.MakeUnitBitmap(partners[i].CurrentForm());
                        GUI.PaintUnitBitmap(partners[i].CurrentForm());
                    }
                }
            }

            // 獲得した経験値の表示
            if (is_useful && !is_event && !Expression.IsOptionDefined("アビリティ経験値無効"))
            {
                GetExp(max_lv_t, "アビリティ", exp_mode: "");
                if (!Expression.IsOptionDefined("合体技パートナー経験値無効"))
                {
                    var loopTo13 = Information.UBound(partners);
                    for (i = 1; i <= loopTo13; i++)
                    {
                        partners[i].CurrentForm().GetExp(null, "アビリティ", "パートナー");
                    }
                }
            }

            // 合体技のパートナーの弾数＆ＥＮの消費
            var loopTo14 = Information.UBound(partners);
            for (i = 1; i <= loopTo14; i++)
            {
                {
                    var withBlock5 = partners[i].CurrentForm();
                    var loopTo15 = withBlock5.CountAbility();
                    for (j = 1; j <= loopTo15; j++)
                    {
                        // パートナーが同名のアビリティを持っていればそのアビリティのデータを使う
                        if ((withBlock5.Ability(j).Name ?? "") == (aname ?? ""))
                        {
                            withBlock5.UseAbility(j);
                            if (withBlock5.IsAbilityClassifiedAs(j, "自"))
                            {
                                if (withBlock5.IsFeatureAvailable("パーツ分離"))
                                {
                                    uname = GeneralLib.LIndex(withBlock5.FeatureData("パーツ分離"), 2);
                                    Unit localOtherForm() { object argIndex1 = uname; var ret = withBlock5.OtherForm(argIndex1); return ret; }

                                    if (localOtherForm().IsAbleToEnter(withBlock5.x, withBlock5.y))
                                    {
                                        withBlock5.Transform(uname);
                                        {
                                            var withBlock6 = withBlock5.CurrentForm();
                                            withBlock6.HP = withBlock6.MaxHP;
                                            withBlock6.UsedAction = withBlock6.MaxAction();
                                        }
                                    }
                                    else
                                    {
                                        withBlock5.Die();
                                    }
                                }
                                else
                                {
                                    withBlock5.Die();
                                }
                            }
                            else if (withBlock5.IsAbilityClassifiedAs(j, "失") && withBlock5.HP == 0)
                            {
                                withBlock5.Die();
                            }
                            else if (withBlock5.IsAbilityClassifiedAs(j, "変"))
                            {
                                if (withBlock5.IsFeatureAvailable("変形技"))
                                {
                                    var loopTo16 = withBlock5.CountFeature();
                                    for (k = 1; k <= loopTo16; k++)
                                    {
                                        string localFeature() { object argIndex1 = k; var ret = withBlock5.Feature(argIndex1); return ret; }

                                        string localFeatureData1() { object argIndex1 = k; var ret = withBlock5.FeatureData(argIndex1); return ret; }

                                        string localLIndex() { string arglist = hsa17e1f441163458982d95695a4abb266(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                                        if (localFeature() == "変形技" && (localLIndex() ?? "") == (aname ?? ""))
                                        {
                                            string localFeatureData() { object argIndex1 = k; var ret = withBlock5.FeatureData(argIndex1); return ret; }

                                            uname = GeneralLib.LIndex(localFeatureData(), 2);
                                            Unit localOtherForm1() { object argIndex1 = uname; var ret = withBlock5.OtherForm(argIndex1); return ret; }

                                            if (localOtherForm1().IsAbleToEnter(withBlock5.x, withBlock5.y))
                                            {
                                                withBlock5.Transform(uname);
                                            }

                                            break;
                                        }
                                    }

                                    if ((uname ?? "") != (withBlock5.CurrentForm().Name ?? ""))
                                    {
                                        if (withBlock5.IsFeatureAvailable("ノーマルモード"))
                                        {
                                            uname = GeneralLib.LIndex(withBlock5.FeatureData(argIndex10), 1);
                                            Unit localOtherForm2() { object argIndex1 = uname; var ret = withBlock5.OtherForm(argIndex1); return ret; }

                                            if (localOtherForm2().IsAbleToEnter(withBlock5.x, withBlock5.y))
                                            {
                                                withBlock5.Transform(uname);
                                            }
                                        }
                                    }
                                }
                                else if (withBlock5.IsFeatureAvailable("ノーマルモード"))
                                {
                                    uname = GeneralLib.LIndex(withBlock5.FeatureData(argIndex11), 1);
                                    Unit localOtherForm3() { object argIndex1 = uname; var ret = withBlock5.OtherForm(argIndex1); return ret; }

                                    if (localOtherForm3().IsAbleToEnter(withBlock5.x, withBlock5.y))
                                    {
                                        withBlock5.Transform(uname);
                                    }
                                }
                            }

                            break;
                        }
                    }

                    // 同名のアビリティがなかった場合は自分のデータを使って処理
                    if (j > withBlock5.CountAbility())
                    {
                        if (this.Ability(a).ENConsumption > 0)
                        {
                            withBlock5.EN = withBlock5.EN - AbilityENConsumption(a);
                        }

                        if (IsAbilityClassifiedAs(a, "消"))
                        {
                            withBlock5.AddCondition("消耗", 1, cdata: "");
                        }

                        if (IsAbilityClassifiedAs(a, "Ｃ") && withBlock5.IsConditionSatisfied("チャージ完了"))
                        {
                            withBlock5.DeleteCondition("チャージ完了");
                        }

                        if (IsAbilityClassifiedAs(a, "気"))
                        {
                            withBlock5.IncreaseMorale((-5 * AbilityLevel(a, "気")));
                        }

                        if (IsAbilityClassifiedAs(a, "霊"))
                        {
                            hp_ratio = 100 * withBlock5.HP / (double)withBlock5.MaxHP;
                            en_ratio = 100 * withBlock5.EN / (double)withBlock5.MaxEN;
                            withBlock5.MainPilot().Plana = (withBlock5.MainPilot().Plana - 5d * AbilityLevel(a, "霊"));
                            withBlock5.HP = (withBlock5.MaxHP * hp_ratio / 100d);
                            withBlock5.EN = (withBlock5.MaxEN * en_ratio / 100d);
                        }
                        else if (IsAbilityClassifiedAs(a, "プ"))
                        {
                            hp_ratio = 100 * withBlock5.HP / (double)withBlock5.MaxHP;
                            en_ratio = 100 * withBlock5.EN / (double)withBlock5.MaxEN;
                            withBlock5.MainPilot().Plana = (withBlock5.MainPilot().Plana - 5d * AbilityLevel(a, "プ"));
                            withBlock5.HP = (withBlock5.MaxHP * hp_ratio / 100d);
                            withBlock5.EN = (withBlock5.MaxEN * en_ratio / 100d);
                        }

                        if (IsAbilityClassifiedAs(a, "失"))
                        {
                            withBlock5.HP = GeneralLib.MaxLng((withBlock5.HP - (long)(withBlock5.MaxHP * AbilityLevel(a, "失")) / 10L), 0);
                        }

                        if (IsAbilityClassifiedAs(a, "自"))
                        {
                            if (withBlock5.IsFeatureAvailable("パーツ分離"))
                            {
                                uname = GeneralLib.LIndex(withBlock5.FeatureData("パーツ分離"), 2);
                                Unit localOtherForm4() { object argIndex1 = uname; var ret = withBlock5.OtherForm(argIndex1); return ret; }

                                if (localOtherForm4().IsAbleToEnter(withBlock5.x, withBlock5.y))
                                {
                                    withBlock5.Transform(uname);
                                    {
                                        var withBlock7 = withBlock5.CurrentForm();
                                        withBlock7.HP = withBlock7.MaxHP;
                                        withBlock7.UsedAction = withBlock7.MaxAction();
                                    }
                                }
                                else
                                {
                                    withBlock5.Die();
                                }
                            }
                            else
                            {
                                withBlock5.Die();
                            }
                        }
                        else if (IsAbilityClassifiedAs(a, "失") && withBlock5.HP == 0)
                        {
                            withBlock5.Die();
                        }
                        else if (IsAbilityClassifiedAs(a, "変"))
                        {
                            if (withBlock5.IsFeatureAvailable("ノーマルモード"))
                            {
                                uname = GeneralLib.LIndex(withBlock5.FeatureData(argIndex15), 1);
                                Unit localOtherForm5() { object argIndex1 = uname; var ret = withBlock5.OtherForm(argIndex1); return ret; }

                                if (localOtherForm5().IsAbleToEnter(withBlock5.x, withBlock5.y))
                                {
                                    withBlock5.Transform(uname);
                                }
                            }
                        }
                    }
                }
            }

            // 移動型マップアビリティによる移動
            if (IsAbilityClassifiedAs(a, "Ｍ移"))
            {
                Jump(tx, ty);
            }

            Finish:
            ;


            // 以下の効果はアビリティデータが変化する可能性があるため、同時には適用されない

            // 自爆の処理

            // ＨＰ消費アビリティで自殺した場合

            // 変形技
            if (IsAbilityClassifiedAs(a, "自"))
            {
                if (IsFeatureAvailable("パーツ分離"))
                {
                    // パーツ合体したユニットが自爆する時はパーツを分離するだけ
                    uname = GeneralLib.LIndex(FeatureData("パーツ分離"), 2);
                    Unit localOtherForm6() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm6().IsAbleToEnter(x, y))
                    {
                        Transform(uname);
                        {
                            var withBlock8 = CurrentForm();
                            withBlock8.HP = withBlock8.MaxHP;
                            withBlock8.UsedAction = withBlock8.MaxAction();
                        }

                        fname = FeatureName("パーツ分離");
                        bool localIsSysMessageDefined() { string argmain_situation = "破壊時分離(" + fname + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        bool localIsSysMessageDefined1() { string argmain_situation = "分離(" + Name + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        bool localIsSysMessageDefined2() { string argmain_situation = "分離(" + fname + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        if (IsSysMessageDefined("破壊時分離(" + Name + ")", sub_situation: ""))
                        {
                            SysMessage("破壊時分離(" + Name + ")", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined())
                        {
                            SysMessage("破壊時分離(" + fname + ")", sub_situation: "", add_msg: "");
                        }
                        else if (IsSysMessageDefined("破壊時分離", sub_situation: ""))
                        {
                            SysMessage("破壊時分離", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined1())
                        {
                            SysMessage("分離(" + Name + ")", sub_situation: "", add_msg: "");
                        }
                        else if (localIsSysMessageDefined2())
                        {
                            SysMessage("分離(" + fname + ")", sub_situation: "", add_msg: "");
                        }
                        else if (IsSysMessageDefined("分離", sub_situation: ""))
                        {
                            SysMessage("分離", sub_situation: "", add_msg: "");
                        }
                        else
                        {
                            GUI.DisplaySysMessage(Nickname + "は破壊されたパーツを分離させた。");
                        }
                    }
                    else
                    {
                        // しかし、パーツ分離できない地形ではそのまま自爆
                        Die();
                        if (!is_event)
                        {
                            Event.HandleEvent("破壊", MainPilot().ID);
                            if (SRC.IsScenarioFinished)
                            {
                                return;
                            }
                        }
                    }
                }
                else
                {
                    Die();
                    if (!is_event)
                    {
                        Event.HandleEvent("破壊", MainPilot().ID);
                        if (SRC.IsScenarioFinished)
                        {
                            return;
                        }
                    }
                }
            }
            else if (IsAbilityClassifiedAs(a, "失") && HP == 0)
            {
                Die();
                if (!is_event)
                {
                    Event.HandleEvent("破壊", MainPilot().ID);
                    if (SRC.IsScenarioFinished)
                    {
                        return;
                    }
                }
            }
            else if (IsAbilityClassifiedAs(a, "変"))
            {
                if (IsFeatureAvailable("変形技"))
                {
                    var loopTo17 = CountFeature();
                    for (i = 1; i <= loopTo17; i++)
                    {
                        string localFeature1() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                        string localFeatureData3() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        string localLIndex1() { string arglist = hs60551c61d0954d3e93ffb43a55a73d66(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                        if (localFeature1() == "変形技" && (localLIndex1() ?? "") == (Ability(a).Name ?? ""))
                        {
                            string localFeatureData2() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            uname = GeneralLib.LIndex(localFeatureData2(), 2);
                            Unit localOtherForm7() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                            if (localOtherForm7().IsAbleToEnter(x, y))
                            {
                                Transform(uname);
                            }

                            break;
                        }
                    }

                    if ((uname ?? "") != (CurrentForm().Name ?? ""))
                    {
                        if (IsFeatureAvailable("ノーマルモード"))
                        {
                            uname = GeneralLib.LIndex(FeatureData(argIndex18), 1);
                            Unit localOtherForm8() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                            if (localOtherForm8().IsAbleToEnter(x, y))
                            {
                                Transform(uname);
                            }
                        }
                    }
                }
                else if (IsFeatureAvailable("ノーマルモード"))
                {
                    uname = GeneralLib.LIndex(FeatureData(argIndex19), 1);
                    Unit localOtherForm9() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm9().IsAbleToEnter(x, y))
                    {
                        Transform(uname);
                    }
                }
            }

            // アイテムを消費
            else if (Ability(a).IsItem() && Stock(a) == 0 && MaxStock(a) > 0)
            {
                // アイテムを削除
                num = Data.CountAbility();
                num = (num + MainPilot().Data.CountAbility());
                var loopTo18 = CountPilot();
                for (i = 2; i <= loopTo18; i++)
                {
                    Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    num = (num + localPilot().Data.CountAbility());
                }

                var loopTo19 = CountSupport();
                for (i = 2; i <= loopTo19; i++)
                {
                    Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    num = (num + localSupport().Data.CountAbility());
                }

                if (IsFeatureAvailable("追加サポート"))
                {
                    num = (num + AdditionalSupport().Data.CountAbility());
                }

                foreach (Item itm in colItem)
                {
                    num = (num + itm.CountAbility());
                    if (a <= num)
                    {
                        itm.Exist = false;
                        DeleteItem((object)itm.ID);
                        break;
                    }
                }
            }

            // 使用後イベント
            if (!is_event)
            {
                Event.HandleEvent("使用後", CurrentForm().MainPilot().ID, aname);
                if (SRC.IsScenarioFinished || SRC.IsCanceled)
                {
                    return;
                }
            }

            GUI.CloseMessageForm();

            // ハイパーモード＆ノーマルモードの自動発動をチェック
            SRC.UList.CheckAutoHyperMode();
            SRC.UList.CheckAutoNormalMode();
        }

        // アビリティの使用によるＥＮ、使用回数の消費等を行う
        public void UseAbility(int a)
        {
            int i, lv;
            double hp_ratio, en_ratio;
            if (this.Ability(a).ENConsumption > 0)
            {
                EN = EN - AbilityENConsumption(a);
            }

            if (this.Ability(a).Stock > 0)
            {
                SetStock(a, (Stock(a) - 1));

                // 一斉使用
                if (IsAbilityClassifiedAs(a, "斉"))
                {
                    var loopTo = Information.UBound(dblStock);
                    for (i = 1; i <= loopTo; i++)
                        SetStock(i, GeneralLib.MinLng((MaxStock(i) * Stock(a)) / MaxStock(a), Stock(i)));
                }
                else
                {
                    var loopTo1 = Information.UBound(dblStock);
                    for (i = 1; i <= loopTo1; i++)
                    {
                        if (IsAbilityClassifiedAs(i, "斉"))
                        {
                            SetStock(i, GeneralLib.MinLng(((MaxStock(i) * Stock(a)) / MaxStock(a) + 0.49999d), Stock(i)));
                        }
                    }
                }

                // 弾数・使用回数共有の処理
                SyncBullet();
            }

            // 消耗技
            if (IsAbilityClassifiedAs(a, "消"))
            {
                AddCondition("消耗", 1, cdata: "");
            }

            // 全ＥＮ消費アビリティ
            if (IsAbilityClassifiedAs(a, "尽"))
            {
                EN = 0;
            }

            // チャージ式アビリティ
            if (IsAbilityClassifiedAs(a, "Ｃ") && IsConditionSatisfied("チャージ完了"))
            {
                DeleteCondition("チャージ完了");
            }

            // 自動充填式アビリティ
            if (AbilityLevel(a, "Ａ") > 0d)
            {
                AddCondition(AbilityNickname(a) + "充填中", AbilityLevel(a, "Ａ"), cdata: "");
            }

            // 気力を消費
            if (IsAbilityClassifiedAs(a, "気"))
            {
                IncreaseMorale((-5 * AbilityLevel(a, "気")));
            }

            // 霊力の消費
            if (IsAbilityClassifiedAs(a, "霊"))
            {
                hp_ratio = 100 * HP / (double)MaxHP;
                en_ratio = 100 * EN / (double)MaxEN;
                MainPilot().Plana = (this.MainPilot().Plana - 5d * AbilityLevel(a, "霊"));
                HP = (MaxHP * hp_ratio / 100d);
                EN = (MaxEN * en_ratio / 100d);
            }
            else if (IsAbilityClassifiedAs(a, "プ"))
            {
                hp_ratio = 100 * HP / (double)MaxHP;
                en_ratio = 100 * EN / (double)MaxEN;
                MainPilot().Plana = (this.MainPilot().Plana - 5d * AbilityLevel(a, "プ"));
                HP = (MaxHP * hp_ratio / 100d);
                EN = (MaxEN * en_ratio / 100d);
            }

            // 資金消費アビリティ
            if (Party == "味方")
            {
                if (IsAbilityClassifiedAs(a, "銭"))
                {
                    SRC.IncrMoney(-GeneralLib.MaxLng(AbilityLevel(a, "銭"), 1) * Value / 10);
                }
            }

            // ＨＰ消費アビリティ
            if (IsAbilityClassifiedAs(a, "失"))
            {
                HP = GeneralLib.MaxLng((HP - (long)(MaxHP * AbilityLevel(a, "失")) / 10L), 0);
            }
        }


        // === アイテム関連処理 ===

        // アイテム装備可能数
        public int MaxItemNum()
        {
            int MaxItemNumRet = default;
            int i;
            MaxItemNumRet = Data.ItemNum;
            if (IsFeatureAvailable("ハードポイント"))
            {
                var loopTo = CountFeature();
                for (i = 1; i <= loopTo; i++)
                {
                    string localFeature() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                    string localFeatureData() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                    string localFeatureData1() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                    if (localFeature() == "ハードポイント" && (localFeatureData() == "強化パーツ" || localFeatureData1() == "アイテム"))
                    {
                        double localFeatureLevel() { object argIndex1 = i; var ret = FeatureLevel(argIndex1); return ret; }

                        MaxItemNumRet = (MaxItemNumRet + localFeatureLevel());
                        break;
                    }
                }
            }

            return MaxItemNumRet;
        }

        // 装備しているアイテムの総数
        public int CountItem()
        {
            int CountItemRet = default;
            CountItemRet = colItem.Count;
            return CountItemRet;
        }

        // アイテム
        public Item Item(object Index)
        {
            Item ItemRet = default;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 645387


            Input:

                    On Error GoTo ErrorHandler

             */
            ItemRet = (Item)colItem[Index];
            return ItemRet;
            ErrorHandler:
            ;

            // 見つからなければアイテム名で検索
            foreach (Item itm in colItem)
            {
                // UPGRADE_WARNING: オブジェクト Index の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                if (Conversions.ToBoolean(Operators.ConditionalCompareObjectEqual(itm.Name, Index, false)))
                {
                    ItemRet = itm;
                    return ItemRet;
                }
            }
            // UPGRADE_NOTE: オブジェクト Item をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            ItemRet = null;
        }

        // アイテムを装備
        public void AddItem(Item itm, bool without_refresh = false)
        {
            int i = default, num;
            var itm2 = default(Item);
            int empty_slot;
            bool found_item;

            // 既に装備していたらそのまま終了
            if (object.ReferenceEquals(itm.Unit, this))
            {
                return;
            }

            // イベント専用アイテムは装備個所を消費しない
            if (itm.Class() == "固定")
            {
                if (itm.IsFeatureAvailable("非表示"))
                {
                    goto EquipItem;
                }
            }

            // 装備個所が足りない場合に元のアイテムを外す
            switch (itm.Part() ?? "")
            {
                case "強化パーツ":
                case "アイテム":
                    {
                        if (itm.FeatureData("ハードポイント") != "強化パーツ" && itm.FeatureData("ハードポイント") != "アイテム")
                        {
                            // 装備している強化パーツ数をカウント
                            num = 0;
                            foreach (Item currentItm2 in colItem)
                            {
                                itm2 = currentItm2;
                                {
                                    var withBlock = itm2;
                                    if (withBlock.Part() == "強化パーツ" || withBlock.Part() == "アイテム")
                                    {
                                        num = (num + withBlock.Size());
                                    }
                                }
                            }

                            // 大型アイテムの場合は余分に外す
                            num = (num + itm.FeatureLevel("大型アイテム"));

                            // 何れかを外さなければならない場合
                            while (num >= MaxItemNum() && num > 0)
                            {
                                found_item = false;

                                // まずはハードポイントを持たないものから
                                foreach (Item currentItm21 in colItem)
                                {
                                    itm2 = currentItm21;
                                    {
                                        var withBlock1 = itm2;
                                        if (withBlock1.Part() == "強化パーツ" || withBlock1.Part() == "アイテム")
                                        {
                                            if (!withBlock1.IsFeatureAvailable("ハードポイント"))
                                            {
                                                num = (num - withBlock1.Size());
                                                if (Party0 != "味方")
                                                {
                                                    withBlock1.Exist = false;
                                                }

                                                DeleteItem(withBlock1.ID);
                                                // UPGRADE_NOTE: オブジェクト itm2 をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                                itm2 = null;
                                                found_item = true;
                                                break;
                                            }
                                        }
                                    }
                                }

                                // ハードポイント付きのものしかない場合
                                if (itm2 is object)
                                {
                                    num = (num - Item(1).Size());
                                    if (Party0 != "味方")
                                    {
                                        Item(1).Exist = false;
                                    }

                                    DeleteItem(1);
                                    found_item = true;
                                }

                                if (!found_item)
                                {
                                    // 外せるアイテムがない
                                    break;
                                }
                            }

                            if (MaxItemNum() == 0)
                            {
                                // 装備出来ません…
                                return;
                            }
                        }

                        break;
                    }

                case "両手":
                    {
                        foreach (Item currentItm22 in colItem)
                        {
                            itm2 = currentItm22;
                            if (itm2.Part() == "両手" || itm2.Part() == "片手" || itm2.Part() == "盾")
                            {
                                if (Party0 != "味方")
                                {
                                    itm2.Exist = false;
                                }

                                DeleteItem(itm2.ID);
                                break;
                            }
                        }

                        break;
                    }

                case "片手":
                    {
                        if (IsFeatureAvailable("両手利き"))
                        {
                            num = 0;
                            foreach (Item currentItm23 in colItem)
                            {
                                itm2 = currentItm23;
                                switch (itm2.Part() ?? "")
                                {
                                    case "両手":
                                        {
                                            if (Party0 != "味方")
                                            {
                                                itm2.Exist = false;
                                            }

                                            DeleteItem(itm2.ID);
                                            break;
                                        }

                                    case "片手":
                                    case "盾":
                                        {
                                            num = (num + 1);
                                            if (num > 1)
                                            {
                                                if (Party0 != "味方")
                                                {
                                                    itm2.Exist = false;
                                                }

                                                DeleteItem(itm2.ID);
                                                break;
                                            }

                                            break;
                                        }
                                }
                            }
                        }
                        else
                        {
                            foreach (Item currentItm24 in colItem)
                            {
                                itm2 = currentItm24;
                                switch (itm2.Part() ?? "")
                                {
                                    case "両手":
                                    case "片手":
                                        {
                                            if (Party0 != "味方")
                                            {
                                                itm2.Exist = false;
                                            }

                                            DeleteItem(itm2.ID);
                                            break;
                                        }
                                }
                            }
                        }

                        break;
                    }

                case "盾":
                    {
                        foreach (Item currentItm25 in colItem)
                        {
                            itm2 = currentItm25;
                            switch (itm2.Part() ?? "")
                            {
                                case "両手":
                                case "盾":
                                    {
                                        if (Party0 != "味方")
                                        {
                                            itm2.Exist = false;
                                        }

                                        DeleteItem(itm2.ID);
                                        break;
                                    }

                                case "片手":
                                    {
                                        i = (i + 1);
                                        if (i > 1)
                                        {
                                            if (Party0 != "味方")
                                            {
                                                itm2.Exist = false;
                                            }

                                            DeleteItem(itm2.ID);
                                            break;
                                        }

                                        break;
                                    }
                            }
                        }

                        break;
                    }

                case "両肩":
                    {
                        foreach (Item currentItm26 in colItem)
                        {
                            itm2 = currentItm26;
                            if (itm2.Part() == "両肩" || itm2.Part() == "肩")
                            {
                                if (Party0 != "味方")
                                {
                                    itm2.Exist = false;
                                }

                                DeleteItem(itm2.ID);
                            }
                        }

                        break;
                    }

                case "肩":
                    {
                        num = 0;
                        foreach (Item currentItm27 in colItem)
                        {
                            itm2 = currentItm27;
                            switch (itm2.Part() ?? "")
                            {
                                case "両肩":
                                    {
                                        if (Party0 != "味方")
                                        {
                                            itm2.Exist = false;
                                        }

                                        DeleteItem(itm2.ID);
                                        break;
                                    }

                                case "肩":
                                    {
                                        num = (num + 1);
                                        if (num > 1)
                                        {
                                            if (Party0 != "味方")
                                            {
                                                itm2.Exist = false;
                                            }

                                            DeleteItem(itm2.ID);
                                            break;
                                        }

                                        break;
                                    }
                            }
                        }

                        break;
                    }
                // 装備個所が「非表示」のアイテムは装備数に制限なし

                case "非表示":
                    {
                        break;
                    }

                default:
                    {
                        // ハードポイントに装備する場合
                        var loopTo = CountFeature();
                        for (i = 1; i <= loopTo; i++)
                        {
                            string localFeature() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                            string localFeatureData() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            if (localFeature() == "ハードポイント" && (localFeatureData() ?? "") == (itm.Part() ?? ""))
                            {
                                // まず空きスロット数を計算
                                empty_slot = ItemSlotSize(itm.Part());
                                foreach (Item currentItm28 in colItem)
                                {
                                    itm2 = currentItm28;
                                    if ((itm2.Part() ?? "") == (itm.Part() ?? ""))
                                    {
                                        empty_slot = (empty_slot - itm2.Size());
                                    }
                                }
                                // 足らないスロット数分、アイテムを外す
                                if (empty_slot < itm.Size())
                                {
                                    foreach (Item currentItm29 in colItem)
                                    {
                                        itm2 = currentItm29;
                                        if ((itm2.Part() ?? "") == (itm.Part() ?? ""))
                                        {
                                            if (Party0 != "味方")
                                            {
                                                itm2.Exist = false;
                                            }

                                            DeleteItem(itm2.ID);
                                            empty_slot = (empty_slot + itm2.Size());
                                            if (empty_slot >= itm.Size())
                                            {
                                                break;
                                            }
                                        }
                                    }
                                }

                                i = 0;
                                break;
                            }
                        }
                        // そうでない場合
                        if (i > 0)
                        {
                            foreach (Item currentItm210 in colItem)
                            {
                                itm2 = currentItm210;
                                if ((itm.Part() ?? "") == (itm2.Part() ?? ""))
                                {
                                    if (Party0 != "味方")
                                    {
                                        itm2.Exist = false;
                                    }

                                    DeleteItem(itm2.ID);
                                    break;
                                }
                            }
                        }

                        break;
                    }
            }

            EquipItem:
            ;


            // 装備されたアイテムは常に存在するとみなす
            if (Status != "破棄")
            {
                itm.Exist = true;
            }

            colItem.Add(itm, itm.ID);
            itm.Unit = this;

            // アイテムを装備したことによるステータスの変化
            Update(without_refresh);
        }

        public void AddItem0(Item itm)
        {
            colItem.Add(itm, itm.ID);
            itm.Unit = this;
        }

        // アイテムをはずす
        public void DeleteItem(object Index, bool without_refresh = false)
        {
            Item itm;
            int num, i, j, num2;
            int prev_max_item_num;
            string[] prev_hard_point;
            int[] prev_hard_point_size;
            string[] cur_hard_point;
            int[] cur_hard_point_size;
            bool is_changed;
            bool is_ambidextrous;
            itm = Item(Index);

            // 存在しないアイテム？
            if (itm is null)
            {
                return;
            }

            // 削除するアイテムの武器・アビリティの残弾数が引き継がれるのを防ぐため、
            // 削除するアイテムによって付加された武器・アビリティのデータを削除する。
            num = Data.CountWeapon();
            num2 = Data.CountAbility();
            if (CountPilot() > 0)
            {
                num = (num + MainPilot().Data.CountWeapon());
                num2 = (num2 + MainPilot().Data.CountAbility());
                var loopTo = CountPilot();
                for (i = 2; i <= loopTo; i++)
                {
                    Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    num = (num + localPilot().Data.CountWeapon());
                    Pilot localPilot1() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                    num2 = (num2 + localPilot1().Data.CountAbility());
                }

                var loopTo1 = CountSupport();
                for (i = 2; i <= loopTo1; i++)
                {
                    Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    num = (num + localSupport().Data.CountWeapon());
                    Pilot localSupport1() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    num2 = (num2 + localSupport1().Data.CountAbility());
                }

                if (IsFeatureAvailable("追加サポート"))
                {
                    num = (num + AdditionalSupport().Data.CountWeapon());
                    num2 = (num2 + AdditionalSupport().Data.CountAbility());
                }
            }

            foreach (Item itm2 in colItem)
            {
                if (ReferenceEquals(itm, itm2))
                {
                    var loopTo2 = (num + itm2.CountWeapon());
                    for (i = (num + 1); i <= loopTo2; i++)
                    {
                        if (i <= CountWeapon())
                        {
                            // UPGRADE_NOTE: オブジェクト WData() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                            WData[i] = null;
                        }
                    }

                    var loopTo3 = (num2 + itm2.CountAbility());
                    for (i = (num2 + 1); i <= loopTo3; i++)
                    {
                        if (i <= CountAbility())
                        {
                            // UPGRADE_NOTE: オブジェクト adata() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                            adata[i] = null;
                        }
                    }

                    break;
                }
                else
                {
                    num = (num + itm2.CountWeapon());
                    num2 = (num2 + itm2.CountAbility());
                }
            }

            colItem.Remove(itm.ID);
            if (itm.Unit is object)
            {
                if (itm.Unit.ID == ID)
                {
                    // UPGRADE_NOTE: オブジェクト itm.Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                    itm.Unit = null;
                }
                // 追加パイロットを持つアイテムを削除する場合
                if (itm.IsFeatureAvailable("追加パイロット"))
                {
                    if (SRC.PList.IsDefined(itm.FeatureData(argIndex3)))
                    {
                        {
                            var withBlock = SRC.PList.Item(itm.FeatureData(argIndex1));
                            withBlock.Alive = false;
                            // UPGRADE_NOTE: オブジェクト PList.Item().Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                            withBlock.Unit = null;
                        }
                    }
                }
            }

            // ハードポイントを持つアイテムをはずした場合は他のアイテムを連続してはずす必要がある
            do
            {
                is_changed = false;

                // 現在のアイテム装備可能回数を記録
                prev_max_item_num = MaxItemNum();
                prev_hard_point = new string[1];
                prev_hard_point_size = new int[1];
                var loopTo4 = CountFeature();
                for (i = 1; i <= loopTo4; i++)
                {
                    if (Feature(i) == "ハードポイント")
                    {
                        string localFeatureData1() { object "追加パイロット" = i; var ret = FeatureData("追加パイロット"); return ret; }

                        string localFeatureData2() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        if (localFeatureData1() != "強化パーツ" && localFeatureData2() != "アイテム")
                        {
                            var loopTo5 = Information.UBound(prev_hard_point);
                            for (j = 1; j <= loopTo5; j++)
                            {
                                string localFeatureData() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                                if ((prev_hard_point[j] ?? "") == (localFeatureData() ?? ""))
                                {
                                    double localFeatureLevel() { object argIndex1 = i; var ret = FeatureLevel(argIndex1); return ret; }

                                    prev_hard_point_size[j] = (prev_hard_point_size[j] + localFeatureLevel());
                                    break;
                                }
                            }

                            if (j > Information.UBound(prev_hard_point))
                            {
                                Array.Resize(prev_hard_point, Information.UBound(prev_hard_point) + 1 + 1);
                                Array.Resize(prev_hard_point_size, Information.UBound(prev_hard_point) + 1);
                                prev_hard_point[Information.UBound(prev_hard_point)] = FeatureData(i);
                                prev_hard_point_size[Information.UBound(prev_hard_point)] = FeatureLevel(i);
                            }
                        }
                    }
                }

                is_ambidextrous = IsFeatureAvailable("両手利き");

                // アイテムを外したことによるステータスの変化
                Update(without_refresh);

                // アイテム装備可能数が減少？
                if (prev_max_item_num > MaxItemNum())
                {
                    is_changed = true;
                    num = MaxItemNum();
                    i = 0;
                    foreach (Item currentItm in colItem)
                    {
                        itm = currentItm;
                        if (itm.Part() == "強化パーツ" || itm.Part() == "アイテム")
                        {
                            i = (i + 1);
                            // ハードポイントを持たないアイテムから選んで削除
                            if (i > num && !itm.IsFeatureAvailable("ハードポイント"))
                            {
                                colItem.Remove(itm.ID);
                                if (itm.Unit is object)
                                {
                                    if (itm.Unit.ID == ID)
                                    {
                                        // UPGRADE_NOTE: オブジェクト itm.Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                        itm.Unit = null;
                                    }
                                }
                                // 追加パイロットを持つアイテムを削除する場合
                                if (itm.IsFeatureAvailable("追加パイロット"))
                                {
                                    if (SRC.PList.IsDefined(itm.FeatureData(argIndex10)))
                                    {
                                        {
                                            var withBlock1 = SRC.PList.Item(itm.FeatureData("追加パイロット"));
                                            withBlock1.Alive = false;
                                            // UPGRADE_NOTE: オブジェクト PList.Item().Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                            withBlock1.Unit = null;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    i = 0;
                    foreach (Item currentItm1 in colItem)
                    {
                        itm = currentItm1;
                        if (itm.Part() == "強化パーツ" || itm.Part() == "アイテム")
                        {
                            i = (i + 1);
                            if (i > num)
                            {
                                colItem.Remove(itm.ID);
                                if (itm.Unit is object)
                                {
                                    if (itm.Unit.ID == ID)
                                    {
                                        // UPGRADE_NOTE: オブジェクト itm.Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                        itm.Unit = null;
                                    }
                                }
                                // 追加パイロットを持つアイテムを削除する場合
                                if (itm.IsFeatureAvailable("追加パイロット"))
                                {
                                    if (SRC.PList.IsDefined(itm.FeatureData("追加パイロット")))
                                    {
                                        {
                                            var withBlock2 = SRC.PList.Item(itm.FeatureData("追加パイロット"));
                                            withBlock2.Alive = false;
                                            // UPGRADE_NOTE: オブジェクト PList.Item().Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                            withBlock2.Unit = null;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // 現在のアイテム装備可能回数を記録
                cur_hard_point = new string[1];
                cur_hard_point_size = new int[1];
                var loopTo6 = CountFeature();
                for (i = 1; i <= loopTo6; i++)
                {
                    if (Feature(i) == "ハードポイント")
                    {
                        var loopTo7 = Information.UBound(cur_hard_point);
                        for (j = 1; j <= loopTo7; j++)
                        {
                            string localFeatureData3() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            if ((cur_hard_point[j] ?? "") == (localFeatureData3() ?? ""))
                            {
                                double localFeatureLevel1() { object argIndex1 = i; var ret = FeatureLevel(argIndex1); return ret; }

                                cur_hard_point_size[j] = (cur_hard_point_size[j] + localFeatureLevel1());
                                break;
                            }
                        }

                        if (j > Information.UBound(cur_hard_point))
                        {
                            Array.Resize(cur_hard_point, Information.UBound(cur_hard_point) + 1 + 1);
                            Array.Resize(cur_hard_point_size, Information.UBound(cur_hard_point) + 1);
                            cur_hard_point[Information.UBound(cur_hard_point)] = FeatureData(i);
                            cur_hard_point_size[Information.UBound(cur_hard_point)] = FeatureLevel(i);
                        }
                    }
                }

                // ハードポイントが減少？
                var loopTo8 = Information.UBound(prev_hard_point);
                for (i = 1; i <= loopTo8; i++)
                {
                    num = 0;
                    var loopTo9 = Information.UBound(cur_hard_point);
                    for (j = 1; j <= loopTo9; j++)
                    {
                        if ((prev_hard_point[i] ?? "") == (cur_hard_point[j] ?? ""))
                        {
                            num = cur_hard_point_size[j];
                        }
                    }

                    if (num < prev_hard_point_size[i])
                    {
                        is_changed = true;
                        foreach (Item currentItm2 in colItem)
                        {
                            itm = currentItm2;
                            if ((itm.Part() ?? "") == (prev_hard_point[i] ?? ""))
                            {
                                num = (num - itm.Size());
                                if (num < 0)
                                {
                                    colItem.Remove(itm.ID);
                                    if (itm.Unit is object)
                                    {
                                        if (itm.Unit.ID == ID)
                                        {
                                            // UPGRADE_NOTE: オブジェクト itm.Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                            itm.Unit = null;
                                        }
                                    }
                                    // 追加パイロットを持つアイテムを削除する場合
                                    if (itm.IsFeatureAvailable("追加パイロット"))
                                    {
                                        if (SRC.PList.IsDefined(itm.FeatureData("追加パイロット")))
                                        {
                                            {
                                                var withBlock3 = SRC.PList.Item(itm.FeatureData(argIndex19));
                                                withBlock3.Alive = false;
                                                // UPGRADE_NOTE: オブジェクト PList.Item().Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                                withBlock3.Unit = null;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // 両手利きで無くなってしまった場合は二個目の片手アイテムを外す
                if (is_ambidextrous && !IsFeatureAvailable("両手利き"))
                {
                    num = 0;
                    foreach (Item currentItm3 in colItem)
                    {
                        itm = currentItm3;
                        if (itm.Part() == "片手")
                        {
                            num = (num + 1);
                            if (num > 1)
                            {
                                is_changed = true;
                                colItem.Remove(itm.ID);
                                if (itm.Unit is object)
                                {
                                    if (itm.Unit.ID == ID)
                                    {
                                        // UPGRADE_NOTE: オブジェクト itm.Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                        itm.Unit = null;
                                    }
                                }
                                // 追加パイロットを持つアイテムを削除する場合
                                if (itm.IsFeatureAvailable("追加パイロット"))
                                {
                                    if (SRC.PList.IsDefined(itm.FeatureData("追加パイロット")))
                                    {
                                        {
                                            var withBlock4 = SRC.PList.Item(itm.FeatureData("追加パイロット"));
                                            withBlock4.Alive = false;
                                            // UPGRADE_NOTE: オブジェクト PList.Item().Unit をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                            withBlock4.Unit = null;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            while (is_changed);
        }

        // 装備個所が ipart のアイテムの装備可能数
        public int ItemSlotSize(string ipart)
        {
            int ItemSlotSizeRet = default;
            int i;
            switch (ipart ?? "")
            {
                case "強化パーツ":
                case "アイテム":
                    {
                        ItemSlotSizeRet = Data.ItemNum;
                        if (!IsFeatureAvailable("ハードポイント"))
                        {
                            return ItemSlotSizeRet;
                        }

                        var loopTo = CountFeature();
                        for (i = 1; i <= loopTo; i++)
                        {
                            if (Feature(i) == "ハードポイント")
                            {
                                switch (FeatureData(i) ?? "")
                                {
                                    case "強化パーツ":
                                    case "アイテム":
                                        {
                                            double localFeatureLevel() { object argIndex1 = i; var ret = FeatureLevel(argIndex1); return ret; }

                                            ItemSlotSizeRet = (ItemSlotSizeRet + localFeatureLevel());
                                            break;
                                        }
                                }
                            }
                        }

                        break;
                    }

                default:
                    {
                        if (!IsFeatureAvailable("ハードポイント"))
                        {
                            ItemSlotSizeRet = 1;
                            return ItemSlotSizeRet;
                        }

                        var loopTo1 = CountFeature();
                        for (i = 1; i <= loopTo1; i++)
                        {
                            if (Feature(i) == "ハードポイント")
                            {
                                if ((FeatureData(i) ?? "") == (ipart ?? ""))
                                {
                                    double localFeatureLevel1() { object argIndex1 = i; var ret = FeatureLevel(argIndex1); return ret; }

                                    ItemSlotSizeRet = (ItemSlotSizeRet + localFeatureLevel1());
                                }
                            }
                        }

                        break;
                    }
            }

            return ItemSlotSizeRet;
        }

        // アイテム iname を装備しているか？
        public bool IsEquiped(string iname)
        {
            bool IsEquipedRet = default;
            int i;
            IsEquipedRet = false;
            var loopTo = CountItem();
            for (i = 1; i <= loopTo; i++)
            {
                Item localItem() { object argIndex1 = i; var ret = Item(argIndex1); return ret; }

                if ((localItem().Name ?? "") == (iname ?? ""))
                {
                    IsEquipedRet = true;
                    return IsEquipedRet;
                }
            }

            return IsEquipedRet;
        }

        // 装備可能な武器クラス
        public string WeaponProficiency()
        {
            string WeaponProficiencyRet = default;
            foreach (FeatureData fd in colFeature)
            {
                if (fd.Name == "武器クラス")
                {
                    WeaponProficiencyRet = WeaponProficiencyRet + " " + fd.StrData;
                }
            }

            return WeaponProficiencyRet;
        }

        // 装備可能な防具クラス
        public string ArmorProficiency()
        {
            string ArmorProficiencyRet = default;
            foreach (FeatureData fd in colFeature)
            {
                if (fd.Name == "防具クラス")
                {
                    ArmorProficiencyRet = ArmorProficiencyRet + " " + fd.StrData;
                }
            }

            return ArmorProficiencyRet;
        }

        // アイテムitを装備できるかどうかを判定
        public bool IsAbleToEquip(Item it)
        {
            bool IsAbleToEquipRet = default;
            string iclass;
            string eclass0, uclass, eclass;
            int i, j;
            // 既に装備済みのアイテムは装備できない
            if (it.Unit is object)
            {
                if (it.Unit.ID == ID)
                {
                    IsAbleToEquipRet = false;
                    return IsAbleToEquipRet;
                }
            }

            // Fixコマンドで固定されたアイテムは装備不可能
            if (Expression.IsGlobalVariableDefined("Fix(" + it.Name + ")"))
            {
                IsAbleToEquipRet = false;
                return IsAbleToEquipRet;
            }

            // 必要技能は満たしているか？
            if (!it.IsAvailable(this))
            {
                IsAbleToEquipRet = false;
                return IsAbleToEquipRet;
            }

            // アイテムのクラスを記録
            iclass = it.Class();

            // 汎用ならばユニットの種類に関わらず装備可能
            if (iclass == "汎用")
            {
                // ただし強化パーツのチェックは必要
                if (it.Part() == "強化パーツ" && IsHero())
                {
                    IsAbleToEquipRet = false;
                    return IsAbleToEquipRet;
                }

                IsAbleToEquipRet = true;
                return IsAbleToEquipRet;
            }

            // 固定アイテムは装備不能とみなす
            if (iclass == "固定")
            {
                IsAbleToEquipRet = false;
                return IsAbleToEquipRet;
            }

            // ユニットクラスから余分な指定を取り除く
            uclass = Class0;

            // 装備個所
            switch (it.Part() ?? "")
            {
                case "武器":
                case "片手":
                case "両手":
                    {
                        eclass = WeaponProficiency();
                        var loopTo = GeneralLib.LLength(eclass);
                        for (i = 1; i <= loopTo; i++)
                        {
                            eclass0 = GeneralLib.LIndex(eclass, i);
                            if ((iclass ?? "") == (eclass0 ?? ""))
                            {
                                IsAbleToEquipRet = true;
                                return IsAbleToEquipRet;
                            }
                            else if (Strings.InStr(iclass, "専用)") > 0)
                            {
                                // ユニットクラス、ユニット名による専用指定？
                                if (Strings.InStr(iclass, eclass0 + "(") == 1 && (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 || Strings.InStr(iclass, "(" + Name + "専用)") > 0 || Strings.InStr(iclass, "(" + Nickname + "専用)") > 0))
                                {
                                    IsAbleToEquipRet = true;
                                    return IsAbleToEquipRet;
                                }

                                // 性別による専用指定？
                                if (CountPilot() > 0)
                                {
                                    if ((iclass ?? "") == (eclass0 + "(" + MainPilot().Sex + "専用)" ?? ""))
                                    {
                                        IsAbleToEquipRet = true;
                                        return IsAbleToEquipRet;
                                    }
                                }
                            }
                        }

                        // 一部の形態でのみ利用可能な武器の判定
                        var loopTo1 = CountOtherForm();
                        for (i = 1; i <= loopTo1; i++)
                        {
                            {
                                var withBlock = OtherForm(i);
                                uclass = withBlock.Class0;
                                eclass = withBlock.WeaponProficiency();
                                var loopTo2 = GeneralLib.LLength(eclass);
                                for (j = 1; j <= loopTo2; j++)
                                {
                                    eclass0 = GeneralLib.LIndex(eclass, j);
                                    if ((iclass ?? "") == (eclass0 ?? ""))
                                    {
                                        IsAbleToEquipRet = true;
                                        return IsAbleToEquipRet;
                                    }
                                    else if (Strings.InStr(iclass, "専用)") > 0)
                                    {
                                        // ユニットクラス、ユニット名による専用指定？
                                        if (Strings.InStr(iclass, eclass0 + "(") == 1 && (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 || Strings.InStr(iclass, "(" + withBlock.Name + "専用)") > 0 || Strings.InStr(iclass, "(" + withBlock.Nickname + "専用)") > 0))
                                        {
                                            IsAbleToEquipRet = true;
                                            return IsAbleToEquipRet;
                                        }

                                        // 性別による専用指定？
                                        if (CountPilot() > 0)
                                        {
                                            if ((iclass ?? "") == (eclass0 + "(" + MainPilot().Sex + "専用)" ?? ""))
                                            {
                                                IsAbleToEquipRet = true;
                                                return IsAbleToEquipRet;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        break;
                    }

                case "体":
                case "頭":
                case "盾":
                    {
                        eclass = ArmorProficiency();
                        var loopTo3 = GeneralLib.LLength(eclass);
                        for (i = 1; i <= loopTo3; i++)
                        {
                            eclass0 = GeneralLib.LIndex(eclass, i);
                            if ((iclass ?? "") == (eclass0 ?? ""))
                            {
                                IsAbleToEquipRet = true;
                                return IsAbleToEquipRet;
                            }
                            else if (Strings.InStr(iclass, "専用)") > 0)
                            {
                                // ユニットクラス、ユニット名による専用指定？
                                if (Strings.InStr(iclass, eclass0 + "(") == 1 && (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 || Strings.InStr(iclass, "(" + Name + "専用)") > 0 || Strings.InStr(iclass, "(" + Nickname + "専用)") > 0))
                                {
                                    IsAbleToEquipRet = true;
                                    return IsAbleToEquipRet;
                                }

                                // 性別による専用指定？
                                if (CountPilot() > 0)
                                {
                                    if ((iclass ?? "") == (eclass0 + "(" + MainPilot().Sex + "専用)" ?? ""))
                                    {
                                        IsAbleToEquipRet = true;
                                        return IsAbleToEquipRet;
                                    }
                                }
                            }
                        }

                        // 一部の形態でのみ利用可能な防具の判定
                        var loopTo4 = CountOtherForm();
                        for (i = 1; i <= loopTo4; i++)
                        {
                            {
                                var withBlock1 = OtherForm(i);
                                uclass = withBlock1.Class0;
                                eclass = withBlock1.ArmorProficiency();
                                var loopTo5 = GeneralLib.LLength(eclass);
                                for (j = 1; j <= loopTo5; j++)
                                {
                                    eclass0 = GeneralLib.LIndex(eclass, j);
                                    if ((iclass ?? "") == (eclass0 ?? ""))
                                    {
                                        IsAbleToEquipRet = true;
                                        return IsAbleToEquipRet;
                                    }
                                    else if (Strings.InStr(iclass, "専用)") > 0)
                                    {
                                        // ユニットクラス、ユニット名による専用指定？
                                        if (Strings.InStr(iclass, eclass0 + "(") == 1 && (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 || Strings.InStr(iclass, "(" + withBlock1.Name + "専用)") > 0 || Strings.InStr(iclass, "(" + withBlock1.Nickname + "専用)") > 0))
                                        {
                                            IsAbleToEquipRet = true;
                                            return IsAbleToEquipRet;
                                        }

                                        // 性別による専用指定？
                                        if (CountPilot() > 0)
                                        {
                                            if ((iclass ?? "") == (eclass0 + "(" + MainPilot().Sex + "専用)" ?? ""))
                                            {
                                                IsAbleToEquipRet = true;
                                                return IsAbleToEquipRet;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        break;
                    }

                case "アイテム":
                case "強化パーツ":
                    {
                        // 強化パーツは人間ユニットには装備できない
                        if (Strings.InStr(it.Part(), "強化パーツ") == 1)
                        {
                            if (IsHero())
                            {
                                IsAbleToEquipRet = false;
                                return IsAbleToEquipRet;
                            }
                        }

                        // これらのアイテムは専用アイテムでない限り必ず装備可能
                        if (Strings.InStr(iclass, "専用)") == 0)
                        {
                            IsAbleToEquipRet = true;
                            return IsAbleToEquipRet;
                        }

                        // ユニットクラス、ユニット名による専用指定？
                        if (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 || Strings.InStr(iclass, "(" + Name + "専用)") > 0 || Strings.InStr(iclass, "(" + Nickname + "専用)") > 0)
                        {
                            IsAbleToEquipRet = true;
                            return IsAbleToEquipRet;
                        }

                        // 性別による専用指定？
                        if (CountPilot() > 0)
                        {
                            if (Strings.InStr(iclass, "(" + MainPilot().Sex + "専用)") > 0)
                            {
                                IsAbleToEquipRet = true;
                                return IsAbleToEquipRet;
                            }
                        }

                        // 他の形態の名前で専用指定されている？
                        var loopTo6 = CountOtherForm();
                        for (i = 1; i <= loopTo6; i++)
                        {
                            {
                                var withBlock2 = OtherForm(i);
                                if (Strings.InStr(iclass, "(" + withBlock2.Class0 + "専用)") > 0 || Strings.InStr(iclass, "(" + withBlock2.Name + "専用)") > 0 || Strings.InStr(iclass, "(" + withBlock2.Nickname + "専用)") > 0)
                                {
                                    IsAbleToEquipRet = true;
                                    return IsAbleToEquipRet;
                                }
                            }
                        }

                        break;
                    }

                default:
                    {
                        // 創作された装備個所のアイテムは専用アイテムでない限り必ず装備可能
                        if (Strings.InStr(iclass, "専用)") == 0)
                        {
                            IsAbleToEquipRet = true;
                            return IsAbleToEquipRet;
                        }

                        // ユニットクラス、ユニット名による専用指定？
                        if (Strings.InStr(iclass, "(" + uclass + "専用)") > 0 || Strings.InStr(iclass, "(" + Name + "専用)") > 0 || Strings.InStr(iclass, "(" + Nickname + "専用)") > 0)
                        {
                            IsAbleToEquipRet = true;
                            return IsAbleToEquipRet;
                        }

                        // 性別による専用指定？
                        if (CountPilot() > 0)
                        {
                            if (Strings.InStr(iclass, "(" + MainPilot().Sex + "専用)") > 0)
                            {
                                IsAbleToEquipRet = true;
                                return IsAbleToEquipRet;
                            }
                        }

                        // 他の形態の名前で専用指定されている？
                        var loopTo7 = CountOtherForm();
                        for (i = 1; i <= loopTo7; i++)
                        {
                            {
                                var withBlock3 = OtherForm(i);
                                if (Strings.InStr(iclass, "(" + withBlock3.Class0 + "専用)") > 0 || Strings.InStr(iclass, "(" + withBlock3.Name + "専用)") > 0 || Strings.InStr(iclass, "(" + withBlock3.Nickname + "専用)") > 0)
                                {
                                    IsAbleToEquipRet = true;
                                    return IsAbleToEquipRet;
                                }
                            }
                        }

                        break;
                    }
            }

            IsAbleToEquipRet = false;
            return IsAbleToEquipRet;
        }


        // === メッセージ関連処理 ===

        // 状況 Situation に応じたパイロットメッセージを表示
        public void PilotMessage(string Situation, [Optional, DefaultParameterValue("")] string msg_mode)
        {
            int k, i, j, w;
            Pilot p;
            MessageData md;
            Dialog dd;
            string msg;
            string[] situations;
            var wname = default(string);
            string[] pnames;
            string buf;
            var selected_pilot = default(string);
            var selected_situation = default(string);
            var selected_msg = default(string);

            // WAVEを演奏したかチェックするため、あらかじめクリア
            Sound.IsWavePlayed = false;

            // 対応メッセージが定義されていなかった場合に使用するシチュエーションを設定
            situations = new string[2];
            situations[1] = Situation;
            switch (Situation ?? "")
            {
                case "分身":
                case "切り払い":
                case "迎撃":
                case "反射":
                case "当て身技":
                case "阻止":
                case "ダミー":
                case "緊急テレポート":
                    {
                        Array.Resize(situations, 3);
                        situations[2] = "回避";
                        break;
                    }

                case "ビーム無効化":
                case "攻撃無効化":
                case "シールド防御":
                    {
                        Array.Resize(situations, 3);
                        situations[2] = "ダメージ小";
                        break;
                    }

                case "回避":
                case "破壊":
                case "ダメージ大":
                case "ダメージ中":
                case "ダメージ小":
                case "かけ声":
                    {
                        break;
                    }

                default:
                    {
                        if (msg_mode == "攻撃" || msg_mode == "カウンター")
                        {
                            // 攻撃メッセージ
                            wname = situations[1];

                            // 武器番号を検索
                            var loopTo = CountWeapon();
                            for (w = 1; w <= loopTo; w++)
                            {
                                {
                                    var withBlock = Weapon(w);
                                    if ((Situation ?? "") == (withBlock.Name ?? "") || (Situation ?? "") == (withBlock.Nickname() ?? ""))
                                    {
                                        break;
                                    }
                                }
                            }

                            if (!IsDefense())
                            {
                                Array.Resize(situations, 3);
                                if (IsWeaponClassifiedAs(w, "格闘系"))
                                {
                                    situations[2] = "格闘";
                                }
                                else
                                {
                                    situations[2] = "射撃";
                                }
                            }
                            else if (msg_mode == "カウンター")
                            {
                                Array.Resize(situations, 4);
                                situations[1] = Situation + "(反撃)";
                                situations[2] = Situation;
                                if (IsWeaponClassifiedAs(w, "格闘系"))
                                {
                                    situations[3] = "格闘";
                                }
                                else
                                {
                                    situations[3] = "射撃";
                                }
                            }
                            else
                            {
                                Array.Resize(situations, 5);
                                situations[1] = Situation + "(反撃)";
                                situations[2] = Situation;
                                if (IsWeaponClassifiedAs(w, "格闘系"))
                                {
                                    situations[3] = "格闘(反撃)";
                                    situations[4] = "格闘";
                                }
                                else
                                {
                                    situations[3] = "射撃(反撃)";
                                    situations[4] = "射撃";
                                }
                            }
                        }
                        else if (msg_mode == "アビリティ")
                        {
                            Array.Resize(situations, 3);
                            situations[2] = "アビリティ";
                        }
                        else if (Strings.InStr(Situation, "(命中)") > 0 || Strings.InStr(Situation, "(回避)") > 0 || Strings.InStr(Situation, "(とどめ)") > 0 || Strings.InStr(Situation, "(クリティカル)") > 0)
                        {
                            // サブシチュエーション付きの攻撃メッセージ

                            // 武器番号を検索
                            wname = Strings.Left(Situation, GeneralLib.InStr2(Situation, "(") - 1);
                            var loopTo1 = CountWeapon();
                            for (w = 1; w <= loopTo1; w++)
                            {
                                {
                                    var withBlock1 = Weapon(w);
                                    if ((wname ?? "") == (withBlock1.Name ?? "") || (wname ?? "") == (withBlock1.Nickname() ?? ""))
                                    {
                                        break;
                                    }
                                }
                            }

                            if (!IsDefense())
                            {
                                Array.Resize(situations, 3);
                                if (IsWeaponClassifiedAs(w, "格闘系"))
                                {
                                    situations[2] = "格闘" + Strings.Mid(Situation, GeneralLib.InStr2(Situation, "("));
                                }
                                else
                                {
                                    situations[2] = "射撃" + Strings.Mid(Situation, GeneralLib.InStr2(Situation, "("));
                                }
                            }
                            else if (msg_mode == "カウンター")
                            {
                                Array.Resize(situations, 4);
                                situations[1] = Situation + "(反撃)";
                                situations[2] = Situation;
                                if (IsWeaponClassifiedAs(w, "格闘系"))
                                {
                                    situations[3] = "格闘" + Strings.Mid(Situation, GeneralLib.InStr2(Situation, "("));
                                }
                                else
                                {
                                    situations[3] = "射撃" + Strings.Mid(Situation, GeneralLib.InStr2(Situation, "("));
                                }
                            }
                            else
                            {
                                Array.Resize(situations, 5);
                                situations[1] = Situation + "(反撃)";
                                situations[2] = Situation;
                                if (IsWeaponClassifiedAs(w, "格闘系"))
                                {
                                    situations[3] = "格闘" + Strings.Mid(Situation, GeneralLib.InStr2(Situation, "(")) + "(反撃)";
                                    situations[4] = "格闘" + Strings.Mid(Situation, GeneralLib.InStr2(Situation, "("));
                                }
                                else
                                {
                                    situations[3] = "射撃" + Strings.Mid(Situation, GeneralLib.InStr2(Situation, "(")) + "(反撃)";
                                    situations[4] = "射撃" + Strings.Mid(Situation, GeneralLib.InStr2(Situation, "("));
                                }
                            }
                        }
                        // 攻撃メッセージでなくても一応攻撃武器名を設定
                        else if (ReferenceEquals(Commands.SelectedUnit, this))
                        {
                            if (0 < Commands.SelectedWeapon && Commands.SelectedWeapon <= CountWeapon())
                            {
                                wname = Weapon(Commands.SelectedWeapon).Name;
                            }
                        }
                        else if (ReferenceEquals(Commands.SelectedTarget, this))
                        {
                            if (0 < Commands.SelectedTWeapon && Commands.SelectedTWeapon <= CountWeapon())
                            {
                                wname = Weapon(Commands.SelectedTWeapon).Name;
                            }
                        }

                        break;
                    }
            }

            // SelectMessageコマンド
            var loopTo2 = Information.UBound(situations);
            for (i = 1; i <= loopTo2; i++)
            {
                buf = "Message(" + MainPilot().ID + "," + situations[i] + ")";
                if (Expression.IsLocalVariableDefined(buf))
                {
                    // UPGRADE_WARNING: オブジェクト LocalVariableList.Item().StringValue の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                    selected_msg = Conversions.ToString(Event.LocalVariableList[buf].StringValue);
                    selected_situation = situations[i];
                    Expression.UndefineVariable(buf);
                    break;
                }

                if (situations[i] == "格闘" || situations[i] == "射撃")
                {
                    buf = "Message(" + MainPilot().ID + ",攻撃)";
                    if (Expression.IsLocalVariableDefined(buf))
                    {
                        // UPGRADE_WARNING: オブジェクト LocalVariableList.Item().StringValue の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                        selected_msg = Conversions.ToString(Event.LocalVariableList[buf].StringValue);
                        selected_situation = "攻撃";
                        Expression.UndefineVariable(buf);
                        break;
                    }
                }

                if (situations[i] == "格闘(反撃)" || situations[i] == "射撃(反撃)")
                {
                    buf = "Message(" + MainPilot().ID + ",攻撃(反撃))";
                    if (Expression.IsLocalVariableDefined(buf))
                    {
                        // UPGRADE_WARNING: オブジェクト LocalVariableList.Item().StringValue の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                        selected_msg = Conversions.ToString(Event.LocalVariableList[buf].StringValue);
                        selected_situation = "攻撃(反撃)";
                        Expression.UndefineVariable(buf);
                        break;
                    }
                }
            }

            if (Strings.InStr(selected_msg, "::") > 0)
            {
                selected_pilot = Strings.Left(selected_msg, Strings.InStr(selected_msg, "::") - 1);
                selected_msg = Strings.Mid(selected_msg, Strings.InStr(selected_msg, "::") + 2);
            }

            // かけ声は３分の２の確率で表示
            if (string.IsNullOrEmpty(selected_msg))
            {
                if (Strings.InStr(Situation, "かけ声") == 1)
                {
                    if (GeneralLib.Dice(3) == 1)
                    {
                        return;
                    }
                }
            }

            // しゃべれない場合
            // ただしSetMessageコマンドでメッセージが設定されている場合は
            // そちらを使用。
            if (string.IsNullOrEmpty(selected_msg))
            {
                if (IsConditionSatisfied("石化") || IsConditionSatisfied("凍結") || IsConditionSatisfied("麻痺"))
                {
                    // 意識不明
                    return;
                }

                if (IsConditionSatisfied("沈黙") || IsConditionSatisfied("憑依"))
                {
                    // 無言
                    if (Strings.InStr(Situation, "(") == 0)
                    {
                        switch (Situation ?? "")
                        {
                            case "ダメージ中":
                            case "ダメージ大":
                            case "破壊":
                                {
                                    if (SRC.NPDList.IsDefined(MainPilot().Name + "(ダメージ)"))
                                    {
                                        GUI.DisplayBattleMessage(MainPilot().Name + "(ダメージ)", "…………！", msg_mode: "");
                                        return;
                                    }

                                    break;
                                }

                            case "かけ声":
                                {
                                    return;
                                }
                        }

                        if (!string.IsNullOrEmpty(wname))
                        {
                            if (SRC.NPDList.IsDefined(MainPilot().Name + "(攻撃)"))
                            {
                                GUI.DisplayBattleMessage(MainPilot().Name + "(攻撃)", "…………！", msg_mode: "");
                                return;
                            }
                        }

                        GUI.DisplayBattleMessage(MainPilot().ID, "…………", msg_mode: "");
                    }

                    return;
                }

                if (IsConditionSatisfied("睡眠"))
                {
                    // 寝言
                    if (Strings.InStr(Situation, "(") == 0)
                    {
                        GUI.DisplayBattleMessage(MainPilot().ID, "ＺＺＺ……", msg_mode: "");
                    }

                    return;
                }

                if (IsConditionSatisfied("恐怖"))
                {
                    if (IsMessageDefined("恐怖"))
                    {
                        // 恐怖状態用メッセージが定義されていればそちらを使う
                        situations = new string[2];
                        situations[1] = "恐怖";
                    }
                    else
                    {
                        // パニック時のメッセージを作成して表示
                        if (Strings.InStr(Situation, "(") == 0)
                        {
                            msg = "";
                            switch (MainPilot().Sex ?? "")
                            {
                                case "男性":
                                    {
                                        switch (GeneralLib.Dice(4))
                                        {
                                            case 1:
                                                {
                                                    msg = "う、うわああああっ！";
                                                    break;
                                                }

                                            case 2:
                                                {
                                                    msg = "うわあああっ！";
                                                    break;
                                                }

                                            case 3:
                                                {
                                                    msg = "ひ、ひいいいっ！";
                                                    break;
                                                }

                                            case 4:
                                                {
                                                    msg = "ひいいいっ！";
                                                    break;
                                                }
                                        }

                                        break;
                                    }

                                case "女性":
                                    {
                                        switch (GeneralLib.Dice(4))
                                        {
                                            case 1:
                                                {
                                                    msg = "きゃあああああっ！";
                                                    break;
                                                }

                                            case 2:
                                                {
                                                    msg = "きゃああっ！";
                                                    break;
                                                }

                                            case 3:
                                                {
                                                    msg = "うわあああっ！";
                                                    break;
                                                }

                                            case 4:
                                                {
                                                    msg = "た、助けてええっ！";
                                                    break;
                                                }
                                        }

                                        break;
                                    }
                            }

                            if (!string.IsNullOrEmpty(msg))
                            {
                                bool localIsDefined() { object argIndex1 = MainPilot().Name + "(ダメージ)"; var ret = SRC.NPDList.IsDefined(argIndex1); return ret; }

                                if (SRC.NPDList.IsDefined(MainPilot().Name + "(泣き)"))
                                {
                                    GUI.DisplayBattleMessage(MainPilot().Name + "(泣き)", msg, msg_mode: "");
                                }
                                else if (localIsDefined())
                                {
                                    GUI.DisplayBattleMessage(MainPilot().Name + "(ダメージ)", msg, msg_mode: "");
                                }
                                else
                                {
                                    GUI.DisplayBattleMessage(MainPilot().ID, msg, msg_mode: "");
                                }
                            }
                        }

                        return;
                    }
                }

                if (IsConditionSatisfied("混乱"))
                {
                    if (IsMessageDefined("混乱"))
                    {
                        // 混乱状態用メッセージが定義されていればそちらを使う
                        situations = new string[2];
                        situations[1] = "混乱";
                    }
                }
            }

            // ダイアログデータを使って判定
            pnames = new string[4];
            pnames[1] = MainPilot().MessageType;
            pnames[2] = MainPilot().MessageType;
            pnames[3] = MainPilot().MessageType;
            if (IsFeatureAvailable("追加パイロット"))
            {
                Array.Resize(pnames, 5);
                pnames[4] = Pilot(1).MessageType;
            }

            var loopTo3 = CountPilot();
            for (i = 2; i <= loopTo3; i++)
            {
                Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                pnames[1] = pnames[1] + " " + localPilot().MessageType;
                Pilot localPilot1() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                pnames[2] = pnames[2] + " " + localPilot1().MessageType;
            }

            var loopTo4 = CountSupport();
            for (i = 1; i <= loopTo4; i++)
            {
                Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                pnames[1] = pnames[1] + " " + localSupport().MessageType;
            }

            if (IsFeatureAvailable("追加サポート"))
            {
                pnames[1] = pnames[1] + " " + AdditionalSupport().MessageType;
            }

            if ((Situation ?? "") == (Commands.SelectedSpecialPower ?? ""))
            {
                pnames[3] = Commands.SelectedPilot.MessageType;
            }

            var loopTo5 = Information.UBound(pnames);
            for (i = 1; i <= loopTo5; i++)
            {
                // 追加パイロットにメッセージデータがあればそちらを優先
                if (i == 4)
                {
                    bool localIsDefined1() { object argIndex1 = MainPilot().MessageType; var ret = SRC.MDList.IsDefined(argIndex1); MainPilot().MessageType = Conversions.ToString(argIndex1); return ret; }

                    if (localIsDefined1())
                    {
                        break;
                    }
                }

                var tmp1 = pnames;
                if (SRC.DDList.IsDefined(tmp1[i]))
                {
                    var tmp = pnames;
                    {
                        var withBlock2 = SRC.DDList.Item(tmp[i]);
                        if (!string.IsNullOrEmpty(selected_msg))
                        {
                            // SelectMessageで選択されたメッセージを検索
                            k = 0;
                            var loopTo6 = withBlock2.CountDialog();
                            for (j = 1; j <= loopTo6; j++)
                            {
                                if ((withBlock2.Situation(j) ?? "") == (selected_situation ?? ""))
                                {
                                    k = (k + 1);
                                    if ((Microsoft.VisualBasic.Compatibility.VB6.Support.Format(k) ?? "") == (selected_msg ?? ""))
                                    {
                                        PlayDialog(withBlock2.Dialog(j), wname);
                                        return;
                                    }
                                }
                                else if ((withBlock2.Situation(j) ?? "") == (selected_msg ?? ""))
                                {
                                    PlayDialog(withBlock2.Dialog(j), wname);
                                    return;
                                }
                            }
                        }
                        else
                        {
                            var loopTo7 = Information.UBound(situations);
                            for (j = 1; j <= loopTo7; j++)
                            {
                                dd = withBlock2.SelectDialog(situations[j], this);
                                if (dd is object)
                                {
                                    PlayDialog(dd, wname);
                                    return;
                                }
                            }
                        }
                    }
                }
            }

            // ゲッターのようなユニットは必ずメインパイロットを使ってメッセージを表示
            if (Data.PilotNum > 0 && ReferenceEquals(MainPilot(), Pilot(1)) && (Situation ?? "") != (Commands.SelectedSpecialPower ?? ""))
            {
                i = GeneralLib.Dice(CountPilot() + CountSupport());
            }
            else
            {
                i = 1;
            }

            TryAgain:
            ;

            // 選んだパイロットによるメッセージデータで判定
            if ((Situation ?? "") == (Commands.SelectedSpecialPower ?? ""))
            {
                bool localIsDefined2() { object argIndex1 = Commands.SelectedPilot.MessageType; var ret = SRC.MDList.IsDefined(argIndex1); Commands.SelectedPilot.MessageType = Conversions.ToString(argIndex1); return ret; }

                if (!localIsDefined2())
                {
                    goto TrySelectedMessage;
                }
            }
            else if (i == 1)
            {
                bool localIsDefined4() { object argIndex1 = MainPilot().MessageType; var ret = SRC.MDList.IsDefined(argIndex1); MainPilot().MessageType = Conversions.ToString(argIndex1); return ret; }

                bool localIsDefined5() { object argIndex1 = 1; object argIndex2 = Pilot(argIndex1).MessageType; var ret = SRC.MDList.IsDefined(argIndex2); Pilot(argIndex1).MessageType = Conversions.ToString(argIndex2); return ret; }

                if (!localIsDefined4() && !localIsDefined5())
                {
                    goto TrySelectedMessage;
                }
            }
            else if (i <= CountPilot())
            {
                Pilot localPilot2() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                bool localIsDefined6() { object argIndex1 = (object)hsfce6a149060e4f46a8f718c3a6bd3f01().MessageType; var ret = SRC.MDList.IsDefined(argIndex1); hsfce6a149060e4f46a8f718c3a6bd3f01().MessageType = Conversions.ToString(argIndex1); return ret; }

                if (!localIsDefined6())
                {
                    i = 1;
                    goto TryAgain;
                }
            }
            else
            {
                Pilot localSupport1() { object argIndex1 = i - CountPilot(); var ret = Support(argIndex1); return ret; }

                bool localIsDefined3() { object argIndex1 = (object)hsaf4c50d4b23f4cb1b890b9fa34bacc97().MessageType; var ret = SRC.MDList.IsDefined(argIndex1); hsaf4c50d4b23f4cb1b890b9fa34bacc97().MessageType = Conversions.ToString(argIndex1); return ret; }

                if (!localIsDefined3())
                {
                    if (i > 1)
                    {
                        i = 1;
                        goto TryAgain;
                    }
                    else
                    {
                        goto TrySelectedMessage;
                    }
                }
            }

            // メッセージを表示
            if ((Situation ?? "") == (Commands.SelectedSpecialPower ?? ""))
            {
                md = SRC.MDList.Item(Commands.SelectedPilot.MessageType);
                Commands.SelectedPilot.MessageType = Conversions.ToString(argIndex16);
                p = Commands.SelectedPilot;
            }
            else if (i == 1)
            {
                md = SRC.MDList.Item(MainPilot().MessageType);
                MainPilot().MessageType = Conversions.ToString(argIndex19);
                p = MainPilot();
                if (md is object)
                {
                    var loopTo8 = Information.UBound(situations);
                    for (j = 1; j <= loopTo8; j++)
                    {
                        if (Strings.Len(md.SelectMessage(situations[j], this)) > 0)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    md = SRC.MDList.Item(Pilot(argIndex20).MessageType);
                    Pilot(1).MessageType = Conversions.ToString(argIndex21);
                    p = Pilot(1);
                }
            }
            else if (i <= CountPilot())
            {
                Pilot localPilot3() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                md = SRC.MDList.Item(localPilot3().MessageType);
                localPilot3().MessageType = Conversions.ToString(argIndex23);
                p = Pilot(i);
            }
            else
            {
                Pilot localSupport2() { object argIndex1 = i - CountPilot(); var ret = Support(argIndex1); return ret; }

                md = SRC.MDList.Item(localSupport2().MessageType);
                localSupport2().MessageType = Conversions.ToString(argIndex17);
                p = Support(i - CountPilot());
            }

            // メッセージデータが見つからない場合は他のパイロットで探しなおす
            if (md is null)
            {
                if (i != 1)
                {
                    i = 1;
                    goto TryAgain;
                }
                else
                {
                    goto TrySelectedMessage;
                }
            }

            if (!string.IsNullOrEmpty(selected_msg))
            {
                // SelectMessageで選択されたメッセージを検索
                k = 0;
                var loopTo9 = md.CountMessage();
                for (j = 1; j <= loopTo9; j++)
                {
                    if ((md.Situation(j) ?? "") == (selected_situation ?? ""))
                    {
                        k = (k + 1);
                        if ((Microsoft.VisualBasic.Compatibility.VB6.Support.Format(k) ?? "") == (selected_msg ?? ""))
                        {
                            PlayMessage(p, md.Message(j), wname);
                            return;
                        }
                    }
                    else if ((md.Situation(j) ?? "") == (selected_msg ?? ""))
                    {
                        PlayMessage(p, md.Message(j), wname);
                        return;
                    }
                }
            }
            else
            {
                // メッセージデータからメッセージを検索
                var loopTo10 = Information.UBound(situations);
                for (j = 1; j <= loopTo10; j++)
                {
                    msg = md.SelectMessage(situations[j], this);
                    if (!string.IsNullOrEmpty(msg))
                    {
                        PlayMessage(p, msg, wname);
                        return;
                    }
                }
            }

            if (i != 1)
            {
                i = 1;
                goto TryAgain;
            }

            TrySelectedMessage:
            ;

            // メッセージを表示
            if (!string.IsNullOrEmpty(selected_msg) && selected_msg != "-")
            {
                if (!string.IsNullOrEmpty(selected_pilot))
                {
                    GUI.DisplayBattleMessage(selected_pilot, selected_msg, msg_mode: "");
                }
                else
                {
                    GUI.DisplayBattleMessage(MainPilot().ID, selected_msg, msg_mode: "");
                }
            }
        }

        // ダイアログの再生
        public void PlayDialog(Dialog dd, string wname)
        {
            string msg, buf;
            int i, idx;
            Unit t;
            int tw;

            // 画像描画が行われたかどうかの判定のためにフラグを初期化
            GUI.IsPictureDrawn = false;
            // ダイアログの個々のメッセージを表示
            var loopTo = dd.Count;
            for (i = 1; i <= loopTo; i++)
            {
                msg = dd.Message(i);

                // メッセージ表示のキャンセル
                if (msg == "-")
                {
                    return;
                }

                // ユニット名
                while (Strings.InStr(msg, "$(ユニット)") > 0)
                {
                    idx = Strings.InStr(msg, "$(ユニット)");
                    buf = Nickname;
                    if (Strings.InStr(buf, "(") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                    }

                    if (Strings.InStr(buf, "専用") > 0)
                    {
                        buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
                    }

                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
                }

                while (Strings.InStr(msg, "$(機体)") > 0)
                {
                    idx = Strings.InStr(msg, "$(機体)");
                    buf = Nickname;
                    if (Strings.InStr(buf, "(") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                    }

                    if (Strings.InStr(buf, "専用") > 0)
                    {
                        buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
                    }

                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 5);
                }

                // パイロット名
                while (Strings.InStr(msg, "$(パイロット)") > 0)
                {
                    buf = MainPilot().get_Nickname(false);
                    if (Strings.InStr(buf, "(") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                    }

                    idx = Strings.InStr(msg, "$(パイロット)");
                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 8);
                }

                // 武器名
                while (Strings.InStr(msg, "$(武器)") > 0)
                {
                    idx = Strings.InStr(msg, "$(武器)");
                    buf = wname;
                    Expression.ReplaceSubExpression(buf);
                    if (Strings.InStr(buf, "(") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                    }

                    if (Strings.InStr(buf, "<") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "<") - 1);
                    }

                    if (Strings.InStr(buf, "＜") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "＜") - 1);
                    }

                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 5);
                }

                // 損傷率
                while (Strings.InStr(msg, "$(損傷率)") > 0)
                {
                    idx = Strings.InStr(msg, "$(損傷率)");
                    msg = Strings.Left(msg, idx - 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (MaxHP - HP) / MaxHP) + Strings.Mid(msg, idx + 6);
                }

                // 相手ユニットを設定
                if (ReferenceEquals(Commands.SelectedUnit, this))
                {
                    t = Commands.SelectedTarget;
                    tw = Commands.SelectedTWeapon;
                }
                else
                {
                    t = Commands.SelectedUnit;
                    tw = Commands.SelectedWeapon;
                }

                if (t is object)
                {
                    // 相手ユニット名
                    while (Strings.InStr(msg, "$(相手ユニット)") > 0)
                    {
                        buf = t.Nickname;
                        if (Strings.InStr(buf, "(") > 0)
                        {
                            buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                        }

                        if (Strings.InStr(buf, "専用") > 0)
                        {
                            buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
                        }

                        idx = Strings.InStr(msg, "$(相手ユニット)");
                        msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 9);
                    }

                    while (Strings.InStr(msg, "$(相手機体)") > 0)
                    {
                        buf = t.Nickname;
                        if (Strings.InStr(buf, "(") > 0)
                        {
                            buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                        }

                        if (Strings.InStr(buf, "専用") > 0)
                        {
                            buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
                        }

                        idx = Strings.InStr(msg, "$(相手機体)");
                        msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
                    }

                    // 相手パイロット名
                    while (Strings.InStr(msg, "$(相手パイロット)") > 0)
                    {
                        buf = t.MainPilot().get_Nickname(false);
                        if (Strings.InStr(buf, "(") > 0)
                        {
                            buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                        }

                        idx = Strings.InStr(msg, "$(相手パイロット)");
                        msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 10);
                    }

                    // 相手武器名
                    while (Strings.InStr(msg, "$(相手武器)") > 0)
                    {
                        if (1 <= tw && tw <= t.CountWeapon())
                        {
                            buf = t.WeaponNickname(tw);
                        }
                        else
                        {
                            buf = "";
                        }

                        if (Strings.InStr(buf, "<") > 0)
                        {
                            buf = Strings.Left(buf, Strings.InStr(buf, "<") - 1);
                        }

                        if (Strings.InStr(buf, "＜") > 0)
                        {
                            buf = Strings.Left(buf, Strings.InStr(buf, "＜") - 1);
                        }

                        idx = Strings.InStr(msg, "$(相手武器)");
                        msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
                    }

                    // 相手損傷率
                    while (Strings.InStr(msg, "$(相手損傷率)") > 0)
                    {
                        buf = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (t.MaxHP - t.HP) / t.MaxHP);
                        idx = Strings.InStr(msg, "$(相手損傷率)");
                        msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 8);
                    }
                }

                // メッセージを表示
                if ((dd.Name(i) ?? "") == (MainPilot().Name ?? ""))
                {
                    GUI.DisplayBattleMessage(MainPilot().ID, msg, msg_mode: "");
                }
                else if (Strings.Left(dd.Name(i), 1) == "@")
                {
                    GUI.DisplayBattleMessage(Strings.Mid(dd.Name(i), 2), msg, msg_mode: "");
                }
                else
                {
                    GUI.DisplayBattleMessage(dd.Name(i), msg, msg_mode: "");
                }
            }

            // カットインは消去しておく
            if (!Expression.IsOptionDefined("戦闘中画面初期化無効"))
            {
                if (GUI.IsPictureDrawn)
                {
                    GUI.ClearPicture();
                    // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                    GUI.MainForm.picMain(0).Refresh();
                }
            }
        }

        // メッセージを再生
        public void PlayMessage(Pilot p, string msg, string wname)
        {
            string buf;
            int idx;
            Unit t;
            int tw;

            // メッセージ表示をキャンセル
            if (msg == "-")
            {
                return;
            }

            // 画像描画が行われたかどうかの判定のためにフラグを初期化
            GUI.IsPictureDrawn = false;

            // ユニット名
            while (Strings.InStr(msg, "$(ユニット)") > 0)
            {
                idx = Strings.InStr(msg, "$(ユニット)");
                buf = Nickname;
                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                if (Strings.InStr(buf, "専用") > 0)
                {
                    buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
                }

                msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
            }

            while (Strings.InStr(msg, "$(機体)") > 0)
            {
                idx = Strings.InStr(msg, "$(機体)");
                buf = Nickname;
                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                if (Strings.InStr(buf, "専用") > 0)
                {
                    buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
                }

                msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 5);
            }

            // パイロット名
            while (Strings.InStr(msg, "$(パイロット)") > 0)
            {
                buf = MainPilot().get_Nickname(false);
                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                idx = Strings.InStr(msg, "$(パイロット)");
                msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 8);
            }

            // 武器名
            while (Strings.InStr(msg, "$(武器)") > 0)
            {
                idx = Strings.InStr(msg, "$(武器)");
                buf = wname;
                Expression.ReplaceSubExpression(buf);
                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                if (Strings.InStr(buf, "<") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "<") - 1);
                }

                if (Strings.InStr(buf, "＜") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "＜") - 1);
                }

                msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 5);
            }

            // 損傷率
            while (Strings.InStr(msg, "$(損傷率)") > 0)
            {
                idx = Strings.InStr(msg, "$(損傷率)");
                msg = Strings.Left(msg, idx - 1) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (MaxHP - HP) / MaxHP) + Strings.Mid(msg, idx + 6);
            }

            // 相手ユニットを設定
            if (ReferenceEquals(Commands.SelectedUnit, this))
            {
                t = Commands.SelectedTarget;
                tw = Commands.SelectedTWeapon;
            }
            else
            {
                t = Commands.SelectedUnit;
                tw = Commands.SelectedWeapon;
            }

            if (t is object)
            {
                // 相手ユニット名
                while (Strings.InStr(msg, "$(相手ユニット)") > 0)
                {
                    buf = t.Nickname;
                    if (Strings.InStr(buf, "(") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                    }

                    if (Strings.InStr(buf, "専用") > 0)
                    {
                        buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
                    }

                    idx = Strings.InStr(msg, "$(相手ユニット)");
                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 9);
                }

                while (Strings.InStr(msg, "$(相手機体)") > 0)
                {
                    buf = t.Nickname;
                    if (Strings.InStr(buf, "(") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                    }

                    if (Strings.InStr(buf, "専用") > 0)
                    {
                        buf = Strings.Mid(buf, Strings.InStr(buf, "専用") + 2);
                    }

                    idx = Strings.InStr(msg, "$(相手機体)");
                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
                }

                // 相手パイロット名
                while (Strings.InStr(msg, "$(相手パイロット)") > 0)
                {
                    buf = t.MainPilot().get_Nickname(false);
                    if (Strings.InStr(buf, "(") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                    }

                    idx = Strings.InStr(msg, "$(相手パイロット)");
                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 10);
                }

                // 相手武器名
                while (Strings.InStr(msg, "$(相手武器)") > 0)
                {
                    if (1 <= tw && tw <= t.CountWeapon())
                    {
                        buf = t.WeaponNickname(tw);
                    }
                    else
                    {
                        buf = "";
                    }

                    if (Strings.InStr(buf, "<") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "<") - 1);
                    }

                    if (Strings.InStr(buf, "＜") > 0)
                    {
                        buf = Strings.Left(buf, Strings.InStr(buf, "＜") - 1);
                    }

                    idx = Strings.InStr(msg, "$(相手武器)");
                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 7);
                }

                // 相手損傷率
                while (Strings.InStr(msg, "$(相手損傷率)") > 0)
                {
                    buf = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (t.MaxHP - t.HP) / t.MaxHP);
                    idx = Strings.InStr(msg, "$(相手損傷率)");
                    msg = Strings.Left(msg, idx - 1) + buf + Strings.Mid(msg, idx + 8);
                }
            }

            // メッセージを表示
            GUI.DisplayBattleMessage(p.ID, msg, msg_mode: "");

            // カットインは消去しておく
            if (!Expression.IsOptionDefined("戦闘中画面初期化無効"))
            {
                if (GUI.IsPictureDrawn)
                {
                    GUI.ClearPicture();
                    // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                    GUI.MainForm.picMain(0).Refresh();
                }
            }
        }

        // シチュエーション main_situation に対応するメッセージが定義されているか
        public bool IsMessageDefined(string main_situation, bool ignore_condition = false)
        {
            bool IsMessageDefinedRet = default;
            var pnames = new string[5];
            var msg = default(string);
            int i;

            // しゃべれない場合
            if (!ignore_condition)
            {
                if (IsConditionSatisfied("沈黙") || IsConditionSatisfied("憑依") || IsConditionSatisfied("石化") || IsConditionSatisfied("凍結") || IsConditionSatisfied("麻痺") || IsConditionSatisfied("睡眠"))
                {
                    IsMessageDefinedRet = false;
                    return IsMessageDefinedRet;
                }

                // 特殊状態用メッセージが定義されているか確認する場合を考慮
                if (IsConditionSatisfied("恐怖") && main_situation != "恐怖")
                {
                    IsMessageDefinedRet = false;
                    return IsMessageDefinedRet;
                }

                if (IsConditionSatisfied("混乱") && main_situation != "混乱")
                {
                    IsMessageDefinedRet = false;
                    return IsMessageDefinedRet;
                }
            }

            // SetMessageコマンドでメッセージが設定されているか判定
            if (Expression.IsLocalVariableDefined("Message(" + MainPilot().ID + "," + main_situation + ")"))
            {
                IsMessageDefinedRet = true;
                return IsMessageDefinedRet;
            }

            // ダイアログデータを使って判定
            {
                var withBlock = MainPilot();
                pnames[1] = withBlock.MessageType;
                pnames[2] = withBlock.MessageType;
                pnames[3] = withBlock.MessageType;
            }

            pnames[4] = Pilot(1).MessageType;
            var loopTo = CountPilot();
            for (i = 2; i <= loopTo; i++)
            {
                {
                    var withBlock1 = Pilot(i);
                    pnames[1] = pnames[1] + " " + withBlock1.MessageType;
                    pnames[2] = pnames[2] + " " + withBlock1.MessageType;
                }
            }

            var loopTo1 = CountSupport();
            for (i = 1; i <= loopTo1; i++)
            {
                Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                pnames[1] = pnames[1] + " " + localSupport().MessageType;
            }

            if (IsFeatureAvailable("追加サポート"))
            {
                pnames[1] = pnames[1] + " " + AdditionalSupport().MessageType;
            }

            if (!string.IsNullOrEmpty(main_situation))
            {
                if ((main_situation ?? "") == (Commands.SelectedSpecialPower ?? ""))
                {
                    pnames[3] = Commands.SelectedPilot.MessageType;
                }
            }

            for (i = 1; i <= 4; i++)
            {
                var tmp1 = pnames;
                if (SRC.DDList.IsDefined(tmp1[i]))
                {
                    var tmp = pnames;
                    {
                        var withBlock2 = SRC.DDList.Item(tmp[i]);
                        if (withBlock2.SelectDialog(main_situation, this, ignore_condition) is object)
                        {
                            IsMessageDefinedRet = true;
                            return IsMessageDefinedRet;
                        }
                    }
                }
            }

            // メッセージデータを使って判定
            if ((main_situation ?? "") == (Commands.SelectedSpecialPower ?? ""))
            {
                {
                    var withBlock3 = Commands.SelectedPilot;
                    bool localIsDefined() { object argIndex1 = withBlock3.MessageType; var ret = SRC.MDList.IsDefined(argIndex1); withBlock3.MessageType = Conversions.ToString(argIndex1); return ret; }

                    if (localIsDefined())
                    {
                        MessageData localItem() { object argIndex1 = withBlock3.MessageType; var ret = SRC.MDList.Item(argIndex1); withBlock3.MessageType = Conversions.ToString(argIndex1); return ret; }

                        msg = localItem().SelectMessage(main_situation, this);
                    }
                }
            }
            else
            {
                {
                    var withBlock4 = MainPilot();
                    bool localIsDefined1() { object argIndex1 = withBlock4.MessageType; var ret = SRC.MDList.IsDefined(argIndex1); withBlock4.MessageType = Conversions.ToString(argIndex1); return ret; }

                    if (localIsDefined1())
                    {
                        MessageData localItem1() { object argIndex1 = withBlock4.MessageType; var ret = SRC.MDList.Item(argIndex1); withBlock4.MessageType = Conversions.ToString(argIndex1); return ret; }

                        msg = localItem1().SelectMessage(main_situation, this);
                    }
                }

                if (Strings.Len(msg) == 0)
                {
                    {
                        var withBlock5 = Pilot(1);
                        bool localIsDefined2() { object argIndex1 = withBlock5.MessageType; var ret = SRC.MDList.IsDefined(argIndex1); withBlock5.MessageType = Conversions.ToString(argIndex1); return ret; }

                        if (localIsDefined2())
                        {
                            MessageData localItem2() { object argIndex1 = withBlock5.MessageType; var ret = SRC.MDList.Item(argIndex1); withBlock5.MessageType = Conversions.ToString(argIndex1); return ret; }

                            msg = localItem2().SelectMessage(main_situation, this);
                        }
                    }
                }
            }

            if (Strings.Len(msg) > 0)
            {
                IsMessageDefinedRet = true;
            }

            return IsMessageDefinedRet;
        }

        // 解説メッセージを表示
        public void SysMessage(string main_situation, [Optional, DefaultParameterValue("")] string sub_situation, [Optional, DefaultParameterValue("")] string add_msg)
        {
            string uname, msg, uclass;
            string[] situations;
            string idx, buf;
            int i, ret;
            string wname;
            if (string.IsNullOrEmpty(sub_situation) || (main_situation ?? "") == (sub_situation ?? ""))
            {
                situations = new string[2];
                situations[1] = main_situation + "(解説)";
            }
            else
            {
                situations = new string[3];
                situations[1] = main_situation + "(" + sub_situation + ")(解説)";
                situations[2] = main_situation + "(解説)";
            }

            // ADD START MARGE
            // 拡張戦闘アニメデータで検索
            if (SRC.ExtendedAnimation)
            {
                {
                    var withBlock = SRC.EADList;
                    var loopTo = Information.UBound(situations);
                    for (i = 1; i <= loopTo; i++)
                    {
                        // 戦闘アニメ能力で指定された名称で検索
                        if (IsFeatureAvailable("戦闘アニメ"))
                        {
                            uname = FeatureData("戦闘アニメ");
                            if (withBlock.IsDefined(uname))
                            {
                                MessageData localItem() { object argIndex1 = uname; var ret = withBlock.Item(argIndex1); return ret; }

                                msg = localItem().SelectMessage(situations[i], this);
                                if (Strings.Len(msg) > 0)
                                {
                                    goto FoundMessage;
                                }
                            }
                        }

                        // ユニット名称で検索
                        bool localIsDefined() { object argIndex1 = Name; var ret = withBlock.IsDefined(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                        if (localIsDefined())
                        {
                            MessageData localItem1() { object argIndex1 = Name; var ret = withBlock.Item(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                            msg = localItem1().SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                goto FoundMessage;
                            }
                        }

                        // ユニット愛称を修正したもので検索
                        uname = Nickname0;
                        ret = Strings.InStr(uname, "(");
                        if (ret > 1)
                        {
                            uname = Strings.Left(uname, ret - 1);
                        }

                        ret = Strings.InStr(uname, "用");
                        if (ret > 0)
                        {
                            if (ret < Strings.Len(uname))
                            {
                                uname = Strings.Mid(uname, ret + 1);
                            }
                        }

                        ret = Strings.InStr(uname, "型");
                        if (ret > 0)
                        {
                            if (ret < Strings.Len(uname))
                            {
                                uname = Strings.Mid(uname, ret + 1);
                            }
                        }

                        if (Strings.Right(uname, 4) == "カスタム")
                        {
                            uname = Strings.Left(uname, Strings.Len(uname) - 4);
                        }

                        if (Strings.Right(uname, 1) == "改")
                        {
                            uname = Strings.Left(uname, Strings.Len(uname) - 1);
                        }

                        if (withBlock.IsDefined(uname))
                        {
                            MessageData localItem2() { object argIndex1 = uname; var ret = withBlock.Item(argIndex1); return ret; }

                            msg = localItem2().SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                goto FoundMessage;
                            }
                        }

                        // ユニットクラスで検索
                        uclass = Class0;
                        if (withBlock.IsDefined(uclass))
                        {
                            MessageData localItem3() { object argIndex1 = uclass; var ret = withBlock.Item(argIndex1); return ret; }

                            msg = localItem3().SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                goto FoundMessage;
                            }
                        }

                        // 汎用
                        if (withBlock.IsDefined("汎用"))
                        {
                            msg = withBlock.Item("汎用").SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                goto FoundMessage;
                            }
                        }
                    }
                }
            }
            // ADD END MARGE

            // 戦闘アニメデータで検索
            {
                var withBlock1 = SRC.ADList;
                var loopTo1 = Information.UBound(situations);
                for (i = 1; i <= loopTo1; i++)
                {
                    // 戦闘アニメ能力で指定された名称で検索
                    if (IsFeatureAvailable("戦闘アニメ"))
                    {
                        uname = FeatureData("戦闘アニメ");
                        if (withBlock1.IsDefined(uname))
                        {
                            MessageData localItem4() { object argIndex1 = uname; var ret = withBlock1.Item(argIndex1); return ret; }

                            msg = localItem4().SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                goto FoundMessage;
                            }
                        }
                    }

                    // ユニット名称で検索
                    bool localIsDefined1() { object argIndex1 = Name; var ret = withBlock1.IsDefined(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                    if (localIsDefined1())
                    {
                        MessageData localItem5() { object argIndex1 = Name; var ret = withBlock1.Item(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                        msg = localItem5().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            goto FoundMessage;
                        }
                    }

                    // ユニット愛称を修正したもので検索
                    uname = Nickname0;
                    ret = Strings.InStr(uname, "(");
                    if (ret > 1)
                    {
                        uname = Strings.Left(uname, ret - 1);
                    }

                    ret = Strings.InStr(uname, "用");
                    if (ret > 0)
                    {
                        if (ret < Strings.Len(uname))
                        {
                            uname = Strings.Mid(uname, ret + 1);
                        }
                    }

                    ret = Strings.InStr(uname, "型");
                    if (ret > 0)
                    {
                        if (ret < Strings.Len(uname))
                        {
                            uname = Strings.Mid(uname, ret + 1);
                        }
                    }

                    if (Strings.Right(uname, 4) == "カスタム")
                    {
                        uname = Strings.Left(uname, Strings.Len(uname) - 4);
                    }

                    if (Strings.Right(uname, 1) == "改")
                    {
                        uname = Strings.Left(uname, Strings.Len(uname) - 1);
                    }

                    if (withBlock1.IsDefined(uname))
                    {
                        MessageData localItem6() { object argIndex1 = uname; var ret = withBlock1.Item(argIndex1); return ret; }

                        msg = localItem6().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            goto FoundMessage;
                        }
                    }

                    // ユニットクラスで検索
                    uclass = Class0;
                    if (withBlock1.IsDefined(uclass))
                    {
                        MessageData localItem7() { object argIndex1 = uclass; var ret = withBlock1.Item(argIndex1); return ret; }

                        msg = localItem7().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            goto FoundMessage;
                        }
                    }

                    // 汎用
                    if (withBlock1.IsDefined("汎用"))
                    {
                        msg = withBlock1.Item("汎用").SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            goto FoundMessage;
                        }
                    }
                }
            }

            // 特殊効果データで検索
            {
                var withBlock2 = SRC.EDList;
                var loopTo2 = Information.UBound(situations);
                for (i = 1; i <= loopTo2; i++)
                {
                    // 特殊効果能力で指定された名称で検索
                    if (IsFeatureAvailable("特殊効果"))
                    {
                        uname = FeatureData("特殊効果");
                        if (withBlock2.IsDefined(uname))
                        {
                            MessageData localItem8() { object argIndex1 = uname; var ret = withBlock2.Item(argIndex1); return ret; }

                            msg = localItem8().SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                goto FoundMessage;
                            }
                        }
                    }

                    // ユニット名称で検索
                    bool localIsDefined2() { object argIndex1 = Name; var ret = withBlock2.IsDefined(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                    if (localIsDefined2())
                    {
                        MessageData localItem9() { object argIndex1 = Name; var ret = withBlock2.Item(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                        msg = localItem9().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            goto FoundMessage;
                        }
                    }

                    // ユニット愛称を修正したもので検索
                    uname = Nickname0;
                    ret = Strings.InStr(uname, "(");
                    if (ret > 1)
                    {
                        uname = Strings.Left(uname, ret - 1);
                    }

                    ret = Strings.InStr(uname, "用");
                    if (ret > 0)
                    {
                        if (ret < Strings.Len(uname))
                        {
                            uname = Strings.Mid(uname, ret + 1);
                        }
                    }

                    ret = Strings.InStr(uname, "型");
                    if (ret > 0)
                    {
                        if (ret < Strings.Len(uname))
                        {
                            uname = Strings.Mid(uname, ret + 1);
                        }
                    }

                    if (Strings.Right(uname, 4) == "カスタム")
                    {
                        uname = Strings.Left(uname, Strings.Len(uname) - 4);
                    }

                    if (Strings.Right(uname, 1) == "改")
                    {
                        uname = Strings.Left(uname, Strings.Len(uname) - 1);
                    }

                    if (withBlock2.IsDefined(uname))
                    {
                        MessageData localItem10() { object argIndex1 = uname; var ret = withBlock2.Item(argIndex1); return ret; }

                        msg = localItem10().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            goto FoundMessage;
                        }
                    }

                    // ユニットクラスで検索
                    uclass = Class0;
                    if (withBlock2.IsDefined(uclass))
                    {
                        MessageData localItem11() { object argIndex1 = uclass; var ret = withBlock2.Item(argIndex1); return ret; }

                        msg = localItem11().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            goto FoundMessage;
                        }
                    }

                    // 汎用
                    if (withBlock2.IsDefined("汎用"))
                    {
                        msg = withBlock2.Item("汎用").SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            goto FoundMessage;
                        }
                    }
                }
            }

            // 対応するメッセージが見つからなかった
            return;
            FoundMessage:
            ;


            // メッセージ表示のキャンセル
            if (msg == "-")
            {
                return;
            }

            // ユニット名
            while (Strings.InStr(msg, "$(ユニット)") > 0)
            {
                idx = Strings.InStr(msg, "$(ユニット)").ToString();
                buf = Nickname;
                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                if (Strings.InStr(buf, "専用") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "専用") + 2);
                }

                msg = Strings.Left(msg, (Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (Conversions.ToDouble(idx) + 7d));
            }

            while (Strings.InStr(msg, "$(機体)") > 0)
            {
                idx = Strings.InStr(msg, "$(機体)").ToString();
                buf = Nickname;
                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                if (Strings.InStr(buf, "専用") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "専用") + 2);
                }

                msg = Strings.Left(msg, (Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (Conversions.ToDouble(idx) + 5d));
            }

            // パイロット名
            while (Strings.InStr(msg, "$(パイロット)") > 0)
            {
                idx = Strings.InStr(msg, "$(パイロット)").ToString();
                buf = MainPilot().get_Nickname(false);
                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                msg = Strings.Left(msg, (Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (Conversions.ToDouble(idx) + 8d));
            }

            // 武器名
            if (Strings.InStr(msg, "$(武器)") > 0)
            {
                if (ReferenceEquals(Commands.SelectedUnit, this))
                {
                    wname = Weapon(Commands.SelectedWeapon).Name;
                }
                else
                {
                    wname = Weapon(Commands.SelectedTWeapon).Name;
                }

                if (Strings.InStr(wname, "(") > 0)
                {
                    wname = Strings.Left(wname, Strings.InStr(wname, "(") - 1);
                }

                if (Strings.InStr(wname, "<") > 0)
                {
                    wname = Strings.Left(wname, Strings.InStr(wname, "<") - 1);
                }

                while (Strings.InStr(msg, "$(武器)") > 0)
                {
                    idx = Strings.InStr(msg, "$(武器)").ToString();
                    msg = Strings.Left(msg, (Conversions.ToDouble(idx) - 1d)) + wname + Strings.Mid(msg, (Conversions.ToDouble(idx) + 5d));
                }
            }

            // 損傷率
            while (Strings.InStr(msg, "$(損傷率)") > 0)
            {
                idx = Strings.InStr(msg, "$(損傷率)").ToString();
                msg = Strings.Left(msg, (Conversions.ToDouble(idx) - 1d)) + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (MaxHP - HP) / MaxHP) + Strings.Mid(msg, (Conversions.ToDouble(idx) + 6d));
            }

            // 相手ユニット名
            while (Strings.InStr(msg, "$(相手ユニット)") > 0)
            {
                if (ReferenceEquals(Commands.SelectedUnit, this))
                {
                    if (Commands.SelectedTarget is object)
                    {
                        buf = Commands.SelectedTarget.Nickname;
                    }
                    else
                    {
                        buf = "";
                    }
                }
                else
                {
                    buf = Commands.SelectedUnit.Nickname;
                }

                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                if (Strings.InStr(buf, "専用") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "専用") + 2);
                }

                idx = Strings.InStr(msg, "$(相手ユニット)").ToString();
                msg = Strings.Left(msg, (Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (Conversions.ToDouble(idx) + 9d));
            }

            while (Strings.InStr(msg, "$(相手機体)") > 0)
            {
                if (ReferenceEquals(Commands.SelectedUnit, this))
                {
                    if (Commands.SelectedTarget is object)
                    {
                        buf = Commands.SelectedTarget.Nickname;
                    }
                    else
                    {
                        buf = "";
                    }
                }
                else
                {
                    buf = Commands.SelectedUnit.Nickname;
                }

                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                if (Strings.InStr(buf, "専用") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "専用") + 2);
                }

                idx = Strings.InStr(msg, "$(相手機体)").ToString();
                msg = Strings.Left(msg, (Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (Conversions.ToDouble(idx) + 7d));
            }

            // 相手パイロット名
            while (Strings.InStr(msg, "$(相手パイロット)") > 0)
            {
                if (ReferenceEquals(Commands.SelectedUnit, this))
                {
                    if (Commands.SelectedTarget is object)
                    {
                        buf = Commands.SelectedTarget.MainPilot().get_Nickname(false);
                    }
                    else
                    {
                        buf = "";
                    }
                }
                else
                {
                    buf = Commands.SelectedUnit.MainPilot().get_Nickname(false);
                }

                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                idx = Strings.InStr(msg, "$(相手パイロット)").ToString();
                msg = Strings.Left(msg, (Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (Conversions.ToDouble(idx) + 10d));
            }

            // 相手武器名
            while (Strings.InStr(msg, "$(相手武器)") > 0)
            {
                if (ReferenceEquals(Commands.SelectedUnit, this))
                {
                    if (Commands.SelectedTarget is object)
                    {
                        buf = Commands.SelectedTarget.Weapon(Commands.SelectedTWeapon).Name;
                    }
                    else
                    {
                        buf = "";
                    }
                }
                else
                {
                    buf = Commands.SelectedUnit.Weapon(Commands.SelectedWeapon).Name;
                }

                if (Strings.InStr(buf, "(") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "(") - 1);
                }

                if (Strings.InStr(buf, "<") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "<") - 1);
                }

                if (Strings.InStr(buf, "＜") > 0)
                {
                    buf = Strings.Left(buf, Strings.InStr(buf, "＜") - 1);
                }

                idx = Strings.InStr(msg, "$(相手武器)").ToString();
                msg = Strings.Left(msg, (Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (Conversions.ToDouble(idx) + 7d));
            }

            // 相手損傷率
            while (Strings.InStr(msg, "$(相手損傷率)") > 0)
            {
                idx = Strings.InStr(msg, "$(相手損傷率)").ToString();
                if (ReferenceEquals(Commands.SelectedUnit, this))
                {
                    if (Commands.SelectedTarget is object)
                    {
                        {
                            var withBlock3 = Commands.SelectedTarget;
                            buf = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (withBlock3.MaxHP - withBlock3.HP) / withBlock3.MaxHP);
                        }
                    }
                    else
                    {
                        buf = "";
                    }
                }
                else
                {
                    {
                        var withBlock4 = Commands.SelectedUnit;
                        buf = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(100 * (withBlock4.MaxHP - withBlock4.HP) / withBlock4.MaxHP);
                    }
                }

                msg = Strings.Left(msg, (Conversions.ToDouble(idx) - 1d)) + buf + Strings.Mid(msg, (Conversions.ToDouble(idx) + 8d));
            }

            if (!My.MyProject.Forms.frmMessage.Visible)
            {
                GUI.OpenMessageForm(u1: null, u2: null);
            }

            if (!string.IsNullOrEmpty(add_msg))
            {
                GUI.DisplayBattleMessage("-", msg + "." + add_msg, msg_mode: "");
            }
            else
            {
                GUI.DisplayBattleMessage("-", msg, msg_mode: "");
            }
        }

        // 解説メッセージが定義されているか？
        public bool IsSysMessageDefined(string main_situation, [Optional, DefaultParameterValue("")] string sub_situation)
        {
            bool IsSysMessageDefinedRet = default;
            string uclass, uname, msg;
            string[] situations;
            int i, ret;
            if (string.IsNullOrEmpty(sub_situation) || (main_situation ?? "") == (sub_situation ?? ""))
            {
                situations = new string[2];
                situations[1] = main_situation + "(解説)";
            }
            else
            {
                situations = new string[3];
                situations[1] = main_situation + "(" + sub_situation + ")(解説)";
                situations[2] = main_situation + "(解説)";
            }

            // ADD START MARGE
            // 拡張戦闘アニメデータで検索
            if (SRC.ExtendedAnimation)
            {
                {
                    var withBlock = SRC.EADList;
                    var loopTo = Information.UBound(situations);
                    for (i = 1; i <= loopTo; i++)
                    {
                        // 戦闘アニメ能力で指定された名称で検索
                        if (IsFeatureAvailable("戦闘アニメ"))
                        {
                            uname = FeatureData("戦闘アニメ");
                            if (withBlock.IsDefined(uname))
                            {
                                MessageData localItem() { object argIndex1 = uname; var ret = withBlock.Item(argIndex1); return ret; }

                                msg = localItem().SelectMessage(situations[i], this);
                                if (Strings.Len(msg) > 0)
                                {
                                    IsSysMessageDefinedRet = true;
                                    return IsSysMessageDefinedRet;
                                }
                            }
                        }

                        // ユニット名称で検索
                        bool localIsDefined() { object argIndex1 = Name; var ret = withBlock.IsDefined(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                        if (localIsDefined())
                        {
                            MessageData localItem1() { object argIndex1 = Name; var ret = withBlock.Item(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                            msg = localItem1().SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                IsSysMessageDefinedRet = true;
                                return IsSysMessageDefinedRet;
                            }
                        }

                        // ユニット愛称を修正したもので検索
                        uname = Nickname0;
                        ret = Strings.InStr(uname, "(");
                        if (ret > 1)
                        {
                            uname = Strings.Left(uname, ret - 1);
                        }

                        ret = Strings.InStr(uname, "用");
                        if (ret > 0)
                        {
                            if (ret < Strings.Len(uname))
                            {
                                uname = Strings.Mid(uname, ret + 1);
                            }
                        }

                        ret = Strings.InStr(uname, "型");
                        if (ret > 0)
                        {
                            if (ret < Strings.Len(uname))
                            {
                                uname = Strings.Mid(uname, ret + 1);
                            }
                        }

                        if (Strings.Right(uname, 4) == "カスタム")
                        {
                            uname = Strings.Left(uname, Strings.Len(uname) - 4);
                        }

                        if (Strings.Right(uname, 1) == "改")
                        {
                            uname = Strings.Left(uname, Strings.Len(uname) - 1);
                        }

                        if (withBlock.IsDefined(uname))
                        {
                            MessageData localItem2() { object argIndex1 = uname; var ret = withBlock.Item(argIndex1); return ret; }

                            msg = localItem2().SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                IsSysMessageDefinedRet = true;
                                return IsSysMessageDefinedRet;
                            }
                        }

                        // ユニットクラスで検索
                        uclass = Class0;
                        if (withBlock.IsDefined(uclass))
                        {
                            MessageData localItem3() { object argIndex1 = uclass; var ret = withBlock.Item(argIndex1); return ret; }

                            msg = localItem3().SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                IsSysMessageDefinedRet = true;
                                return IsSysMessageDefinedRet;
                            }
                        }

                        // 汎用
                        if (withBlock.IsDefined("汎用"))
                        {
                            msg = withBlock.Item("汎用").SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                IsSysMessageDefinedRet = true;
                                return IsSysMessageDefinedRet;
                            }
                        }
                    }
                }
            }
            // ADD END MARGE

            // 戦闘アニメデータで検索
            {
                var withBlock1 = SRC.ADList;
                var loopTo1 = Information.UBound(situations);
                for (i = 1; i <= loopTo1; i++)
                {
                    // 戦闘アニメ能力で指定された名称で検索
                    if (IsFeatureAvailable("戦闘アニメ"))
                    {
                        uname = FeatureData("戦闘アニメ");
                        if (withBlock1.IsDefined(uname))
                        {
                            MessageData localItem4() { object argIndex1 = uname; var ret = withBlock1.Item(argIndex1); return ret; }

                            msg = localItem4().SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                IsSysMessageDefinedRet = true;
                                return IsSysMessageDefinedRet;
                            }
                        }
                    }

                    // ユニット名称で検索
                    bool localIsDefined1() { object argIndex1 = Name; var ret = withBlock1.IsDefined(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                    if (localIsDefined1())
                    {
                        MessageData localItem5() { object argIndex1 = Name; var ret = withBlock1.Item(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                        msg = localItem5().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            IsSysMessageDefinedRet = true;
                            return IsSysMessageDefinedRet;
                        }
                    }

                    // ユニット愛称を修正したもので検索
                    uname = Nickname0;
                    ret = Strings.InStr(uname, "(");
                    if (ret > 1)
                    {
                        uname = Strings.Left(uname, ret - 1);
                    }

                    ret = Strings.InStr(uname, "用");
                    if (ret > 0)
                    {
                        if (ret < Strings.Len(uname))
                        {
                            uname = Strings.Mid(uname, ret + 1);
                        }
                    }

                    ret = Strings.InStr(uname, "型");
                    if (ret > 0)
                    {
                        if (ret < Strings.Len(uname))
                        {
                            uname = Strings.Mid(uname, ret + 1);
                        }
                    }

                    if (Strings.Right(uname, 4) == "カスタム")
                    {
                        uname = Strings.Left(uname, Strings.Len(uname) - 4);
                    }

                    if (Strings.Right(uname, 1) == "改")
                    {
                        uname = Strings.Left(uname, Strings.Len(uname) - 1);
                    }

                    if (withBlock1.IsDefined(uname))
                    {
                        MessageData localItem6() { object argIndex1 = uname; var ret = withBlock1.Item(argIndex1); return ret; }

                        msg = localItem6().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            IsSysMessageDefinedRet = true;
                            return IsSysMessageDefinedRet;
                        }
                    }

                    // ユニットクラスで検索
                    uclass = Class0;
                    if (withBlock1.IsDefined(uclass))
                    {
                        MessageData localItem7() { object argIndex1 = uclass; var ret = withBlock1.Item(argIndex1); return ret; }

                        msg = localItem7().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            IsSysMessageDefinedRet = true;
                            return IsSysMessageDefinedRet;
                        }
                    }

                    // 汎用
                    if (withBlock1.IsDefined("汎用"))
                    {
                        msg = withBlock1.Item("汎用").SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            IsSysMessageDefinedRet = true;
                            return IsSysMessageDefinedRet;
                        }
                    }
                }
            }

            // 特殊効果データで検索
            {
                var withBlock2 = SRC.EDList;
                var loopTo2 = Information.UBound(situations);
                for (i = 1; i <= loopTo2; i++)
                {
                    // 特殊効果能力で指定された名称で検索
                    if (IsFeatureAvailable("特殊効果"))
                    {
                        uname = FeatureData("特殊効果");
                        if (withBlock2.IsDefined(uname))
                        {
                            MessageData localItem8() { object argIndex1 = uname; var ret = withBlock2.Item(argIndex1); return ret; }

                            msg = localItem8().SelectMessage(situations[i], this);
                            if (Strings.Len(msg) > 0)
                            {
                                IsSysMessageDefinedRet = true;
                                return IsSysMessageDefinedRet;
                            }
                        }
                    }

                    // ユニット名称で検索
                    bool localIsDefined2() { object argIndex1 = Name; var ret = withBlock2.IsDefined(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                    if (localIsDefined2())
                    {
                        MessageData localItem9() { object argIndex1 = Name; var ret = withBlock2.Item(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                        msg = localItem9().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            IsSysMessageDefinedRet = true;
                            return IsSysMessageDefinedRet;
                        }
                    }

                    // ユニット愛称を修正したもので検索
                    uname = Nickname0;
                    ret = Strings.InStr(uname, "(");
                    if (ret > 1)
                    {
                        uname = Strings.Left(uname, ret - 1);
                    }

                    ret = Strings.InStr(uname, "用");
                    if (ret > 0)
                    {
                        if (ret < Strings.Len(uname))
                        {
                            uname = Strings.Mid(uname, ret + 1);
                        }
                    }

                    ret = Strings.InStr(uname, "型");
                    if (ret > 0)
                    {
                        if (ret < Strings.Len(uname))
                        {
                            uname = Strings.Mid(uname, ret + 1);
                        }
                    }

                    if (Strings.Right(uname, 4) == "カスタム")
                    {
                        uname = Strings.Left(uname, Strings.Len(uname) - 4);
                    }

                    if (Strings.Right(uname, 1) == "改")
                    {
                        uname = Strings.Left(uname, Strings.Len(uname) - 1);
                    }

                    if (withBlock2.IsDefined(uname))
                    {
                        MessageData localItem10() { object argIndex1 = uname; var ret = withBlock2.Item(argIndex1); return ret; }

                        msg = localItem10().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            IsSysMessageDefinedRet = true;
                            return IsSysMessageDefinedRet;
                        }
                    }

                    // ユニットクラスで検索
                    uclass = Class0;
                    if (withBlock2.IsDefined(uclass))
                    {
                        MessageData localItem11() { object argIndex1 = uclass; var ret = withBlock2.Item(argIndex1); return ret; }

                        msg = localItem11().SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            IsSysMessageDefinedRet = true;
                            return IsSysMessageDefinedRet;
                        }
                    }

                    // 汎用
                    if (withBlock2.IsDefined("汎用"))
                    {
                        msg = withBlock2.Item("汎用").SelectMessage(situations[i], this);
                        if (Strings.Len(msg) > 0)
                        {
                            IsSysMessageDefinedRet = true;
                            return IsSysMessageDefinedRet;
                        }
                    }
                }
            }

            IsSysMessageDefinedRet = false;
            return IsSysMessageDefinedRet;
        }


        // === 特殊効果関連処理 ===

        // 特殊効果データを検索
        public string SpecialEffectData(string main_situation, [Optional, DefaultParameterValue("")] string sub_situation)
        {
            string SpecialEffectDataRet = default;
            string uname, uclass;
            string[] situations;
            int i, ret;

            // シチュエーションのリストを構築
            if (string.IsNullOrEmpty(sub_situation) || (main_situation ?? "") == (sub_situation ?? ""))
            {
                situations = new string[2];
                situations[1] = main_situation;
            }
            else
            {
                situations = new string[3];
                situations[1] = main_situation + "(" + sub_situation + ")";
                situations[2] = main_situation;
            }

            var loopTo = Information.UBound(situations);
            for (i = 1; i <= loopTo; i++)
            {
                // 特殊効果能力で指定された名称で検索
                if (IsFeatureAvailable("特殊効果"))
                {
                    uname = FeatureData("特殊効果");
                    if (SRC.EDList.IsDefined(uname))
                    {
                        MessageData localItem() { object argIndex1 = uname; var ret = SRC.EDList.Item(argIndex1); return ret; }

                        SpecialEffectDataRet = localItem().SelectMessage(situations[i], this);
                        if (Strings.Len(SpecialEffectDataRet) > 0)
                        {
                            return SpecialEffectDataRet;
                        }
                    }
                }

                // ユニット名称で検索
                bool localIsDefined() { object argIndex1 = Name; var ret = SRC.EDList.IsDefined(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                if (localIsDefined())
                {
                    MessageData localItem1() { object argIndex1 = Name; var ret = SRC.EDList.Item(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                    SpecialEffectDataRet = localItem1().SelectMessage(situations[i], this);
                    if (Strings.Len(SpecialEffectDataRet) > 0)
                    {
                        return SpecialEffectDataRet;
                    }
                }

                // ユニット愛称を修正したもので検索
                uname = Nickname;
                ret = Strings.InStr(uname, "(");
                if (ret > 1)
                {
                    uname = Strings.Left(uname, ret - 1);
                }

                ret = Strings.InStr(uname, "用");
                if (ret > 0)
                {
                    if (ret < Strings.Len(uname))
                    {
                        uname = Strings.Mid(uname, ret + 1);
                    }
                }

                ret = Strings.InStr(uname, "型");
                if (ret > 0)
                {
                    if (ret < Strings.Len(uname))
                    {
                        uname = Strings.Mid(uname, ret + 1);
                    }
                }

                if (Strings.Right(uname, 4) == "カスタム")
                {
                    uname = Strings.Left(uname, Strings.Len(uname) - 4);
                }

                if (Strings.Right(uname, 1) == "改")
                {
                    uname = Strings.Left(uname, Strings.Len(uname) - 1);
                }

                if (SRC.EDList.IsDefined(uname))
                {
                    MessageData localItem2() { object argIndex1 = uname; var ret = SRC.EDList.Item(argIndex1); return ret; }

                    SpecialEffectDataRet = localItem2().SelectMessage(situations[i], this);
                    if (Strings.Len(SpecialEffectDataRet) > 0)
                    {
                        return SpecialEffectDataRet;
                    }
                }

                // ユニットクラスで検索
                uclass = Class0;
                if (SRC.EDList.IsDefined(uclass))
                {
                    MessageData localItem3() { object argIndex1 = uclass; var ret = SRC.EDList.Item(argIndex1); return ret; }

                    SpecialEffectDataRet = localItem3().SelectMessage(situations[i], this);
                    if (Strings.Len(SpecialEffectDataRet) > 0)
                    {
                        return SpecialEffectDataRet;
                    }
                }

                // 汎用
                if (SRC.EDList.IsDefined("汎用"))
                {
                    SpecialEffectDataRet = SRC.EDList.Item("汎用").SelectMessage(situations[i], this);
                    if (Strings.Len(SpecialEffectDataRet) > 0)
                    {
                        return SpecialEffectDataRet;
                    }
                }
            }

            return SpecialEffectDataRet;
        }

        // 特殊効果データを再生
        public void SpecialEffect(string main_situation, [Optional, DefaultParameterValue("")] string sub_situation, bool keep_message_form = false)
        {
            string anime, sname;
            string[] animes;
            int idx, i, j, w = default;
            double ret;
            string buf;
            int anime_head;
            bool is_message_form_opened;
            var is_weapon = default(bool);
            var is_ability = default(bool);
            bool in_bulk;
            var wait_time = default;
            var need_refresh = default(bool);
            int prev_obj_color;
            int prev_obj_fill_color;
            int prev_obj_fill_style;
            int prev_obj_draw_width;
            string prev_obj_draw_option;
            Unit prev_selected_target;

            // 特殊効果データを検索
            anime = SpecialEffectData(main_situation, sub_situation);
            GeneralLib.TrimString(anime);

            // 表示キャンセル
            if (string.IsNullOrEmpty(anime) || anime == "-")
            {
                return;
            }

            // マウスの右ボタンでキャンセル
            if (GUI.IsRButtonPressed())
            {
                // 式評価のみ行う
                Expression.FormatMessage(anime);
                return;
            }

            if (SRC.BattleAnimation && !Expression.IsOptionDefined("戦闘アニメ非自動選択"))
            {
                var loopTo = CountWeapon();
                for (i = 1; i <= loopTo; i++)
                {
                    if ((Weapon(i).Name ?? "") == (main_situation ?? ""))
                    {
                        w = i;
                        break;
                    }
                }

                if (w > 0)
                {
                    switch (Strings.LCase(anime) ?? "")
                    {
                        case "swing.wav":
                            {
                                if (Strings.InStr(main_situation, "槍") > 0 || Strings.InStr(main_situation, "スピア") > 0 || Strings.InStr(main_situation, "ランス") > 0 || Strings.InStr(main_situation, "ジャベリン") > 0)
                                {
                                    Effect.ShowAnimation("刺突攻撃");
                                    return;
                                }
                                else if (IsWeaponClassifiedAs(w, "武") || IsWeaponClassifiedAs(w, "実"))
                                {
                                    Effect.ShowAnimation("白兵武器攻撃");
                                    return;
                                }

                                break;
                            }
                    }
                }
                else if (Strings.InStr(main_situation, "(命中)") > 0)
                {
                    switch (Strings.LCase(anime) ?? "")
                    {
                        case "break.wav":
                            {
                                Effect.ShowAnimation("打撃命中");
                                return;
                            }

                        case "combo.wav":
                            {
                                Effect.ShowAnimation("乱打命中");
                                return;
                            }

                        case "crash.wav":
                            {
                                Effect.ShowAnimation("強打命中 Crash.wav");
                                return;
                            }

                        case "explode.wav":
                            {
                                Effect.ShowAnimation("爆発命中");
                                return;
                            }

                        case "explode(far).wav":
                            {
                                Effect.ShowAnimation("超爆発命中 Explode(Far).wav");
                                return;
                            }

                        case "explode(nuclear).wav":
                            {
                                Effect.ShowAnimation("超爆発命中 Explode(Nuclear).wav");
                                return;
                            }

                        case "fire.wav":
                            {
                                Effect.ShowAnimation("炎命中");
                                return;
                            }

                        case "glass.wav":
                            {
                                if (IsWeaponClassifiedAs(w, "冷"))
                                {
                                    Effect.ShowAnimation("凍結命中 Glass.wav");
                                }

                                return;
                            }

                        case "punch.wav":
                            {
                                Effect.ShowAnimation("打撃命中");
                                return;
                            }

                        case "punch(2).wav":
                        case "punch(3).wav":
                        case "punch(4).wav":
                            {
                                Effect.ShowAnimation("連打命中");
                                return;
                            }

                        case "saber.wav":
                        case "slash.wav":
                            {
                                Effect.ShowAnimation("斬撃命中 " + anime);
                                return;
                            }

                        case "shock(low).wav":
                            {
                                Effect.ShowAnimation("強打命中 Shock(Low).wav");
                                return;
                            }

                        case "stab.wav":
                            {
                                Effect.ShowAnimation("刺突命中");
                                return;
                            }

                        case "thunder.wav":
                            {
                                Effect.ShowAnimation("放電命中 Thunder.wav");
                                return;
                            }

                        case "whip.wav":
                            {
                                Effect.ShowAnimation("打撃命中 Whip.wav");
                                return;
                            }
                    }
                }
            }

            // メッセージウィンドウは表示されている？
            is_message_form_opened = My.MyProject.Forms.frmMessage.Visible;

            // オブジェクト色等を記録しておく
            prev_obj_color = Event.ObjColor;
            prev_obj_fill_color = Event.ObjFillColor;
            prev_obj_fill_style = Event.ObjFillStyle;
            prev_obj_draw_width = Event.ObjDrawWidth;
            prev_obj_draw_option = Event.ObjDrawOption;

            // オブジェクト色等をデフォルトに戻す
            Event.ObjColor = ColorTranslator.ToOle(Color.White);
            Event.ObjFillColor = ColorTranslator.ToOle(Color.White);
            // UPGRADE_ISSUE: 定数 vbFSTransparent はアップグレードされませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="55B59875-9A95-4B71-9D6A-7C294BF7139D"' をクリックしてください。
            Event.ObjFillStyle = vbFSTransparent;
            Event.ObjDrawWidth = 1;
            Event.ObjDrawOption = "";

            // 検索するシチュエーションが武器名かどうか調べる
            var loopTo1 = CountWeapon();
            for (i = 1; i <= loopTo1; i++)
            {
                if ((main_situation ?? "") == (Weapon(i).Name ?? ""))
                {
                    is_weapon = true;
                    break;
                }
            }

            // 検索するシチュエーションがアビリティかどうか調べる
            var loopTo2 = CountAbility();
            for (i = 1; i <= loopTo2; i++)
            {
                if ((main_situation ?? "") == (Ability(i).Name ?? ""))
                {
                    is_ability = true;
                    break;
                }
            }

            // イベント用ターゲットを記録しておく
            prev_selected_target = Event.SelectedTargetForEvent;

            // 攻撃でもアビリティでもない場合、ターゲットが設定されていなければ
            // 自分自身をターゲットに設定する
            // (発動アニメではアニメ表示にSelectedTargetForEventが使われるため)
            if (!is_weapon && !is_ability)
            {
                if (Event.SelectedTargetForEvent is null)
                {
                    Event.SelectedTargetForEvent = this;
                }
            }

            // 特殊効果指定を分割
            animes = new string[2];
            anime_head = 1;
            var loopTo3 = Strings.Len(anime);
            for (i = 1; i <= loopTo3; i++)
            {
                if (Strings.Mid(anime, i, 1) == ";")
                {
                    animes[Information.UBound(animes)] = Strings.Mid(anime, anime_head, i - anime_head);
                    Array.Resize(animes, Information.UBound(animes) + 1 + 1);
                    anime_head = (i + 1);
                }
            }

            animes[Information.UBound(animes)] = Strings.Mid(anime, anime_head);
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 743599


            Input:

                    On Error GoTo ErrorHandler

             */
            var loopTo4 = Information.UBound(animes);
            for (i = 1; i <= loopTo4; i++)
            {
                anime = animes[i];

                // 式評価
                Expression.FormatMessage(anime);

                // 画面クリア？
                if (Strings.LCase(anime) == "clear")
                {
                    GUI.ClearPicture();
                    need_refresh = true;
                    goto NextAnime;
                }

                // 特殊効果
                switch (Strings.LCase(Strings.Right(GeneralLib.LIndex(anime, 1), 4)) ?? "")
                {
                    case ".wav":
                    case ".mp3":
                        {
                            // 効果音
                            Sound.PlayWave(anime);
                            if (wait_time > 0)
                            {
                                if (need_refresh)
                                {
                                    // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                                    GUI.MainForm.picMain(0).Refresh();
                                    need_refresh = false;
                                }

                                GUI.Sleep(wait_time);
                                wait_time = 0;
                            }

                            goto NextAnime;
                            break;
                        }

                    case ".bmp":
                    case ".jpg":
                    case ".gif":
                    case ".png":
                        {
                            // カットインの表示
                            if (wait_time > 0)
                            {
                                anime = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(wait_time / 100d) + ";" + anime;
                                wait_time = 0;
                                need_refresh = false;
                            }
                            else if (Strings.Left(anime, 1) == "@")
                            {
                                need_refresh = false;
                            }
                            else
                            {
                                need_refresh = true;
                            }

                            GUI.DisplayBattleMessage("-", anime, msg_mode: "");
                            goto NextAnime;
                            break;
                        }
                }

                switch (Strings.LCase(GeneralLib.LIndex(anime, 1)) ?? "")
                {
                    case "line":
                    case "circle":
                    case "arc":
                    case "oval":
                    case "color":
                    case "fillcolor":
                    case "fillstyle":
                    case "drawwidth":
                        {
                            // 画面処理コマンド
                            if (wait_time > 0)
                            {
                                anime = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(wait_time / 100d) + ";" + anime;
                                wait_time = 0;
                                need_refresh = false;
                            }
                            else
                            {
                                need_refresh = true;
                            }

                            GUI.DisplayBattleMessage("-", anime, msg_mode: "");
                            goto NextAnime;
                            break;
                        }

                    case "center":
                        {
                            // 指定したユニットを中央表示
                            buf = Expression.GetValueAsString(GeneralLib.ListIndex(anime, 2));
                            if (SRC.UList.IsDefined(buf))
                            {
                                {
                                    var withBlock = SRC.UList.Item(buf);
                                    GUI.Center(withBlock.x, withBlock.y);
                                    GUI.RedrawScreen();
                                    need_refresh = false;
                                }
                            }

                            goto NextAnime;
                            break;
                        }

                    case "keep":
                        {
                            // そのまま終了
                            break;
                        }
                }

                // ウェイト？
                if (Information.IsNumeric(anime))
                {
                    wait_time = (100d * Conversions.ToDouble(anime));
                    goto NextAnime;
                }

                // メッセージ表示として処理
                if (wait_time > 0)
                {
                    anime = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(wait_time / 100d) + ";" + anime;
                    wait_time = 0;
                }

                if (!My.MyProject.Forms.frmMessage.Visible)
                {
                    if (ReferenceEquals(Commands.SelectedTarget, this))
                    {
                        GUI.OpenMessageForm(this, u2: null);
                    }
                    else
                    {
                        GUI.OpenMessageForm(Commands.SelectedTarget, this);
                    }
                }

                GUI.DisplayBattleMessage("-", anime, msg_mode: "");
                goto NextAnime;
                NextAnime:
                ;
            }

            if (SRC.BattleAnimation && !GUI.IsPictureDrawn && !Expression.IsOptionDefined("戦闘アニメ非自動選択"))
            {
                if (w > 0)
                {
                    Effect.ShowAnimation("デフォルト攻撃");
                }
                else if (Strings.InStr(main_situation, "(命中)") > 0)
                {
                    Effect.ShowAnimation("ダメージ命中 -.wav");
                }
            }

            // 特殊効果再生後にウェイトを入れる？
            if (need_refresh)
            {
                // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                GUI.MainForm.picMain(0).Refresh();
                need_refresh = false;
            }

            if (wait_time > 0)
            {
                GUI.Sleep(wait_time);
                wait_time = 0;
            }

            // 画像を消去しておく
            if (GUI.IsPictureDrawn && Strings.InStr(main_situation, "(準備)") == 0 && Strings.LCase(anime) != "keep")
            {
                GUI.ClearPicture();
                // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                GUI.MainForm.picMain(0).Refresh();
            }

            // 最初から表示されていたのでなければメッセージウィンドウを閉じる
            if (!is_message_form_opened && !keep_message_form)
            {
                GUI.CloseMessageForm();
            }

            // オブジェクト色等を元に戻す
            Event.ObjColor = prev_obj_color;
            Event.ObjFillColor = prev_obj_fill_color;
            Event.ObjFillStyle = prev_obj_fill_style;
            Event.ObjDrawWidth = prev_obj_draw_width;
            Event.ObjDrawOption = prev_obj_draw_option;

            // イベント用ターゲットを元に戻す
            Event.SelectedTargetForEvent = prev_selected_target;
            return;
            ErrorHandler:
            ;
            if (Strings.Len(Event.EventErrorMessage) > 0)
            {
                Event.DisplayEventErrorMessage(Event.CurrentLineNum, Event.EventErrorMessage);
                Event.EventErrorMessage = "";
            }
            else
            {
                Event.DisplayEventErrorMessage(Event.CurrentLineNum, "");
            }
        }

        // 特殊効果データが定義されているか？
        public bool IsSpecialEffectDefined(string main_situation, [Optional, DefaultParameterValue("")] string sub_situation)
        {
            bool IsSpecialEffectDefinedRet = default;
            string msg;
            msg = SpecialEffectData(main_situation, sub_situation);
            if (Strings.Len(msg) > 0)
            {
                IsSpecialEffectDefinedRet = true;
            }

            return IsSpecialEffectDefinedRet;
        }


        // === 戦闘アニメ関連処理 ===

        // 戦闘アニメデータを検索
        // MOD START MARGE
        // Public Function AnimationData(main_situation As String, sub_situation As String) As String
        public string AnimationData(string main_situation, string sub_situation, bool ext_anime_only = false)
        {
            string AnimationDataRet = default;
            // MOD END MARGE
            string uname, uclass;
            string[] situations;
            int i, ret;
            if (!SRC.BattleAnimation)
            {
                return AnimationDataRet;
            }

            // シチュエーションのリストを構築
            if (string.IsNullOrEmpty(sub_situation) || (main_situation ?? "") == (sub_situation ?? ""))
            {
                situations = new string[2];
                situations[1] = main_situation;
            }
            else
            {
                situations = new string[3];
                situations[1] = main_situation + "(" + sub_situation + ")";
                situations[2] = main_situation;
            }

            var loopTo = Information.UBound(situations);
            for (i = 1; i <= loopTo; i++)
            {
                // 戦闘アニメ能力で指定された名称で検索
                if (IsFeatureAvailable("戦闘アニメ"))
                {
                    uname = FeatureData("戦闘アニメ");
                    // MOD START MARGE
                    // If ADList.IsDefined(uname) Then
                    // AnimationData = ADList.Item(uname).SelectMessage(situations(i), Me)
                    // If Len(AnimationData) > 0 Then
                    // Exit Function
                    // End If
                    // End If
                    if (SRC.ExtendedAnimation)
                    {
                        if (SRC.EADList.IsDefined(uname))
                        {
                            MessageData localItem() { object argIndex1 = uname; var ret = SRC.EADList.Item(argIndex1); return ret; }

                            AnimationDataRet = localItem().SelectMessage(situations[i], this);
                            if (Strings.Len(AnimationDataRet) > 0)
                            {
                                return AnimationDataRet;
                            }
                        }
                    }

                    if (!ext_anime_only)
                    {
                        if (SRC.ADList.IsDefined(uname))
                        {
                            MessageData localItem1() { object argIndex1 = uname; var ret = SRC.ADList.Item(argIndex1); return ret; }

                            AnimationDataRet = localItem1().SelectMessage(situations[i], this);
                            if (Strings.Len(AnimationDataRet) > 0)
                            {
                                return AnimationDataRet;
                            }
                        }
                    }
                    // MOD END MARGE
                }

                // ユニット名称で検索
                // MOD START MARGE
                // If ADList.IsDefined(Name) Then
                // AnimationData = ADList.Item(Name).SelectMessage(situations(i), Me)
                // If Len(AnimationData) > 0 Then
                // Exit Function
                // End If
                // End If
                if (SRC.ExtendedAnimation)
                {
                    bool localIsDefined() { object argIndex1 = Name; var ret = SRC.EADList.IsDefined(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                    if (localIsDefined())
                    {
                        MessageData localItem2() { object argIndex1 = Name; var ret = SRC.EADList.Item(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                        AnimationDataRet = localItem2().SelectMessage(situations[i], this);
                        if (Strings.Len(AnimationDataRet) > 0)
                        {
                            return AnimationDataRet;
                        }
                    }
                }

                if (!ext_anime_only)
                {
                    bool localIsDefined1() { object argIndex1 = Name; var ret = SRC.ADList.IsDefined(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                    if (localIsDefined1())
                    {
                        MessageData localItem3() { object argIndex1 = Name; var ret = SRC.ADList.Item(argIndex1); Name = Conversions.ToString(argIndex1); return ret; }

                        AnimationDataRet = localItem3().SelectMessage(situations[i], this);
                        if (Strings.Len(AnimationDataRet) > 0)
                        {
                            return AnimationDataRet;
                        }
                    }
                }
                // MOD END MARGE

                // ユニット愛称を修正したもので検索
                uname = Nickname0;
                ret = Strings.InStr(uname, "(");
                if (ret > 1)
                {
                    uname = Strings.Left(uname, ret - 1);
                }

                ret = Strings.InStr(uname, "用");
                if (ret > 0)
                {
                    if (ret < Strings.Len(uname))
                    {
                        uname = Strings.Mid(uname, ret + 1);
                    }
                }

                ret = Strings.InStr(uname, "型");
                if (ret > 0)
                {
                    if (ret < Strings.Len(uname))
                    {
                        uname = Strings.Mid(uname, ret + 1);
                    }
                }

                if (Strings.Right(uname, 4) == "カスタム")
                {
                    uname = Strings.Left(uname, Strings.Len(uname) - 4);
                }

                if (Strings.Right(uname, 1) == "改")
                {
                    uname = Strings.Left(uname, Strings.Len(uname) - 1);
                }
                // MOD START MARGE
                // If ADList.IsDefined(uname) Then
                // AnimationData = ADList.Item(uname).SelectMessage(situations(i), Me)
                // If Len(AnimationData) > 0 Then
                // Exit Function
                // End If
                // End If
                if (SRC.ExtendedAnimation)
                {
                    if (SRC.EADList.IsDefined(uname))
                    {
                        MessageData localItem4() { object argIndex1 = uname; var ret = SRC.EADList.Item(argIndex1); return ret; }

                        AnimationDataRet = localItem4().SelectMessage(situations[i], this);
                        if (Strings.Len(AnimationDataRet) > 0)
                        {
                            return AnimationDataRet;
                        }
                    }
                }

                if (!ext_anime_only)
                {
                    if (SRC.ADList.IsDefined(uname))
                    {
                        MessageData localItem5() { object argIndex1 = uname; var ret = SRC.ADList.Item(argIndex1); return ret; }

                        AnimationDataRet = localItem5().SelectMessage(situations[i], this);
                        if (Strings.Len(AnimationDataRet) > 0)
                        {
                            return AnimationDataRet;
                        }
                    }
                }
                // MOD END MARGE

                // ユニットクラスで検索
                uclass = Class0;
                // MOD START MARGE
                // If ADList.IsDefined(uclass) Then
                // AnimationData = ADList.Item(uclass).SelectMessage(situations(i), Me)
                // If Len(AnimationData) > 0 Then
                // Exit Function
                // End If
                // End If
                if (SRC.ExtendedAnimation)
                {
                    if (SRC.EADList.IsDefined(uclass))
                    {
                        MessageData localItem6() { object argIndex1 = uclass; var ret = SRC.EADList.Item(argIndex1); return ret; }

                        AnimationDataRet = localItem6().SelectMessage(situations[i], this);
                        if (Strings.Len(AnimationDataRet) > 0)
                        {
                            return AnimationDataRet;
                        }
                    }
                }

                if (!ext_anime_only)
                {
                    if (SRC.ADList.IsDefined(uclass))
                    {
                        MessageData localItem7() { object argIndex1 = uclass; var ret = SRC.ADList.Item(argIndex1); return ret; }

                        AnimationDataRet = localItem7().SelectMessage(situations[i], this);
                        if (Strings.Len(AnimationDataRet) > 0)
                        {
                            return AnimationDataRet;
                        }
                    }
                }
                // MOD END MARGE

                // 汎用
                // MOD START MARGE
                // If ADList.IsDefined("汎用") Then
                // AnimationData = ADList.Item("汎用").SelectMessage(situations(i), Me)
                // If Len(AnimationData) > 0 Then
                // Exit Function
                // End If
                // End If
                if (SRC.ExtendedAnimation)
                {
                    if (SRC.EADList.IsDefined("汎用"))
                    {
                        AnimationDataRet = SRC.EADList.Item("汎用").SelectMessage(situations[i], this);
                        if (Strings.Len(AnimationDataRet) > 0)
                        {
                            return AnimationDataRet;
                        }
                    }
                }

                if (!ext_anime_only)
                {
                    if (SRC.ADList.IsDefined("汎用"))
                    {
                        AnimationDataRet = SRC.ADList.Item("汎用").SelectMessage(situations[i], this);
                        if (Strings.Len(AnimationDataRet) > 0)
                        {
                            return AnimationDataRet;
                        }
                    }
                }
                // MOD END MARGE
            }

            return AnimationDataRet;
        }

        // 戦闘アニメを再生
        public void PlayAnimation(string main_situation, [Optional, DefaultParameterValue("")] string sub_situation, bool keep_message_form = false)
        {
            string anime, sname = default;
            string[] animes;
            int j, i, idx;
            var ret = default(double);
            var buf = default(string);
            int anime_head;
            bool is_message_form_opened;
            var is_weapon = default(bool);
            var is_ability = default(bool);
            var in_bulk = default(bool);
            var wait_time = default;
            var need_refresh = default(bool);
            int prev_obj_color;
            int prev_obj_fill_color;
            int prev_obj_fill_style;
            int prev_obj_draw_width;
            string prev_obj_draw_option;
            Unit prev_selected_target;

            // 戦闘アニメデータを検索
            anime = AnimationData(main_situation, sub_situation);

            // 見つからなかった場合は一括指定を試してみる
            if (string.IsNullOrEmpty(anime))
            {
                switch (Strings.Right(main_situation, 4) ?? "")
                {
                    case "(準備)":
                    case "(攻撃)":
                    case "(命中)":
                        {
                            anime = AnimationData(Strings.Left(main_situation, Strings.Len(main_situation) - 4), sub_situation);
                            in_bulk = true;
                            break;
                        }

                    case "(発動)":
                        {
                            anime = AnimationData(Strings.Left(main_situation, Strings.Len(main_situation) - 4), sub_situation);
                            break;
                        }
                }
            }

            GeneralLib.TrimString(anime);

            // 表示キャンセル
            if (string.IsNullOrEmpty(anime) || anime == "-")
            {
                return;
            }

            // マウスの右ボタンでキャンセル
            if (GUI.IsRButtonPressed())
            {
                // MOD START MARGE
                // '式評価のみ行う
                // FormatMessage anime
                // Exit Sub
                // アニメの終了処理はキャンセルしない
                if (main_situation != "終了" && Strings.Right(main_situation, 4) != "(終了)")
                {
                    // 式評価のみ行う
                    Expression.FormatMessage(anime);
                    return;
                }
                // MOD END MARGE
            }

            // メッセージウィンドウは表示されている？
            is_message_form_opened = My.MyProject.Forms.frmMessage.Visible;

            // オブジェクト色等を記録しておく
            prev_obj_color = Event.ObjColor;
            prev_obj_fill_color = Event.ObjFillColor;
            prev_obj_fill_style = Event.ObjFillStyle;
            prev_obj_draw_width = Event.ObjDrawWidth;
            prev_obj_draw_option = Event.ObjDrawOption;

            // オブジェクト色等をデフォルトに戻す
            Event.ObjColor = ColorTranslator.ToOle(Color.White);
            Event.ObjFillColor = ColorTranslator.ToOle(Color.White);
            // UPGRADE_ISSUE: 定数 vbFSTransparent はアップグレードされませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="55B59875-9A95-4B71-9D6A-7C294BF7139D"' をクリックしてください。
            Event.ObjFillStyle = vbFSTransparent;
            Event.ObjDrawWidth = 1;
            Event.ObjDrawOption = "";

            // 検索するシチュエーションが武器名かどうか調べる
            var loopTo = CountWeapon();
            for (i = 1; i <= loopTo; i++)
            {
                if ((main_situation ?? "") == (Weapon(i).Name + "(攻撃)" ?? ""))
                {
                    is_weapon = true;
                    break;
                }
            }

            // 検索するシチュエーションがアビリティかどうか調べる
            var loopTo1 = CountAbility();
            for (i = 1; i <= loopTo1; i++)
            {
                if ((main_situation ?? "") == (Ability(i).Name + "(発動)" ?? ""))
                {
                    is_ability = true;
                    break;
                }
            }

            // イベント用ターゲットを記録しておく
            prev_selected_target = Event.SelectedTargetForEvent;

            // 攻撃でもアビリティでもない場合、ターゲットが設定されていなければ
            // 自分自身をターゲットに設定する
            // (発動アニメではアニメ表示にSelectedTargetForEventが使われるため)
            if (!is_weapon && !is_ability)
            {
                if (Event.SelectedTargetForEvent is null)
                {
                    Event.SelectedTargetForEvent = this;
                }
            }

            // アニメ指定を分割
            animes = new string[2];
            anime_head = 1;
            var loopTo2 = Strings.Len(anime);
            for (i = 1; i <= loopTo2; i++)
            {
                if (Strings.Mid(anime, i, 1) == ";")
                {
                    animes[Information.UBound(animes)] = Strings.Mid(anime, anime_head, i - anime_head);
                    Array.Resize(animes, Information.UBound(animes) + 1 + 1);
                    anime_head = (i + 1);
                }
            }

            animes[Information.UBound(animes)] = Strings.Mid(anime, anime_head);
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 761038


            Input:

                    On Error GoTo ErrorHandler

             */
            var loopTo3 = Information.UBound(animes);
            for (i = 1; i <= loopTo3; i++)
            {
                anime = animes[i];

                // 最後に実行されたのがサブルーチン呼び出しかどうかを判定するため
                // サブルーチン名をあらかじめクリアしておく
                sname = "";

                // 式評価
                Expression.FormatMessage(anime);

                // 画面クリア？
                if (Strings.LCase(anime) == "clear")
                {
                    GUI.ClearPicture();
                    need_refresh = true;
                    goto NextAnime;
                }

                // 戦闘アニメ以外の特殊効果
                switch (Strings.LCase(Strings.Right(GeneralLib.LIndex(anime, 1), 4)) ?? "")
                {
                    case ".wav":
                    case ".mp3":
                        {
                            // 効果音
                            Sound.PlayWave(anime);
                            if (wait_time > 0)
                            {
                                if (need_refresh)
                                {
                                    // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                                    GUI.MainForm.picMain(0).Refresh();
                                    need_refresh = false;
                                }

                                GUI.Sleep(wait_time);
                                wait_time = 0;
                            }

                            goto NextAnime;
                            break;
                        }

                    case ".bmp":
                    case ".jpg":
                    case ".gif":
                    case ".png":
                        {
                            // カットインの表示
                            if (wait_time > 0)
                            {
                                anime = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(wait_time / 100d) + ";" + anime;
                                wait_time = 0;
                                need_refresh = false;
                            }
                            else if (Strings.Left(anime, 1) == "@")
                            {
                                need_refresh = false;
                            }
                            else
                            {
                                need_refresh = true;
                            }

                            GUI.DisplayBattleMessage("-", anime, msg_mode: "");
                            goto NextAnime;
                            break;
                        }
                }

                switch (Strings.LCase(GeneralLib.LIndex(anime, 1)) ?? "")
                {
                    case "line":
                    case "circle":
                    case "arc":
                    case "oval":
                    case "color":
                    case "fillcolor":
                    case "fillstyle":
                    case "drawwidth":
                        {
                            // 画面処理コマンド
                            if (wait_time > 0)
                            {
                                anime = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(wait_time / 100d) + ";" + anime;
                                wait_time = 0;
                                need_refresh = false;
                            }
                            else
                            {
                                need_refresh = true;
                            }

                            GUI.DisplayBattleMessage("-", anime, msg_mode: "");
                            goto NextAnime;
                            break;
                        }

                    case "center":
                        {
                            // 指定したユニットを中央表示
                            buf = Expression.GetValueAsString(GeneralLib.ListIndex(anime, 2));
                            if (SRC.UList.IsDefined(buf))
                            {
                                {
                                    var withBlock = SRC.UList.Item(buf);
                                    GUI.Center(withBlock.x, withBlock.y);
                                    GUI.RedrawScreen();
                                    need_refresh = false;
                                }
                            }

                            goto NextAnime;
                            break;
                        }

                    case "keep":
                        {
                            // そのまま終了
                            break;
                        }
                }

                // ウェイト？
                if (Information.IsNumeric(anime))
                {
                    wait_time = (100d * Conversions.ToDouble(anime));
                    goto NextAnime;
                }

                // サブルーチンの呼び出しが確定

                // 戦闘アニメ再生用のサブルーチン名を作成
                sname = GeneralLib.LIndex(anime, 1);
                if (Strings.Left(sname, 1) == "@")
                {
                    sname = Strings.Mid(sname, 2);
                }
                else if (is_weapon)
                {
                    // 武器名の場合
                    sname = "戦闘アニメ_" + sname + "攻撃";
                }
                else
                {
                    // その他の場合
                    // 括弧を含んだ武器名に対応するため、"("は後ろから検索
                    idx = GeneralLib.InStr2(main_situation, "(");

                    // 変形系のシチュエーションではサフィックスを無視
                    if (idx > 0)
                    {
                        switch (Strings.Left(main_situation, idx - 1) ?? "")
                        {
                            case "変形":
                            case "ハイパーモード":
                            case "ノーマルモード":
                            case "パーツ分離":
                            case "合体":
                            case "分離":
                                {
                                    idx = 0;
                                    break;
                                }
                        }
                    }

                    // 武器名(攻撃無効化)の場合もサフィックスを無視
                    if (idx > 0)
                    {
                        if (Strings.Mid(main_situation, idx) == "(攻撃無効化)")
                        {
                            idx = 0;
                        }
                    }

                    if (idx > 0)
                    {
                        // サフィックスあり
                        sname = "戦闘アニメ_" + sname + Strings.Mid(main_situation, idx + 1, Strings.Len(main_situation) - idx - 1);
                    }
                    else
                    {
                        sname = "戦闘アニメ_" + sname + "発動";
                    }
                }

                // サブルーチンが見つからなかった
                if (Event.FindNormalLabel(sname) == 0)
                {
                    if (in_bulk)
                    {
                        // 一括指定を利用している場合
                        switch (Strings.Right(main_situation, 4) ?? "")
                        {
                            case "(準備)":
                                {
                                    // 表示をキャンセル
                                    goto NextAnime;
                                    break;
                                }

                            case "(攻撃)":
                                {
                                    // 複数のアニメ指定がある場合は諦めて他のものを使う
                                    if (Information.UBound(animes) > 1)
                                    {
                                        goto NextAnime;
                                    }
                                    // そうでなければ「デフォルト」を使用
                                    sname = "戦闘アニメ_デフォルト攻撃";
                                    break;
                                }

                            case "(命中)":
                                {
                                    // 複数のアニメ指定がある場合は諦めて他のものを使う
                                    if (Information.UBound(animes) > 1)
                                    {
                                        goto NextAnime;
                                    }
                                    // そうでなければ「ダメージ」を使用
                                    sname = "戦闘アニメ_ダメージ命中";
                                    break;
                                }
                        }
                    }
                    else
                    {
                        if (wait_time > 0)
                        {
                            anime = Microsoft.VisualBasic.Compatibility.VB6.Support.Format(wait_time / 100d) + ";" + anime;
                            wait_time = 0;
                        }

                        if (!My.MyProject.Forms.frmMessage.Visible)
                        {
                            if (ReferenceEquals(Commands.SelectedTarget, this))
                            {
                                GUI.OpenMessageForm(this, u2: null);
                            }
                            else
                            {
                                GUI.OpenMessageForm(Commands.SelectedTarget, this);
                            }
                        }

                        GUI.DisplayBattleMessage("-", anime, msg_mode: "");
                        goto NextAnime;
                    }
                }

                sname = "`" + sname + "`";

                // 引数の構築
                var loopTo4 = GeneralLib.ListLength(anime);
                for (j = 2; j <= loopTo4; j++)
                    sname = sname + "," + GeneralLib.ListIndex(anime, j);
                if (in_bulk)
                {
                    sname = sname + ",`一括指定`";
                }

                // 戦闘アニメ再生前にウェイトを入れる
                if (need_refresh)
                {
                    // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                    GUI.MainForm.picMain(0).Refresh();
                    need_refresh = false;
                }

                if (wait_time > 0)
                {
                    GUI.Sleep(wait_time);
                    wait_time = 0;
                }

                // 画像描画が行われたかどうかの判定のためにフラグを初期化
                GUI.IsPictureDrawn = false;

                // 戦闘アニメ再生
                Event.SaveBasePoint();
                Expression.CallFunction("Call(" + sname + ")", Expression.ValueType.StringType, buf, ret);
                Event.RestoreBasePoint();

                // 画像を消去しておく
                if (GUI.IsPictureDrawn && Strings.LCase(buf) != "keep")
                {
                    GUI.ClearPicture();
                    // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                    GUI.MainForm.picMain(0).Refresh();
                }

                NextAnime:
                ;
            }

            // 戦闘アニメ再生後にウェイトを入れる？
            if (need_refresh)
            {
                // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                GUI.MainForm.picMain(0).Refresh();
                need_refresh = false;
            }

            if (wait_time > 0)
            {
                GUI.Sleep(wait_time);
                wait_time = 0;
            }

            // 画像を消去しておく
            if (GUI.IsPictureDrawn && string.IsNullOrEmpty(sname) && Strings.InStr(main_situation, "(準備)") == 0 && Strings.LCase(anime) != "keep")
            {
                GUI.ClearPicture();
                // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                GUI.MainForm.picMain(0).Refresh();
            }

            // 最初から表示されていたのでなければメッセージウィンドウを閉じる
            if (!is_message_form_opened && !keep_message_form)
            {
                GUI.CloseMessageForm();
            }

            // オブジェクト色等を元に戻す
            Event.ObjColor = prev_obj_color;
            Event.ObjFillColor = prev_obj_fill_color;
            Event.ObjFillStyle = prev_obj_fill_style;
            Event.ObjDrawWidth = prev_obj_draw_width;
            Event.ObjDrawOption = prev_obj_draw_option;

            // イベント用ターゲットを元に戻す
            Event.SelectedTargetForEvent = prev_selected_target;
            return;
            ErrorHandler:
            ;
            if (Strings.Len(Event.EventErrorMessage) > 0)
            {
                Event.DisplayEventErrorMessage(Event.CurrentLineNum, Event.EventErrorMessage);
                Event.EventErrorMessage = "";
            }
            else
            {
                Event.DisplayEventErrorMessage(Event.CurrentLineNum, "");
            }
        }

        // 戦闘アニメが定義されているか？
        // MOD START MARGE
        // Public Function IsAnimationDefined(main_situation As String, _
        // '    Optional sub_situation As String) As Boolean
        public bool IsAnimationDefined(string main_situation, [Optional, DefaultParameterValue("")] string sub_situation, bool ext_anime_only = false)
        {
            bool IsAnimationDefinedRet = default;
            // MOD END MARGE
            string anime;

            // MOD START MARGE
            // anime = AnimationData(main_situation, sub_situation)
            anime = AnimationData(main_situation, sub_situation, ext_anime_only);
            // MOD END MARGE

            if (Strings.Len(anime) > 0)
            {
                IsAnimationDefinedRet = true;
            }
            else
            {
                IsAnimationDefinedRet = false;
            }

            return IsAnimationDefinedRet;
        }



        // ユニットを(new_x,new_y)に配置
        public void StandBy(int new_x, int new_y, string smode = "")
        {
            int j, i, k;

            // とりあえず地形を考慮せずにデフォルトのポジションを決めておく
            // (Createコマンドの後で空中移動用アイテムを付けるときのため)
            for (i = 0; i <= 20; i++)
            {
                var loopTo = GeneralLib.MinLng(new_x + i, Map.MapWidth);
                for (j = GeneralLib.MaxLng(new_x - i, 1); j <= loopTo; j++)
                {
                    var loopTo1 = GeneralLib.MinLng(new_y + i, Map.MapHeight);
                    for (k = GeneralLib.MaxLng(new_y - i, 1); k <= loopTo1; k++)
                    {
                        if ((Math.Abs((new_x - j)) + Math.Abs((new_y - k))) == i)
                        {
                            if (Map.MapDataForUnit[j, k] is null)
                            {
                                x = j;
                                y = k;
                                goto DefaultPositionDefined;
                            }
                        }
                    }
                }
            }

            DefaultPositionDefined:
            ;


            // 空いた場所を検索
            for (i = 0; i <= 20; i++)
            {
                // ユニット同士を隣接させずに配置する？
                // MOD START MARGE
                // If smode = "部隊配置" Then
                if (Strings.InStr(smode, "部隊配置") > 0)
                {
                    // MOD END MARGE
                    if (i % 2 != 0)
                    {
                        goto NextDistance;
                    }
                }
                // 指定した場所の周りを調べる
                var loopTo2 = GeneralLib.MinLng(new_x + i, Map.MapWidth);
                for (j = GeneralLib.MaxLng(new_x - i, 1); j <= loopTo2; j++)
                {
                    var loopTo3 = GeneralLib.MinLng(new_y + i, Map.MapHeight);
                    for (k = GeneralLib.MaxLng(new_y - i, 1); k <= loopTo3; k++)
                    {
                        if ((Math.Abs((new_x - j)) + Math.Abs((new_y - k))) != i)
                        {
                            goto NextLoop;
                        }

                        // 既に他のユニットがいる？
                        if (Map.MapDataForUnit[j, k] is object)
                        {
                            goto NextLoop;
                        }

                        // 進入不能の地形？
                        if (Map.TerrainMoveCost(j, k) > 100)
                        {
                            goto NextLoop;
                        }

                        switch (Map.TerrainClass(j, k) ?? "")
                        {
                            case "空":
                                {
                                    if (!IsTransAvailable("空"))
                                    {
                                        goto NextLoop;
                                    }

                                    break;
                                }

                            case "水":
                                {
                                    if (!IsTransAvailable("水上") && !IsTransAvailable("空") && get_Adaption(3) == 0)
                                    {
                                        goto NextLoop;
                                    }

                                    break;
                                }

                            case "深水":
                                {
                                    if (!IsTransAvailable("水上") && !IsTransAvailable("空") && !IsTransAvailable("水"))
                                    {
                                        goto NextLoop;
                                    }

                                    break;
                                }
                        }

                        // 空き位置が見つかった
                        x = j;
                        y = k;
                        goto ExitFor;
                        NextLoop:
                        ;
                    }
                }

                NextDistance:
                ;
            }

            ExitFor:
            ;


            // 空いた場所がなかった？
            if (x == 0 && y == 0)
            {
                Status = "待機";
                return;
            }

            // 他の形態と格納したユニットの座標も合わせておく
            var loopTo4 = CountOtherForm();
            for (i = 1; i <= loopTo4; i++)
            {
                {
                    var withBlock = OtherForm(i);
                    withBlock.x = x;
                    withBlock.y = y;
                }
            }

            var loopTo5 = CountUnitOnBoard();
            for (i = 1; i <= loopTo5; i++)
            {
                {
                    var withBlock1 = UnitOnBoard(i);
                    withBlock1.x = x;
                    withBlock1.y = y;
                }
            }

            // 格納されていた場合はあらかじめ降ろしておく
            if (Status == "格納")
            {
                foreach (Unit u in SRC.UList)
                {
                    var loopTo6 = u.CountUnitOnBoard();
                    for (i = 1; i <= loopTo6; i++)
                    {
                        Unit localUnitOnBoard() { object argIndex1 = i; var ret = u.UnitOnBoard(argIndex1); return ret; }

                        if ((ID ?? "") == (localUnitOnBoard().ID ?? ""))
                        {
                            u.UnloadUnit(ID);
                            goto EndLoop;
                        }
                    }
                }

                EndLoop:
                ;
            }

            // Statusを更新
            Status = "出撃";
            var loopTo7 = CountOtherForm();
            for (i = 1; i <= loopTo7; i++)
            {
                Unit localOtherForm() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                localOtherForm().Status = "他形態";
            }

            // ユニットのいる地形は？
            switch (Map.TerrainClass(x, y) ?? "")
            {
                case "空":
                    {
                        Area = "空中";
                        break;
                    }

                case "陸":
                    {
                        if (IsTransAvailable("地中") && Area == "地中")
                        {
                            Area = "地中";
                        }
                        else if (IsTransAvailable("空") && get_Adaption(1) >= get_Adaption(2))
                        {
                            Area = "空中";
                        }
                        else if (IsTransAvailable("陸"))
                        {
                            Area = "地上";
                        }
                        else
                        {
                            Area = "空中";
                        }

                        break;
                    }

                case "屋内":
                    {
                        if (IsTransAvailable("空") && get_Adaption(1) >= get_Adaption(2))
                        {
                            Area = "空中";
                        }
                        else if (IsTransAvailable("陸"))
                        {
                            Area = "地上";
                        }
                        else
                        {
                            Area = "空中";
                        }

                        break;
                    }

                case "月面":
                    {
                        if (IsTransAvailable("空") || IsTransAvailable("宇宙"))
                        {
                            Area = "宇宙";
                        }
                        else if (IsTransAvailable("陸"))
                        {
                            Area = "地上";
                        }
                        else
                        {
                            Area = "宇宙";
                        }

                        break;
                    }

                case "水":
                case "深水":
                    {
                        if (IsTransAvailable("空") && get_Adaption(1) >= get_Adaption(2))
                        {
                            Area = "空中";
                        }
                        else if (IsTransAvailable("水上"))
                        {
                            Area = "水上";
                        }
                        else
                        {
                            Area = "水中";
                        }

                        break;
                    }

                case "宇宙":
                    {
                        Area = "宇宙";
                        break;
                    }

                default:
                    {
                        Area = "地上";
                        break;
                    }
            }

            // マップに登録
            Map.MapDataForUnit[x, y] = this;

            // ビットマップを作成
            if (BitmapID == 0)
            {
                BitmapID = GUI.MakeUnitBitmap(this);
            }

            // 登場時アニメを表示
            // MOD START MARGE
            // If (smode = "出撃" Or smode = "部隊配置") _
            // '        And MainForm.Visible _
            // '        And Not IsPictureVisible _
            // '        And Not IsRButtonPressed() _
            // '        And BitmapID > 0 _
            // '    Then
            var fname = default(string);
            int start_time, current_time;
            if ((Strings.InStr(smode, "出撃") > 0 || Strings.InStr(smode, "部隊配置") > 0) && GUI.MainForm.Visible && !GUI.IsPictureVisible && !GUI.IsRButtonPressed() && BitmapID > 0)
            {
                // MOD END MARGE

                // ユニット出現音
                Sound.PlayWave("UnitOn.wav");

                // 表示させる画像
                switch (Party0 ?? "")
                {
                    case "味方":
                    case "ＮＰＣ":
                        {
                            fname = @"Bitmap\Event\AUnitOn0";
                            break;
                        }

                    case "敵":
                        {
                            fname = @"Bitmap\Event\EUnitOn0";
                            break;
                        }

                    case "中立":
                        {
                            fname = @"Bitmap\Event\NUnitOn0";
                            break;
                        }
                }

                if (SRC.FileSystem.FileExists(SRC.AppPath + fname + "1.bmp"))
                {
                    // アニメ表示開始時刻を記録
                    start_time = GeneralLib.timeGetTime();
                    for (i = 1; i <= 4; i++)
                    {
                        // 画像を透過表示
                        if (GUI.DrawPicture(fname + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(i) + ".bmp", GUI.MapToPixelX(x), GUI.MapToPixelY(y), 32, 32, 0, 0, 0, 0, "透過") == false)
                        {
                            break;
                        }
                        // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                        GUI.MainForm.picMain(0).Refresh();

                        // ウェイト
                        do
                        {
                            Application.DoEvents();
                            current_time = GeneralLib.timeGetTime();
                        }
                        while (current_time < start_time + 15);
                        start_time = current_time;

                        // 画像を消去
                        GUI.ClearPicture();
                    }

                    // アニメ画像は上書きして消してしまうので……
                    GUI.IsPictureVisible = false;
                }
            }

            // ユニット画像をマップに描画
            if (!GUI.IsPictureVisible && !string.IsNullOrEmpty(Map.MapFileName))
            {
                // MOD START MARGE
                // If smode = "非同期" Then
                if (Strings.InStr(smode, "非同期") > 0)
                {
                    // MOD END MARGE
                    GUI.PaintUnitBitmap(this, "リフレッシュ無し");
                }
                else
                {
                    GUI.PaintUnitBitmap(this);
                }
            }

            // 制御不能？
            if (IsFeatureAvailable("制御不可"))
            {
                AddCondition("暴走", -1, cdata: "");
            }

            Update();
            SRC.PList.UpdateSupportMod(this);
        }

        // ユニットを(new_x,new_y)に移動
        public void Move(int new_x, int new_y, bool without_en_consumption = false, bool by_cancel = false, bool by_teleport_or_jump = false)
        {
            int prev_x, prev_y;
            int i;

            // ユニットをマップからいったん削除
            if (ReferenceEquals(Map.MapDataForUnit[x, y], this))
            {
                // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                Map.MapDataForUnit[x, y] = null;
            }

            if (GUI.IsPictureVisible)
            {
                GUI.EraseUnitBitmap(x, y, false);
            }
            else
            {
                GUI.EraseUnitBitmap(x, y, false);
            }

            SRC.PList.UpdateSupportMod(this);

            // ユニット位置を指定された座標に
            prev_x = x;
            prev_y = y;
            x = new_x;
            y = new_y;
            var loopTo = CountOtherForm();
            for (i = 1; i <= loopTo; i++)
            {
                {
                    var withBlock = OtherForm(i);
                    withBlock.x = x;
                    withBlock.y = y;
                }
            }

            var loopTo1 = CountUnitOnBoard();
            for (i = 1; i <= loopTo1; i++)
            {
                {
                    var withBlock1 = UnitOnBoard(i);
                    withBlock1.x = x;
                    withBlock1.y = y;
                }
            }

            // 指定された場所に既にユニットが存在？
            if (Map.MapDataForUnit[x, y] is object)
            {
                {
                    var withBlock2 = Map.MapDataForUnit[x, y];
                    // 合体？
                    var loopTo2 = withBlock2.CountFeature();
                    for (i = 1; i <= loopTo2; i++)
                    {
                        string localFeature() { object argIndex1 = i; var ret = withBlock2.Feature(argIndex1); return ret; }

                        string localFeatureData2() { object argIndex1 = i; var ret = withBlock2.FeatureData(argIndex1); return ret; }

                        int localLLength() { string arglist = hsb631fea4c5cf49098946ae0a91f0346e(); var ret = GeneralLib.LLength(arglist); return ret; }

                        if (localFeature() == "合体" && localLLength() == 3)
                        {
                            string localFeatureData1() { object argIndex1 = i; var ret = withBlock2.FeatureData(argIndex1); return ret; }

                            string localLIndex1() { string arglist = hsb6975299bb8a44cda80cb8aa733a682c(); var ret = GeneralLib.LIndex(arglist, 3); return ret; }

                            if (SRC.UList.IsDefined(localLIndex1()))
                            {
                                string localFeatureData() { object argIndex1 = i; var ret = withBlock2.FeatureData(argIndex1); return ret; }

                                string localLIndex() { string arglist = hs429ff88444314337bcbc774b8db33f1c(); var ret = GeneralLib.LIndex(arglist, 3); return ret; }

                                Unit localItem() { object argIndex1 = (object)hs60134dcbf45946b48db157b192860c4e(); var ret = SRC.UList.Item(argIndex1); return ret; }

                                if (ReferenceEquals(localItem().CurrentForm(), this))
                                {
                                    Combine(uname: "");
                                    return;
                                }
                            }
                        }
                    }

                    // 着艦？
                    if (!withBlock2.IsFeatureAvailable("母艦"))
                    {
                        GUI.ErrorMessage("合体元ユニット「" + Name + "」が複数あるため合体処理が出来ません");
                        return;
                    }
                }

                // 着艦処理
                Land(Map.MapDataForUnit[x, y], by_cancel);
                return;
            }

            // 移動先によるユニット位置変更
            switch (Map.TerrainClass(x, y) ?? "")
            {
                case "空":
                    {
                        Area = "空中";
                        break;
                    }

                case "陸":
                case "屋内":
                    {
                        switch (Area ?? "")
                        {
                            case "水中":
                            case "水上":
                                {
                                    Area = "地上";
                                    break;
                                }

                            case "宇宙":
                                {
                                    if (IsTransAvailable("空") && get_Adaption(1) >= get_Adaption(2))
                                    {
                                        Area = "空中";
                                    }
                                    else if (IsTransAvailable("陸"))
                                    {
                                        Area = "地上";
                                    }
                                    else
                                    {
                                        Area = "空中";
                                    }

                                    break;
                                }
                        }

                        break;
                    }

                case "月面":
                    {
                        switch (Area ?? "")
                        {
                            // 変更なし
                            case "地上":
                            case "地中":
                                {
                                    break;
                                }

                            default:
                                {
                                    if ((IsTransAvailable("空") || IsTransAvailable("宇宙")) && get_Adaption(4) >= get_Adaption(2))
                                    {
                                        Area = "宇宙";
                                    }
                                    else if (IsTransAvailable("陸"))
                                    {
                                        Area = "地上";
                                    }
                                    else
                                    {
                                        Area = "宇宙";
                                    }

                                    break;
                                }
                        }

                        break;
                    }

                case "水":
                case "深水":
                    {
                        switch (Area ?? "")
                        {
                            case "地上":
                                {
                                    if (IsTransAvailable("水上"))
                                    {
                                        Area = "水上";
                                    }
                                    else
                                    {
                                        Area = "水中";
                                    }

                                    break;
                                }

                            case "宇宙":
                                {
                                    Area = "水中";
                                    break;
                                }
                        }

                        break;
                    }

                case "宇宙":
                    {
                        Area = "宇宙";
                        break;
                    }
            }

            // マップにユニットを登録
            Map.MapDataForUnit[x, y] = this;

            // ユニット描画
            if (!GUI.IsPictureVisible)
            {
                if (SRC.MoveAnimation && !by_cancel && !by_teleport_or_jump)
                {
                    GUI.MoveUnitBitmap2(this, 20);
                }
                else
                {
                    GUI.PaintUnitBitmap(this);
                }
            }

            // 移動によるＥＮ消費
            if (!without_en_consumption)
            {
                switch (Area ?? "")
                {
                    case "地上":
                    case "水上":
                        {
                            if (IsFeatureAvailable("ホバー移動"))
                            {
                                EN = EN - 5;
                            }

                            break;
                        }

                    case "空中":
                    case "宇宙":
                        {
                            EN = EN - 5;
                            break;
                        }

                    case "地中":
                        {
                            EN = EN - 10;
                            break;
                        }
                }
            }

            // 情報更新
            Update();
            SRC.PList.UpdateSupportMod(this);
        }

        // ユニットを(new_x,new_y)にジャンプ
        public void Jump(int new_x, int new_y, bool do_refresh = true)
        {
            int j, i, k;

            // ユニットを一旦マップから削除
            // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Map.MapDataForUnit[x, y] = null;
            GUI.EraseUnitBitmap(x, y, do_refresh);
            SRC.PList.UpdateSupportMod(this);

            // 空き位置を検索
            for (i = 0; i <= 10; i++)
            {
                var loopTo = GeneralLib.MinLng(new_x + i, Map.MapWidth);
                for (j = GeneralLib.MaxLng(new_x - i, 1); j <= loopTo; j++)
                {
                    var loopTo1 = GeneralLib.MinLng(new_y + i, Map.MapHeight);
                    for (k = GeneralLib.MaxLng(new_y - i, 1); k <= loopTo1; k++)
                    {
                        if ((Math.Abs((new_x - j)) + Math.Abs((new_y - k))) != i)
                        {
                            goto NextLoop;
                        }

                        if (Map.MapDataForUnit[j, k] is object)
                        {
                            goto NextLoop;
                        }

                        if (Map.TerrainMoveCost(j, k) > 100)
                        {
                            goto NextLoop;
                        }

                        switch (Map.TerrainClass(j, k) ?? "")
                        {
                            case "空":
                                {
                                    if (!IsTransAvailable("空"))
                                    {
                                        goto NextLoop;
                                    }

                                    break;
                                }

                            case "水":
                            case "深水":
                                {
                                    if (!IsTransAvailable("水上") && !IsTransAvailable("空") && get_Adaption(3) == 0)
                                    {
                                        goto NextLoop;
                                    }

                                    break;
                                }
                        }

                        x = j;
                        y = k;
                        goto ExitFor;
                        NextLoop:
                        ;
                    }
                }
            }

            ExitFor:
            ;


            // 他の形態と格納したユニットの座標を更新
            var loopTo2 = CountOtherForm();
            for (i = 1; i <= loopTo2; i++)
            {
                {
                    var withBlock = OtherForm(i);
                    withBlock.x = x;
                    withBlock.y = y;
                }
            }

            var loopTo3 = CountUnitOnBoard();
            for (i = 1; i <= loopTo3; i++)
            {
                {
                    var withBlock1 = UnitOnBoard(i);
                    withBlock1.x = x;
                    withBlock1.y = y;
                }
            }

            // 移動先によるユニット位置変更
            switch (Map.TerrainClass(x, y) ?? "")
            {
                case "空":
                    {
                        Area = "空中";
                        break;
                    }

                case "陸":
                case "屋内":
                    {
                        switch (Area ?? "")
                        {
                            case "水中":
                            case "水上":
                                {
                                    Area = "地上";
                                    break;
                                }

                            case "宇宙":
                                {
                                    if (IsTransAvailable("空") && get_Adaption(1) >= get_Adaption(2))
                                    {
                                        Area = "空中";
                                    }
                                    else if (IsTransAvailable("陸"))
                                    {
                                        Area = "地上";
                                    }
                                    else
                                    {
                                        Area = "空中";
                                    }

                                    break;
                                }
                        }

                        break;
                    }

                case "月面":
                    {
                        switch (Area ?? "")
                        {
                            // 変更なし
                            case "地上":
                            case "地中":
                                {
                                    break;
                                }

                            default:
                                {
                                    if ((IsTransAvailable("空") || IsTransAvailable("宇宙")) && get_Adaption(4) >= get_Adaption(2))
                                    {
                                        Area = "宇宙";
                                    }
                                    else if (IsTransAvailable("陸"))
                                    {
                                        Area = "地上";
                                    }
                                    else
                                    {
                                        Area = "宇宙";
                                    }

                                    break;
                                }
                        }

                        break;
                    }

                case "水":
                case "深水":
                    {
                        switch (Area ?? "")
                        {
                            case "地上":
                                {
                                    if (IsTransAvailable("水上"))
                                    {
                                        Area = "水上";
                                    }
                                    else
                                    {
                                        Area = "水中";
                                    }

                                    break;
                                }

                            case "宇宙":
                                {
                                    Area = "水中";
                                    break;
                                }
                        }

                        break;
                    }

                case "宇宙":
                    {
                        Area = "宇宙";
                        break;
                    }
            }

            // マップにユニットを登録
            Map.MapDataForUnit[x, y] = this;

            // 情報更新
            Update();
            SRC.PList.UpdateSupportMod(this);

            // ユニット描画
            if (do_refresh)
            {
                GUI.PaintUnitBitmap(this);
            }
        }

        // マップ上から脱出
        public void Escape(string smode = "")
        {
            Unit u;
            int i, j;

            // 母艦に乗っていた場合は降りておく
            if (Status == "格納")
            {
                foreach (Unit currentU in SRC.UList)
                {
                    u = currentU;
                    var loopTo = u.CountUnitOnBoard();
                    for (i = 1; i <= loopTo; i++)
                    {
                        Unit localUnitOnBoard() { object argIndex1 = i; var ret = u.UnitOnBoard(argIndex1); return ret; }

                        if ((ID ?? "") == (localUnitOnBoard().ID ?? ""))
                        {
                            u.UnloadUnit(ID);
                            goto EndLoop;
                        }
                    }
                }

                EndLoop:
                ;
            }

            // 出撃している場合は画面上からユニットを消去
            if (Status == "出撃" || Status == "破壊")
            {
                if (ReferenceEquals(Map.MapDataForUnit[x, y], this))
                {
                    // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                    Map.MapDataForUnit[x, y] = null;
                    if (smode == "非同期" || GUI.IsPictureVisible || string.IsNullOrEmpty(Map.MapFileName))
                    {
                        GUI.EraseUnitBitmap(x, y, false);
                    }
                    else
                    {
                        GUI.EraseUnitBitmap(x, y, true);
                    }

                    SRC.PList.UpdateSupportMod(this);
                }
            }

            if (Status == "出撃" || Status == "格納")
            {
                Status = "待機";
            }

            // 破壊をキャンセル状態は解除
            if (IsConditionSatisfied("破壊キャンセル"))
            {
                DeleteCondition("破壊キャンセル");
            }

            // ユニットを格納していたら降ろす
            foreach (Unit currentU1 in colUnitOnBoard)
            {
                u = currentU1;
                u.Status = "待機";
                colUnitOnBoard.Remove(u.ID);
            }

            // 召喚したユニットを解放
            DismissServant();

            // 魅了・憑依したユニットを解放
            DismissSlave();

            // ステータス表示中の場合は表示を解除
            if (ReferenceEquals(this, Status.DisplayedUnit))
            {
                Status.ClearUnitStatus();
            }
        }

        // 母艦 u に着艦
        public void Land(Unit u, bool by_cancel = false, bool is_event = false)
        {
            string tclass;
            int i;

            // Landコマンドで着艦した場合
            if (is_event)
            {
                if (Status == "出撃" || Status == "格納")
                {
                    Escape();
                }
                else
                {
                    // 出撃のための前準備

                    // ユニットが存在する位置を決定
                    if (u.Status == "出撃")
                    {
                        tclass = Map.TerrainClass(u.x, u.y);
                    }
                    else
                    {
                        tclass = Map.TerrainClass((Map.MapWidth / 2), (Map.MapHeight / 2));
                    }

                    switch (tclass ?? "")
                    {
                        case "空":
                            {
                                Area = "空中";
                                break;
                            }

                        case "陸":
                        case "屋内":
                            {
                                if (IsTransAvailable("空") && Strings.Mid(strAdaption, 1, 1) == "A")
                                {
                                    Area = "空中";
                                }
                                else if (IsTransAvailable("陸"))
                                {
                                    Area = "地上";
                                }
                                else
                                {
                                    Area = "空中";
                                }

                                break;
                            }

                        case "月面":
                            {
                                if ((IsTransAvailable("空") || IsTransAvailable("宇宙")) && Strings.Mid(strAdaption, 4, 1) == "A")
                                {
                                    Area = "宇宙";
                                }
                                else if (IsTransAvailable("陸"))
                                {
                                    Area = "地上";
                                }
                                else
                                {
                                    Area = "宇宙";
                                }

                                break;
                            }

                        case "水":
                        case "深水":
                            {
                                if (IsTransAvailable("空"))
                                {
                                    Area = "空中";
                                }
                                else if (IsTransAvailable("水上"))
                                {
                                    Area = "水上";
                                }
                                else
                                {
                                    Area = "水中";
                                }

                                break;
                            }

                        case "宇宙":
                            {
                                Area = "宇宙";
                                break;
                            }
                    }

                    // 行動回数等を回復
                    UsedAction = 0;
                    UsedSupportAttack = 0;
                    UsedSupportGuard = 0;
                    UsedSyncAttack = 0;
                    UsedCounterAttack = 0;
                    if (BitmapID == 0)
                    {
                        {
                            var withBlock = SRC.UList.Item(Name);
                            if ((withBlock.Party0 ?? "") == (Party0 ?? "") && withBlock.BitmapID != 0 && (withBlock.get_Bitmap(false) ?? "") == (get_Bitmap(false) ?? ""))
                            {
                                BitmapID = withBlock.BitmapID;
                            }
                            else
                            {
                                BitmapID = GUI.MakeUnitBitmap(this);
                            }
                        }

                        Name = Conversions.ToString(argIndex1);
                    }

                    if (IsFeatureAvailable("制御不可"))
                    {
                        AddCondition("暴走", -1, cdata: "");
                    }
                }
            }

            // 母艦に自分自身を格納
            u.LoadUnit(this);

            // 座標を母艦に合わせる
            x = u.x;
            y = u.y;
            Status = "格納";
            if (Area != "宇宙" && Area != "空中")
            {
                Area = "地上";
            }

            // 気力減少
            if (!by_cancel)
            {
                {
                    var withBlock1 = MainPilot();
                    if (withBlock1.Personality != "機械")
                    {
                        if (Expression.IsOptionDefined("母艦収納時気力低下小"))
                        {
                            withBlock1.Morale = GeneralLib.MinLng(withBlock1.Morale, GeneralLib.MaxLng(withBlock1.Morale - 5, 100));
                        }
                        else
                        {
                            withBlock1.Morale = (withBlock1.Morale - 5);
                        }
                    }
                }

                var loopTo = CountPilot();
                for (i = 1; i <= loopTo; i++)
                {
                    {
                        var withBlock2 = Pilot(i);
                        if ((MainPilot().ID ?? "") != (withBlock2.ID ?? "") && withBlock2.Personality != "機械")
                        {
                            if (Expression.IsOptionDefined("母艦収納時気力低下小"))
                            {
                                withBlock2.Morale = GeneralLib.MinLng(withBlock2.Morale, GeneralLib.MaxLng(withBlock2.Morale - 5, 100));
                            }
                            else
                            {
                                withBlock2.Morale = (withBlock2.Morale - 5);
                            }
                        }
                    }
                }

                var loopTo1 = CountSupport();
                for (i = 1; i <= loopTo1; i++)
                {
                    {
                        var withBlock3 = Support(i);
                        if (withBlock3.Personality != "機械")
                        {
                            if (Expression.IsOptionDefined("母艦収納時気力低下小"))
                            {
                                withBlock3.Morale = GeneralLib.MinLng(withBlock3.Morale, GeneralLib.MaxLng(withBlock3.Morale - 5, 100));
                            }
                            else
                            {
                                withBlock3.Morale = (withBlock3.Morale - 5);
                            }
                        }
                    }
                }

                if (IsFeatureAvailable("追加サポート"))
                {
                    {
                        var withBlock4 = AdditionalSupport();
                        if (withBlock4.Personality != "機械")
                        {
                            if (Expression.IsOptionDefined("母艦収納時気力低下小"))
                            {
                                withBlock4.Morale = GeneralLib.MinLng(withBlock4.Morale, GeneralLib.MaxLng(withBlock4.Morale - 5, 100));
                            }
                            else
                            {
                                withBlock4.Morale = (withBlock4.Morale - 5);
                            }
                        }
                    }
                }
            }
        }

        // new_form へ変形（換装、ハイパーモード、パーツ分離＆合体を含む）
        public void Transform(string new_form)
        {
            string list;
            int i, idx, idx2, j;
            Unit u;
            string[] wname;
            int[] wbullet;
            int[] wmaxbullet;
            string[] aname;
            int[] astock;
            int[] amaxstock;
            double hp_ratio, en_ratio;
            int prev_x, prev_y;
            string buf;
            hp_ratio = 100 * HP / (double)MaxHP;
            en_ratio = 100 * EN / (double)MaxEN;
            u = OtherForm(new_form);
            u.Status = Status;
            if (Status != "破棄")
            {
                Status = "他形態";
            }

            // 制御不可能な形態から元に戻る場合は暴走を解除
            if (IsFeatureAvailable("制御不可"))
            {
                if (IsConditionSatisfied("暴走"))
                {
                    DeleteCondition("暴走");
                }
            }

            // 元の形態に戻る？
            if ((GeneralLib.LIndex(FeatureData("ノーマルモード"), 1) ?? "") == (new_form ?? ""))
            {
                if (IsConditionSatisfied("ノーマルモード付加"))
                {
                    // 変身が解ける場合
                    if (!string.IsNullOrEmpty(Map.MapFileName))
                    {
                        var loopTo = GeneralLib.LLength(FeatureData("ノーマルモード"));
                        for (i = 2; i <= loopTo; i++)
                        {
                            switch (GeneralLib.LIndex(FeatureData("ノーマルモード"), i) ?? "")
                            {
                                case "消耗あり":
                                    {
                                        AddCondition("消耗", 1, cdata: "");
                                        break;
                                    }

                                case "気力低下":
                                    {
                                        IncreaseMorale(-10);
                                        break;
                                    }
                            }
                        }
                    }

                    DeleteCondition("ノーマルモード付加");
                    if (IsConditionSatisfied("能力コピー"))
                    {
                        DeleteCondition("能力コピー");
                        DeleteCondition("パイロット画像");
                        DeleteCondition("メッセージ");
                    }
                }
                // ハイパーモードが解ける場合
                else if (!string.IsNullOrEmpty(Map.MapFileName))
                {
                    AddCondition("消耗", 1, cdata: "");
                    var loopTo1 = GeneralLib.LLength(FeatureData("ノーマルモード"));
                    for (i = 2; i <= loopTo1; i++)
                    {
                        switch (GeneralLib.LIndex(FeatureData("ノーマルモード"), i) ?? "")
                        {
                            case "消耗なし":
                                {
                                    DeleteCondition("消耗");
                                    break;
                                }

                            case "気力低下":
                                {
                                    IncreaseMorale(-10);
                                    break;
                                }
                        }
                    }
                }

                if (IsConditionSatisfied("残り時間"))
                {
                    DeleteCondition("残り時間");
                }
            }

            // 戦闘アニメで変更されたユニット画像を元に戻す
            if (IsConditionSatisfied("ユニット画像"))
            {
                DeleteCondition("ユニット画像");
                BitmapID = GUI.MakeUnitBitmap(this);
            }

            if (IsConditionSatisfied("非表示付加"))
            {
                DeleteCondition("非表示付加");
                BitmapID = GUI.MakeUnitBitmap(this);
            }

            int counter;
            {
                var withBlock = u;
                // パラメータ受け継ぎ
                withBlock.BossRank = BossRank;
                withBlock.Rank = Rank;
                withBlock.Mode = Mode;
                withBlock.Area = Area;
                withBlock.UsedSupportAttack = UsedSupportAttack;
                withBlock.UsedSupportGuard = UsedSupportGuard;
                withBlock.UsedSyncAttack = UsedSyncAttack;
                withBlock.UsedCounterAttack = UsedCounterAttack;
                withBlock.Master = Master;
                // UPGRADE_NOTE: オブジェクト Master をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                Master = null;
                withBlock.Summoner = Summoner;
                // UPGRADE_NOTE: オブジェクト Summoner をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                Summoner = null;

                // アイテム受け継ぎ
                var loopTo2 = CountItem();
                for (i = 1; i <= loopTo2; i++)
                {
                    Item localItem() { object argIndex1 = i; var ret = Item(argIndex1); return ret; }

                    withBlock.AddItem0(localItem());
                }

                // スペシャルパワー効果のコピー
                CopySpecialPowerInEffect(u);
                RemoveAllSpecialPowerInEffect();

                // 特殊ステータスのコピー
                var loopTo3 = withBlock.CountCondition();
                for (i = 1; i <= loopTo3; i++)
                {
                    withBlock.DeleteCondition0(1);
                }

                var loopTo4 = CountCondition();
                for (i = 1; i <= loopTo4; i++)
                {
                    int localConditionLifetime1() { object argIndex1 = i; var ret = ConditionLifetime(argIndex1); return ret; }

                    string localConditionData1() { object argIndex1 = i; var ret = ConditionData(argIndex1); return ret; }

                    string localConditionData2() { object argIndex1 = i; var ret = ConditionData(argIndex1); return ret; }

                    if (localConditionLifetime1() != 0 && Strings.InStr(localConditionData1(), "パイロット能力付加") == 0 && Strings.InStr(localConditionData2(), "パイロット能力強化") == 0)
                    {
                        string localCondition() { object argIndex1 = i; var ret = Condition(argIndex1); return ret; }

                        int localConditionLifetime() { object argIndex1 = i; var ret = ConditionLifetime(argIndex1); return ret; }

                        double localConditionLevel() { object argIndex1 = i; var ret = ConditionLevel(argIndex1); return ret; }

                        string localConditionData() { object argIndex1 = i; var ret = ConditionData(argIndex1); return ret; }

                        withBlock.AddCondition(localCondition(), localConditionLifetime(), localConditionLevel(), localConditionData());
                    }
                }

                var loopTo5 = CountCondition();
                for (i = 1; i <= loopTo5; i++)
                {
                    DeleteCondition0(1);
                }

                // パイロットの乗せ換え
                list = FeatureData("変形");
                if (GeneralLib.LLength(list) > 0 && Data.PilotNum == -GeneralLib.LLength(list) && CountPilot() == GeneralLib.LLength(list))
                {
                    // 変形によりパイロットの順番が変化する場合
                    var loopTo6 = GeneralLib.LLength(list);
                    for (idx = 2; idx <= loopTo6; idx++)
                    {
                        if ((withBlock.Name ?? "") == (GeneralLib.LIndex(list, idx) ?? ""))
                        {
                            break;
                        }
                    }

                    if (idx <= GeneralLib.LLength(list))
                    {
                        list = withBlock.FeatureData("変形");
                        var loopTo7 = GeneralLib.LLength(list);
                        for (idx2 = 2; idx2 <= loopTo7; idx2++)
                        {
                            buf = GeneralLib.LIndex(list, idx2);
                            if ((Name ?? "") == (buf ?? ""))
                            {
                                break;
                            }
                        }

                        j = 2;
                        var loopTo8 = CountPilot();
                        for (i = 1; i <= loopTo8; i++)
                        {
                            switch (i)
                            {
                                case 1:
                                    {
                                        Pilot localPilot() { object argIndex1 = idx; var ret = Pilot(argIndex1); return ret; }

                                        withBlock.AddPilot(localPilot());
                                        break;
                                    }

                                case var @case when @case == idx2:
                                    {
                                        withBlock.AddPilot(Pilot(1));
                                        break;
                                    }

                                default:
                                    {
                                        if (idx == j)
                                        {
                                            j = (j + 1);
                                        }

                                        Pilot localPilot1() { object argIndex1 = j; var ret = Pilot(argIndex1); return ret; }

                                        withBlock.AddPilot(localPilot1());
                                        j = (j + 1);
                                        break;
                                    }
                            }
                        }
                    }
                    else
                    {
                        var loopTo9 = CountPilot();
                        for (i = 1; i <= loopTo9; i++)
                        {
                            Pilot localPilot2() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                            withBlock.AddPilot(localPilot2());
                        }
                    }
                }
                else
                {
                    var loopTo10 = CountPilot();
                    for (i = 1; i <= loopTo10; i++)
                    {
                        Pilot localPilot3() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                        withBlock.AddPilot(localPilot3());
                    }
                }

                var loopTo11 = CountSupport();
                for (i = 1; i <= loopTo11; i++)
                {
                    Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                    withBlock.AddSupport(localSupport());
                }

                var loopTo12 = CountUnitOnBoard();
                for (i = 1; i <= loopTo12; i++)
                {
                    Unit localUnitOnBoard() { object argIndex1 = i; var ret = UnitOnBoard(argIndex1); return ret; }

                    withBlock.LoadUnit(localUnitOnBoard());
                }

                var loopTo13 = CountServant();
                for (i = 1; i <= loopTo13; i++)
                {
                    Unit localServant() { object argIndex1 = i; var ret = Servant(argIndex1); return ret; }

                    withBlock.AddServant(localServant());
                }

                var loopTo14 = CountSlave();
                for (i = 1; i <= loopTo14; i++)
                {
                    Unit localSlave() { object argIndex1 = i; var ret = Slave(argIndex1); return ret; }

                    withBlock.AddSlave(localSlave());
                }

                var loopTo15 = CountPilot();
                for (i = 1; i <= loopTo15; i++)
                {
                    DeletePilot(1);
                }

                var loopTo16 = CountSupport();
                for (i = 1; i <= loopTo16; i++)
                {
                    DeleteSupport(1);
                }

                var loopTo17 = CountUnitOnBoard();
                for (i = 1; i <= loopTo17; i++)
                {
                    UnloadUnit(1);
                }

                var loopTo18 = CountServant();
                for (i = 1; i <= loopTo18; i++)
                {
                    DeleteServant(1);
                }

                var loopTo19 = CountSlave();
                for (i = 1; i <= loopTo19; i++)
                {
                    DeleteSlave(1);
                }

                var loopTo20 = withBlock.CountPilot();
                for (i = 1; i <= loopTo20; i++)
                {
                    Pilot localPilot4() { object argIndex1 = i; var ret = withBlock.Pilot(argIndex1); return ret; }

                    localPilot4().Unit = u;
                }

                var loopTo21 = withBlock.CountSupport();
                for (i = 1; i <= loopTo21; i++)
                {
                    Pilot localSupport1() { object argIndex1 = i; var ret = withBlock.Support(argIndex1); return ret; }

                    localSupport1().Unit = u;
                    Pilot localSupport4() { object argIndex1 = i; var ret = withBlock.Support(argIndex1); return ret; }

                    if (localSupport4().SupportIndex > 0)
                    {
                        if (IsFeatureAvailable("分離") && withBlock.IsFeatureAvailable("分離"))
                        {
                            var loopTo22 = GeneralLib.LLength(withBlock.FeatureData("分離"));
                            for (j = 2; j <= loopTo22; j++)
                            {
                                Pilot localSupport3() { object argIndex1 = i; var ret = withBlock.Support(argIndex1); return ret; }

                                string localLIndex() { object argIndex1 = "分離"; string arglist = withBlock.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, j); return ret; }

                                if ((GeneralLib.LIndex(FeatureData("分離"), (localSupport3().SupportIndex + 1)) ?? "") == (localLIndex() ?? ""))
                                {
                                    Pilot localSupport2() { object argIndex1 = i; var ret = withBlock.Support(argIndex1); return ret; }

                                    localSupport2().SupportIndex = (j - 1);
                                    break;
                                }
                            }
                        }
                    }
                }

                withBlock.Update();

                // 弾数データを記録
                wname = new string[(CountWeapon() + 1)];
                wbullet = new int[(CountWeapon() + 1)];
                wmaxbullet = new int[(CountWeapon() + 1)];
                var loopTo23 = CountWeapon();
                for (i = 1; i <= loopTo23; i++)
                {
                    wname[i] = Weapon(i).Name;
                    wbullet[i] = Bullet(i);
                    wmaxbullet[i] = MaxBullet(i);
                }

                aname = new string[(CountAbility() + 1)];
                astock = new int[(CountAbility() + 1)];
                amaxstock = new int[(CountAbility() + 1)];
                var loopTo24 = CountAbility();
                for (i = 1; i <= loopTo24; i++)
                {
                    aname[i] = Ability(i).Name;
                    astock[i] = Stock(i);
                    amaxstock[i] = MaxStock(i);
                }

                // 弾数の受け継ぎ
                idx = 1;
                var loopTo25 = withBlock.CountWeapon();
                for (i = 1; i <= loopTo25; i++)
                {
                    counter = idx;
                    var loopTo26 = Information.UBound(wname);
                    for (j = counter; j <= loopTo26; j++)
                    {
                        if ((withBlock.Weapon(i).Name ?? "") == (wname[j] ?? "") && withBlock.MaxBullet(i) > 0 && wmaxbullet[j] > 0)
                        {
                            withBlock.SetBullet(i, ((wbullet[j] * withBlock.MaxBullet(i)) / wmaxbullet[j]));
                            idx = (j + 1);
                            break;
                        }
                    }
                }

                idx = 1;
                var loopTo27 = withBlock.CountAbility();
                for (i = 1; i <= loopTo27; i++)
                {
                    counter = idx;
                    var loopTo28 = Information.UBound(aname);
                    for (j = counter; j <= loopTo28; j++)
                    {
                        if ((withBlock.Ability(i).Name ?? "") == (aname[j] ?? "") && withBlock.MaxStock(i) > 0 && amaxstock[j] > 0)
                        {
                            withBlock.SetStock(i, ((astock[j] * withBlock.MaxStock(i)) / amaxstock[j]));
                            idx = (j + 1);
                            break;
                        }
                    }
                }

                // 弾数・使用回数共有の実現
                withBlock.SyncBullet();

                // アイテムを削除
                var loopTo29 = CountItem();
                for (i = 1; i <= loopTo29; i++)
                {
                    DeleteItem(1);
                }

                withBlock.Update();

                // ＨＰ＆ＥＮの受け継ぎ
                string localLIndex1() { object argIndex1 = "パーツ分離"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                if ((new_form ?? "") == (localLIndex1() ?? ""))
                {
                    withBlock.HP = withBlock.MaxHP;
                }
                else
                {
                    withBlock.HP = (withBlock.MaxHP * hp_ratio / 100d);
                }

                withBlock.EN = (withBlock.MaxEN * en_ratio / 100d);

                // ノーマルモードや制限時間つきの形態の場合は残り時間を付加
                if (!withBlock.IsConditionSatisfied("残り時間"))
                {
                    if (withBlock.IsFeatureAvailable("ノーマルモード"))
                    {
                        string localLIndex4() { object argIndex1 = "ノーマルモード"; string arglist = withBlock.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                        if (Information.IsNumeric(localLIndex4()))
                        {
                            if (withBlock.IsConditionSatisfied("残り時間"))
                            {
                                withBlock.DeleteCondition("残り時間");
                            }

                            string localLIndex2() { object argIndex1 = "ノーマルモード"; string arglist = withBlock.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                            string localLIndex3() { object argIndex1 = "ノーマルモード"; string arglist = withBlock.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                            withBlock.AddCondition("残り時間", Conversions.Toint(localLIndex3()), cdata: "");
                        }
                    }
                    else if (withBlock.IsFeatureAvailable("制限時間"))
                    {
                        withBlock.AddCondition("残り時間", Conversions.Toint(withBlock.FeatureData("制限時間")), cdata: "");
                    }
                }
                else if (!withBlock.IsFeatureAvailable("ノーマルモード") && !withBlock.IsFeatureAvailable("制限時間"))
                {
                    // 残り時間が必要ない形態にTransformコマンドで強制変形された？
                    withBlock.DeleteCondition("残り時間");
                }

                switch (withBlock.Status ?? "")
                {
                    case "出撃":
                        {
                            // 変形後のユニットを出撃させる
                            // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                            Map.MapDataForUnit[x, y] = null;
                            prev_x = x;
                            prev_y = y;
                            withBlock.UsedAction = UsedAction;
                            withBlock.StandBy(x, y);
                            if (withBlock.x != prev_x || withBlock.y != prev_y)
                            {
                                GUI.EraseUnitBitmap(prev_x, prev_y, false);
                            }

                            break;
                        }

                    case "格納":
                        {
                            // 変形後のユニットを格納する
                            foreach (Unit eu in SRC.UList)
                            {
                                var loopTo30 = eu.CountUnitOnBoard();
                                for (j = 1; j <= loopTo30; j++)
                                {
                                    Unit localUnitOnBoard1() { object argIndex1 = j; var ret = eu.UnitOnBoard(argIndex1); return ret; }

                                    if ((ID ?? "") == (localUnitOnBoard1().ID ?? ""))
                                    {
                                        eu.UnloadUnit(ID);
                                        eu.LoadUnit(u);
                                        goto EndLoop;
                                    }
                                }
                            }

                            EndLoop:
                            ;
                            break;
                        }
                }
            }

            if (string.IsNullOrEmpty(Map.MapFileName))
            {
                return;
            }

            // ハイパーモードが解ける場合
            buf = FeatureData("ノーマルモード");
            if ((GeneralLib.LIndex(buf, 1) ?? "") == (new_form ?? ""))
            {
                var loopTo31 = GeneralLib.LLength(buf);
                for (i = 2; i <= loopTo31; i++)
                {
                    switch (GeneralLib.LIndex(buf, i) ?? "")
                    {
                        case "回数制限":
                            {
                                AddCondition("行動不能", -1, cdata: "");
                                break;
                            }
                    }
                }
            }
        }

        // 合体
        public void Combine([Optional, DefaultParameterValue("")] string uname, bool is_event = false)
        {
            int k, i, j, l;
            Unit u;
            Unit[] rarray;
            string prev_status;
            double hp_ratio = default, en_ratio = default;
            string fdata;
            prev_status = Status;
            if (string.IsNullOrEmpty(uname))
            {
                // 合体形態が指定されてなければその場所にいるユニットと２体合体
                // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                u = null;
                var loopTo = CountFeature();
                for (i = 1; i <= loopTo; i++)
                {
                    if (Feature(i) == "合体")
                    {
                        fdata = FeatureData(i);
                        bool localIsDefined() { object argIndex1 = GeneralLib.LIndex(fdata, 2); var ret = SRC.UList.IsDefined(argIndex1); return ret; }

                        if (GeneralLib.LLength(fdata) == 3 && Map.MapDataForUnit[x, y].Name == GeneralLib.LIndex(fdata, 3) && localIsDefined())
                        {
                            string localFeatureData() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            string localLIndex() { string arglist = hs81b489053b0047fb8fab2715d76f0b3f(); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                            Unit localItem() { object argIndex1 = (object)hse7677c879f2b418e8dbb67c5dad5db85(); var ret = SRC.UList.Item(argIndex1); return ret; }

                            u = localItem().CurrentForm();
                            break;
                        }
                    }
                }

                if (u is null)
                {
                    var loopTo1 = CountFeature();
                    for (i = 1; i <= loopTo1; i++)
                    {
                        if (Feature(i) == "合体")
                        {
                            fdata = FeatureData(i);
                            bool localIsDefined1() { object argIndex1 = GeneralLib.LIndex(fdata, 2); var ret = SRC.UList.IsDefined(argIndex1); return ret; }

                            if (GeneralLib.LLength(fdata) == 3 && Map.MapDataForUnit[x, y].IsEqual(GeneralLib.LIndex(fdata, 3)) && localIsDefined1())
                            {
                                Unit localItem1() { object argIndex1 = GeneralLib.LIndex(fdata, 2); var ret = SRC.UList.Item(argIndex1); return ret; }

                                u = localItem1().CurrentForm();
                                break;
                            }
                        }
                    }
                }

                // 合体のパートナーを調べる
                var loopTo2 = u.CountFeature();
                for (i = 1; i <= loopTo2; i++)
                {
                    string localFeature() { object argIndex1 = i; var ret = u.Feature(argIndex1); return ret; }

                    string localFeatureData1() { object argIndex1 = i; var ret = u.FeatureData(argIndex1); return ret; }

                    int localLLength() { string arglist = hs51faf446da8e4981a1c2f1fe759168f4(); var ret = GeneralLib.LLength(arglist); return ret; }

                    string localFeatureData2() { object argIndex1 = i; var ret = u.FeatureData(argIndex1); return ret; }

                    string localLIndex1() { string arglist = hsb077af4743da47379ef57233cdc6fa2e(); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                    string localFeatureData3() { object argIndex1 = i; var ret = u.FeatureData(argIndex1); return ret; }

                    string localLIndex2() { string arglist = hs35a57c94693d489ca95b1b6c02b7f584(); var ret = GeneralLib.LIndex(arglist, 3); return ret; }

                    string localFeatureData4() { object argIndex1 = i; var ret = u.FeatureData(argIndex1); return ret; }

                    string localLIndex3() { string arglist = hscc5ae77b155c4db6b72a8ff201c4d383(); var ret = GeneralLib.LIndex(arglist, 3); return ret; }

                    string localFeatureData5() { object argIndex1 = i; var ret = u.FeatureData(argIndex1); return ret; }

                    string localLIndex4() { string arglist = hs55605004ddf144379941d1bb4dbdc993(); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                    if (localFeature() == "分離" && localLLength() == 3 && (IsEqual(localLIndex1()) && Map.MapDataForUnit[x, y].IsEqual(localLIndex2()) || IsEqual(localLIndex3()) && Map.MapDataForUnit[x, y].IsEqual(localLIndex4())))
                    {
                        break;
                    }
                }
            }
            else
            {
                // 合体ユニットが作成されていない
                bool localIsDefined2() { object argIndex1 = uname; var ret = SRC.UList.IsDefined(argIndex1); return ret; }

                if (!localIsDefined2())
                {
                    GUI.ErrorMessage(uname + "が作成されていません");
                    SRC.ExitGame();
                }

                Unit localItem2() { object argIndex1 = uname; var ret = SRC.UList.Item(argIndex1); return ret; }

                u = localItem2().CurrentForm();

                // 合体のパートナーを調べる
                var loopTo3 = u.CountFeature();
                for (i = 1; i <= loopTo3; i++)
                {
                    string localFeature1() { object argIndex1 = i; var ret = u.Feature(argIndex1); return ret; }

                    string localFeatureData6() { object argIndex1 = i; var ret = u.FeatureData(argIndex1); return ret; }

                    int localLLength1() { string arglist = hs19d13409c3c14abeb6633b778b53f517(); var ret = GeneralLib.LLength(arglist); return ret; }

                    if (localFeature1() == "分離" && localLLength1() > 2)
                    {
                        break;
                    }
                }
            }

            // 合体するユニットの配列を作成
            if (i > u.CountFeature())
            {
                GUI.ErrorMessage(u.Name + "のデータに" + Name + "に対する分離指定がみつかりません。" + "書式を確認してください。");
                return;
            }

            string localFeatureData7() { object argIndex1 = i; var ret = u.FeatureData(argIndex1); return ret; }

            int localLLength2() { string arglist = hs7e9583a3d5b64b0e89ed2b453203ed96(); var ret = GeneralLib.LLength(arglist); return ret; }

            rarray = new Unit[(localLLength2())];
            var loopTo4 = Information.UBound(rarray);
            for (j = 1; j <= loopTo4; j++)
            {
                string localFeatureData9() { object argIndex1 = i; var ret = u.FeatureData(argIndex1); return ret; }

                string localLIndex6() { string arglist = hsdde5a2bab5114fb984e607877f33a598(); var ret = GeneralLib.LIndex(arglist, (j + 1)); return ret; }

                bool localIsDefined3() { object argIndex1 = (object)hs864ff7ed86044dd6afb3abdbc02521a4(); var ret = SRC.UList.IsDefined(argIndex1); return ret; }

                if (!localIsDefined3())
                {
                    string localFeatureData8() { object argIndex1 = i; var ret = u.FeatureData(argIndex1); return ret; }

                    string localLIndex5() { string arglist = hsd9f70e51b07d4e9fa7669aca81ec510a(); var ret = GeneralLib.LIndex(arglist, (j + 1)); return ret; }

                    GUI.ErrorMessage(localLIndex5() + "が作成されていません");
                    return;
                }

                string localFeatureData10() { object argIndex1 = i; var ret = u.FeatureData(argIndex1); return ret; }

                string localLIndex7() { string arglist = hs00e33e973a4149d388ddb705e43ffed7(); var ret = GeneralLib.LIndex(arglist, (j + 1)); return ret; }

                rarray[j] = SRC.UList.Item(localLIndex7());
            }

            string BGM;
            if (!is_event)
            {
                if (Status == "出撃")
                {
                    // ダイアログでメッセージを表示させるため追加パイロットをあらかじめ作成
                    if (u.IsFeatureAvailable("追加パイロット"))
                    {
                        bool localIsDefined5() { object argIndex1 = "追加パイロット"; object argIndex2 = u.FeatureData(argIndex1); var ret = SRC.PList.IsDefined(argIndex2); return ret; }

                        if (!localIsDefined5())
                        {
                            bool localIsDefined4() { object argIndex1 = "追加パイロット"; object argIndex2 = u.FeatureData(argIndex1); var ret = SRC.PDList.IsDefined(argIndex2); return ret; }

                            if (!localIsDefined4())
                            {
                                GUI.ErrorMessage(u.Name + "の追加パイロット「" + u.FeatureData("追加パイロット") + "」のデータが見つかりません");
                                SRC.TerminateSRC();
                            }

                            SRC.PList.Add(u.FeatureData("追加パイロット"), MainPilot().Level, Party0, gid: "");
                            this.Party0 = argpparty;
                        }
                    }

                    bool localIsMessageDefined1() { string argmain_situation = "合体(" + u.Name + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                    bool localIsMessageDefined2() { object argIndex1 = "合体"; string argmain_situation = "合体(" + FeatureName(argIndex1) + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                    if (localIsMessageDefined1() || localIsMessageDefined2() || IsMessageDefined("合体"))
                    {
                        if (IsFeatureAvailable("合体ＢＧＭ"))
                        {
                            var loopTo5 = CountFeature();
                            for (i = 1; i <= loopTo5; i++)
                            {
                                string localFeature2() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                                string localFeatureData13() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                                string localLIndex8() { string arglist = hs8b8df815445f4c329f8d70f276cd46e5(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                                if (localFeature2() == "合体ＢＧＭ" && (localLIndex8() ?? "") == (u.Name ?? ""))
                                {
                                    string localFeatureData11() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                                    string localFeatureData12() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                                    BGM = Sound.SearchMidiFile(Strings.Mid(localFeatureData11(), Strings.InStr(localFeatureData12(), " ") + 1));
                                    if (Strings.Len(BGM) > 0)
                                    {
                                        Sound.ChangeBGM(BGM);
                                        GUI.Sleep(500);
                                    }

                                    break;
                                }
                            }
                        }

                        GUI.OpenMessageForm(u1: null, u2: null);
                        bool localIsMessageDefined() { object argIndex1 = "合体"; string argmain_situation = "合体(" + FeatureName(argIndex1) + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                        if (IsMessageDefined("合体(" + u.Name + ")"))
                        {
                            PilotMessage("合体(" + u.Name + ")", msg_mode: "");
                        }
                        else if (localIsMessageDefined())
                        {
                            PilotMessage("合体(" + FeatureName("合体") + ")", msg_mode: "");
                        }
                        else
                        {
                            PilotMessage("合体", msg_mode: "");
                        }

                        GUI.CloseMessageForm();
                    }
                }
            }

            // 分離ユニットと合体ユニットが同名の武器を持つ場合は弾数を累積するため
            // このような武器の弾数を0にする
            var loopTo6 = u.CountWeapon();
            for (i = 1; i <= loopTo6; i++)
            {
                var loopTo7 = Information.UBound(rarray);
                for (j = 1; j <= loopTo7; j++)
                {
                    {
                        var withBlock = rarray[j].CurrentForm();
                        var loopTo8 = withBlock.CountWeapon();
                        for (k = 1; k <= loopTo8; k++)
                        {
                            if ((u.Weapon(i).Name ?? "") == (withBlock.Weapon(k).Name ?? ""))
                            {
                                u.SetBullet(i, 0);
                                break;
                            }
                        }
                    }
                }
            }
            // 使用回数を合わせる
            var loopTo9 = u.CountAbility();
            for (i = 1; i <= loopTo9; i++)
            {
                var loopTo10 = Information.UBound(rarray);
                for (j = 1; j <= loopTo10; j++)
                {
                    {
                        var withBlock1 = rarray[j].CurrentForm();
                        var loopTo11 = withBlock1.CountAbility();
                        for (k = 1; k <= loopTo11; k++)
                        {
                            if ((u.Ability(i).Name ?? "") == (withBlock1.Ability(k).Name ?? ""))
                            {
                                u.SetStock(i, 0);
                                break;
                            }
                        }
                    }
                }
            }

            // １番目のユニットのステータスを合体後のユニットに継承
            {
                var withBlock2 = rarray[1].CurrentForm();
                withBlock2.CopySpecialPowerInEffect(u);
                withBlock2.RemoveAllSpecialPowerInEffect();
                var loopTo12 = withBlock2.CountItem();
                for (i = 1; i <= loopTo12; i++)
                {
                    Item localItem3() { object argIndex1 = i; var ret = withBlock2.Item(argIndex1); return ret; }

                    u.AddItem(localItem3());
                }

                u.Master = withBlock2.Master;
                // UPGRADE_NOTE: オブジェクト rarray().CurrentForm.Master をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                withBlock2.Master = null;
                u.Summoner = withBlock2.Summoner;
                // UPGRADE_NOTE: オブジェクト rarray().CurrentForm.Summoner をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                withBlock2.Summoner = null;
                u.UsedSupportAttack = withBlock2.UsedSupportAttack;
                u.UsedSupportGuard = withBlock2.UsedSupportGuard;
                u.UsedSyncAttack = withBlock2.UsedSyncAttack;
                u.UsedCounterAttack = withBlock2.UsedCounterAttack;
                var loopTo13 = withBlock2.CountServant();
                for (i = 1; i <= loopTo13; i++)
                {
                    Unit localServant() { object argIndex1 = i; var ret = withBlock2.Servant(argIndex1); return ret; }

                    u.AddServant(localServant());
                }

                var loopTo14 = withBlock2.CountServant();
                for (i = 1; i <= loopTo14; i++)
                {
                    withBlock2.DeleteServant(1);
                }

                var loopTo15 = withBlock2.CountSlave();
                for (i = 1; i <= loopTo15; i++)
                {
                    Unit localSlave() { object argIndex1 = i; var ret = withBlock2.Slave(argIndex1); return ret; }

                    u.AddSlave(localSlave());
                }

                var loopTo16 = withBlock2.CountSlave();
                for (i = 1; i <= loopTo16; i++)
                {
                    withBlock2.DeleteSlave(1);
                }

                // 合体する各ユニットに対しての処理を行う
            }

            var loopTo17 = Information.UBound(rarray);
            for (i = 1; i <= loopTo17; i++)
            {
                // マップ上から撤退させる
                {
                    var withBlock3 = rarray[i].CurrentForm();
                    switch (withBlock3.Status ?? "")
                    {
                        case "出撃":
                            {
                                withBlock3.Status = "待機";
                                // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                Map.MapDataForUnit[withBlock3.x, withBlock3.y] = null;
                                GUI.EraseUnitBitmap(withBlock3.x, withBlock3.y);
                                break;
                            }

                        case "格納":
                            {
                                withBlock3.Status = "待機";
                                foreach (Unit eu in SRC.UList)
                                {
                                    var loopTo18 = eu.CountUnitOnBoard();
                                    for (j = 1; j <= loopTo18; j++)
                                    {
                                        Unit localUnitOnBoard() { object argIndex1 = j; var ret = eu.UnitOnBoard(argIndex1); return ret; }

                                        if ((withBlock3.ID ?? "") == (localUnitOnBoard().ID ?? ""))
                                        {
                                            eu.UnloadUnit(withBlock3.ID);
                                            goto EndLoop;
                                        }
                                    }
                                }

                                EndLoop:
                                ;
                                break;
                            }
                    }
                }

                // デフォルトの形態に変形させておく
                if (!ReferenceEquals(rarray[i].CurrentForm(), rarray[i]))
                {
                    rarray[i].CurrentForm().Transform(rarray[i].Name);
                    rarray[i].Name = argnew_form;
                }

                {
                    var withBlock4 = rarray[i];
                    if (i == 1)
                    {
                        withBlock4.Status = "旧主形態";
                    }
                    else
                    {
                        withBlock4.Status = "旧形態";
                    }

                    hp_ratio = hp_ratio + 100 * withBlock4.HP / (double)withBlock4.MaxHP;
                    en_ratio = en_ratio + 100 * withBlock4.EN / (double)withBlock4.MaxEN;
                    if (withBlock4.Rank > u.Rank)
                    {
                        u.Rank = withBlock4.Rank;
                    }

                    if (withBlock4.BossRank > u.BossRank)
                    {
                        u.BossRank = withBlock4.BossRank;
                        u.FullRecover();
                    }

                    if (withBlock4.IsFeatureAvailable("召喚ユニット"))
                    {
                        // 召喚ユニットの場合はパイロットの乗せ換えは行わない
                        if (Strings.InStr(withBlock4.MainPilot().Name, "(ザコ)") > 0 || Strings.InStr(withBlock4.MainPilot().Name, "(汎用)") > 0)
                        {
                            // 汎用パイロットの場合は削除
                            withBlock4.MainPilot().Alive = false;
                        }
                    }
                    else
                    {
                        // パイロットの乗せ換え
                        var loopTo19 = withBlock4.CountPilot();
                        for (j = 1; j <= loopTo19; j++)
                        {
                            Pilot localPilot() { object argIndex1 = j; var ret = withBlock4.Pilot(argIndex1); return ret; }

                            localPilot().Ride(u);
                        }

                        var loopTo20 = withBlock4.CountPilot();
                        for (j = 1; j <= loopTo20; j++)
                        {
                            withBlock4.DeletePilot(1);
                        }

                        // サポートの乗せ換え
                        var loopTo21 = withBlock4.CountSupport();
                        for (j = 1; j <= loopTo21; j++)
                        {
                            Pilot localSupport() { object argIndex1 = j; var ret = withBlock4.Support(argIndex1); return ret; }

                            localSupport().Ride(u, true);
                            Pilot localSupport1() { object argIndex1 = j; var ret = withBlock4.Support(argIndex1); return ret; }

                            localSupport1().SupportIndex = i;
                        }

                        var loopTo22 = withBlock4.CountSupport();
                        for (j = 1; j <= loopTo22; j++)
                        {
                            withBlock4.DeleteSupport(1);
                        }
                    }

                    // 搭載ユニットの乗せ換え
                    var loopTo23 = withBlock4.CountUnitOnBoard();
                    for (j = 1; j <= loopTo23; j++)
                    {
                        Unit localUnitOnBoard1() { object argIndex1 = j; var ret = withBlock4.UnitOnBoard(argIndex1); return ret; }

                        u.LoadUnit(localUnitOnBoard1());
                    }

                    var loopTo24 = u.CountUnitOnBoard();
                    for (j = 1; j <= loopTo24; j++)
                    {
                        withBlock4.UnloadUnit(1);
                    }

                    // 分離ユニットと共通する武装の弾数は一旦0にクリア
                    var loopTo25 = u.CountWeapon();
                    for (j = 1; j <= loopTo25; j++)
                    {
                        var loopTo26 = withBlock4.CountWeapon();
                        for (k = 1; k <= loopTo26; k++)
                        {
                            if ((u.Weapon(j).Name ?? "") == (withBlock4.Weapon(k).Name ?? ""))
                            {
                                u.SetBullet(j, 0);
                                break;
                            }
                        }

                        var loopTo27 = withBlock4.CountOtherForm();
                        for (k = 1; k <= loopTo27; k++)
                        {
                            {
                                var withBlock5 = withBlock4.OtherForm(k);
                                var loopTo28 = withBlock5.CountWeapon();
                                for (l = 1; l <= loopTo28; l++)
                                {
                                    if ((u.Weapon(j).Name ?? "") == (withBlock5.Weapon(l).Name ?? ""))
                                    {
                                        u.SetBullet(j, 0);
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // アビリティの使用回数も同様の処理を行う
                    var loopTo29 = u.CountAbility();
                    for (j = 1; j <= loopTo29; j++)
                    {
                        var loopTo30 = withBlock4.CountAbility();
                        for (k = 1; k <= loopTo30; k++)
                        {
                            if ((u.Ability(j).Name ?? "") == (withBlock4.Ability(k).Name ?? ""))
                            {
                                u.SetStock(j, 0);
                                break;
                            }
                        }

                        var loopTo31 = withBlock4.CountOtherForm();
                        for (k = 1; k <= loopTo31; k++)
                        {
                            {
                                var withBlock6 = withBlock4.OtherForm(k);
                                var loopTo32 = withBlock6.CountAbility();
                                for (l = 1; l <= loopTo32; l++)
                                {
                                    if ((u.Ability(j).Name ?? "") == (withBlock6.Ability(l).Name ?? ""))
                                    {
                                        u.SetStock(j, 0);
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // スペシャルパワーの効果を消去
                    withBlock4.RemoveAllSpecialPowerInEffect();
                }
            }

            // 合体後のユニットの武装の弾数及びアビリティの使用回数は分離ユニットの
            // 弾数及び使用回数の合計に設定する
            var loopTo33 = Information.UBound(rarray);
            for (i = 1; i <= loopTo33; i++)
            {
                {
                    var withBlock7 = rarray[i];
                    // 武装の弾数の処理
                    var loopTo34 = u.CountWeapon();
                    for (j = 1; j <= loopTo34; j++)
                    {
                        var loopTo35 = withBlock7.CountWeapon();
                        for (k = 1; k <= loopTo35; k++)
                        {
                            if ((u.Weapon(j).Name ?? "") == (withBlock7.Weapon(k).Name ?? ""))
                            {
                                u.SetBullet(j, (u.Bullet(j) + withBlock7.Bullet(k)));
                                goto NextWeapon;
                            }
                        }

                        var loopTo36 = withBlock7.CountOtherForm();
                        for (k = 1; k <= loopTo36; k++)
                        {
                            {
                                var withBlock8 = withBlock7.OtherForm(k);
                                var loopTo37 = withBlock8.CountWeapon();
                                for (l = 1; l <= loopTo37; l++)
                                {
                                    if ((u.Weapon(j).Name ?? "") == (withBlock8.Weapon(l).Name ?? ""))
                                    {
                                        u.SetBullet(j, (u.Bullet(j) + withBlock8.Bullet(l)));
                                        goto NextWeapon;
                                    }
                                }
                            }
                        }

                        NextWeapon:
                        ;
                    }

                    // アビリティの使用回数の処理
                    var loopTo38 = u.CountAbility();
                    for (j = 1; j <= loopTo38; j++)
                    {
                        var loopTo39 = withBlock7.CountAbility();
                        for (k = 1; k <= loopTo39; k++)
                        {
                            if ((u.Ability(j).Name ?? "") == (withBlock7.Ability(k).Name ?? ""))
                            {
                                u.SetStock(j, (u.Stock(j) + withBlock7.Stock(k)));
                                goto NextAbility;
                            }
                        }

                        var loopTo40 = withBlock7.CountOtherForm();
                        for (k = 1; k <= loopTo40; k++)
                        {
                            {
                                var withBlock9 = withBlock7.OtherForm(k);
                                var loopTo41 = withBlock9.CountAbility();
                                for (l = 1; l <= loopTo41; l++)
                                {
                                    if ((u.Ability(j).Name ?? "") == (withBlock9.Ability(l).Name ?? ""))
                                    {
                                        u.SetStock(j, (u.Stock(j) + withBlock9.Stock(l)));
                                        goto NextAbility;
                                    }
                                }
                            }
                        }

                        NextAbility:
                        ;
                    }
                }
            }

            // １番目のユニットのアイテムを外す
            {
                var withBlock10 = rarray[1];
                var loopTo42 = withBlock10.CountItem();
                for (i = 1; i <= loopTo42; i++)
                {
                    withBlock10.DeleteItem(1);
                }
            }

            // 合体後のユニットに関する処理
            u.Update();
            u.Party = Party0;
            var loopTo43 = u.CountOtherForm();
            for (i = 1; i <= loopTo43; i++)
            {
                Unit localOtherForm() { object argIndex1 = i; var ret = u.OtherForm(argIndex1); return ret; }

                localOtherForm().Party = Party0;
            }

            var loopTo44 = u.CountPilot();
            for (i = 1; i <= loopTo44; i++)
            {
                Pilot localPilot1() { object argIndex1 = i; var ret = u.Pilot(argIndex1); return ret; }

                localPilot1().Party = Party0;
            }

            var loopTo45 = u.CountSupport();
            for (i = 1; i <= loopTo45; i++)
            {
                Pilot localSupport2() { object argIndex1 = i; var ret = u.Support(argIndex1); return ret; }

                localSupport2().Party = Party0;
            }

            u.HP = (u.MaxHP * hp_ratio / 100d / Information.UBound(rarray));
            u.EN = (1 * u.MaxEN * en_ratio / 100d / Information.UBound(rarray));

            // 弾数・使用回数共有の実現
            u.SyncBullet();
            if (prev_status == "出撃")
            {
                u.StandBy(x, y);

                // ノーマルモードや制限時間つきの形態の場合は残り時間を付加
                if (u.IsFeatureAvailable("ノーマルモード"))
                {
                    string localLIndex11() { object argIndex1 = "ノーマルモード"; string arglist = u.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                    if (Information.IsNumeric(localLIndex11()))
                    {
                        if (u.IsConditionSatisfied("残り時間"))
                        {
                            u.DeleteCondition("残り時間");
                        }

                        string localLIndex9() { object argIndex1 = "ノーマルモード"; string arglist = u.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                        string localLIndex10() { object argIndex1 = "ノーマルモード"; string arglist = u.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                        u.AddCondition("残り時間", Conversions.Toint(localLIndex10()), cdata: "");
                    }
                }
                else if (u.IsFeatureAvailable("制限時間"))
                {
                    u.AddCondition("残り時間", Conversions.Toint(u.FeatureData("制限時間")), cdata: "");
                }
            }
            else
            {
                u.Status = prev_status;
            }

            // 分離ユニットの座標を合体後のユニットの座標に合わせる
            var loopTo46 = Information.UBound(rarray);
            for (i = 1; i <= loopTo46; i++)
            {
                {
                    var withBlock11 = rarray[i].CurrentForm();
                    withBlock11.x = u.x;
                    withBlock11.y = u.y;
                }
            }
        }

        // 分離
        // UPGRADE_NOTE: Split は Split にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
        public void Split()
        {
            int k, i, j, l;
            int idx, n;
            string buf;
            Unit[] uarray;
            double hp_ratio, en_ratio;
            string pname;
            Pilot p;
            hp_ratio = 100 * HP / (double)MaxHP;
            en_ratio = 100 * EN / (double)MaxEN;

            // まずは撤退
            if (Status == "出撃")
            {
                // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                Map.MapDataForUnit[x, y] = null;
                GUI.EraseUnitBitmap(x, y);
            }

            // 分離先のユニットを調べる
            buf = FeatureData("分離");
            uarray = new Unit[(GeneralLib.LLength(buf))];
            var loopTo = GeneralLib.LLength(buf);
            for (i = 2; i <= loopTo; i++)
            {
                uarray[i - 1] = SRC.UList.Item(GeneralLib.LIndex(buf, i));
                if (uarray[i - 1] is null)
                {
                    GUI.ErrorMessage(GeneralLib.LIndex(buf, (i - 1)) + "が存在しません");
                    return;
                }
            }

            // 分離後の１番機を検索
            var loopTo1 = Information.UBound(uarray);
            for (i = 1; i <= loopTo1; i++)
            {
                if (uarray[i].Status == "旧主形態")
                {
                    break;
                }
            }

            if (i > Information.UBound(uarray))
            {
                i = 1;
            }

            // １番機に現在のステータスを継承
            CopySpecialPowerInEffect(uarray[i]);
            RemoveAllSpecialPowerInEffect();
            {
                var withBlock = uarray[i];
                var loopTo2 = CountItem();
                for (j = 1; j <= loopTo2; j++)
                {
                    Item localItem() { object argIndex1 = j; var ret = Item(argIndex1); return ret; }

                    withBlock.AddItem(localItem());
                }

                var loopTo3 = CountItem();
                for (j = 1; j <= loopTo3; j++)
                {
                    DeleteItem(1);
                }

                withBlock.Master = Master;
                // UPGRADE_NOTE: オブジェクト Master をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                Master = null;
                withBlock.Summoner = Summoner;
                // UPGRADE_NOTE: オブジェクト Summoner をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                Summoner = null;
                withBlock.UsedSupportAttack = UsedSupportAttack;
                withBlock.UsedSupportGuard = UsedSupportGuard;
                withBlock.UsedSyncAttack = UsedSyncAttack;
                withBlock.UsedCounterAttack = UsedCounterAttack;
                var loopTo4 = CountServant();
                for (j = 1; j <= loopTo4; j++)
                {
                    Unit localServant() { object argIndex1 = j; var ret = Servant(argIndex1); return ret; }

                    withBlock.AddServant(localServant());
                }

                var loopTo5 = CountServant();
                for (j = 1; j <= loopTo5; j++)
                {
                    DeleteServant(1);
                }

                var loopTo6 = CountSlave();
                for (j = 1; j <= loopTo6; j++)
                {
                    Unit localSlave() { object argIndex1 = j; var ret = Slave(argIndex1); return ret; }

                    withBlock.AddSlave(localSlave());
                }

                var loopTo7 = CountSlave();
                for (j = 1; j <= loopTo7; j++)
                {
                    DeleteSlave(1);
                }
            }

            // 各分離ユニットに対する処理
            n = 1;
            int counter;
            var loopTo8 = Information.UBound(uarray);
            for (i = 1; i <= loopTo8; i++)
            {
                {
                    var withBlock1 = uarray[i];
                    // 召喚ユニットでない場合は陣営を合わせる
                    if (!withBlock1.IsFeatureAvailable("召喚ユニット"))
                    {
                        withBlock1.Party = Party0;
                    }

                    // パイロットの搭乗
                    if (CountPilot() > 0)
                    {
                        var loopTo9 = Math.Abs(withBlock1.Data.PilotNum);
                        for (j = 1; j <= loopTo9; j++)
                        {
                            if (withBlock1.IsFeatureAvailable("召喚ユニット"))
                            {
                                if (Status == "出撃" || Status == "格納")
                                {
                                    pname = withBlock1.FeatureData("追加パイロット");
                                    PilotData localItem1() { object argIndex1 = pname; var ret = SRC.PDList.Item(argIndex1); return ret; }

                                    PilotData localItem2() { object argIndex1 = pname; var ret = SRC.PDList.Item(argIndex1); return ret; }

                                    if (Strings.InStr(localItem1().Name, "(ザコ)") > 0 || Strings.InStr(localItem2().Name, "(汎用)") > 0)
                                    {
                                        p = SRC.PList.Add(pname, MainPilot().Level, Party, gid: "");
                                        Party = argpparty;
                                        p.FullRecover();
                                    }
                                    else
                                    {
                                        bool localIsDefined() { object argIndex1 = pname; var ret = SRC.PList.IsDefined(argIndex1); return ret; }

                                        if (!localIsDefined())
                                        {
                                            p = SRC.PList.Add(pname, MainPilot().Level, Party, gid: "");
                                            Party = argpparty1;
                                            p.FullRecover();
                                        }
                                        else
                                        {
                                            p = SRC.PList.Item(pname);
                                        }
                                    }

                                    p.Ride(uarray[i]);
                                }
                            }
                            else
                            {
                                if (n <= CountPilot())
                                {
                                    Pilot localPilot() { object argIndex1 = n; var ret = Pilot(argIndex1); return ret; }

                                    localPilot().Ride(uarray[i]);
                                    n = (n + 1);
                                }
                                else if (!withBlock1.IsFeatureAvailable("追加パイロット"))
                                {
                                    if (CountSupport() > 0)
                                    {
                                        Support(1).Ride(uarray[i]);
                                        DeleteSupport(1);
                                    }
                                    else
                                    {
                                        GUI.ErrorMessage(Name + "分離後のユニットに載せる" + "パイロットが存在しません。" + "データのパイロット数を確認して下さい。");
                                        SRC.TerminateSRC();
                                    }
                                }
                            }
                        }
                    }

                    withBlock1.Update();

                    // 母艦の場合は格納したユニットを受け渡し
                    if (withBlock1.IsFeatureAvailable("母艦"))
                    {
                        var loopTo10 = CountUnitOnBoard();
                        for (j = 1; j <= loopTo10; j++)
                        {
                            Unit localUnitOnBoard() { object argIndex1 = j; var ret = UnitOnBoard(argIndex1); return ret; }

                            withBlock1.LoadUnit(localUnitOnBoard());
                        }

                        var loopTo11 = CountUnitOnBoard();
                        for (j = 1; j <= loopTo11; j++)
                        {
                            UnloadUnit(1);
                        }
                    }

                    // ＨＰ＆ＥＮの同期
                    withBlock1.HP = (withBlock1.MaxHP * hp_ratio / 100d);
                    withBlock1.EN = (1 * withBlock1.MaxEN * en_ratio / 100d);

                    // 弾数を合わせる
                    idx = 1;
                    var loopTo12 = CountWeapon();
                    for (j = 1; j <= loopTo12; j++)
                    {
                        counter = idx;
                        var loopTo13 = withBlock1.CountWeapon();
                        for (k = counter; k <= loopTo13; k++)
                        {
                            if ((Weapon(j).Name ?? "") == (withBlock1.Weapon(k).Name ?? "") && this.Weapon(j).Bullet > 0 && withBlock1.Weapon(k).Bullet > 0)
                            {
                                withBlock1.SetBullet(k, ((withBlock1.MaxBullet(k) * Bullet(j)) / MaxBullet(j)));
                                idx = (k + 1);
                                break;
                            }
                        }
                    }

                    var loopTo14 = withBlock1.CountOtherForm();
                    for (j = 1; j <= loopTo14; j++)
                    {
                        {
                            var withBlock2 = withBlock1.OtherForm(j);
                            idx = 1;
                            var loopTo15 = CountWeapon();
                            for (k = 1; k <= loopTo15; k++)
                            {
                                counter = idx;
                                var loopTo16 = withBlock2.CountWeapon();
                                for (l = counter; l <= loopTo16; l++)
                                {
                                    if ((Weapon(k).Name ?? "") == (withBlock2.Weapon(l).Name ?? "") && this.Weapon(k).Bullet > 0 && withBlock2.Weapon(l).Bullet > 0)
                                    {
                                        withBlock2.SetBullet(l, ((withBlock2.MaxBullet(l) * Bullet(k)) / MaxBullet(k)));
                                        idx = (l + 1);
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // 使用回数を合わせる
                    idx = 1;
                    var loopTo17 = CountAbility();
                    for (j = 1; j <= loopTo17; j++)
                    {
                        counter = idx;
                        var loopTo18 = withBlock1.CountAbility();
                        for (k = counter; k <= loopTo18; k++)
                        {
                            if ((Ability(j).Name ?? "") == (withBlock1.Ability(k).Name ?? "") && this.Ability(j).Stock > 0 && withBlock1.Ability(k).Stock > 0)
                            {
                                withBlock1.SetStock(k, ((withBlock1.Ability(k).Stock * Stock(j)) / MaxStock(j)));
                                idx = (k + 1);
                                break;
                            }
                        }
                    }

                    var loopTo19 = withBlock1.CountOtherForm();
                    for (j = 1; j <= loopTo19; j++)
                    {
                        {
                            var withBlock3 = withBlock1.OtherForm(j);
                            idx = 1;
                            var loopTo20 = CountAbility();
                            for (k = 1; k <= loopTo20; k++)
                            {
                                counter = idx;
                                var loopTo21 = withBlock3.CountAbility();
                                for (l = counter; l <= loopTo21; l++)
                                {
                                    if ((Ability(k).Name ?? "") == (withBlock3.Ability(l).Name ?? "") && this.Ability(k).Stock > 0 && withBlock3.Ability(l).Stock > 0)
                                    {
                                        withBlock3.SetStock(l, ((withBlock3.Ability(l).Stock * Stock(k)) / MaxStock(k)));
                                        idx = (l + 1);
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // 弾数・使用回数共有の実現
                    withBlock1.SyncBullet();

                    // 出撃 or 格納？
                    withBlock1.Status = Status;
                    switch (Status ?? "")
                    {
                        case "出撃":
                            {
                                if (i == 1)
                                {
                                    withBlock1.UsedAction = UsedAction;
                                }
                                else
                                {
                                    withBlock1.UsedAction = GeneralLib.MaxLng(UsedAction, withBlock1.UsedAction);
                                    withBlock1.UsedSupportAttack = 0;
                                    withBlock1.UsedSupportGuard = 0;
                                    withBlock1.UsedSyncAttack = 0;
                                    withBlock1.UsedCounterAttack = 0;
                                }

                                withBlock1.StandBy(x, y);
                                break;
                            }

                        case "格納":
                            {
                                foreach (Unit eu in SRC.UList)
                                {
                                    var loopTo22 = eu.CountOtherForm();
                                    for (j = 1; j <= loopTo22; j++)
                                    {
                                        Unit localUnitOnBoard1() { object argIndex1 = j; var ret = eu.UnitOnBoard(argIndex1); return ret; }

                                        if ((ID ?? "") == (localUnitOnBoard1().ID ?? ""))
                                        {
                                            eu.LoadUnit(uarray[i]);
                                            goto EndLoop;
                                        }
                                    }
                                }

                                EndLoop:
                                ;
                                break;
                            }
                    }

                    // ノーマルモードや制限時間つきの形態の場合は残り時間を付加
                    if (withBlock1.IsFeatureAvailable("ノーマルモード"))
                    {
                        string localLIndex2() { object argIndex1 = "ノーマルモード"; string arglist = withBlock1.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                        if (Information.IsNumeric(localLIndex2()))
                        {
                            if (withBlock1.IsConditionSatisfied("残り時間"))
                            {
                                withBlock1.DeleteCondition("残り時間");
                            }

                            string localLIndex() { object argIndex1 = "ノーマルモード"; string arglist = withBlock1.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                            string localLIndex1() { object argIndex1 = "ノーマルモード"; string arglist = withBlock1.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                            withBlock1.AddCondition("残り時間", Conversions.Toint(localLIndex1()), cdata: "");
                        }
                    }
                    else if (withBlock1.IsFeatureAvailable("制限時間"))
                    {
                        withBlock1.AddCondition("残り時間", Conversions.Toint(withBlock1.FeatureData("制限時間")), cdata: "");
                    }
                }
            }

            // パイロットを合体ユニットから削除
            var loopTo23 = CountPilot();
            for (i = 1; i <= loopTo23; i++)
            {
                DeletePilot(1);
            }

            // サポートパイロットの乗り換え
            var loopTo24 = CountSupport();
            for (i = 1; i <= loopTo24; i++)
            {
                {
                    var withBlock4 = Support(i);
                    if (withBlock4.SupportIndex == 0)
                    {
                        Unit localItem3() { object argIndex1 = GeneralLib.LIndex(buf, 2); var ret = SRC.UList.Item(argIndex1); return ret; }

                        withBlock4.Ride(localItem3());
                    }
                    else
                    {
                        withBlock4.Ride(uarray[withBlock4.SupportIndex]);
                    }
                }
            }

            var loopTo25 = CountSupport();
            for (i = 1; i <= loopTo25; i++)
            {
                DeleteSupport(1);
            }

            // 格納されている場合は母艦から自分のエントリーを外しておく
            if (Status == "格納")
            {
                foreach (Unit u in SRC.UList)
                {
                    var loopTo26 = u.CountUnitOnBoard();
                    for (j = 1; j <= loopTo26; j++)
                    {
                        Unit localUnitOnBoard2() { object argIndex1 = j; var ret = u.UnitOnBoard(argIndex1); return ret; }

                        if ((ID ?? "") == (localUnitOnBoard2().ID ?? ""))
                        {
                            u.UnloadUnit(ID);
                            goto EndLoop2;
                        }
                    }
                }

                EndLoop2:
                ;
            }

            Status = "他形態";

            // ユニットステータスコマンドの場合以外は制限時間付き合体ユニットは
            // ２度とその形態を利用できない
            if (string.IsNullOrEmpty(Map.MapFileName))
            {
                return;
            }

            if (IsFeatureAvailable("制限時間"))
            {
                AddCondition("行動不能", -1, cdata: "");
            }
        }

        // 経験値を入手
        // t:ターゲット
        // exp_situation:経験値入手の理由
        // exp_mode:マップ攻撃による入手？
        public int GetExp(Unit t, string exp_situation, [Optional, DefaultParameterValue("")] string exp_mode)
        {
            int GetExpRet = default;
            var xp = default;
            int j, i, n;
            int prev_level;
            string[] prev_stype;
            string[] prev_sname;
            double[] prev_slevel;
            string[] prev_special_power;
            string stype, sname;
            Pilot p;
            string msg;

            // 経験値を入手するのは味方ユニット及びＮＰＣの召喚ユニットのみ
            if ((Party != "味方" || Party0 != "味方") && (Party != "ＮＰＣ" || Party0 != "ＮＰＣ" || !IsFeatureAvailable("召喚ユニット")))
            {
                return GetExpRet;
            }

            // メインパイロットの現在の能力を記録
            {
                var withBlock = MainPilot();
                prev_level = withBlock.Level;
                prev_special_power = new string[(withBlock.CountSpecialPower + 1)];
                var loopTo = withBlock.CountSpecialPower;
                for (i = 1; i <= loopTo; i++)
                    prev_special_power[i] = withBlock.get_SpecialPower(i);
                prev_stype = new string[(withBlock.CountSkill() + 1)];
                prev_sname = new string[(withBlock.CountSkill() + 1)];
                prev_slevel = new double[(withBlock.CountSkill() + 1)];
                var loopTo1 = withBlock.CountSkill();
                for (i = 1; i <= loopTo1; i++)
                {
                    prev_stype[i] = withBlock.Skill(i);
                    prev_sname[i] = withBlock.SkillName(i);
                    prev_slevel[i] = withBlock.SkillLevel(i, "基本値");
                }
            }

            // ターゲットが指定されていない場合は自分がターゲット
            if (t is null)
            {
                t = this;
            }

            // ターゲットにパイロットが乗っていない場合は経験値なし
            if (t.CountPilot() == 0)
            {
                return GetExpRet;
            }

            // ユニットに乗っているパイロット総数を計算
            n = (CountPilot() + CountSupport());
            if (IsFeatureAvailable("追加サポート"))
            {
                n = (n + 1);
            }

            // 各パイロットが経験値を入手
            var loopTo2 = n;
            for (i = 1; i <= loopTo2; i++)
            {
                if (i <= CountPilot())
                {
                    p = Pilot(i);
                }
                else if (i <= (CountPilot() + CountSupport()))
                {
                    p = Support(i - CountPilot());
                }
                else
                {
                    p = AdditionalSupport();
                }

                switch (exp_situation ?? "")
                {
                    case "破壊":
                        {
                            xp = t.ExpValue + t.MainPilot().ExpValue;
                            if (IsUnderSpecialPowerEffect("獲得経験値増加") && exp_mode != "パートナー")
                            {
                                xp = (xp * (1d + 0.1d * SpecialPowerEffectLevel("獲得経験値増加")));
                            }

                            break;
                        }

                    case "攻撃":
                        {
                            xp = (t.ExpValue + t.MainPilot().ExpValue) / 10;
                            if (IsUnderSpecialPowerEffect("獲得経験値増加") && exp_mode != "パートナー")
                            {
                                xp = (xp * (1d + 0.1d * SpecialPowerEffectLevel("獲得経験値増加")));
                            }

                            break;
                        }

                    case "アビリティ":
                        {
                            if (ReferenceEquals(t, this))
                            {
                                xp = 50;
                            }
                            else
                            {
                                xp = 100;
                            }

                            break;
                        }

                    case "修理":
                        {
                            xp = 100;
                            break;
                        }

                    case "補給":
                        {
                            xp = 150;
                            break;
                        }
                }

                if (!IsUnderSpecialPowerEffect("獲得経験値増加") || Expression.IsOptionDefined("収得効果重複"))
                {
                    if (p.IsSkillAvailable("素質"))
                    {
                        if (p.IsSkillLevelSpecified("素質"))
                        {
                            xp = ((long)(xp * (10d + p.SkillLevel("素質", ref_mode: ""))) / 10L);
                        }
                        else
                        {
                            xp = (1.5d * xp);
                        }
                    }
                }

                if (p.IsSkillAvailable("遅成長"))
                {
                    xp = xp / 2;
                }

                // 対象のパイロットのレベル差による修正
                switch ((t.MainPilot().Level - p.Level))
                {
                    case var @case when @case > 7:
                        {
                            xp = 5 * xp;
                            break;
                        }

                    case 7:
                        {
                            xp = (4.5d * xp);
                            break;
                        }

                    case 6:
                        {
                            xp = 4 * xp;
                            break;
                        }

                    case 5:
                        {
                            xp = (3.5d * xp);
                            break;
                        }

                    case 4:
                        {
                            xp = 3 * xp;
                            break;
                        }

                    case 3:
                        {
                            xp = (2.5d * xp);
                            break;
                        }

                    case 2:
                        {
                            xp = 2 * xp;
                            break;
                        }

                    case 1:
                        {
                            xp = (1.5d * xp);
                            break;
                        }

                    case 0:
                        {
                            break;
                        }

                    case -1:
                        {
                            xp = xp / 2;
                            break;
                        }

                    case -2:
                        {
                            xp = xp / 4;
                            break;
                        }

                    case -3:
                        {
                            xp = xp / 6;
                            break;
                        }

                    case -4:
                        {
                            xp = xp / 8;
                            break;
                        }

                    case -5:
                        {
                            xp = xp / 10;
                            break;
                        }

                    case var case1 when case1 < -5:
                        {
                            xp = xp / 12;
                            break;
                        }
                }

                p.Exp = p.Exp + xp;

                // 一番目のパイロットが獲得した経験値を返す
                if (i == 1)
                {
                    GetExpRet = xp;
                }
            }

            // 追加パイロットの場合、一番目のパイロットにレベル、経験値を合わせる
            if (!ReferenceEquals(MainPilot(), Pilot(1)))
            {
                MainPilot().Level = Pilot(1).Level;
                MainPilot().Exp = Pilot(1).Exp;
            }

            // 召喚主も経験値を入手
            if (Summoner is object)
            {
                Summoner.CurrentForm().GetExp(t, exp_situation, "パートナー");
            }

            // マップ攻撃による経験値収得の場合はメッセージ表示を省略
            if (exp_mode == "マップ")
            {
                return GetExpRet;
            }

            // 経験値入手時のメッセージ
            {
                var withBlock1 = MainPilot();
                if (withBlock1.Level > prev_level)
                {
                    // レベルアップ

                    if (IsAnimationDefined("レベルアップ", sub_situation: ""))
                    {
                        PlayAnimation("レベルアップ", sub_situation: "");
                    }
                    else if (IsSpecialEffectDefined("レベルアップ", sub_situation: ""))
                    {
                        SpecialEffect("レベルアップ", sub_situation: "");
                    }

                    if (IsMessageDefined("レベルアップ"))
                    {
                        PilotMessage("レベルアップ", msg_mode: "");
                    }

                    msg = withBlock1.get_Nickname(false) + "は経験値[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(GetExpRet) + "]を獲得、" + "レベル[" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock1.Level) + "]にレベルアップ。";

                    // 特殊能力の習得
                    var loopTo3 = withBlock1.CountSkill();
                    for (i = 1; i <= loopTo3; i++)
                    {
                        stype = withBlock1.Skill(i);
                        sname = withBlock1.SkillName(i);
                        if (Strings.InStr(sname, "非表示") == 0)
                        {
                            switch (stype ?? "")
                            {
                                case "同調率":
                                case "霊力":
                                case "追加レベル":
                                case "魔力所有":
                                    {
                                        break;
                                    }

                                case "ＳＰ消費減少":
                                case "スペシャルパワー自動発動":
                                case "ハンター":
                                    {
                                        var loopTo4 = Information.UBound(prev_stype);
                                        for (j = 1; j <= loopTo4; j++)
                                        {
                                            if ((stype ?? "") == (prev_stype[j] ?? ""))
                                            {
                                                if ((sname ?? "") == (prev_sname[j] ?? ""))
                                                {
                                                    break;
                                                }
                                            }
                                        }

                                        if (j > Information.UBound(prev_stype))
                                        {
                                            msg = msg + ";" + sname + "を習得した。";
                                        }

                                        break;
                                    }

                                default:
                                    {
                                        var loopTo5 = Information.UBound(prev_stype);
                                        for (j = 1; j <= loopTo5; j++)
                                        {
                                            if ((stype ?? "") == (prev_stype[j] ?? ""))
                                            {
                                                break;
                                            }
                                        }

                                        double localSkillLevel() { object argIndex1 = i; string argref_mode = "基本値"; var ret = withBlock1.SkillLevel(argIndex1, argref_mode); return ret; }

                                        if (j > Information.UBound(prev_stype))
                                        {
                                            msg = msg + ";" + sname + "を習得した。";
                                        }
                                        else if (localSkillLevel() > prev_slevel[j])
                                        {
                                            msg = msg + ";" + prev_sname[j] + " => " + sname + "。";
                                        }

                                        break;
                                    }
                            }
                        }
                    }

                    // スペシャルパワーの習得
                    if (withBlock1.CountSpecialPower > Information.UBound(prev_special_power))
                    {
                        msg = msg + ";" + Expression.Term("スペシャルパワー", this);
                        var loopTo6 = withBlock1.CountSpecialPower;
                        for (i = 1; i <= loopTo6; i++)
                        {
                            sname = withBlock1.get_SpecialPower(i);
                            var loopTo7 = Information.UBound(prev_special_power);
                            for (j = 1; j <= loopTo7; j++)
                            {
                                if ((sname ?? "") == (prev_special_power[j] ?? ""))
                                {
                                    break;
                                }
                            }

                            if (j > Information.UBound(prev_special_power))
                            {
                                msg = msg + "「" + sname + "」";
                            }
                        }

                        msg = msg + "を習得した。";
                    }

                    GUI.DisplaySysMessage(msg);
                    if (GUI.MessageWait < 10000)
                    {
                        GUI.Sleep(GUI.MessageWait);
                    }

                    Event.HandleEvent("レベルアップ", withBlock1.ID);
                    SRC.PList.UpdateSupportMod(this);
                }
                else if (GetExpRet > 0)
                {
                    GUI.DisplaySysMessage(withBlock1.get_Nickname(false) + "は" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(GetExpRet) + "の経験値を得た。");
                }
            }

            return GetExpRet;
        }

        // ユニットの陣営を変更
        public void ChangeParty(string new_party)
        {
            int i;

            // 陣営を変更
            Party = new_party;

            // ビットマップを作り直す
            BitmapID = GUI.MakeUnitBitmap(this);

            // パイロットの陣営を変更
            var loopTo = CountPilot();
            for (i = 1; i <= loopTo; i++)
            {
                Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                localPilot().Party = new_party;
            }

            var loopTo1 = CountSupport();
            for (i = 1; i <= loopTo1; i++)
            {
                Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                localSupport().Party = new_party;
            }

            if (IsFeatureAvailable("追加サポート"))
            {
                AdditionalSupport().Party = new_party;
            }

            // 他形態の陣営を変更
            var loopTo2 = CountOtherForm();
            for (i = 1; i <= loopTo2; i++)
            {
                Unit localOtherForm() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                localOtherForm().Party = new_party;
                Unit localOtherForm1() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                localOtherForm1().BitmapID = 0;
            }

            // 出撃中？
            if (Status == "出撃")
            {
                // 自分の陣営のステージなら行動可能に
                if ((Party ?? "") == (SRC.Stage ?? ""))
                {
                    Rest();
                }
                // マップ上のユニット画像を更新
                GUI.PaintUnitBitmap(this);
            }

            SRC.PList.UpdateSupportMod(this);

            // 思考モードを通常に
            Mode = "通常";
        }

        // ユニットに乗っているパイロットの気力をnumだけ増減
        // is_event:イベントによる気力増減(性格を無視して気力操作)
        public void IncreaseMorale(int num, bool is_event = false)
        {
            Pilot p;
            if (CountPilot() == 0)
            {
                return;
            }

            // メインパイロット
            {
                var withBlock = MainPilot();
                if (withBlock.Personality != "機械" || is_event)
                {
                    withBlock.Morale = (withBlock.Morale + num);
                }
            }

            // サブパイロット
            foreach (Pilot currentP in colPilot)
            {
                p = currentP;
                if ((MainPilot().ID ?? "") != (p.ID ?? "") && (p.Personality != "機械" || is_event))
                {
                    p.Morale = (p.Morale + num);
                }
            }

            // サポート
            foreach (Pilot currentP1 in colSupport)
            {
                p = currentP1;
                if (p.Personality != "機械" || is_event)
                {
                    p.Morale = (p.Morale + num);
                }
            }

            // 追加サポート
            if (IsFeatureAvailable("追加サポート"))
            {
                {
                    var withBlock1 = AdditionalSupport();
                    if (withBlock1.Personality != "機械" || is_event)
                    {
                        withBlock1.Morale = (withBlock1.Morale + num);
                    }
                }
            }
        }

        // ユニットが破壊された時の処理
        public void Die(bool without_update = false)
        {
            int i, j;
            string pname;
            HP = 0;
            Status = "破壊";

            // 破壊をキャンセルし、破壊イベント内で処理をしたい場合
            if (IsConditionSatisfied("破壊キャンセル"))
            {
                DeleteCondition("破壊キャンセル");
                goto SkipExplode;
            }

            // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Map.MapDataForUnit[x, y] = null;

            // 爆発表示
            GUI.ClearPicture();
            if (IsAnimationDefined("脱出", sub_situation: ""))
            {
                GUI.EraseUnitBitmap(x, y, false);
                PlayAnimation("脱出", sub_situation: "");
            }
            else if (IsSpecialEffectDefined("脱出", sub_situation: ""))
            {
                GUI.EraseUnitBitmap(x, y, false);
                SpecialEffect("脱出", sub_situation: "");
            }
            else
            {
                Effect.DieAnimation(this);
            }

            SkipExplode:
            ;


            // 召喚したユニットを解放
            DismissServant();

            // 魅了・憑依したユニットを解放
            DismissSlave();
            if (Master is object)
            {
                Master.CurrentForm().DeleteSlave(ID);
                // UPGRADE_NOTE: オブジェクト Master をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                Master = null;
            }

            if (Summoner is object)
            {
                Summoner.CurrentForm().DeleteServant(ID);
                // UPGRADE_NOTE: オブジェクト Summoner をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                Summoner = null;
            }

            // 支配しているユニットを強制退却
            if (IsFeatureAvailable("支配"))
            {
                var loopTo = GeneralLib.LLength(FeatureData("支配"));
                for (i = 2; i <= loopTo; i++)
                {
                    pname = GeneralLib.LIndex(FeatureData("支配"), i);
                    foreach (Pilot p in SRC.PList)
                    {
                        if ((p.Name ?? "") == (pname ?? "") || (p.get_Nickname(false) ?? "") == (pname ?? ""))
                        {
                            if (p.Unit is object)
                            {
                                if (p.Unit.Status == "出撃" || p.Unit.Status == "格納")
                                {
                                    p.Unit.Die(true);
                                }
                            }
                        }
                    }
                }
            }

            // 情報更新
            if (!without_update)
            {
                SRC.PList.UpdateSupportMod(this);
            }
        }

        // スペシャルパワー自爆による自爆
        public void SuicidalExplosion(bool is_event = false)
        {
            int i, j;
            int prev_hp;
            Unit u, t;
            int dmg, tdmg;
            string uname, fname;
            PilotMessage("自爆", msg_mode: "");
            GUI.DisplaySysMessage(Nickname + "は自爆した。");

            // ダメージ量設定
            dmg = HP;

            // 効果範囲の設定
            Map.AreaInRange(x, y, 1, 1, "");
            Map.MaskData[x, y] = true;

            // 爆発
            GUI.EraseUnitBitmap(x, y);
            Effect.ExplodeAnimation(Size, x, y);
            this.Size = argtsize;

            // パーツ分離できれば自爆後にパーツ分離
            if (IsFeatureAvailable("パーツ分離"))
            {
                uname = GeneralLib.LIndex(FeatureData("パーツ分離"), 2);
                Unit localOtherForm() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

                if (localOtherForm().IsAbleToEnter(x, y))
                {
                    Transform(uname);
                    Map.MapDataForUnit[x, y].HP = Map.MapDataForUnit[x, y].MaxHP;
                    fname = FeatureName("パーツ分離");
                    bool localIsSysMessageDefined() { string argmain_situation = "破壊時分離(" + fname + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    bool localIsSysMessageDefined1() { string argmain_situation = "分離(" + Name + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    bool localIsSysMessageDefined2() { string argmain_situation = "分離(" + fname + ")"; string argsub_situation = ""; var ret = IsSysMessageDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    if (IsSysMessageDefined("破壊時分離(" + Name + ")", sub_situation: ""))
                    {
                        SysMessage("破壊時分離(" + Name + ")", sub_situation: "", add_msg: "");
                    }
                    else if (localIsSysMessageDefined())
                    {
                        SysMessage("破壊時分離(" + fname + ")", sub_situation: "", add_msg: "");
                    }
                    else if (IsSysMessageDefined("破壊時分離", sub_situation: ""))
                    {
                        SysMessage("破壊時分離", sub_situation: "", add_msg: "");
                    }
                    else if (localIsSysMessageDefined1())
                    {
                        SysMessage("分離(" + Name + ")", sub_situation: "", add_msg: "");
                    }
                    else if (localIsSysMessageDefined2())
                    {
                        SysMessage("分離(" + fname + ")", sub_situation: "", add_msg: "");
                    }
                    else if (IsSysMessageDefined("分離", sub_situation: ""))
                    {
                        SysMessage("分離", sub_situation: "", add_msg: "");
                    }
                    else
                    {
                        GUI.DisplaySysMessage(Nickname + "は破壊されたパーツを分離させた。");
                    }

                    goto SkipSuicide;
                }
            }

            // 自分を破壊
            HP = 0;
            GUI.UpdateMessageForm(this, u2: null);
            // 既に爆発アニメーションを表示しているので
            AddCondition("破壊キャンセル", 1, cdata: "");
            // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Map.MapDataForUnit[x, y] = null;
            Die();
            if (!is_event)
            {
                u = Commands.SelectedUnit;
                Commands.SelectedUnit = this;
                Event.HandleEvent("破壊", MainPilot().ID);
                Commands.SelectedUnit = u;
                if (SRC.IsScenarioFinished)
                {
                    SRC.IsScenarioFinished = false;
                    return;
                }
            }

            SkipSuicide:
            ;


            // 周りのエリアに爆発効果を適用
            var loopTo = Map.MapWidth;
            for (i = 1; i <= loopTo; i++)
            {
                var loopTo1 = Map.MapHeight;
                for (j = 1; j <= loopTo1; j++)
                {
                    if (Map.MaskData[i, j])
                    {
                        goto NextLoop;
                    }

                    t = Map.MapDataForUnit[i, j];
                    if (t is null)
                    {
                        goto NextLoop;
                    }

                    {
                        var withBlock = t;
                        GUI.ClearMessageForm();
                        if (CurrentForm().Party == "味方" || CurrentForm().Party == "ＮＰＣ")
                        {
                            GUI.UpdateMessageForm(t, CurrentForm());
                        }
                        else
                        {
                            GUI.UpdateMessageForm(CurrentForm(), t);
                        }

                        // ダメージの適用
                        prev_hp = withBlock.HP;
                        if (withBlock.IsConditionSatisfied("無敵"))
                        {
                            tdmg = 0;
                        }
                        else if (withBlock.IsConditionSatisfied("不死身"))
                        {
                            withBlock.HP = GeneralLib.MaxLng(withBlock.HP - dmg, 10);
                            tdmg = prev_hp - withBlock.HP;
                        }
                        else
                        {
                            withBlock.HP = withBlock.HP - dmg;
                            tdmg = prev_hp - withBlock.HP;
                        }

                        // 特殊能力「不安定」による暴走チェック
                        if (withBlock.IsFeatureAvailable("不安定"))
                        {
                            if (withBlock.HP <= withBlock.MaxHP / 4 && !withBlock.IsConditionSatisfied("暴走"))
                            {
                                withBlock.AddCondition("暴走", -1, cdata: "");
                                withBlock.Update();
                            }
                        }

                        // ダメージを受ければ眠りからさめる
                        if (withBlock.IsConditionSatisfied("睡眠"))
                        {
                            withBlock.DeleteCondition("睡眠");
                        }

                        if (CurrentForm().Party == "味方" || CurrentForm().Party == "ＮＰＣ")
                        {
                            GUI.UpdateMessageForm(t, CurrentForm());
                        }
                        else
                        {
                            GUI.UpdateMessageForm(CurrentForm(), t);
                        }

                        if (withBlock.HP > 0)
                        {
                            GUI.DrawSysString(withBlock.x, withBlock.y, Microsoft.VisualBasic.Compatibility.VB6.Support.Format(tdmg));
                            // UPGRADE_ISSUE: Control picMain は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                            GUI.MainForm.picMain(0).Refresh();
                        }

                        if (withBlock.HP == 0)
                        {
                            if (withBlock.IsUnderSpecialPowerEffect("復活"))
                            {
                                withBlock.HP = withBlock.MaxHP;
                                withBlock.RemoveSpecialPowerInEffect("破壊");
                                GUI.DisplaySysMessage(withBlock.Nickname + "は復活した！");
                                goto NextLoop;
                            }

                            if (withBlock.IsFeatureAvailable("パーツ分離"))
                            {
                                uname = GeneralLib.LIndex(withBlock.FeatureData("パーツ分離"), 2);
                                Unit localOtherForm1() { object argIndex1 = uname; var ret = withBlock.OtherForm(argIndex1); return ret; }

                                if (localOtherForm1().IsAbleToEnter(withBlock.x, withBlock.y))
                                {
                                    withBlock.Transform(uname);
                                    {
                                        var withBlock1 = withBlock.CurrentForm();
                                        withBlock1.HP = withBlock1.MaxHP;
                                        withBlock1.UsedAction = withBlock1.MaxAction();
                                    }

                                    GUI.DisplaySysMessage(withBlock.Nickname + "は破壊されたパーツを分離させた。");
                                    goto NextLoop;
                                }
                            }

                            withBlock.Die();
                        }

                        if (!is_event)
                        {
                            u = Commands.SelectedUnit;
                            Commands.SelectedUnit = withBlock.CurrentForm();
                            Commands.SelectedTarget = this;
                            if (withBlock.Status == "破壊")
                            {
                                GUI.DisplaySysMessage(withBlock.Nickname + "は破壊された");
                                Event.HandleEvent("破壊", withBlock.MainPilot().ID);
                            }
                            else
                            {
                                GUI.DisplaySysMessage(withBlock.Nickname + "は" + tdmg + "のダメージを受けた。;" + "残りＨＰは" + Microsoft.VisualBasic.Compatibility.VB6.Support.Format(withBlock.HP) + "（損傷率 = " + 100 * (withBlock.MaxHP - withBlock.HP) / withBlock.MaxHP + "％）");
                                Event.HandleEvent("損傷率", withBlock.MainPilot().ID, 100 - withBlock.HP * 100 / withBlock.MaxHP);
                            }

                            Commands.SelectedUnit = u;
                            if (SRC.IsScenarioFinished)
                            {
                                SRC.IsScenarioFinished = false;
                                return;
                            }
                        }
                    }

                    NextLoop:
                    ;
                }
            }
        }


        // === ステータス回復関連処理 ===

        // ステータスを全回復
        public void FullRecover()
        {
            int i, j;

            // パイロットのステータスを全回復
            var loopTo = CountPilot();
            for (i = 1; i <= loopTo; i++)
            {
                Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                localPilot().FullRecover();
            }

            var loopTo1 = CountSupport();
            for (i = 1; i <= loopTo1; i++)
            {
                Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                localSupport().FullRecover();
            }

            if (IsFeatureAvailable("追加パイロット"))
            {
                if (SRC.PList.IsDefined(FeatureData("追加パイロット")))
                {
                    Pilot localItem() { object argIndex1 = "追加パイロット"; object argIndex2 = FeatureData(argIndex1); var ret = SRC.PList.Item(argIndex2); return ret; }

                    localItem().FullRecover();
                }
            }

            {
                var withBlock = CurrentForm();
                // ＨＰを回復
                withBlock.HP = withBlock.MaxHP;

                // ＥＮ、弾数を回復
                withBlock.FullSupply();

                // ステータス異常のみを消去
                i = 1;
                while (i <= withBlock.CountCondition())
                {
                    string localCondition() { object argIndex1 = i; var ret = withBlock.Condition(argIndex1); return ret; }

                    string localCondition1() { object argIndex1 = i; var ret = withBlock.Condition(argIndex1); return ret; }

                    string localCondition2() { object argIndex1 = i; var ret = withBlock.Condition(argIndex1); return ret; }

                    string localCondition3() { object argIndex1 = i; var ret = withBlock.Condition(argIndex1); return ret; }

                    string localCondition4() { object argIndex1 = i; var ret = withBlock.Condition(argIndex1); return ret; }

                    string localCondition5() { object argIndex1 = i; var ret = withBlock.Condition(argIndex1); return ret; }

                    string localCondition6() { object argIndex1 = i; var ret = withBlock.Condition(argIndex1); return ret; }

                    if (localCondition() == "残り時間" || localCondition1() == "非操作" || Strings.Right(localCondition2(), 2) == "付加" || Strings.Right(localCondition3(), 2) == "強化" || Strings.Right(localCondition4(), 3) == "付加２" || Strings.Right(localCondition5(), 3) == "強化２" || Strings.Right(localCondition6(), 2) == "ＵＰ")
                    {
                        i = (i + 1);
                    }
                    else
                    {
                        withBlock.DeleteCondition(i);
                    }
                }

                // サポートアタック＆ガード、同時援護攻撃、カウンター攻撃回数回復
                withBlock.UsedSupportAttack = 0;
                withBlock.UsedSupportGuard = 0;
                withBlock.UsedSyncAttack = 0;
                withBlock.UsedCounterAttack = 0;
                withBlock.Mode = "通常";

                // 他形態も回復
                var loopTo2 = withBlock.CountOtherForm();
                for (i = 1; i <= loopTo2; i++)
                {
                    {
                        var withBlock1 = withBlock.OtherForm(i);
                        withBlock1.HP = withBlock1.MaxHP;
                        withBlock1.EN = withBlock1.MaxEN;
                        var loopTo3 = withBlock1.CountWeapon();
                        for (j = 1; j <= loopTo3; j++)
                            withBlock1.SetBullet(j, withBlock1.MaxBullet(j));
                        var loopTo4 = withBlock1.CountAbility();
                        for (j = 1; j <= loopTo4; j++)
                            withBlock1.SetStock(j, withBlock1.MaxStock(j));
                    }
                }
            }
        }

        // ＥＮ＆弾数を回復
        public void FullSupply()
        {
            int i, j;

            // ＥＮ回復
            EN = MaxEN;

            // 弾数回復
            var loopTo = CountWeapon();
            for (i = 1; i <= loopTo; i++)
                dblBullet[i] = 1d;
            var loopTo1 = CountAbility();
            for (i = 1; i <= loopTo1; i++)
                dblStock[i] = 1d;

            // 他形態も回復
            var loopTo2 = CountOtherForm();
            for (i = 1; i <= loopTo2; i++)
            {
                {
                    var withBlock = OtherForm(i);
                    withBlock.EN = withBlock.MaxEN;
                    var loopTo3 = withBlock.CountWeapon();
                    for (j = 1; j <= loopTo3; j++)
                        withBlock.SetBullet(j, withBlock.MaxBullet(j));
                    var loopTo4 = withBlock.CountAbility();
                    for (j = 1; j <= loopTo4; j++)
                        withBlock.SetStock(j, withBlock.MaxStock(j));
                }
            }
        }

        // 弾数のみを回復
        public void BulletSupply()
        {
            int i, j;
            var loopTo = CountWeapon();
            for (i = 1; i <= loopTo; i++)
                dblBullet[i] = 1d;

            // 他形態も回復
            var loopTo1 = CountOtherForm();
            for (i = 1; i <= loopTo1; i++)
            {
                {
                    var withBlock = OtherForm(i);
                    var loopTo2 = withBlock.CountWeapon();
                    for (j = 1; j <= loopTo2; j++)
                        withBlock.SetBullet(j, withBlock.MaxBullet(j));
                }
            }
        }

        // ＨＰを percent ％回復
        public void RecoverHP(double percent)
        {
            HP = (HP + MaxHP * percent / 100d);
            if (HP <= 0)
            {
                HP = 1;
            }

            // 特殊能力「不安定」による暴走チェック
            if (IsFeatureAvailable("不安定"))
            {
                if (HP <= MaxHP / 4 && !IsConditionSatisfied("暴走"))
                {
                    AddCondition("暴走", -1, cdata: "");
                }
            }
        }

        // ＥＮを percent ％回復
        public void RecoverEN(double percent)
        {
            EN = (EN + MaxEN * percent / 100d);
            if (EN <= 0)
            {
                EN = 0;
            }
        }

        // ターン経過によるステータス回復
        public void Rest()
        {
            int hp_recovery = default, en_recovery = default;
            int hp_up = default, en_up = default;
            double hp_ratio, en_ratio;
            string spname, buf;
            int i, j;
            Unit u;
            TerrainData td;
            string cname;
            var is_time_limit = default(bool);
            var next_form = default(string);
            // ADD START MARGE
            var is_terrain_effective = default(bool);
            var is_immune_to_terrain_effect = default(bool);
            // ADD END MARGE

            // 味方ステージの1ターン目(スタートイベント直後)は回復を行わない
            if (SRC.Stage == "味方" && SRC.Turn == 1)
            {
                return;
            }

            // データ更新
            Update();

            // 変形に対応して自分を登録
            u = this;
            {
                var withBlock = MainPilot();
                // 霊力回復
                if (withBlock.MaxPlana() > 0)
                {
                    hp_ratio = 100 * HP / (double)MaxHP;
                    en_ratio = 100 * EN / (double)MaxEN;
                    withBlock.Plana = (withBlock.Plana + withBlock.MaxPlana() / 16 + (long)(withBlock.MaxPlana() * FeatureLevel("霊力回復")) / 10L - (long)(withBlock.MaxPlana() * FeatureLevel("霊力消費")) / 10L);
                    HP = ((long)(MaxHP * hp_ratio) / 100L);
                    EN = ((long)(MaxEN * en_ratio) / 100L);
                }

                // ＳＰ回復
                if (withBlock.IsSkillAvailable("ＳＰ回復"))
                {
                    withBlock.SP = withBlock.SP + withBlock.Level / 8 + 5;
                }

                if (withBlock.IsSkillAvailable("精神統一"))
                {
                    if (withBlock.SP < withBlock.MaxSP / 5)
                    {
                        withBlock.SP = withBlock.SP + withBlock.MaxSP / 10;
                    }
                }
            }

            // ＳＰ回復
            var loopTo = CountPilot();
            for (i = 2; i <= loopTo; i++)
            {
                {
                    var withBlock1 = Pilot(i);
                    if (withBlock1.IsSkillAvailable("ＳＰ回復"))
                    {
                        withBlock1.SP = withBlock1.SP + withBlock1.Level / 8 + 5;
                    }

                    if (withBlock1.IsSkillAvailable("精神統一"))
                    {
                        if (withBlock1.SP < withBlock1.MaxSP / 5)
                        {
                            withBlock1.SP = withBlock1.SP + withBlock1.MaxSP / 10;
                        }
                    }
                }
            }

            var loopTo1 = CountSupport();
            for (i = 1; i <= loopTo1; i++)
            {
                {
                    var withBlock2 = Support(i);
                    if (withBlock2.IsSkillAvailable("ＳＰ回復"))
                    {
                        withBlock2.SP = withBlock2.SP + withBlock2.Level / 8 + 5;
                    }

                    if (withBlock2.IsSkillAvailable("精神統一"))
                    {
                        if (withBlock2.SP < withBlock2.MaxSP / 5)
                        {
                            withBlock2.SP = withBlock2.SP + withBlock2.MaxSP / 10;
                        }
                    }
                }
            }

            if (IsFeatureAvailable("追加サポート"))
            {
                {
                    var withBlock3 = AdditionalSupport();
                    if (withBlock3.IsSkillAvailable("ＳＰ回復"))
                    {
                        withBlock3.SP = withBlock3.SP + withBlock3.Level / 8 + 5;
                    }

                    if (withBlock3.IsSkillAvailable("精神統一"))
                    {
                        if (withBlock3.SP < withBlock3.MaxSP / 5)
                        {
                            withBlock3.SP = withBlock3.SP + withBlock3.MaxSP / 10;
                        }
                    }
                }
            }

            // 行動回数
            UsedAction = 0;

            // スペシャルパワー効果を解除
            RemoveSpecialPowerInEffect("ターン");

            // スペシャルパワー自動発動
            {
                var withBlock4 = MainPilot();
                var loopTo2 = withBlock4.CountSkill();
                for (i = 1; i <= loopTo2; i++)
                {
                    if (withBlock4.Skill(i) == "スペシャルパワー自動発動")
                    {
                        string localSkillData() { object argIndex1 = i; var ret = withBlock4.SkillData(argIndex1); return ret; }

                        spname = GeneralLib.LIndex(localSkillData(), 2);
                        string localSkillData1() { object argIndex1 = i; var ret = withBlock4.SkillData(argIndex1); return ret; }

                        string localLIndex() { string arglist = hsbeebf58ad14b49d88a05b39a41264136(); var ret = GeneralLib.LIndex(arglist, 3); return ret; }

                        int localStrToLng() { string argexpr = hsa615f5f7d41941adb5ff8c50a645e7c9(); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                        if (withBlock4.Morale >= localStrToLng() && !IsSpecialPowerInEffect(spname))
                        {
                            GUI.Center(x, y);
                            withBlock4.UseSpecialPower(spname, 0d);
                            if (Status == "他形態")
                            {
                                return;
                            }
                        }
                    }
                }

                if (IsConditionSatisfied("スペシャルパワー自動発動付加") || IsConditionSatisfied("スペシャルパワー自動発動付加２"))
                {
                    spname = GeneralLib.LIndex(withBlock4.SkillData("スペシャルパワー自動発動"), 2);
                    string localLIndex1() { object argIndex1 = "スペシャルパワー自動発動"; string arglist = withBlock4.SkillData(argIndex1); var ret = GeneralLib.LIndex(arglist, 3); return ret; }

                    int localStrToLng1() { string argexpr = hs007c2f9d021b4299932cdd690ee4914e(); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                    if (withBlock4.Morale >= localStrToLng1() && !IsSpecialPowerInEffect(spname))
                    {
                        GUI.Center(x, y);
                        withBlock4.UseSpecialPower(spname, 0d);
                        if (Status == "他形態")
                        {
                            return;
                        }
                    }
                }
            }

            var loopTo3 = CountPilot();
            for (i = 2; i <= loopTo3; i++)
            {
                {
                    var withBlock5 = Pilot(i);
                    var loopTo4 = withBlock5.CountSkill();
                    for (j = 1; j <= loopTo4; j++)
                    {
                        if (withBlock5.Skill(j) == "スペシャルパワー自動発動")
                        {
                            string localSkillData2() { object argIndex1 = j; var ret = withBlock5.SkillData(argIndex1); return ret; }

                            spname = GeneralLib.LIndex(localSkillData2(), 2);
                            string localSkillData3() { object argIndex1 = j; var ret = withBlock5.SkillData(argIndex1); return ret; }

                            string localLIndex2() { string arglist = hsa05862d2d473454a8c0d7941dff82ac5(); var ret = GeneralLib.LIndex(arglist, 3); return ret; }

                            int localStrToLng2() { string argexpr = hs1050a377ee804d6d86fc7e98398e12ee(); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (withBlock5.Morale >= localStrToLng2() && !IsSpecialPowerInEffect(spname))
                            {
                                GUI.Center(x, y);
                                withBlock5.UseSpecialPower(spname, 0d);
                                if (Status == "他形態")
                                {
                                    return;
                                }
                            }
                        }
                    }
                }
            }

            var loopTo5 = CountSupport();
            for (i = 1; i <= loopTo5; i++)
            {
                {
                    var withBlock6 = Support(i);
                    var loopTo6 = withBlock6.CountSkill();
                    for (j = 1; j <= loopTo6; j++)
                    {
                        if (withBlock6.Skill(j) == "スペシャルパワー自動発動")
                        {
                            string localSkillData4() { object argIndex1 = j; var ret = withBlock6.SkillData(argIndex1); return ret; }

                            spname = GeneralLib.LIndex(localSkillData4(), 2);
                            string localSkillData5() { object argIndex1 = j; var ret = withBlock6.SkillData(argIndex1); return ret; }

                            string localLIndex3() { string arglist = hsfa97fc36239f45ffacc7690204644669(); var ret = GeneralLib.LIndex(arglist, 3); return ret; }

                            int localStrToLng3() { string argexpr = hsaaa9e6d3323e4453a1b656c0d1ba1987(); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (withBlock6.Morale >= localStrToLng3() && !IsSpecialPowerInEffect(spname))
                            {
                                GUI.Center(x, y);
                                withBlock6.UseSpecialPower(spname, 0d);
                                if (Status == "他形態")
                                {
                                    return;
                                }
                            }
                        }
                    }
                }
            }

            if (IsFeatureAvailable("追加サポート"))
            {
                {
                    var withBlock7 = AdditionalSupport();
                    var loopTo7 = withBlock7.CountSkill();
                    for (i = 1; i <= loopTo7; i++)
                    {
                        if (withBlock7.Skill(i) == "スペシャルパワー自動発動")
                        {
                            string localSkillData6() { object argIndex1 = i; var ret = withBlock7.SkillData(argIndex1); return ret; }

                            spname = GeneralLib.LIndex(localSkillData6(), 2);
                            string localSkillData7() { object argIndex1 = i; var ret = withBlock7.SkillData(argIndex1); return ret; }

                            string localLIndex4() { string arglist = hs393cfbef7a894559b16f4706c8e49b64(); var ret = GeneralLib.LIndex(arglist, 3); return ret; }

                            int localStrToLng4() { string argexpr = hsd3fcfdcfd593490696f3d091f42d35e5(); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                            if (withBlock7.Morale >= localStrToLng4() && !IsSpecialPowerInEffect(spname))
                            {
                                GUI.Center(x, y);
                                withBlock7.UseSpecialPower(spname, 0d);
                                if (Status == "他形態")
                                {
                                    return;
                                }
                            }
                        }
                    }
                }
            }

            // 起死回生
            {
                var withBlock8 = MainPilot();
                if (withBlock8.IsSkillAvailable("起死回生") && withBlock8.SP <= withBlock8.MaxSP / 5 && HP <= MaxHP / 5 && EN <= MaxEN / 5)
                {
                    withBlock8.SP = withBlock8.MaxSP;
                    HP = MaxHP;
                    EN = MaxEN;
                    if (SRC.SpecialPowerAnimation)
                    {
                        GUI.Center(x, y);
                        if (SRC.SPDList.IsDefined("ド根性"))
                        {
                            SRC.SPDList.Item("ド根性").PlayAnimation();
                        }
                    }
                }
            }

            // ＨＰとＥＮ回復＆消費
            // MOD START MARGE
            // If Not IsConditionSatisfied("回復不能") Then
            if (!IsConditionSatisfied("回復不能") && !IsSpecialPowerInEffect("回復不能"))
            {
                // MOD END MARGE
                if (IsFeatureAvailable("ＨＰ回復"))
                {
                    hp_recovery = (10d * FeatureLevel("ＨＰ回復"));
                }

                if (IsFeatureAvailable("ＥＮ回復"))
                {
                    en_recovery = (10d * FeatureLevel("ＥＮ回復"));
                }
            }

            if (IsFeatureAvailable("ＨＰ消費"))
            {
                hp_recovery = (hp_recovery - 10d * FeatureLevel("ＨＰ消費"));
            }

            if (IsFeatureAvailable("ＥＮ消費"))
            {
                en_recovery = (en_recovery - 10d * FeatureLevel("ＥＮ消費"));
            }

            // 毒によるＨＰ減少
            int plv;
            if (IsConditionSatisfied("毒"))
            {
                if (Expression.IsOptionDefined("毒効果大") && BossRank < 0)
                {
                    plv = 25;
                }
                else
                {
                    plv = 10;
                }

                // 変化なし
                if (Weakness("毒"))
                {
                    plv = (2 * plv);
                }
                else if (Effective("毒"))
                {
                }
                else if (Immune("毒") || Absorb("毒"))
                {
                    plv = 0;
                }
                else if (Resist("毒"))
                {
                    plv = (plv / 2);
                }

                hp_recovery = hp_recovery - plv;
            }

            // 活動限界時間切れ？
            if (ConditionLifetime("活動限界") == 1)
            {
                GUI.Center(x, y);
                Escape();
                GUI.OpenMessageForm(u1: null, u2: null);
                GUI.DisplaySysMessage(Nickname + "は強制的に退却させられた。");
                GUI.CloseMessageForm();
                Event.HandleEvent("破壊", MainPilot().ID);
            }

            // 死の宣告
            if (ConditionLifetime("死の宣告") == 1)
            {
                hp_recovery = hp_recovery - 1000;
            }

            // 残り時間
            if (ConditionLifetime("残り時間") == 1)
            {
                is_time_limit = true;
                if (IsFeatureAvailable("ノーマルモード"))
                {
                    // ハイパーモード＆変身の時間切れの場合は戻り先の形態を記録しておく
                    next_form = GeneralLib.LIndex(FeatureData("ノーマルモード"), 1);
                }
            }

            // ＨＰ回復などを付加した場合のことを考えて状態のアップデートは
            // ＨＰ＆ＥＮ回復量を計算した後に行う
            hp_ratio = 100 * HP / (double)MaxHP;
            en_ratio = 100 * EN / (double)MaxEN;
            UpdateCondition(true);
            HP = ((long)(MaxHP * hp_ratio) / 100L);
            EN = ((long)(MaxEN * en_ratio) / 100L);

            // サポートアタック＆ガード
            UsedSupportAttack = 0;
            UsedSupportGuard = 0;

            // 同時援護攻撃
            UsedSyncAttack = 0;

            // カウンター攻撃
            UsedCounterAttack = 0;

            // チャージ完了？
            if (ConditionLifetime("チャージ") == 0)
            {
                AddCondition("チャージ完了", 1, cdata: "");
            }

            // 付加された移動能力が切れた場合の処理
            if (Status == "出撃" && !string.IsNullOrEmpty(Map.MapFileName))
            {
                switch (Area ?? "")
                {
                    case "空中":
                        {
                            if (!IsTransAvailable("空"))
                            {
                                if (!IsAbleToEnter(x, y))
                                {
                                    GUI.Center(x, y);
                                    Escape();
                                    GUI.OpenMessageForm(u1: null, u2: null);
                                    GUI.DisplaySysMessage(Nickname + "は強制的に退却させられた。");
                                    GUI.CloseMessageForm();
                                    Event.HandleEvent("破壊", MainPilot().ID);
                                    return;
                                }
                                // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                Map.MapDataForUnit[x, y] = null;
                                GUI.EraseUnitBitmap(x, y);
                                StandBy(x, y);
                            }

                            break;
                        }

                    case "地上":
                        {
                            if (!IsTransAvailable("陸"))
                            {
                                if (!IsAbleToEnter(x, y))
                                {
                                    GUI.Center(x, y);
                                    Escape();
                                    GUI.OpenMessageForm(u1: null, u2: null);
                                    GUI.DisplaySysMessage(Nickname + "は強制的に退却させられた。");
                                    GUI.CloseMessageForm();
                                    Event.HandleEvent("破壊", MainPilot().ID);
                                    return;
                                }
                                // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                Map.MapDataForUnit[x, y] = null;
                                GUI.EraseUnitBitmap(x, y);
                                StandBy(x, y);
                            }

                            break;
                        }

                    case "水上":
                        {
                            if (!IsFeatureAvailable("水上移動") && !IsFeatureAvailable("ホバー移動"))
                            {
                                if (!IsAbleToEnter(x, y))
                                {
                                    GUI.Center(x, y);
                                    Escape();
                                    GUI.OpenMessageForm(u1: null, u2: null);
                                    GUI.DisplaySysMessage(Nickname + "は強制的に退却させられた。");
                                    GUI.CloseMessageForm();
                                    Event.HandleEvent("破壊", MainPilot().ID);
                                    return;
                                }
                                // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                Map.MapDataForUnit[x, y] = null;
                                GUI.EraseUnitBitmap(x, y);
                                StandBy(x, y);
                            }

                            break;
                        }

                    case "水中":
                        {
                            if (get_Adaption(3) == 0)
                            {
                                if (!IsAbleToEnter(x, y))
                                {
                                    GUI.Center(x, y);
                                    Escape();
                                    GUI.OpenMessageForm(u1: null, u2: null);
                                    GUI.DisplaySysMessage(Nickname + "は強制的に退却させられた。");
                                    GUI.CloseMessageForm();
                                    Event.HandleEvent("破壊", MainPilot().ID);
                                    return;
                                }
                                // UPGRADE_NOTE: オブジェクト MapDataForUnit() をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                                Map.MapDataForUnit[x, y] = null;
                                GUI.EraseUnitBitmap(x, y);
                                StandBy(x, y);
                            }

                            break;
                        }
                }
            }

            if (Status == "格納")
            {
                // 格納時は回復率ＵＰ
                // MOD START MARGE
                // If Not IsConditionSatisfied("回復不能") Then
                if (!IsConditionSatisfied("回復不能") && !IsSpecialPowerInEffect("回復不能"))
                {
                    // MOD END MARGE
                    hp_recovery = hp_recovery + 50;
                    en_recovery = en_recovery + 50;
                }

                // 弾数回復
                var loopTo8 = CountWeapon();
                for (i = 1; i <= loopTo8; i++)
                    dblBullet[i] = 1d;
                var loopTo9 = CountAbility();
                for (i = 1; i <= loopTo9; i++)
                    dblStock[i] = 1d;
            }
            else
            {
                // MOD START MARGE
                // '格納されてない場合は地形による回復修正
                // If Not IsConditionSatisfied("回復不能") Then
                // hp_recovery = hp_recovery + TerrainEffectForHPRecover(X, Y)
                // en_recovery = en_recovery + TerrainEffectForENRecover(X, Y)
                // End If
                // 
                // '地形による減少修正＆状態付加
                // Set td = TDList.Item(MapData(X, Y, 0))
                // With td
                // For i = 1 To .CountFeature
                // Select Case .Feature(i)
                // Case "ＨＰ減少"
                // If Weakness(.FeatureData(i)) Then
                // hp_recovery = hp_recovery - 20 * .FeatureLevel(i)
                // ElseIf Effective(.FeatureData(i)) Then
                // hp_recovery = hp_recovery - 10 * .FeatureLevel(i)
                // ElseIf Not Immune(.FeatureData(i)) Then
                // If Absorb(.FeatureData(i)) Then
                // hp_recovery = hp_recovery + 10 * .FeatureLevel(i)
                // ElseIf Resist(.FeatureData(i)) Then
                // hp_recovery = hp_recovery - 5 * .FeatureLevel(i)
                // Else
                // hp_recovery = hp_recovery - 10 * .FeatureLevel(i)
                // End If
                // End If
                // 
                // Case "ＥＮ減少"
                // If Weakness(.FeatureData(i)) Then
                // en_recovery = en_recovery - 20 * .FeatureLevel(i)
                // ElseIf Effective(.FeatureData(i)) Then
                // en_recovery = en_recovery - 10 * .FeatureLevel(i)
                // ElseIf Not Immune(.FeatureData(i)) Then
                // If Absorb(.FeatureData(i)) Then
                // en_recovery = en_recovery + 10 * .FeatureLevel(i)
                // ElseIf Resist(.FeatureData(i)) Then
                // en_recovery = en_recovery - 5 * .FeatureLevel(i)
                // Else
                // en_recovery = en_recovery - 10 * .FeatureLevel(i)
                // End If
                // End If
                // 
                // Case "ＨＰ増加"
                // If Not IsConditionSatisfied("回復不能") Then
                // hp_up = hp_up + 1000 * .FeatureLevel(i)
                // End If
                // 
                // Case "ＥＮ増加"
                // If Not IsConditionSatisfied("回復不能") Then
                // en_up = en_up + 10 * .FeatureLevel(i)
                // End If
                // 
                // Case "ＨＰ低下"
                // If Weakness(.FeatureData(i)) Then
                // hp_up = hp_up - 2000 * .FeatureLevel(i)
                // ElseIf Effective(.FeatureData(i)) Then
                // hp_up = hp_up - 1000 * .FeatureLevel(i)
                // ElseIf Not Immune(.FeatureData(i)) Then
                // If Absorb(.FeatureData(i)) Then
                // hp_up = hp_up + 1000 * .FeatureLevel(i)
                // ElseIf Resist(.FeatureData(i)) Then
                // hp_up = hp_up - 500 * .FeatureLevel(i)
                // Else
                // hp_up = hp_up - 1000 * .FeatureLevel(i)
                // End If
                // End If
                // 
                // Case "ＥＮ低下"
                // If Weakness(.FeatureData(i)) Then
                // en_up = en_up - 20 * .FeatureLevel(i)
                // ElseIf Effective(.FeatureData(i)) Then
                // en_up = en_up - 10 * .FeatureLevel(i)
                // ElseIf Not Immune(.FeatureData(i)) Then
                // If Absorb(.FeatureData(i)) Then
                // en_up = en_up + 10 * .FeatureLevel(i)
                // ElseIf Resist(.FeatureData(i)) Then
                // en_up = en_up - 5 * .FeatureLevel(i)
                // Else
                // en_up = en_up - 10 * .FeatureLevel(i)
                // End If
                // End If
                // 
                // Case "状態付加"
                // cname = .FeatureData(i)
                // 
                // '状態が無効化されるかチェック
                // Select Case cname
                // Case "装甲劣化"
                // If SpecialEffectImmune("劣") Then
                // cname = ""
                // End If
                // Case "混乱"
                // If SpecialEffectImmune("乱") Then
                // cname = ""
                // End If
                // Case "恐怖"
                // If SpecialEffectImmune("恐") Then
                // cname = ""
                // End If
                // Case "踊り"
                // If SpecialEffectImmune("踊") Then
                // cname = ""
                // End If
                // Case "狂戦士"
                // If SpecialEffectImmune("狂") Then
                // cname = ""
                // End If
                // Case "ゾンビ"
                // If SpecialEffectImmune("ゾ") Then
                // cname = ""
                // End If
                // Case "回復不能"
                // If SpecialEffectImmune("害") Then
                // cname = ""
                // End If
                // Case "石化"
                // If SpecialEffectImmune("石") Then
                // cname = ""
                // End If
                // Case "凍結"
                // If SpecialEffectImmune("凍") Then
                // cname = ""
                // End If
                // Case "麻痺"
                // If SpecialEffectImmune("痺") Then
                // cname = ""
                // End If
                // Case "睡眠"
                // If SpecialEffectImmune("眠") Then
                // cname = ""
                // End If
                // Case "毒"
                // If SpecialEffectImmune("毒") Then
                // cname = ""
                // End If
                // Case "盲目"
                // If SpecialEffectImmune("盲") Then
                // cname = ""
                // End If
                // Case "沈黙"
                // If SpecialEffectImmune("黙") Then
                // cname = ""
                // End If
                // '属性使用不能状態
                // Case "オーラ使用不能"
                // If SpecialEffectImmune("剋オ") Then
                // cname = ""
                // End If
                // Case "超能力使用不能"
                // If SpecialEffectImmune("剋超") Then
                // cname = ""
                // End If
                // Case "同調率使用不能"
                // If SpecialEffectImmune("剋シ") Then
                // cname = ""
                // End If
                // Case "超感覚使用不能"
                // If SpecialEffectImmune("剋サ") Then
                // cname = ""
                // End If
                // Case "知覚強化使用不能"
                // If SpecialEffectImmune("剋サ") Then
                // cname = ""
                // End If
                // Case "霊力使用不能"
                // If SpecialEffectImmune("剋霊") Then
                // cname = ""
                // End If
                // Case "術使用不能"
                // If SpecialEffectImmune("剋術") Then
                // cname = ""
                // End If
                // Case "技使用不能"
                // If SpecialEffectImmune("剋技") Then
                // cname = ""
                // End If
                // Case Else
                // If Len(cname) > 6 Then
                // If Right$(cname, 6) = "属性弱点付加" Then
                // If SpecialEffectImmune("弱" && Left$(cname, Len(cname) - 6)) _
                // '                                            Or Absorb(Left$(cname, Len(cname) - 6)) _
                // '                                            Or Immune(Left$(cname, Len(cname) - 6)) _
                // '                                        Then
                // cname = ""
                // End If
                // ElseIf Right$(cname, 6) = "属性有効付加" Then
                // If SpecialEffectImmune("有" && Left$(cname, Len(cname) - 6)) _
                // '                                            Or Absorb(Left$(cname, Len(cname) - 6)) _
                // '                                            Or Immune(Left$(cname, Len(cname) - 6)) _
                // '                                        Then
                // cname = ""
                // End If
                // ElseIf Right$(cname, 6) = "属性使用不能" Then
                // If SpecialEffectImmune("剋" && Left$(cname, Len(cname) - 6)) Then
                // cname = ""
                // End If
                // End If
                // End If
                // End Select
                // 
                // If cname <> "" Then
                // If .IsFeatureLevelSpecified(i) Then
                // AddCondition cname, .FeatureLevel(i)
                // Else
                // AddCondition cname, 10000
                // End If
                // End If
                // End Select
                // Next
                // End With
                // 格納されてない場合は地形による各種修正＆状態付加
                // MOD START 240a
                // Set td = TDList.Item(MapData(X, Y, 0))
                // レイヤーの状態に応じて上層下層どちらを取得するか判別
                switch (Map.MapData[x, y, Map.MapDataIndex.BoxType])
                {
                    case Map.BoxTypes.Under:
                    case Map.BoxTypes.UpperBmpOnly:
                        {
                            td = SRC.TDList.Item(Map.MapData[x, y, Map.MapDataIndex.TerrainType]);
                            break;
                        }

                    default:
                        {
                            td = SRC.TDList.Item(Map.MapData[x, y, Map.MapDataIndex.LayerType]);
                            break;
                        }
                }
                // MOD START 240a
                // 地形効果が適用される位置にいるかを判定
                if (td.IsFeatureAvailable("効果範囲"))
                {
                    var loopTo10 = GeneralLib.LLength(td.FeatureData("効果範囲"));
                    for (i = 1; i <= loopTo10; i++)
                    {
                        string localLIndex5() { object argIndex1 = "効果範囲"; string arglist = td.FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, i); return ret; }

                        if ((Area ?? "") == (localLIndex5() ?? ""))
                        {
                            is_terrain_effective = true;
                            break;
                        }
                    }
                }
                else
                {
                    is_terrain_effective = true;
                }

                // 地形効果に対する無効化能力を持っているか
                if (IsFeatureAvailable("地形効果無効化"))
                {
                    if (GeneralLib.LLength(FeatureData(argIndex30)) > 1)
                    {
                        var loopTo11 = GeneralLib.LLength(FeatureData("地形効果無効化"));
                        for (i = 2; i <= loopTo11; i++)
                        {
                            string localLIndex6() { object argIndex1 = "地形効果無効化"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, i); return ret; }

                            if ((td.Name ?? "") == (localLIndex6() ?? ""))
                            {
                                is_immune_to_terrain_effect = true;
                                break;
                            }
                        }
                    }
                    else
                    {
                        is_immune_to_terrain_effect = true;
                    }
                }
                else if (IsSpecialPowerInEffect("地形効果無効化"))
                {
                    is_immune_to_terrain_effect = true;
                }

                // 地形効果を適用
                if (is_terrain_effective)
                {
                    var loopTo12 = td.CountFeature();
                    for (i = 1; i <= loopTo12; i++)
                    {
                        if (!IsConditionSatisfied("回復不能") && !IsSpecialPowerInEffect("回復不能"))
                        {
                            switch (td.Feature(i) ?? "")
                            {
                                case "ＨＰ回復":
                                    {
                                        double localFeatureLevel() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                        hp_recovery = (hp_recovery + 10d * localFeatureLevel());
                                        break;
                                    }

                                case "ＥＮ回復":
                                    {
                                        double localFeatureLevel1() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                        en_recovery = (en_recovery + 10d * localFeatureLevel1());
                                        break;
                                    }

                                case "ＨＰ増加":
                                    {
                                        double localFeatureLevel2() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                        hp_up = (hp_up + 1000d * localFeatureLevel2());
                                        break;
                                    }

                                case "ＥＮ増加":
                                    {
                                        double localFeatureLevel3() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                        en_up = (en_up + 10d * localFeatureLevel3());
                                        break;
                                    }
                            }
                        }

                        if (!is_immune_to_terrain_effect)
                        {
                            switch (td.Feature(i) ?? "")
                            {
                                case "ＨＰ減少":
                                    {
                                        string localFeatureData() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        string localFeatureData1() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localEffective() { string arganame = hs910888dc06c349a7b21a4df1e60d8c7a(); var ret = Effective(arganame); return ret; }

                                        string localFeatureData2() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localAbsorb() { string arganame = hs52033841100047b99c1279b816aeef70(); var ret = Absorb(arganame); return ret; }

                                        string localFeatureData3() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localResist() { string arganame = hsc6f55b713dcb4a289541bb10d274fe96(); var ret = Resist(arganame); return ret; }

                                        string localFeatureData4() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localImmune() { string arganame = hs7f2e711ffdc34440b08ea8add7c269ee(); var ret = Immune(arganame); return ret; }

                                        if (Weakness(localFeatureData()))
                                        {
                                            double localFeatureLevel4() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            hp_recovery = (hp_recovery - 20d * localFeatureLevel4());
                                        }
                                        else if (localEffective())
                                        {
                                            double localFeatureLevel5() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            hp_recovery = (hp_recovery - 10d * localFeatureLevel5());
                                        }
                                        else if (localAbsorb())
                                        {
                                            double localFeatureLevel6() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            hp_recovery = (hp_recovery + 10d * localFeatureLevel6());
                                        }
                                        else if (localResist())
                                        {
                                            double localFeatureLevel7() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            hp_recovery = (hp_recovery - 5d * localFeatureLevel7());
                                        }
                                        else if (!localImmune())
                                        {
                                            double localFeatureLevel8() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            hp_recovery = (hp_recovery - 10d * localFeatureLevel8());
                                        }

                                        break;
                                    }

                                case "ＥＮ減少":
                                    {
                                        string localFeatureData5() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        string localFeatureData6() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localEffective1() { string arganame = hs3c05c0f0f5c74d50b2ebe668e4cefb50(); var ret = Effective(arganame); return ret; }

                                        string localFeatureData7() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localAbsorb1() { string arganame = hsf2d45f6c0d3242c088a863c924424bdc(); var ret = Absorb(arganame); return ret; }

                                        string localFeatureData8() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localResist1() { string arganame = hs2feadcdb67784d8bb37649df03e02004(); var ret = Resist(arganame); return ret; }

                                        string localFeatureData9() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localImmune1() { string arganame = hs2ea0185e20964cc686bdf2ee374b1db5(); var ret = Immune(arganame); return ret; }

                                        if (Weakness(localFeatureData5()))
                                        {
                                            double localFeatureLevel9() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            en_recovery = (en_recovery - 20d * localFeatureLevel9());
                                        }
                                        else if (localEffective1())
                                        {
                                            double localFeatureLevel10() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            en_recovery = (en_recovery - 10d * localFeatureLevel10());
                                        }
                                        else if (localAbsorb1())
                                        {
                                            double localFeatureLevel11() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            en_recovery = (en_recovery + 10d * localFeatureLevel11());
                                        }
                                        else if (localResist1())
                                        {
                                            double localFeatureLevel12() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            en_recovery = (en_recovery - 5d * localFeatureLevel12());
                                        }
                                        else if (!localImmune1())
                                        {
                                            double localFeatureLevel13() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            en_recovery = (en_recovery - 10d * localFeatureLevel13());
                                        }

                                        break;
                                    }

                                case "ＨＰ低下":
                                    {
                                        string localFeatureData10() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        string localFeatureData11() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localEffective2() { string arganame = hsde07f92cead745858b4d820263f53c91(); var ret = Effective(arganame); return ret; }

                                        string localFeatureData12() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localAbsorb2() { string arganame = hs94c6cc3a1d3d4ca68ebec987f086a962(); var ret = Absorb(arganame); return ret; }

                                        string localFeatureData13() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localResist2() { string arganame = hs736b9f12f5c24c189d82474b29c54514(); var ret = Resist(arganame); return ret; }

                                        string localFeatureData14() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localImmune2() { string arganame = hs125e0e0f0c7f4295afab6bc4e0bdd8b7(); var ret = Immune(arganame); return ret; }

                                        if (Weakness(localFeatureData10()))
                                        {
                                            double localFeatureLevel14() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            hp_up = (hp_up - 2000d * localFeatureLevel14());
                                        }
                                        else if (localEffective2())
                                        {
                                            double localFeatureLevel15() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            hp_up = (hp_up - 1000d * localFeatureLevel15());
                                        }
                                        else if (localAbsorb2())
                                        {
                                            double localFeatureLevel16() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            hp_up = (hp_up + 1000d * localFeatureLevel16());
                                        }
                                        else if (localResist2())
                                        {
                                            double localFeatureLevel17() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            hp_up = (hp_up - 500d * localFeatureLevel17());
                                        }
                                        else if (!localImmune2())
                                        {
                                            double localFeatureLevel18() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            hp_up = (hp_up - 1000d * localFeatureLevel18());
                                        }

                                        break;
                                    }

                                case "ＥＮ低下":
                                    {
                                        string localFeatureData15() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        string localFeatureData16() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localEffective3() { string arganame = hs19293752f23e4276b0cbef58767f8358(); var ret = Effective(arganame); return ret; }

                                        string localFeatureData17() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localAbsorb3() { string arganame = hs5c8089f996604cf3acee553527084f88(); var ret = Absorb(arganame); return ret; }

                                        string localFeatureData18() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localResist3() { string arganame = hs7282195c4a7b4004aadd6adbd33a9a60(); var ret = Resist(arganame); return ret; }

                                        string localFeatureData19() { object argIndex1 = i; var ret = td.FeatureData(argIndex1); return ret; }

                                        bool localImmune3() { string arganame = hs18e2d5e0cbb14782bbf344a497c3c2ed(); var ret = Immune(arganame); return ret; }

                                        if (Weakness(localFeatureData15()))
                                        {
                                            double localFeatureLevel19() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            en_up = (en_up - 20d * localFeatureLevel19());
                                        }
                                        else if (localEffective3())
                                        {
                                            double localFeatureLevel20() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            en_up = (en_up - 10d * localFeatureLevel20());
                                        }
                                        else if (localAbsorb3())
                                        {
                                            double localFeatureLevel21() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            en_up = (en_up + 10d * localFeatureLevel21());
                                        }
                                        else if (localResist3())
                                        {
                                            double localFeatureLevel22() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            en_up = (en_up - 5d * localFeatureLevel22());
                                        }
                                        else if (!localImmune3())
                                        {
                                            double localFeatureLevel23() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                            en_up = (en_up - 10d * localFeatureLevel23());
                                        }

                                        break;
                                    }

                                case "状態付加":
                                    {
                                        cname = td.FeatureData(i);

                                        // 状態が無効化されるかチェック
                                        switch (cname ?? "")
                                        {
                                            case "装甲劣化":
                                                {
                                                    if (SpecialEffectImmune("劣"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "混乱":
                                                {
                                                    if (SpecialEffectImmune("乱"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "恐怖":
                                                {
                                                    if (SpecialEffectImmune("恐"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "踊り":
                                                {
                                                    if (SpecialEffectImmune("踊"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "狂戦士":
                                                {
                                                    if (SpecialEffectImmune("狂"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "ゾンビ":
                                                {
                                                    if (SpecialEffectImmune("ゾ"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "回復不能":
                                                {
                                                    if (SpecialEffectImmune("害"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "石化":
                                                {
                                                    if (SpecialEffectImmune("石"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "凍結":
                                                {
                                                    if (SpecialEffectImmune("凍"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "麻痺":
                                                {
                                                    if (SpecialEffectImmune("痺"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "睡眠":
                                                {
                                                    if (SpecialEffectImmune("眠"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "毒":
                                                {
                                                    if (SpecialEffectImmune("毒"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "盲目":
                                                {
                                                    if (SpecialEffectImmune("盲"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "沈黙":
                                                {
                                                    if (SpecialEffectImmune("黙"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }
                                            // 属性使用不能状態
                                            case "オーラ使用不能":
                                                {
                                                    if (SpecialEffectImmune("剋オ"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "超能力使用不能":
                                                {
                                                    if (SpecialEffectImmune("剋超"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "同調率使用不能":
                                                {
                                                    if (SpecialEffectImmune("剋シ"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "超感覚使用不能":
                                                {
                                                    if (SpecialEffectImmune("剋サ"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "知覚強化使用不能":
                                                {
                                                    if (SpecialEffectImmune("剋サ"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "霊力使用不能":
                                                {
                                                    if (SpecialEffectImmune("剋霊"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "術使用不能":
                                                {
                                                    if (SpecialEffectImmune("剋術"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            case "技使用不能":
                                                {
                                                    if (SpecialEffectImmune("剋技"))
                                                    {
                                                        cname = "";
                                                    }

                                                    break;
                                                }

                                            default:
                                                {
                                                    if (Strings.Len(cname) > 6)
                                                    {
                                                        if (Strings.Right(cname, 6) == "属性弱点付加")
                                                        {
                                                            bool localSpecialEffectImmune() { string arganame = "弱" + Strings.Left(cname, Strings.Len(cname) - 6); var ret = SpecialEffectImmune(arganame); return ret; }

                                                            bool localAbsorb4() { string arganame = Strings.Left(cname, Strings.Len(cname) - 6); var ret = Absorb(arganame); return ret; }

                                                            bool localImmune4() { string arganame = Strings.Left(cname, Strings.Len(cname) - 6); var ret = Immune(arganame); return ret; }

                                                            if (localSpecialEffectImmune() || localAbsorb4() || localImmune4())
                                                            {
                                                                cname = "";
                                                            }
                                                        }
                                                        else if (Strings.Right(cname, 6) == "属性有効付加")
                                                        {
                                                            bool localSpecialEffectImmune1() { string arganame = "有" + Strings.Left(cname, Strings.Len(cname) - 6); var ret = SpecialEffectImmune(arganame); return ret; }

                                                            bool localAbsorb5() { string arganame = Strings.Left(cname, Strings.Len(cname) - 6); var ret = Absorb(arganame); return ret; }

                                                            bool localImmune5() { string arganame = Strings.Left(cname, Strings.Len(cname) - 6); var ret = Immune(arganame); return ret; }

                                                            if (localSpecialEffectImmune1() || localAbsorb5() || localImmune5())
                                                            {
                                                                cname = "";
                                                            }
                                                        }
                                                        else if (Strings.Right(cname, 6) == "属性使用不能")
                                                        {
                                                            if (SpecialEffectImmune("剋" + Strings.Left(cname, Strings.Len(cname) - 6)))
                                                            {
                                                                cname = "";
                                                            }
                                                        }
                                                    }

                                                    break;
                                                }
                                        }

                                        if (!string.IsNullOrEmpty(cname))
                                        {
                                            if (td.IsFeatureLevelSpecified(i))
                                            {
                                                double localFeatureLevel24() { object argIndex1 = i; var ret = td.FeatureLevel(argIndex1); return ret; }

                                                AddCondition(cname, localFeatureLevel24(), cdata: "");
                                            }
                                            else
                                            {
                                                AddCondition(cname, 10000, cdata: "");
                                            }
                                        }

                                        break;
                                    }
                            }
                        }
                    }
                }
                // MOD END MARGE
            }

            // ＥＮは毎ターン5回復
            // MOD START MARGE
            // If Not IsConditionSatisfied("回復不能") _
            // '        And Not IsOptionDefined("ＥＮ自然回復無効") _
            // '    Then
            if (!IsConditionSatisfied("回復不能") && !IsSpecialPowerInEffect("回復不能") && !Expression.IsOptionDefined("ＥＮ自然回復無効"))
            {
                // MOD END MARGE
                EN = EN + 5;
            }

            // 算出した回復率を使ってＨＰを回復
            HP = HP + MaxHP * hp_recovery / 100 + hp_up;
            if (HP <= 0)
            {
                HP = 1;
            }

            // 特殊能力「不安定」による暴走チェック
            if (IsFeatureAvailable("不安定"))
            {
                if (HP <= MaxHP / 4 && !IsConditionSatisfied("暴走"))
                {
                    AddCondition("暴走", -1, cdata: "");
                }
            }

            // 算出した回復率を使ってＥＮを回復
            if (EN + MaxEN * en_recovery / 100 + en_up > 0)
            {
                EN = EN + MaxEN * en_recovery / 100 + en_up;
            }
            else
            {
                // ＥＮが減少して０になる場合はハイパーモード解除もしくは行動不能
                if (IsFeatureAvailable("ノーマルモード"))
                {
                    // ただしノーマルモードに戻れない地形だとそのまま退却……
                    string localLIndex8() { object argIndex1 = "ノーマルモード"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                    Unit localOtherForm() { object argIndex1 = (object)hs35732b48c6874150a97edd31eb6e765a(); var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm().IsAbleToEnter(x, y))
                    {
                        string localLIndex7() { object argIndex1 = "ノーマルモード"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                        Transform(localLIndex7());
                    }
                    else
                    {
                        GUI.Center(x, y);
                        Escape();
                        GUI.OpenMessageForm(u1: null, u2: null);
                        GUI.DisplaySysMessage(Nickname + "は強制的に退却させられた。");
                        GUI.CloseMessageForm();
                        Event.HandleEvent("破壊", MainPilot().ID);
                        return;
                    }
                }
                else if (IsFeatureAvailable("変形"))
                {
                    // 変形できれば変形
                    buf = FeatureData("変形");
                    var loopTo13 = GeneralLib.LLength(buf);
                    for (i = 2; i <= loopTo13; i++)
                    {
                        {
                            var withBlock9 = OtherForm(GeneralLib.LIndex(buf, i));
                            if (withBlock9.IsAbleToEnter(x, y) && !withBlock9.IsFeatureAvailable("ＥＮ消費"))
                            {
                                Transform(GeneralLib.LIndex(buf, i));
                                break;
                            }
                        }
                    }

                    if (i > GeneralLib.LLength(buf))
                    {
                        EN = 0;
                    }
                }
                else
                {
                    EN = 0;
                }
            }

            // データ更新
            Update();

            // 時間切れ？
            if (is_time_limit)
            {
                if (!string.IsNullOrEmpty(next_form))
                {
                    // ハイパーモード＆変身の時間切れ
                    u = OtherForm(next_form);
                    if (u.IsAbleToEnter(x, y))
                    {
                        // ダイアログでメッセージを表示させるため追加パイロットをあらかじめ作成
                        if (u.IsFeatureAvailable("追加パイロット"))
                        {
                            bool localIsDefined() { object argIndex1 = "追加パイロット"; object argIndex2 = u.FeatureData(argIndex1); var ret = SRC.PList.IsDefined(argIndex2); return ret; }

                            if (!localIsDefined())
                            {
                                SRC.PList.Add(u.FeatureData("追加パイロット"), MainPilot().Level, Party0, gid: "");
                                this.Party0 = argpparty;
                            }
                        }

                        // ノーマルモードメッセージ
                        bool localIsMessageDefined() { string argmain_situation = "ノーマルモード(" + u.Name + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                        if (IsMessageDefined("ノーマルモード(" + Name + "=>" + u.Name + ")"))
                        {
                            GUI.OpenMessageForm(u1: null, u2: null);
                            PilotMessage("ノーマルモード(" + Name + "=>" + u.Name + ")", msg_mode: "");
                            GUI.CloseMessageForm();
                        }
                        else if (localIsMessageDefined())
                        {
                            GUI.OpenMessageForm(u1: null, u2: null);
                            PilotMessage("ノーマルモード(" + u.Name + ")", msg_mode: "");
                            GUI.CloseMessageForm();
                        }
                        else if (IsMessageDefined("ノーマルモード"))
                        {
                            GUI.OpenMessageForm(u1: null, u2: null);
                            PilotMessage("ノーマルモード", msg_mode: "");
                            GUI.CloseMessageForm();
                        }
                        // 特殊効果
                        bool localIsSpecialEffectDefined() { string argmain_situation = "ノーマルモード(" + u.Name + ")"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                        if (IsSpecialEffectDefined("ノーマルモード(" + Name + "=>" + u.Name + ")", sub_situation: ""))
                        {
                            SpecialEffect("ノーマルモード(" + Name + "=>" + u.Name + ")", sub_situation: "");
                        }
                        else if (localIsSpecialEffectDefined())
                        {
                            SpecialEffect("ノーマルモード(" + u.Name + ")", sub_situation: "");
                        }
                        else if (IsSpecialEffectDefined("ノーマルモード", sub_situation: ""))
                        {
                            SpecialEffect("ノーマルモード", sub_situation: "");
                        }

                        // 変形
                        string localLIndex9() { object argIndex1 = "ノーマルモード"; string arglist = FeatureData(argIndex1); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                        Transform(localLIndex9());
                    }
                    else
                    {
                        // 変形するとその地形にいれなくなる場合は退却
                        GUI.Center(x, y);
                        Escape();
                        GUI.OpenMessageForm(u1: null, u2: null);
                        GUI.DisplaySysMessage(Nickname + "は強制的に退却させられた。");
                        GUI.CloseMessageForm();
                        Event.HandleEvent("破壊", MainPilot().ID);
                        return;
                    }
                }
                else if (IsFeatureAvailable("分離"))
                {
                    // 合体時間切れ

                    // メッセージ表示
                    bool localIsMessageDefined2() { string argmain_situation = "分離(" + Name + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                    bool localIsMessageDefined3() { object argIndex1 = "分離"; string argmain_situation = "分離(" + FeatureName(argIndex1) + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                    if (localIsMessageDefined2() || localIsMessageDefined3() || IsMessageDefined("分離"))
                    {
                        if (IsFeatureAvailable("分離ＢＧＭ"))
                        {
                            Sound.StartBGM(FeatureData("分離ＢＧＭ"));
                            GUI.Sleep(500);
                        }
                        else if (MainPilot().BGM != "-")
                        {
                            Sound.StartBGM(MainPilot().BGM);
                            MainPilot().BGM = argbgm_name1;
                            GUI.Sleep(500);
                        }

                        GUI.Center(x, y);
                        GUI.RefreshScreen();
                        GUI.OpenMessageForm(u1: null, u2: null);
                        bool localIsMessageDefined1() { object argIndex1 = "分離"; string argmain_situation = "分離(" + FeatureName(argIndex1) + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                        if (IsMessageDefined("分離(" + Name + ")"))
                        {
                            PilotMessage("分離(" + Name + ")", msg_mode: "");
                        }
                        else if (localIsMessageDefined1())
                        {
                            PilotMessage("分離(" + FeatureName("分離") + ")", msg_mode: "");
                        }
                        else
                        {
                            PilotMessage("分離", msg_mode: "");
                        }

                        GUI.CloseMessageForm();
                    }
                    // 特殊効果
                    bool localIsSpecialEffectDefined1() { object argIndex1 = "分離"; string argmain_situation = "分離(" + FeatureName(argIndex1) + ")"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

                    if (IsSpecialEffectDefined("分離(" + Name + ")", sub_situation: ""))
                    {
                        SpecialEffect("分離(" + Name + ")", sub_situation: "");
                    }
                    else if (localIsSpecialEffectDefined1())
                    {
                        SpecialEffect("分離(" + FeatureName("分離") + ")", sub_situation: "");
                    }
                    else
                    {
                        SpecialEffect("分離", sub_situation: "");
                    }

                    // 分離
                    Split();
                }
                else
                {
                    // 制限時間切れ
                    GUI.Center(x, y);
                    GUI.RefreshScreen();
                    GUI.OpenMessageForm(u1: null, u2: null);
                    GUI.DisplaySysMessage(Nickname + "は制限時間切れのため退却します。");
                    GUI.CloseMessageForm();
                    Escape();
                    Event.HandleEvent("破壊", MainPilot().ID);
                    return;
                }
            }

            // ハイパーモード＆ノーマルモードの自動発動をチェック
            CurrentForm().CheckAutoHyperMode();
            CurrentForm().CheckAutoNormalMode();
        }

        // ハイパーモードの自動発動チェック
        public void CheckAutoHyperMode()
        {
            bool is_available, message_window_visible = default;
            string fname, fdata;
            double flevel;
            string uname;
            int i;

            // ハイパーモードが自動発動するか判定

            if (Status != "出撃")
            {
                return;
            }

            if (!IsFeatureAvailable("ハイパーモード"))
            {
                return;
            }

            fname = FeatureName("ハイパーモード");
            flevel = FeatureLevel("ハイパーモード");
            fdata = FeatureData("ハイパーモード");
            if (Strings.InStr(fdata, "自動発動") == 0)
            {
                return;
            }

            // 発動条件を満たす？
            if (this.MainPilot().Morale < (10d * flevel) + 100 && (HP > MaxHP / 4 || Strings.InStr(fdata, "気力発動") > 0))
            {
                return;
            }

            // 変身中・能力コピー中はハイパーモードを使用できない
            if (IsConditionSatisfied("ノーマルモード付加"))
            {
                return;
            }

            // ハイパーモード先の形態が利用可能？
            uname = GeneralLib.LIndex(fdata, 2);
            is_available = false;
            {
                var withBlock = OtherForm(uname);
                switch (Map.TerrainClass(x, y) ?? "")
                {
                    case "空":
                        {
                            if (withBlock.IsTransAvailable("空"))
                            {
                                is_available = true;
                            }

                            break;
                        }

                    case "深水":
                        {
                            if (withBlock.IsTransAvailable("空") || withBlock.IsTransAvailable("水") || withBlock.IsTransAvailable("水上"))
                            {
                                is_available = true;
                            }

                            break;
                        }

                    default:
                        {
                            is_available = true;
                            break;
                        }
                }

                if (!withBlock.IsAbleToEnter(x, y))
                {
                    is_available = false;
                }
            }

            // 自動発動する？
            if (!is_available)
            {
                return;
            }

            // ダイアログでメッセージを表示させるため追加パイロットをあらかじめ作成
            if (SRC.UDList.IsDefined(uname))
            {
                {
                    var withBlock1 = SRC.UDList.Item(uname);
                    if (IsFeatureAvailable("追加パイロット"))
                    {
                        bool localIsDefined() { object argIndex1 = "追加パイロット"; object argIndex2 = FeatureData(argIndex1); var ret = SRC.PList.IsDefined(argIndex2); return ret; }

                        if (!localIsDefined())
                        {
                            SRC.PList.Add(FeatureData("追加パイロット"), MainPilot().Level, Party0, gid: "");
                            this.Party0 = argpparty;
                        }
                    }
                }
            }

            // ＢＧＭを切り替え
            if (IsFeatureAvailable("ハイパーモードＢＧＭ"))
            {
                var loopTo = CountFeature();
                for (i = 1; i <= loopTo; i++)
                {
                    string localFeature() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                    string localFeatureData2() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                    string localLIndex() { string arglist = hs2eb6d7953f284c87970de1e6c7ca058d(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                    if (localFeature() == "ハイパーモードＢＧＭ" && (localLIndex() ?? "") == (uname ?? ""))
                    {
                        string localFeatureData() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        string localFeatureData1() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        Sound.StartBGM(Strings.Mid(localFeatureData(), Strings.InStr(localFeatureData1(), " ") + 1));
                        GUI.Sleep(500);
                        break;
                    }
                }
            }

            // メッセージを表示
            bool localIsMessageDefined2() { string argmain_situation = "ハイパーモード(" + Name + "=>" + uname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

            bool localIsMessageDefined3() { string argmain_situation = "ハイパーモード(" + uname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

            bool localIsMessageDefined4() { string argmain_situation = "ハイパーモード(" + fname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

            if (localIsMessageDefined2() || localIsMessageDefined3() || localIsMessageDefined4() || IsMessageDefined("ハイパーモード"))
            {
                GUI.Center(x, y);
                GUI.RefreshScreen();
                if (!message_window_visible)
                {
                    GUI.OpenMessageForm(u1: null, u2: null);
                }
                else
                {
                    message_window_visible = true;
                }

                // メッセージを表示
                bool localIsMessageDefined() { string argmain_situation = "ハイパーモード(" + uname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                bool localIsMessageDefined1() { string argmain_situation = "ハイパーモード(" + fname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                if (IsMessageDefined("ハイパーモード(" + Name + "=>" + uname + ")"))
                {
                    PilotMessage("ハイパーモード(" + Name + "=>" + uname + ")", msg_mode: "");
                }
                else if (localIsMessageDefined())
                {
                    PilotMessage("ハイパーモード(" + uname + ")", msg_mode: "");
                }
                else if (localIsMessageDefined1())
                {
                    PilotMessage("ハイパーモード(" + fname + ")", msg_mode: "");
                }
                else
                {
                    PilotMessage("ハイパーモード", msg_mode: "");
                }

                if (!message_window_visible)
                {
                    GUI.CloseMessageForm();
                }
            }

            // 特殊効果
            Commands.SaveSelections();
            Commands.SelectedUnit = this;
            Event.SelectedUnitForEvent = this;
            // UPGRADE_NOTE: オブジェクト SelectedTarget をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Commands.SelectedTarget = null;
            // UPGRADE_NOTE: オブジェクト SelectedTargetForEvent をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Event.SelectedTargetForEvent = null;
            bool localIsAnimationDefined() { string argmain_situation = "ハイパーモード(" + uname + ")"; string argsub_situation = ""; var ret = IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            bool localIsAnimationDefined1() { object argIndex1 = "ハイパーモード"; string argmain_situation = "ハイパーモード(" + FeatureName(argIndex1) + ")"; string argsub_situation = ""; var ret = IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            bool localIsSpecialEffectDefined() { string argmain_situation = "ハイパーモード(" + Name + "=>" + uname + ")"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            bool localIsSpecialEffectDefined1() { string argmain_situation = "ハイパーモード(" + uname + ")"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            bool localIsSpecialEffectDefined2() { string argmain_situation = "ハイパーモード(" + fname + ")"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            if (IsAnimationDefined("ハイパーモード(" + Name + "=>" + uname + ")", sub_situation: ""))
            {
                PlayAnimation("ハイパーモード(" + Name + "=>" + uname + ")", sub_situation: "");
            }
            else if (localIsAnimationDefined())
            {
                PlayAnimation("ハイパーモード(" + uname + ")", sub_situation: "");
            }
            else if (localIsAnimationDefined1())
            {
                PlayAnimation("ハイパーモード(" + FeatureName("ハイパーモード") + ")", sub_situation: "");
            }
            else if (IsAnimationDefined("ハイパーモード", sub_situation: ""))
            {
                PlayAnimation("ハイパーモード", sub_situation: "");
            }
            else if (localIsSpecialEffectDefined())
            {
                SpecialEffect("ハイパーモード(" + Name + "=>" + uname + ")", sub_situation: "");
            }
            else if (localIsSpecialEffectDefined1())
            {
                SpecialEffect("ハイパーモード(" + uname + ")", sub_situation: "");
            }
            else if (localIsSpecialEffectDefined2())
            {
                SpecialEffect("ハイパーモード(" + fname + ")", sub_situation: "");
            }
            else
            {
                SpecialEffect("ハイパーモード", sub_situation: "");
            }

            Commands.RestoreSelections();

            // ハイパーモードに変形
            Transform(uname);

            // ユニット変数を置き換え
            if (Commands.SelectedUnit is object)
            {
                if ((ID ?? "") == (Commands.SelectedUnit.ID ?? ""))
                {
                    Commands.SelectedUnit = CurrentForm();
                }
            }

            if (Event.SelectedUnitForEvent is object)
            {
                if ((ID ?? "") == (Event.SelectedUnitForEvent.ID ?? ""))
                {
                    Event.SelectedUnitForEvent = CurrentForm();
                }
            }

            if (Commands.SelectedTarget is object)
            {
                if ((ID ?? "") == (Commands.SelectedTarget.ID ?? ""))
                {
                    Commands.SelectedTarget = CurrentForm();
                }
            }

            if (Event.SelectedTargetForEvent is object)
            {
                if ((ID ?? "") == (Event.SelectedTargetForEvent.ID ?? ""))
                {
                    Event.SelectedTargetForEvent = CurrentForm();
                }
            }

            // 変形イベント
            {
                var withBlock2 = CurrentForm();
                Event.HandleEvent("変形", withBlock2.MainPilot().ID, withBlock2.Name);
            }
        }

        // ノーマルモードの自動発動チェック
        public bool CheckAutoNormalMode(bool without_redraw = false)
        {
            bool CheckAutoNormalModeRet = default;
            var message_window_visible = default(bool);
            string uname;
            int i;

            // ノーマルモードが自動発動するか判定

            if (Status != "出撃")
            {
                return CheckAutoNormalModeRet;
            }

            if (!IsFeatureAvailable("ノーマルモード"))
            {
                return CheckAutoNormalModeRet;
            }

            // まだ元の形態でもＯＫ？
            if (IsAbleToEnter(x, y))
            {
                return CheckAutoNormalModeRet;
            }

            // ノーマルモード先が利用可能？
            uname = GeneralLib.LIndex(FeatureData("ノーマルモード"), 1);
            Unit localOtherForm() { object argIndex1 = uname; var ret = OtherForm(argIndex1); return ret; }

            if (!localOtherForm().IsAbleToEnter(x, y))
            {
                return CheckAutoNormalModeRet;
            }

            // ダイアログでメッセージを表示させるため追加パイロットをあらかじめ作成
            if (SRC.UDList.IsDefined(uname))
            {
                {
                    var withBlock = SRC.UDList.Item(uname);
                    if (IsFeatureAvailable("追加パイロット"))
                    {
                        bool localIsDefined() { object argIndex1 = "追加パイロット"; object argIndex2 = FeatureData(argIndex1); var ret = SRC.PList.IsDefined(argIndex2); return ret; }

                        if (!localIsDefined())
                        {
                            SRC.PList.Add(FeatureData("追加パイロット"), MainPilot().Level, Party0, gid: "");
                            this.Party0 = argpparty;
                        }
                    }
                }
            }

            // メッセージを表示
            bool localIsMessageDefined1() { string argmain_situation = "ノーマルモード(" + Name + "=>" + uname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

            bool localIsMessageDefined2() { string argmain_situation = "ノーマルモード(" + uname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

            if (localIsMessageDefined1() || localIsMessageDefined2() || IsMessageDefined("ノーマルモード"))
            {
                // ＢＧＭを切り替え
                if (IsFeatureAvailable("ノーマルモードＢＧＭ"))
                {
                    var loopTo = CountFeature();
                    for (i = 1; i <= loopTo; i++)
                    {
                        string localFeature() { object argIndex1 = i; var ret = Feature(argIndex1); return ret; }

                        string localFeatureData2() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        string localLIndex() { string arglist = hsbe3464a93f8d41b68a3072a6446fded5(); var ret = GeneralLib.LIndex(arglist, 1); return ret; }

                        if (localFeature() == "ノーマルモードＢＧＭ" && (localLIndex() ?? "") == (uname ?? ""))
                        {
                            string localFeatureData() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            string localFeatureData1() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                            Sound.StartBGM(Strings.Mid(localFeatureData(), Strings.InStr(localFeatureData1(), " ") + 1));
                            GUI.Sleep(500);
                            break;
                        }
                    }
                }

                GUI.Center(x, y);
                GUI.RefreshScreen();
                if (!message_window_visible)
                {
                    GUI.OpenMessageForm(u1: null, u2: null);
                }
                else
                {
                    message_window_visible = true;
                }

                // メッセージを表示
                bool localIsMessageDefined() { string argmain_situation = "ノーマルモード(" + uname + ")"; var ret = IsMessageDefined(argmain_situation); return ret; }

                if (IsMessageDefined("ノーマルモード(" + Name + "=>" + uname + ")"))
                {
                    PilotMessage("ノーマルモード(" + Name + "=>" + uname + ")", msg_mode: "");
                }
                else if (localIsMessageDefined())
                {
                    PilotMessage("ノーマルモード(" + uname + ")", msg_mode: "");
                }
                else
                {
                    PilotMessage("ノーマルモード", msg_mode: "");
                }

                if (!message_window_visible)
                {
                    GUI.CloseMessageForm();
                }
            }

            // 特殊効果
            Commands.SaveSelections();
            Commands.SelectedUnit = this;
            Event.SelectedUnitForEvent = this;
            // UPGRADE_NOTE: オブジェクト SelectedTarget をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Commands.SelectedTarget = null;
            // UPGRADE_NOTE: オブジェクト SelectedTargetForEvent をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            Event.SelectedTargetForEvent = null;
            bool localIsAnimationDefined() { string argmain_situation = "ノーマルモード(" + uname + ")"; string argsub_situation = ""; var ret = IsAnimationDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            bool localIsSpecialEffectDefined() { string argmain_situation = "ノーマルモード(" + Name + "=>" + uname + ")"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            bool localIsSpecialEffectDefined1() { string argmain_situation = "ノーマルモード(" + uname + ")"; string argsub_situation = ""; var ret = IsSpecialEffectDefined(argmain_situation, sub_situation: argsub_situation); return ret; }

            if (IsAnimationDefined("ノーマルモード(" + Name + "=>" + uname + ")", sub_situation: ""))
            {
                PlayAnimation("ノーマルモード(" + Name + "=>" + uname + ")", sub_situation: "");
            }
            else if (localIsAnimationDefined())
            {
                PlayAnimation("ノーマルモード(" + uname + ")", sub_situation: "");
            }
            else if (IsAnimationDefined("ノーマルモード", sub_situation: ""))
            {
                PlayAnimation("ノーマルモード", sub_situation: "");
            }
            else if (localIsSpecialEffectDefined())
            {
                SpecialEffect("ノーマルモード(" + Name + "=>" + uname + ")", sub_situation: "");
            }
            else if (localIsSpecialEffectDefined1())
            {
                SpecialEffect("ノーマルモード(" + uname + ")", sub_situation: "");
            }
            else
            {
                SpecialEffect("ノーマルモード", sub_situation: "");
            }

            Commands.RestoreSelections();

            // ノーマルモードに変形
            Transform(uname);

            // ユニット変数を置き換え
            if (Commands.SelectedUnit is object)
            {
                if ((ID ?? "") == (Commands.SelectedUnit.ID ?? ""))
                {
                    Commands.SelectedUnit = CurrentForm();
                }
            }

            if (Event.SelectedUnitForEvent is object)
            {
                if ((ID ?? "") == (Event.SelectedUnitForEvent.ID ?? ""))
                {
                    Event.SelectedUnitForEvent = CurrentForm();
                }
            }

            if (Commands.SelectedTarget is object)
            {
                if ((ID ?? "") == (Commands.SelectedTarget.ID ?? ""))
                {
                    Commands.SelectedTarget = CurrentForm();
                }
            }

            if (Event.SelectedTargetForEvent is object)
            {
                if ((ID ?? "") == (Event.SelectedTargetForEvent.ID ?? ""))
                {
                    Event.SelectedTargetForEvent = CurrentForm();
                }
            }

            // 画面の再描画が必要？
            if (CurrentForm().IsConditionSatisfied("消耗"))
            {
                CheckAutoNormalModeRet = true;
                if (!without_redraw)
                {
                    GUI.RedrawScreen();
                }
            }

            // 変形イベント
            {
                var withBlock1 = CurrentForm();
                Event.HandleEvent("変形", withBlock1.MainPilot().ID, withBlock1.Name);
            }

            return CheckAutoNormalModeRet;
        }


        // データをリセット
        // UPGRADE_NOTE: Reset は Reset にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
        public void Reset()
        {
            int i;
            string pname;
            var loopTo = CountCondition();
            for (i = 1; i <= loopTo; i++)
            {
                DeleteCondition0(1);
            }

            RemoveAllSpecialPowerInEffect();
            Update();
            var loopTo1 = CountPilot();
            for (i = 1; i <= loopTo1; i++)
            {
                Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                localPilot().FullRecover();
            }

            var loopTo2 = CountSupport();
            for (i = 1; i <= loopTo2; i++)
            {
                Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                localSupport().FullRecover();
            }

            if (IsFeatureAvailable("追加パイロット"))
            {
                pname = FeatureData("追加パイロット");
                if (SRC.PList.IsDefined(pname))
                {
                    Pilot localItem() { object argIndex1 = pname; var ret = SRC.PList.Item(argIndex1); return ret; }

                    localItem().FullRecover();
                }
            }

            if (IsFeatureAvailable("追加サポート"))
            {
                pname = FeatureData("追加サポート");
                if (SRC.PList.IsDefined(pname))
                {
                    Pilot localItem1() { object argIndex1 = pname; var ret = SRC.PList.Item(argIndex1); return ret; }

                    localItem1().FullRecover();
                }
            }

            HP = MaxHP;
            FullSupply();
            Mode = "通常";
        }

        // 相手ユニットが敵かどうかを判定
        public bool IsEnemy(Unit t, bool for_move = false)
        {
            bool IsEnemyRet = default;
            string myparty, tparty;

            // 自分自身は常に味方
            if (ReferenceEquals(t, this))
            {
                IsEnemyRet = false;
                return IsEnemyRet;
            }

            // 暴走したユニットにとってはすべてが敵
            if (IsConditionSatisfied("暴走"))
            {
                IsEnemyRet = true;
                return IsEnemyRet;
            }

            // 混乱した場合はランダムで判定
            if (IsConditionSatisfied("混乱"))
            {
                if (for_move)
                {
                    IsEnemyRet = true;
                }
                else if (GeneralLib.Dice(2) == 1)
                {
                    IsEnemyRet = true;
                }
                else
                {
                    IsEnemyRet = false;
                }

                return IsEnemyRet;
            }

            myparty = Party;
            tparty = t.Party;

            // 味方ユニットは暴走、憑依、魅了したユニットを排除可能
            // (暴走した味方ユニットのPartyはＮＰＣとみなされる)
            if (myparty == "味方" && tparty == "ＮＰＣ")
            {
                if (t.IsConditionSatisfied("暴走") || t.IsConditionSatisfied("憑依") || t.IsConditionSatisfied("魅了"))
                {
                    IsEnemyRet = true;
                    return IsEnemyRet;
                }
            }

            if (myparty != "味方")
            {
                // ターゲットの陣営が限定されている場合、敵対関係にない陣営の
                // ユニットは味方と見なされる。
                // ただし、プレイヤーがコントロールするユニットはこのような自
                // 分を攻撃してこないユニットも排除可能。

                // 特定の陣営のみを狙う場合
                switch (Mode ?? "")
                {
                    case "味方":
                    case "ＮＰＣ":
                        {
                            switch (tparty ?? "")
                            {
                                case "味方":
                                case "ＮＰＣ":
                                    {
                                        IsEnemyRet = true;
                                        break;
                                    }

                                default:
                                    {
                                        IsEnemyRet = false;
                                        break;
                                    }
                            }

                            return IsEnemyRet;
                        }

                    case "敵":
                    case "中立":
                        {
                            if ((tparty ?? "") == (Mode ?? ""))
                            {
                                IsEnemyRet = true;
                            }
                            else
                            {
                                IsEnemyRet = false;
                            }

                            return IsEnemyRet;
                        }
                }

                // 相手が特定の陣営のみを狙う場合
                switch (t.Mode ?? "")
                {
                    case "味方":
                    case "ＮＰＣ":
                        {
                            switch (myparty ?? "")
                            {
                                case "味方":
                                case "ＮＰＣ":
                                    {
                                        IsEnemyRet = true;
                                        break;
                                    }

                                default:
                                    {
                                        IsEnemyRet = false;
                                        break;
                                    }
                            }

                            return IsEnemyRet;
                        }

                    case "敵":
                    case "中立":
                        {
                            if ((myparty ?? "") == (t.Mode ?? ""))
                            {
                                IsEnemyRet = true;
                            }
                            else
                            {
                                IsEnemyRet = false;
                            }

                            return IsEnemyRet;
                        }
                }
            }

            // 敵味方を判定
            switch (myparty ?? "")
            {
                case "味方":
                case "ＮＰＣ":
                    {
                        switch (tparty ?? "")
                        {
                            case "味方":
                            case "ＮＰＣ":
                                {
                                    IsEnemyRet = false;
                                    break;
                                }

                            default:
                                {
                                    IsEnemyRet = true;
                                    break;
                                }
                        }

                        break;
                    }

                default:
                    {
                        if ((myparty ?? "") == (tparty ?? ""))
                        {
                            IsEnemyRet = false;
                        }
                        else
                        {
                            IsEnemyRet = true;
                        }

                        break;
                    }
            }

            return IsEnemyRet;
        }

        // 相手ユニットが味方かどうかを判定
        public bool IsAlly(Unit t)
        {
            bool IsAllyRet = default;
            // 自分自身は常に味方
            if (ReferenceEquals(t, this))
            {
                IsAllyRet = true;
                return IsAllyRet;
            }

            // 暴走したユニットにとってはすべてが敵
            if (IsConditionSatisfied("暴走"))
            {
                IsAllyRet = false;
                return IsAllyRet;
            }

            // 混乱した場合はランダムで判定
            if (IsConditionSatisfied("混乱"))
            {
                if (GeneralLib.Dice(2) == 1)
                {
                    IsAllyRet = true;
                }
                else
                {
                    IsAllyRet = false;
                }

                return IsAllyRet;
            }

            // 敵味方を判定
            switch (Party ?? "")
            {
                case "味方":
                case "ＮＰＣ":
                    {
                        if (t.Party == "味方" || t.Party == "ＮＰＣ")
                        {
                            IsAllyRet = true;
                        }
                        else
                        {
                            IsAllyRet = false;
                        }

                        break;
                    }

                default:
                    {
                        if ((Party ?? "") == (t.Party ?? ""))
                        {
                            IsAllyRet = true;
                        }
                        else
                        {
                            IsAllyRet = false;
                        }

                        break;
                    }
            }

            return IsAllyRet;
        }


        // === ユニット搭載関連処理 ===

        // ユニットを搭載
        public void LoadUnit(Unit u)
        {
            colUnitOnBoard.Add(u, u.ID);
        }

        // 搭載したユニットを削除
        public void UnloadUnit(object Index)
        {
            int i;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 896556


            Input:

                    On Error GoTo ErrorHandler

             */
            colUnitOnBoard.Remove(Index);
            return;
            ErrorHandler:
            ;
            var loopTo = colUnitOnBoard.Count;
            for (i = 1; i <= loopTo; i++)
            {
                // UPGRADE_WARNING: オブジェクト colUnitOnBoard(i).Name の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                if (Conversions.ToBoolean(Operators.ConditionalCompareObjectEqual(colUnitOnBoard[i].Name, Index, false)))
                {
                    colUnitOnBoard.Remove(i);
                    return;
                }
            }
        }

        // 搭載したユニットの総数
        public int CountUnitOnBoard()
        {
            int CountUnitOnBoardRet = default;
            CountUnitOnBoardRet = colUnitOnBoard.Count;
            return CountUnitOnBoardRet;
        }

        // 搭載したユニット
        public Unit UnitOnBoard(object Index)
        {
            Unit UnitOnBoardRet = default;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 897275


            Input:

                    On Error GoTo ErrorHandler

             */
            UnitOnBoardRet = (Unit)colUnitOnBoard[Index];
            return UnitOnBoardRet;
            ErrorHandler:
            ;
            foreach (Unit u in colUnitOnBoard)
            {
                // UPGRADE_WARNING: オブジェクト Index の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                if (Conversions.ToBoolean(Operators.ConditionalCompareObjectEqual(u.Name, Index, false)))
                {
                    UnitOnBoardRet = u;
                    return UnitOnBoardRet;
                }
            }
        }


        // === 召喚ユニット関連処理 ===

        // 召喚ユニットを追加
        public void AddServant(Unit u)
        {
            // 既に登録している？
            if (Servant((object)u.ID) is object)
            {
                return;
            }

            colServant.Add(u, u.ID);
        }

        // 召喚ユニットを削除
        public void DeleteServant(object Index)
        {
            int i;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 898022


            Input:

                    On Error GoTo ErrorHandler

             */
            colServant.Remove(Index);
            return;
            ErrorHandler:
            ;
            var loopTo = colServant.Count;
            for (i = 1; i <= loopTo; i++)
            {
                // UPGRADE_WARNING: オブジェクト colServant(i).Name の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                if (Conversions.ToBoolean(Operators.ConditionalCompareObjectEqual(colServant[i].Name, Index, false)))
                {
                    colServant.Remove(i);
                    return;
                }
            }
        }

        // 召喚ユニット総数
        public int CountServant()
        {
            int CountServantRet = default;
            CountServantRet = colServant.Count;
            return CountServantRet;
        }

        // 召喚ユニット
        public Unit Servant(object Index)
        {
            Unit ServantRet = default;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 898700


            Input:

                    On Error GoTo ErrorHandler

             */
            ServantRet = (Unit)colServant[Index];
            return ServantRet;
            ErrorHandler:
            ;
            foreach (Unit u in colServant)
            {
                // UPGRADE_WARNING: オブジェクト Index の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                if (Conversions.ToBoolean(Operators.ConditionalCompareObjectEqual(u.Name, Index, false)))
                {
                    ServantRet = u;
                    return ServantRet;
                }
            }
        }

        // 召喚ユニットを解放する
        public void DismissServant()
        {
            int i, j;
            string uname;
            var loopTo = CountServant();
            for (i = 1; i <= loopTo; i++)
            {
                {
                    var withBlock = Servant(1).CurrentForm();
                    switch (withBlock.Status ?? "")
                    {
                        case "出撃":
                        case "格納":
                            {
                                withBlock.Escape();
                                withBlock.Status = "破棄";
                                break;
                            }

                        case "旧主形態":
                        case "旧形態":
                            {
                                var loopTo1 = withBlock.CountFeature();
                                for (j = 1; j <= loopTo1; j++)
                                {
                                    if (withBlock.Feature(j) == "合体")
                                    {
                                        string localFeatureData() { object argIndex1 = j; var ret = withBlock.FeatureData(argIndex1); return ret; }

                                        uname = GeneralLib.LIndex(localFeatureData(), 2);
                                        if (SRC.UList.IsDefined(uname))
                                        {
                                            Unit localItem() { object argIndex1 = uname; var ret = SRC.UList.Item(argIndex1); return ret; }

                                            localItem().CurrentForm().Split();
                                        }
                                    }
                                }

                                {
                                    var withBlock1 = withBlock.CurrentForm();
                                    if (withBlock1.Status == "出撃" || withBlock1.Status == "格納")
                                    {
                                        withBlock1.Escape();
                                        withBlock1.Status = "破棄";
                                    }
                                }

                                break;
                            }
                    }
                }

                DeleteServant(1);
            }
        }


        // === 隷属ユニット関連処理 ===

        // 隷属ユニットを追加
        public void AddSlave(Unit u)
        {
            colSlave.Add(u, u.ID);
        }

        // 隷属ユニットを削除
        public void DeleteSlave(object Index)
        {
            int i;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 900193


            Input:

                    On Error GoTo ErrorHandler

             */
            colSlave.Remove(Index);
            return;
            ErrorHandler:
            ;
            var loopTo = colSlave.Count;
            for (i = 1; i <= loopTo; i++)
            {
                // UPGRADE_WARNING: オブジェクト colSlave(i).Name の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                if (Conversions.ToBoolean(Operators.ConditionalCompareObjectEqual(colSlave[i].Name, Index, false)))
                {
                    colSlave.Remove(i);
                    return;
                }
            }
        }

        // 隷属ユニット総数
        public int CountSlave()
        {
            int CountSlaveRet = default;
            CountSlaveRet = colSlave.Count;
            return CountSlaveRet;
        }

        // 隷属ユニット
        public Unit Slave(object Index)
        {
            Unit SlaveRet = default;
            ;
#error Cannot convert OnErrorGoToStatementSyntax - see comment for details
            /* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ErrorHandler' at character 900853


            Input:

                    On Error GoTo ErrorHandler

             */
            SlaveRet = (Unit)colSlave[Index];
            return SlaveRet;
            ErrorHandler:
            ;
            foreach (Unit u in colSlave)
            {
                // UPGRADE_WARNING: オブジェクト Index の既定プロパティを解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6A50421D-15FE-4896-8A1B-2EC21E9037B2"' をクリックしてください。
                if (Conversions.ToBoolean(Operators.ConditionalCompareObjectEqual(u.Name, Index, false)))
                {
                    SlaveRet = u;
                    return SlaveRet;
                }
            }
        }

        // 隷属ユニットを解放する
        public void DismissSlave()
        {
            int i;
            var loopTo = CountSlave();
            for (i = 1; i <= loopTo; i++)
            {
                {
                    var withBlock = Slave(1).CurrentForm();
                    if (withBlock.IsConditionSatisfied("魅了") && withBlock.Master is object)
                    {
                        if (ReferenceEquals(withBlock.Master.CurrentForm(), this))
                        {
                            withBlock.DeleteCondition("魅了");
                            // UPGRADE_NOTE: オブジェクト Slave().CurrentForm.Master をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                            withBlock.Master = null;
                        }
                    }

                    if (withBlock.IsConditionSatisfied("憑依") && withBlock.Master is object)
                    {
                        if (ReferenceEquals(withBlock.Master.CurrentForm(), this))
                        {
                            withBlock.DeleteCondition("憑依");
                            // UPGRADE_NOTE: オブジェクト Slave().CurrentForm.Master をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                            withBlock.Master = null;
                        }
                    }
                }

                DeleteSlave(1);
            }
        }

        // === 一時中断用データ関連処理 ===

        // 一時中断用データをファイルにセーブする
        public void Dump()
        {
            Condition cnd;
            int i;
            FileSystem.WriteLine(SRC.SaveDataFileNumber, Name, ID, Party0);
            FileSystem.WriteLine(SRC.SaveDataFileNumber, Rank, BossRank, x, y);
            FileSystem.WriteLine(SRC.SaveDataFileNumber, Area, UsedAction, Mode, Status);
            if (Master is object)
            {
                FileSystem.WriteLine(SRC.SaveDataFileNumber, Master.ID);
            }
            else
            {
                FileSystem.WriteLine(SRC.SaveDataFileNumber, "-");
            }

            if (Summoner is object)
            {
                FileSystem.WriteLine(SRC.SaveDataFileNumber, Summoner.ID);
            }
            else
            {
                FileSystem.WriteLine(SRC.SaveDataFileNumber, "-");
            }

            FileSystem.WriteLine(SRC.SaveDataFileNumber, UsedSupportAttack, UsedSupportGuard);
            FileSystem.WriteLine(SRC.SaveDataFileNumber, UsedSyncAttack, UsedCounterAttack);
            FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)CountOtherForm());
            var loopTo = CountOtherForm();
            for (i = 1; i <= loopTo; i++)
            {
                Unit localOtherForm() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                FileSystem.WriteLine(SRC.SaveDataFileNumber, localOtherForm().ID);
            }

            FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)CountUnitOnBoard());
            var loopTo1 = CountUnitOnBoard();
            for (i = 1; i <= loopTo1; i++)
            {
                Unit localUnitOnBoard() { object argIndex1 = i; var ret = UnitOnBoard(argIndex1); return ret; }

                FileSystem.WriteLine(SRC.SaveDataFileNumber, localUnitOnBoard().ID);
            }

            FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)CountPilot());
            var loopTo2 = CountPilot();
            for (i = 1; i <= loopTo2; i++)
            {
                Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                FileSystem.WriteLine(SRC.SaveDataFileNumber, localPilot().ID);
            }

            FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)CountSupport());
            var loopTo3 = CountSupport();
            for (i = 1; i <= loopTo3; i++)
            {
                Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                FileSystem.WriteLine(SRC.SaveDataFileNumber, localSupport().ID);
            }

            if (AdditionalSupport() is null)
            {
                FileSystem.WriteLine(SRC.SaveDataFileNumber, "");
            }
            else
            {
                FileSystem.WriteLine(SRC.SaveDataFileNumber, AdditionalSupport().ID);
            }

            FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)CountServant());
            var loopTo4 = CountServant();
            for (i = 1; i <= loopTo4; i++)
            {
                Unit localServant() { object argIndex1 = i; var ret = Servant(argIndex1); return ret; }

                FileSystem.WriteLine(SRC.SaveDataFileNumber, localServant().ID);
            }

            FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)CountItem());
            var loopTo5 = CountItem();
            for (i = 1; i <= loopTo5; i++)
            {
                Item localItem() { object argIndex1 = i; var ret = Item(argIndex1); return ret; }

                FileSystem.WriteLine(SRC.SaveDataFileNumber, localItem().ID);
            }

            FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)colSpecialPowerInEffect.Count);
            foreach (Condition currentCnd in colSpecialPowerInEffect)
            {
                cnd = currentCnd;
                FileSystem.WriteLine(SRC.SaveDataFileNumber, cnd.Name, cnd.StrData);
            }

            FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)colCondition.Count);
            foreach (Condition currentCnd1 in colCondition)
            {
                cnd = currentCnd1;
                FileSystem.WriteLine(SRC.SaveDataFileNumber, cnd.Name, cnd.Lifetime, cnd.Level, cnd.StrData);
            }

            FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)CountWeapon());
            var loopTo6 = CountWeapon();
            for (i = 1; i <= loopTo6; i++)
                FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)Bullet(i));
            FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)CountAbility());
            var loopTo7 = CountAbility();
            for (i = 1; i <= loopTo7; i++)
                FileSystem.WriteLine(SRC.SaveDataFileNumber, (object)Stock(i));
            FileSystem.WriteLine(SRC.SaveDataFileNumber, HP, EN);
        }

        // 一時中断用データをファイルからロードする
        public void Restore()
        {
            var sbuf = default(string);
            var ibuf = default;
            var lbuf = default;
            // UPGRADE_NOTE: ctype は ctype にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
            string ctype = default, cdata = default;
            int cltime;
            double clevel;
            int num = default, i, ret;

            // Name, ID, Party
            FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
            strName = sbuf;
            Data = SRC.UDList.Item(sbuf);
            FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
            ID = sbuf;
            FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
            strParty = sbuf;

            // Rank, BossRank, X, Y
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            intRank = ibuf;
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            intBossRank = ibuf;
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            x = ibuf;
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            y = ibuf;

            // Area, Action, Mode, Status
            FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
            Area = sbuf;
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            UsedAction = ibuf;
            FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
            strMode = sbuf;
            FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
            Status = sbuf;

            // Master, Summoner
            FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
            FileSystem.Input(SRC.SaveDataFileNumber, sbuf);

            // UsedSupportAttack, UsedSupportGuard
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            UsedSupportAttack = ibuf;
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            UsedSupportGuard = ibuf;

            // UsedSyncAttack, UsedCounterAttack
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            UsedSyncAttack = ibuf;
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            UsedCounterAttack = ibuf;

            // OtherForm
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo = num;
            for (i = 1; i <= loopTo; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // UnitOnBoard
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo1 = num;
            for (i = 1; i <= loopTo1; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Pilot
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo2 = num;
            for (i = 1; i <= loopTo2; i++)
            {
                FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
                Pilot localItem() { object argIndex1 = sbuf; var ret = SRC.PList.Item(argIndex1); return ret; }

                AddPilot(localItem());
            }

            // Support
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo3 = num;
            for (i = 1; i <= loopTo3; i++)
            {
                FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
                Pilot localItem1() { object argIndex1 = sbuf; var ret = SRC.PList.Item(argIndex1); return ret; }

                AddSupport(localItem1());
            }

            // AdditionalSupport
            if (SRC.SaveDataVersion >= 20210)
            {
                FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
                if (!string.IsNullOrEmpty(sbuf))
                {
                    pltAdditionalSupport = SRC.PList.Item(sbuf);
                    pltAdditionalSupport.Unit = this;
                    pltAdditionalSupport.IsAdditionalSupport = true;
                }
            }

            // Servant
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo4 = num;
            for (i = 1; i <= loopTo4; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Item
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo5 = num;
            for (i = 1; i <= loopTo5; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // SpecialPowerInEffect
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo6 = num;
            for (i = 1; i <= loopTo6; i++)
            {
                FileSystem.Input(SRC.SaveDataFileNumber, ctype);
                FileSystem.Input(SRC.SaveDataFileNumber, cdata);
                MakeSpecialPowerInEffect(ctype, cdata);
            }

            // Condition
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo7 = num;
            for (i = 1; i <= loopTo7; i++)
            {
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

                // 付加した特殊能力のデータに「"」や「,」が含まれているとデータの処理が
                // 正しく行えないので手動でパーシング

                ret = Strings.InStr(sbuf, ",");
                ctype = Strings.Left(sbuf, ret - 1);
                if (Strings.Left(ctype, 1) == "\"")
                {
                    ctype = Strings.Mid(ctype, 2, Strings.Len(ctype) - 2);
                }

                sbuf = Strings.Mid(sbuf, ret + 1);
                ret = Strings.InStr(sbuf, ",");
                cltime = GeneralLib.StrToLng(Strings.Left(sbuf, ret - 1));
                sbuf = Strings.Mid(sbuf, ret + 1);
                ret = Strings.InStr(sbuf, ",");
                clevel = GeneralLib.StrToLng(Strings.Left(sbuf, ret - 1));
                sbuf = Strings.Mid(sbuf, ret + 1);
                cdata = sbuf;
                if (Strings.Left(cdata, 1) == "\"")
                {
                    cdata = Strings.Mid(cdata, 2, Strings.Len(cdata) - 2);
                }

                if (SRC.SaveDataVersion < 10741)
                {
                    if (Strings.InStr(cdata, " パイロット能力付加 ") > 0)
                    {
                        goto NextCondition;
                    }

                    if (Strings.InStr(cdata, " パイロット能力強化 ") > 0)
                    {
                        goto NextCondition;
                    }
                }

                AddCondition(ctype, cltime, clevel, cdata);
                NextCondition:
                ;
            }

            // Weapon
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo8 = num;
            for (i = 1; i <= loopTo8; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Ability
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo9 = num;
            for (i = 1; i <= loopTo9; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // HP, EN
            FileSystem.Input(SRC.SaveDataFileNumber, lbuf);
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            HP = lbuf;
            EN = ibuf;
        }

        // 一時中断用データのリンク情報をファイルからロードする
        public void RestoreLinkInfo()
        {
            string sbuf;
            var ibuf = default;
            var lbuf = default;
            double dbuf;
            int i, num = default;
            Item itm;

            // Name, ID, Party
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Rank, BossRank, X, Y
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Area, Action, Mode, Status
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Master, Summoner
            FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
            Master = SRC.UList.Item(sbuf);
            FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
            Summoner = SRC.UList.Item(sbuf);

            // SupportAttackStock, SupportGuardStock
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);
            // UsedSyncAttack, UsedCounterAttack
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // OtherForm
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo = num;
            for (i = 1; i <= loopTo; i++)
            {
                FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
                Unit localItem() { object argIndex1 = sbuf; var ret = SRC.UList.Item(argIndex1); return ret; }

                AddOtherForm(localItem());
            }

            // UnitOnBoard
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo1 = num;
            for (i = 1; i <= loopTo1; i++)
            {
                FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
                Unit localItem1() { object argIndex1 = sbuf; var ret = SRC.UList.Item(argIndex1); return ret; }

                LoadUnit(localItem1());
            }

            // Pilot
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo2 = num;
            for (i = 1; i <= loopTo2; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Support
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo3 = num;
            for (i = 1; i <= loopTo3; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // AdditionalSupport
            if (SRC.SaveDataVersion >= 20210)
            {
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);
            }

            // Servant
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo4 = num;
            for (i = 1; i <= loopTo4; i++)
            {
                FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
                Unit localItem2() { object argIndex1 = sbuf; var ret = SRC.UList.Item(argIndex1); return ret; }

                AddServant(localItem2());
            }

            // Item
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo5 = num;
            for (i = 1; i <= loopTo5; i++)
            {
                FileSystem.Input(SRC.SaveDataFileNumber, sbuf);
                Item localItem3() { object argIndex1 = sbuf; var ret = SRC.IList.Item(argIndex1); return ret; }

                AddItem0(localItem3());
            }

            // SpecialPowerInEffect
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo6 = num;
            for (i = 1; i <= loopTo6; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Condition
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo7 = num;
            for (i = 1; i <= loopTo7; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);
            Update(true);

            // Weapon
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo8 = num;
            for (i = 1; i <= loopTo8; i++)
            {
                FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
                if (i <= CountWeapon())
                {
                    SetBullet(i, ibuf);
                }
            }

            // Ability
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo9 = num;
            for (i = 1; i <= loopTo9; i++)
            {
                FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
                if (i <= CountAbility())
                {
                    SetStock(i, ibuf);
                }
            }

            // HP, EN
            FileSystem.Input(SRC.SaveDataFileNumber, lbuf);
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            HP = lbuf;
            EN = ibuf;
        }

        // 一時中断用データのパラメータ情報をファイルからロードする
        public void RestoreParameter()
        {
            string sbuf;
            var ibuf = default;
            var lbuf = default;
            double dbuf;
            int i, num = default;

            // Name, ID, Party
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Rank, BossRank, X, Y
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Area, Action, Mode, Status
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Master
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);
            // Summoner
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // SupportAttackStock, SupportGuardStock
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);
            // UsedSyncAttack, UsedCounterAttack
            sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // OtherForm
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo = num;
            for (i = 1; i <= loopTo; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // UnitOnBoard
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo1 = num;
            for (i = 1; i <= loopTo1; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Pilot
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo2 = num;
            for (i = 1; i <= loopTo2; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Support
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo3 = num;
            for (i = 1; i <= loopTo3; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // AdditionalSupport
            if (SRC.SaveDataVersion >= 20210)
            {
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);
            }

            // Servant
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo4 = num;
            for (i = 1; i <= loopTo4; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Item
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo5 = num;
            for (i = 1; i <= loopTo5; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // SpecialPowerInEffect
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo6 = num;
            for (i = 1; i <= loopTo6; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Condition
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo7 = num;
            for (i = 1; i <= loopTo7; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Weapon
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo8 = num;
            for (i = 1; i <= loopTo8; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // Ability
            FileSystem.Input(SRC.SaveDataFileNumber, num);
            var loopTo9 = num;
            for (i = 1; i <= loopTo9; i++)
                sbuf = FileSystem.LineInput(SRC.SaveDataFileNumber);

            // HP, EN
            FileSystem.Input(SRC.SaveDataFileNumber, lbuf);
            FileSystem.Input(SRC.SaveDataFileNumber, ibuf);
            HP = lbuf;
            EN = ibuf;
            Update();
        }


        // === 各種処理を行うための関数＆サブルーチン ===

        // 出撃中？
        public bool IsOperational()
        {
            bool IsOperationalRet = default;
            int i;
            if (Status == "出撃")
            {
                IsOperationalRet = true;
                return IsOperationalRet;
            }

            var loopTo = CountOtherForm();
            for (i = 1; i <= loopTo; i++)
            {
                Unit localOtherForm() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                if (localOtherForm().Status == "出撃")
                {
                    IsOperationalRet = true;
                    return IsOperationalRet;
                }
            }

            IsOperationalRet = false;
            return IsOperationalRet;
        }

        // ユニットがユニット nm と同一？
        public bool IsEqual(string nm)
        {
            bool IsEqualRet = default;
            int i;
            if ((Name ?? "") == (nm ?? ""))
            {
                IsEqualRet = true;
                return IsEqualRet;
            }

            var loopTo = CountOtherForm();
            for (i = 1; i <= loopTo; i++)
            {
                Unit localOtherForm() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                if ((localOtherForm().Name ?? "") == (nm ?? ""))
                {
                    IsEqualRet = true;
                    return IsEqualRet;
                }
            }

            IsEqualRet = false;
            return IsEqualRet;
        }

        // ユニットが現在とっている形態
        public Unit CurrentForm()
        {
            Unit CurrentFormRet = default;
            int i;
            if (Status == "他形態")
            {
                var loopTo = CountOtherForm();
                for (i = 1; i <= loopTo; i++)
                {
                    Unit localOtherForm() { object argIndex1 = i; var ret = OtherForm(argIndex1); return ret; }

                    if (localOtherForm().Status != "他形態")
                    {
                        CurrentFormRet = OtherForm(i);
                        return CurrentFormRet;
                    }
                }
            }

            CurrentFormRet = this;
            return CurrentFormRet;
        }

        // 人間ユニットかどうか判定
        public bool IsHero()
        {
            bool IsHeroRet = default;
            {
                var withBlock = Data;
                if (Strings.Left(withBlock.Class, 1) == "(")
                {
                    IsHeroRet = true;
                }
                else
                {
                    IsHeroRet = false;
                }
            }

            return IsHeroRet;
        }

        // (tx,ty)の地点の周囲に「連携攻撃」を行ってくれるユニットがいるかどうかを判定
        public Unit LookForAttackHelp(int tx, int ty)
        {
            Unit LookForAttackHelpRet = default;
            Unit u;
            int i;
            for (i = 1; i <= 4; i++)
            {
                // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                u = null;
                switch (i)
                {
                    case 1:
                        {
                            if (tx > 1)
                            {
                                u = Map.MapDataForUnit[tx - 1, ty];
                            }

                            break;
                        }

                    case 2:
                        {
                            if (tx < Map.MapWidth)
                            {
                                u = Map.MapDataForUnit[tx + 1, ty];
                            }

                            break;
                        }

                    case 3:
                        {
                            if (ty > 1)
                            {
                                u = Map.MapDataForUnit[tx, ty - 1];
                            }

                            break;
                        }

                    case 4:
                        {
                            if (ty < Map.MapHeight)
                            {
                                u = Map.MapDataForUnit[tx, ty + 1];
                            }

                            break;
                        }
                }

                // ユニットがいる？
                if (u is null)
                {
                    goto NextLoop;
                }

                // ユニットが敵でない？
                if (IsEnemy(u))
                {
                    goto NextLoop;
                }
                // 信頼度を満たしている？
                if (GeneralLib.Dice(10) > u.MainPilot().Relation(MainPilot()))
                {
                    goto NextLoop;
                }

                // 行動可能？
                if (u.MaxAction() == 0)
                {
                    goto NextLoop;
                }

                // 正常な判断力がある？
                if (u.IsConditionSatisfied("混乱") || u.IsConditionSatisfied("暴走") || u.IsConditionSatisfied("魅了") || u.IsConditionSatisfied("憑依") || u.IsConditionSatisfied("恐怖") || u.IsConditionSatisfied("狂戦士"))
                {
                    goto NextLoop;
                }

                // メッセージが登録されている？
                bool localIsMessageDefined() { string argmain_situation = "連携攻撃(" + u.MainPilot().Name + ")"; var ret = IsMessageDefined(argmain_situation, true); return ret; }

                bool localIsMessageDefined1() { string argmain_situation = "連携攻撃(" + u.MainPilot().get_Nickname(false) + ")"; var ret = IsMessageDefined(argmain_situation, true); return ret; }

                if (!localIsMessageDefined() && !localIsMessageDefined1())
                {
                    goto NextLoop;
                }

                // 見つかった
                LookForAttackHelpRet = u;
                return LookForAttackHelpRet;
                NextLoop:
                ;
            }

            // 見つからなかった
            // UPGRADE_NOTE: オブジェクト LookForAttackHelp をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            LookForAttackHelpRet = null;
            return LookForAttackHelpRet;
        }

        // tからの攻撃に対して「かばう」を行ってくれるユニットがいるかどうか判定
        public Unit LookForGuardHelp(Unit t, int tw, bool is_critical)
        {
            Unit LookForGuardHelpRet = default;
            Unit u;
            int i;
            int dmg;
            double ratio;
            int ux, uy;
            string uarea;
            for (i = 1; i <= 4; i++)
            {
                // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                u = null;
                switch (i)
                {
                    case 1:
                        {
                            if (x > 1)
                            {
                                u = Map.MapDataForUnit[x - 1, y];
                            }

                            break;
                        }

                    case 2:
                        {
                            if (x < Map.MapWidth)
                            {
                                u = Map.MapDataForUnit[x + 1, y];
                            }

                            break;
                        }

                    case 3:
                        {
                            if (y > 1)
                            {
                                u = Map.MapDataForUnit[x, y - 1];
                            }

                            break;
                        }

                    case 4:
                        {
                            if (y < Map.MapHeight)
                            {
                                u = Map.MapDataForUnit[x, y + 1];
                            }

                            break;
                        }
                }

                // ユニットがいる？
                if (u is null)
                {
                    goto NextLoop;
                }

                // ユニットが敵でない？
                if (IsEnemy(u))
                {
                    goto NextLoop;
                }

                {
                    var withBlock = u;
                    // 信頼度を満たしている？
                    if (GeneralLib.Dice(10) > withBlock.MainPilot().Relation(MainPilot()))
                    {
                        goto NextLoop;
                    }

                    // 行動可能？
                    if (withBlock.MaxAction() == 0)
                    {
                        goto NextLoop;
                    }

                    // 正常な判断力がある？
                    if (withBlock.IsConditionSatisfied("混乱") || withBlock.IsConditionSatisfied("暴走") || withBlock.IsConditionSatisfied("魅了") || withBlock.IsConditionSatisfied("憑依") || withBlock.IsConditionSatisfied("恐怖") || withBlock.IsConditionSatisfied("狂戦士"))
                    {
                        goto NextLoop;
                    }

                    // メッセージが登録されている？
                    bool localIsMessageDefined() { string argmain_situation = "かばう(" + MainPilot().Name + ")"; var ret = withBlock.IsMessageDefined(argmain_situation, true); return ret; }

                    bool localIsMessageDefined1() { string argmain_situation = "かばう(" + MainPilot().get_Nickname(false) + ")"; var ret = withBlock.IsMessageDefined(argmain_situation, true); return ret; }

                    if (!localIsMessageDefined() && !localIsMessageDefined1())
                    {
                        goto NextLoop;
                    }

                    // 援護相手のユニットのいる地形に進入可能？
                    if ((Area ?? "") != (withBlock.Area ?? ""))
                    {
                        switch (Area ?? "")
                        {
                            case "空中":
                                {
                                    if (withBlock.get_Adaption(1) == 0)
                                    {
                                        goto NextLoop;
                                    }

                                    break;
                                }

                            case "地上":
                                {
                                    if (withBlock.get_Adaption(2) == 0)
                                    {
                                        goto NextLoop;
                                    }

                                    break;
                                }

                            case "水中":
                            case "水上":
                                {
                                    if (withBlock.get_Adaption(3) == 0)
                                    {
                                        goto NextLoop;
                                    }

                                    break;
                                }

                            case "宇宙":
                                {
                                    if (Map.TerrainClass(x, y) == "月面")
                                    {
                                        if (!withBlock.IsTransAvailable("空") && !withBlock.IsTransAvailable("宇宙"))
                                        {
                                            goto NextLoop;
                                        }
                                    }
                                    else if (withBlock.get_Adaption(4) == 0)
                                    {
                                        goto NextLoop;
                                    }

                                    break;
                                }
                        }
                    }

                    // ダメージを算出
                    if (withBlock.IsFeatureAvailable("防御不可") || t.IsWeaponClassifiedAs(tw, "殺"))
                    {
                        ratio = 1d;
                    }
                    else
                    {
                        ratio = 0.5d;
                    }

                    if (is_critical)
                    {
                        if (Expression.IsOptionDefined("ダメージ倍率低下"))
                        {
                            ratio = 1.2d * ratio;
                        }
                        else
                        {
                            ratio = 1.5d * ratio;
                        }
                    }

                    ux = withBlock.x;
                    uy = withBlock.y;
                    uarea = withBlock.Area;
                    withBlock.x = x;
                    withBlock.y = y;
                    withBlock.Area = Area;
                    dmg = t.ExpDamage(tw, u, true, ratio);
                    withBlock.x = ux;
                    withBlock.y = uy;
                    withBlock.Area = uarea;

                    // 自分が倒されてしまうような場合はかばわない
                    if (dmg >= withBlock.HP)
                    {
                        goto NextLoop;
                    }
                }

                // 見つかった
                LookForGuardHelpRet = u;
                return LookForGuardHelpRet;
                NextLoop:
                ;
            }

            // 見つからなかった
            // UPGRADE_NOTE: オブジェクト LookForGuardHelp をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
            LookForGuardHelpRet = null;
            return LookForGuardHelpRet;
        }

        // 最大サポートアタック回数
        public int MaxSupportAttack()
        {
            int MaxSupportAttackRet = default;
            {
                var withBlock = MainPilot();
                MaxSupportAttackRet = GeneralLib.MaxLng(withBlock.SkillLevel("援護攻撃", ref_mode: ""), withBlock.SkillLevel("援護", ref_mode: ""));
            }

            return MaxSupportAttackRet;
        }

        // 最大サポートガード回数
        public int MaxSupportGuard()
        {
            int MaxSupportGuardRet = default;
            {
                var withBlock = MainPilot();
                MaxSupportGuardRet = GeneralLib.MaxLng(withBlock.SkillLevel("援護防御", ref_mode: ""), withBlock.SkillLevel("援護", ref_mode: ""));
            }

            return MaxSupportGuardRet;
        }

        // 最大同時援護攻撃回数
        public int MaxSyncAttack()
        {
            int MaxSyncAttackRet = default;
            MaxSyncAttackRet = MainPilot().SkillLevel("統率", ref_mode: "");
            return MaxSyncAttackRet;
        }

        // 最大カウンター攻撃回数
        public int MaxCounterAttack()
        {
            int MaxCounterAttackRet = default;
            {
                var withBlock = MainPilot();
                MaxCounterAttackRet = withBlock.SkillLevel("カウンター", ref_mode: "");
                if (withBlock.IsSkillAvailable("先手必勝"))
                {
                    if (GeneralLib.LLength(withBlock.SkillData("先手必勝")) == 2)
                    {
                        string localLIndex() { object argIndex1 = "先手必勝"; string arglist = withBlock.SkillData(argIndex1); var ret = GeneralLib.LIndex(arglist, 2); return ret; }

                        int localStrToLng() { string argexpr = hs82ee736ae10e4616bf0a2d5cf18f3478(); var ret = GeneralLib.StrToLng(argexpr); return ret; }

                        if (withBlock.Morale >= localStrToLng())
                        {
                            MaxCounterAttackRet = 1000;
                        }
                    }
                    else if (withBlock.Morale >= 120)
                    {
                        MaxCounterAttackRet = 1000;
                    }
                }
            }

            return MaxCounterAttackRet;
        }

        // ユニット t に対して周囲にサポートアタックを行ってくれるユニットがいるかどうかを判定
        public Unit LookForSupportAttack(Unit t)
        {
            Unit LookForSupportAttackRet = default;
            Unit u;
            int i, w;
            int max_wpower;
            string team, uteam;

            // 正常な判断が可能？
            if (IsConditionSatisfied("混乱"))
            {
                return LookForSupportAttackRet;
            }

            // 同士討ちの場合はどちらに荷担すべきか分からないので……
            if (t is object)
            {
                if ((Party ?? "") == (t.Party ?? ""))
                {
                    return LookForSupportAttackRet;
                }
            }

            team = MainPilot().SkillData("チーム");
            max_wpower = -1;
            for (i = 1; i <= 4; i++)
            {
                // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                u = null;
                switch (i)
                {
                    case 1:
                        {
                            if (x > 1)
                            {
                                u = Map.MapDataForUnit[x - 1, y];
                            }

                            break;
                        }

                    case 2:
                        {
                            if (x < Map.MapWidth)
                            {
                                u = Map.MapDataForUnit[x + 1, y];
                            }

                            break;
                        }

                    case 3:
                        {
                            if (y > 1)
                            {
                                u = Map.MapDataForUnit[x, y - 1];
                            }

                            break;
                        }

                    case 4:
                        {
                            if (y < Map.MapHeight)
                            {
                                u = Map.MapDataForUnit[x, y + 1];
                            }

                            break;
                        }
                }

                if (u is null)
                {
                    goto NextUnit;
                }
                // サポートアタック数が残っている？
                if (u.MaxSupportAttack() <= u.UsedSupportAttack)
                {
                    goto NextUnit;
                }

                // 行動数が残っている？
                if (u.Action == 0)
                {
                    goto NextUnit;
                }

                // 正常な判断が可能？
                if (u.IsConditionSatisfied("混乱") || u.IsConditionSatisfied("暴走") || u.IsConditionSatisfied("恐怖") || u.IsConditionSatisfied("狂戦士") || u.IsConditionSatisfied("踊り"))
                {
                    goto NextUnit;
                }

                // 味方？
                switch (u.Party ?? "")
                {
                    case "ＮＰＣ":
                        {
                            switch (Party ?? "")
                            {
                                case "敵":
                                case "中立":
                                    {
                                        goto NextUnit;
                                        break;
                                    }
                            }

                            break;
                        }

                    default:
                        {
                            if ((u.Party ?? "") != (Party ?? ""))
                            {
                                goto NextUnit;
                            }

                            break;
                        }
                }

                // 同じチームに属している？
                uteam = u.MainPilot().SkillData("チーム");
                if ((team ?? "") != (uteam ?? "") && !string.IsNullOrEmpty(uteam))
                {
                    goto NextUnit;
                }

                // まだターゲットが特定されていない？
                if (t is null)
                {
                    LookForSupportAttackRet = u;
                    return LookForSupportAttackRet;
                }

                // 攻撃可能？
                // 高い威力の武器はリストの最後の方にあることが多いので後ろから判定
                w = u.CountWeapon();
                while (w > 0)
                {
                    // 攻撃力が今まで見つかった武器以下の場合は選考外
                    if (u.WeaponPower(w, t.Area) <= max_wpower)
                    {
                        goto NextWeapon;
                    }

                    // サポートアタックに利用可能？
                    if (u.IsWeaponClassifiedAs(w, "Ｍ"))
                    {
                        goto NextWeapon;
                    }

                    if (u.IsWeaponClassifiedAs(w, "合"))
                    {
                        goto NextWeapon;
                    }

                    if (!u.IsWeaponAvailable(w, "移動前"))
                    {
                        goto NextWeapon;
                    }

                    if (!u.IsTargetWithinRange(w, t))
                    {
                        goto NextWeapon;
                    }

                    if (u.Party == "味方" && u.Party0 == "味方")
                    {
                        // 味方ユニットは自爆攻撃をサポートアタックには使用しない
                        if (u.IsWeaponClassifiedAs(w, "自"))
                        {
                            goto NextWeapon;
                        }

                        // 自動反撃の場合、味方ユニットは残弾数が少ない武器を使用しない
                        // UPGRADE_ISSUE: Control mnuMapCommandItem は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
                        if (GUI.MainForm.mnuMapCommandItem(Commands.AutoDefenseCmdID).Checked)
                        {
                            if (!u.IsWeaponClassifiedAs(w, "永"))
                            {
                                if (u.Bullet(w) == 1 || u.MaxBullet(w) == 2 || u.MaxBullet(w) == 3)
                                {
                                    goto NextWeapon;
                                }
                            }

                            if (u.WeaponENConsumption(w) > 0)
                            {
                                if (u.WeaponENConsumption(w) >= u.EN / 2 || u.WeaponENConsumption(w) >= u.MaxEN / 4)
                                {
                                    goto NextWeapon;
                                }
                            }

                            if (u.IsWeaponClassifiedAs(w, "尽"))
                            {
                                goto NextWeapon;
                            }
                        }
                    }

                    // 援護攻撃用の武器が見つかった
                    max_wpower = u.WeaponPower(w, t.Area);
                    LookForSupportAttackRet = u;
                    NextWeapon:
                    ;
                    w = (w - 1);
                }

                NextUnit:
                ;
            }

            return LookForSupportAttackRet;
        }

        // ユニット t からの攻撃に対して周囲にサポートガードを行ってくれるユニットが
        // いるかどうかを判定
        public Unit LookForSupportGuard(Unit t, int tw)
        {
            Unit LookForSupportGuardRet = default;
            Unit u;
            int i;
            int my_dmg, dmg;
            double ratio;
            int ux, uy;
            string uarea;
            string team, uteam;

            // マップ攻撃はサポートガード不能
            if (t.IsWeaponClassifiedAs(tw, "Ｍ"))
            {
                return LookForSupportGuardRet;
            }

            // スペシャルパワーでサポートガードが無効化されている？
            if (t.IsUnderSpecialPowerEffect("サポートガード無効化"))
            {
                return LookForSupportGuardRet;
            }

            // 同士討ちの場合は本来の陣営に属するユニットのみを守る
            if ((Party ?? "") == (t.Party ?? "") || Party == "ＮＰＣ" && t.Party == "味方")
            {
                if ((Party ?? "") != (Party0 ?? ""))
                {
                    return LookForSupportGuardRet;
                }

                if (IsConditionSatisfied("暴走"))
                {
                    return LookForSupportGuardRet;
                }
            }

            // 自分が受けるダメージを求めておく
            my_dmg = t.ExpDamage(tw, this, true);

            // かばう必要がない？
            // 手動反撃で味方の場合はダメージにかかわらず常にかばう
            // UPGRADE_ISSUE: Control mnuMapCommandItem は、汎用名前空間 Form 内にあるため、解決できませんでした。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="084D22AD-ECB1-400F-B4C7-418ECEC5E36E"' をクリックしてください。
            if (Party != "味方" || GUI.MainForm.mnuMapCommandItem(Commands.AutoDefenseCmdID).Checked)
            {
                if (t.IsNormalWeapon(tw))
                {
                    if (my_dmg < MaxHP / 20 && my_dmg < HP / 5)
                    {
                        return LookForSupportGuardRet;
                    }
                }
                else
                {
                    if (t.CriticalProbability(tw, this) > 0)
                    {
                        return LookForSupportGuardRet;
                    }
                }
            }

            team = MainPilot().SkillData("チーム");
            for (i = 1; i <= 4; i++)
            {
                // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                u = null;
                switch (i)
                {
                    case 1:
                        {
                            if (x > 1)
                            {
                                u = Map.MapDataForUnit[x - 1, y];
                            }

                            break;
                        }

                    case 2:
                        {
                            if (x < Map.MapWidth)
                            {
                                u = Map.MapDataForUnit[x + 1, y];
                            }

                            break;
                        }

                    case 3:
                        {
                            if (y > 1)
                            {
                                u = Map.MapDataForUnit[x, y - 1];
                            }

                            break;
                        }

                    case 4:
                        {
                            if (y < Map.MapHeight)
                            {
                                u = Map.MapDataForUnit[x, y + 1];
                            }

                            break;
                        }
                }

                if (u is null)
                {
                    goto NextUnit;
                }

                if (ReferenceEquals(u, t))
                {
                    goto NextUnit;
                }

                {
                    var withBlock = u;
                    // サポートガード数が残っている？
                    if (withBlock.MaxSupportGuard() <= withBlock.UsedSupportGuard)
                    {
                        goto NextUnit;
                    }

                    // 行動可能？
                    if (withBlock.MaxAction() == 0)
                    {
                        goto NextUnit;
                    }

                    // スペシャルパワーでサポートガードが封印されている？
                    if (withBlock.IsUnderSpecialPowerEffect("サポートガード不能"))
                    {
                        goto NextUnit;
                    }

                    // 正常な判断が可能？
                    if (withBlock.IsConditionSatisfied("混乱") || withBlock.IsConditionSatisfied("暴走") || withBlock.IsConditionSatisfied("恐怖") || withBlock.IsConditionSatisfied("狂戦士"))
                    {
                        goto NextUnit;
                    }

                    // ＨＰが高いほうを優先
                    if (LookForSupportGuardRet is object)
                    {
                        if (LookForSupportGuardRet.HP >= withBlock.HP)
                        {
                            goto NextUnit;
                        }
                    }

                    // 味方？
                    switch (withBlock.Party ?? "")
                    {
                        case "味方":
                            {
                                if (Expression.IsOptionDefined("対ＮＰＣサポートガード無効"))
                                {
                                    if ((withBlock.Party ?? "") != (Party ?? ""))
                                    {
                                        goto NextUnit;
                                    }
                                }
                                else
                                {
                                    switch (Party ?? "")
                                    {
                                        case "敵":
                                        case "中立":
                                            {
                                                goto NextUnit;
                                                break;
                                            }
                                    }
                                }

                                break;
                            }

                        case "ＮＰＣ":
                            {
                                switch (Party ?? "")
                                {
                                    case "敵":
                                    case "中立":
                                        {
                                            goto NextUnit;
                                            break;
                                        }
                                }

                                break;
                            }

                        default:
                            {
                                if ((withBlock.Party ?? "") != (Party ?? ""))
                                {
                                    goto NextUnit;
                                }

                                break;
                            }
                    }

                    // 同じチームに属している？
                    uteam = withBlock.MainPilot().SkillData("チーム");
                    if ((team ?? "") != (uteam ?? "") && !string.IsNullOrEmpty(uteam))
                    {
                        goto NextUnit;
                    }

                    // 援護相手のユニットのいる地形に進入可能？
                    if ((Area ?? "") != (withBlock.Area ?? ""))
                    {
                        switch (Area ?? "")
                        {
                            case "空中":
                                {
                                    if (!withBlock.IsTransAvailable("空"))
                                    {
                                        goto NextUnit;
                                    }

                                    break;
                                }

                            case "地上":
                                {
                                    if (withBlock.get_Adaption(2) == 0)
                                    {
                                        goto NextUnit;
                                    }

                                    break;
                                }

                            case "水中":
                            case "水上":
                                {
                                    if (withBlock.get_Adaption(3) == 0)
                                    {
                                        goto NextUnit;
                                    }

                                    break;
                                }

                            case "宇宙":
                                {
                                    if (withBlock.get_Adaption(4) == 0)
                                    {
                                        goto NextUnit;
                                    }

                                    break;
                                }
                        }
                    }

                    // 機械をかばうのは機械のみ
                    if (MainPilot().Personality == "機械")
                    {
                        if (withBlock.MainPilot().Personality != "機械")
                        {
                            goto NextUnit;
                        }
                    }

                    // ダメージを算出
                    if (withBlock.IsFeatureAvailable("防御不可") || t.IsWeaponClassifiedAs(tw, "殺"))
                    {
                        ratio = 1d;
                    }
                    else
                    {
                        ratio = 0.5d;
                    }

                    if (t.IsNormalWeapon(tw))
                    {
                        // ダメージは常に最悪の状況を考えてクリティカル時の値に
                        if (Expression.IsOptionDefined("ダメージ倍率低下"))
                        {
                            ratio = 1.2d * ratio;
                        }
                        else
                        {
                            ratio = 1.5d * ratio;
                        }
                    }

                    ux = withBlock.x;
                    uy = withBlock.y;
                    uarea = withBlock.Area;
                    withBlock.x = x;
                    withBlock.y = y;
                    withBlock.Area = Area;
                    dmg = t.ExpDamage(tw, u, true, ratio);
                    withBlock.x = ux;
                    withBlock.y = uy;
                    withBlock.Area = uarea;

                    // ボスはザコを見殺しにする！
                    if (withBlock.BossRank > BossRank)
                    {
                        // 被るダメージが少ない場合は別だけど……
                        if (dmg >= withBlock.MaxHP / 20 || dmg >= withBlock.HP / 5)
                        {
                            goto NextUnit;
                        }
                    }

                    // 自分が倒されてしまうような場合はかばわない(クリティカルを含む)
                    if (dmg >= withBlock.HP)
                    {
                        // ボスは例外……
                        if (withBlock.BossRank >= BossRank)
                        {
                            goto NextUnit;
                        }
                    }
                }

                LookForSupportGuardRet = u;
                NextUnit:
                ;
            }

            return LookForSupportGuardRet;
        }

        // (tx,ty)の地点の周囲にサポートを行ってくれるユニットがいるかどうかを判定。
        public int LookForSupport(int tx, int ty, bool for_attack = false)
        {
            int LookForSupportRet = default;
            Unit u;
            int i;
            var do_support = default(bool);
            string team, uteam;
            {
                var withBlock = MainPilot();
                // 自分自身がサポートを行うことが出来るか？
                if (withBlock.IsSkillAvailable("援護") || withBlock.IsSkillAvailable("援護攻撃") || withBlock.IsSkillAvailable("援護防御") || withBlock.IsSkillAvailable("指揮") || withBlock.IsSkillAvailable("広域サポート"))
                {
                    do_support = true;
                }

                team = withBlock.SkillData("チーム");
            }

            for (i = 1; i <= 4; i++)
            {
                // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                u = null;
                switch (i)
                {
                    case 1:
                        {
                            if (tx > 1)
                            {
                                u = Map.MapDataForUnit[tx - 1, ty];
                            }

                            break;
                        }

                    case 2:
                        {
                            if (tx < Map.MapWidth)
                            {
                                u = Map.MapDataForUnit[tx + 1, ty];
                            }

                            break;
                        }

                    case 3:
                        {
                            if (ty > 1)
                            {
                                u = Map.MapDataForUnit[tx, ty - 1];
                            }

                            break;
                        }

                    case 4:
                        {
                            if (ty < Map.MapHeight)
                            {
                                u = Map.MapDataForUnit[tx, ty + 1];
                            }

                            break;
                        }
                }

                if (u is null)
                {
                    goto NextUnit;
                }

                if (ReferenceEquals(u, this))
                {
                    goto NextUnit;
                }

                {
                    var withBlock1 = u;
                    // 正常な判断が可能？
                    if (withBlock1.IsConditionSatisfied("混乱") || withBlock1.IsConditionSatisfied("暴走") || withBlock1.IsConditionSatisfied("恐怖") || withBlock1.IsConditionSatisfied("狂戦士"))
                    {
                        goto NextUnit;
                    }

                    // 味方？
                    if (IsEnemy(u) || withBlock1.IsEnemy(this))
                    {
                        goto NextUnit;
                    }

                    // 同じチームに属している？
                    uteam = withBlock1.MainPilot().SkillData("チーム");
                    if ((team ?? "") != (uteam ?? "") && !string.IsNullOrEmpty(team) && !string.IsNullOrEmpty(uteam))
                    {
                        goto NextUnit;
                    }

                    // 移動のみの場合、相手がこれから移動してしまっては意味がない
                    if (!for_attack)
                    {
                        if (withBlock1.Action > 0)
                        {
                            goto NextUnit;
                        }
                    }

                    // 自分自身がサポート可能であれば、相手が誰でも役に立つ
                    if (do_support)
                    {
                        LookForSupportRet = (LookForSupportRet + 1);
                    }

                    // サポート能力を持っている？
                    {
                        var withBlock2 = withBlock1.MainPilot();
                        if (withBlock2.IsSkillAvailable("援護") || withBlock2.IsSkillAvailable("援護攻撃"))
                        {
                            LookForSupportRet = (LookForSupportRet + 1);
                            // これから攻撃する場合、相手が行動出来ればサポートアタックが可能
                            if (for_attack)
                            {
                                if (u.Action > 0)
                                {
                                    LookForSupportRet = (LookForSupportRet + 1);
                                    // 同時援護攻撃が可能であればさらにボーナス
                                    if (MainPilot().IsSkillAvailable("統率"))
                                    {
                                        LookForSupportRet = (LookForSupportRet + 1);
                                    }
                                }
                            }
                        }
                        else if (withBlock2.IsSkillAvailable("援護防御") || withBlock2.IsSkillAvailable("指揮") || withBlock2.IsSkillAvailable("広域サポート"))
                        {
                            LookForSupportRet = (LookForSupportRet + 1);
                        }
                    }
                }

                NextUnit:
                ;
            }

            return LookForSupportRet;
        }

        // 合体技のパートナーを探す
        // UPGRADE_NOTE: ctype は ctype にアップグレードされました。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="A9E4979A-37FA-4718-9994-97DD76ED70A7"' をクリックしてください。
        public void CombinationPartner(string ctype, int w, Unit[] partners, int tx = 0, int ty = 0, bool check_formation = false)
        {
            Unit u;
            string uname;
            int j, i, k;
            int clevel = default, cnum = default;
            var clist = default(string);
            string cname;
            int cmorale, cen, cplana = default;
            int crange, loop_limit;

            // 正常な判断が可能？
            if (IsConditionSatisfied("混乱"))
            {
                partners = new Unit[1];
                return;
            }

            // 合体技のデータを調べておく
            if (ctype == "武装")
            {
                cname = Weapon(w).Name;
                cen = WeaponENConsumption(w);
                cmorale = Weapon(w).NecessaryMorale;
                if (IsWeaponClassifiedAs(w, "霊"))
                {
                    cplana = (5d * WeaponLevel(w, "霊"));
                }
                else if (IsWeaponClassifiedAs(w, "プ"))
                {
                    cplana = (5d * WeaponLevel(w, "プ"));
                }

                crange = WeaponMaxRange(w);
            }
            else
            {
                cname = Ability(w).Name;
                cen = AbilityENConsumption(w);
                cmorale = Ability(w).NecessaryMorale;
                if (IsAbilityClassifiedAs(w, "霊"))
                {
                    cplana = (5d * AbilityLevel(w, "霊"));
                }
                else if (IsAbilityClassifiedAs(w, "プ"))
                {
                    cplana = (5d * AbilityLevel(w, "プ"));
                }

                crange = AbilityMaxRange(w);
            }

            // ユニットの特殊能力「合体技」の検索
            var loopTo = CountFeature();
            for (i = 1; i <= loopTo; i++)
            {
                if (Feature(i) == "合体技")
                {
                    string localFeatureData1() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                    if ((GeneralLib.LIndex(localFeatureData1(), 1) ?? "") == (cname ?? ""))
                    {
                        if (IsFeatureLevelSpecified(i))
                        {
                            clevel = FeatureLevel(i);
                        }
                        else
                        {
                            clevel = 0;
                        }

                        string localFeatureData() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                        clist = GeneralLib.ListTail(localFeatureData(), 2);
                        cnum = GeneralLib.LLength(clist);
                        break;
                    }
                }
            }

            if (i > CountFeature())
            {
                partners = new Unit[1];
                return;
            }

            // 出撃していない場合
            if (Status != "出撃" || string.IsNullOrEmpty(Map.MapFileName))
            {
                // パートナーが仲間にいるだけでよい
                var loopTo1 = cnum;
                for (i = 1; i <= loopTo1; i++)
                {
                    uname = GeneralLib.LIndex(clist, i);

                    // パートナーがユニット名で指定されている場合
                    if (SRC.UList.IsDefined(uname))
                    {
                        {
                            var withBlock = SRC.UList.Item(uname);
                            if (withBlock.Status == "出撃" || withBlock.Status == "待機")
                            {
                                goto NextPartner;
                            }
                        }
                    }

                    // パートナーがパイロット名で指定されている場合
                    if (SRC.PList.IsDefined(uname))
                    {
                        Pilot localItem1() { object argIndex1 = uname; var ret = SRC.PList.Item(argIndex1); return ret; }

                        Pilot localItem2() { object argIndex1 = uname; var ret = SRC.PList.Item(argIndex1); return ret; }

                        if (localItem2().Unit is object)
                        {
                            Pilot localItem() { object argIndex1 = uname; var ret = SRC.PList.Item(argIndex1); return ret; }

                            {
                                var withBlock1 = localItem().Unit;
                                if (withBlock1.Status == "出撃" || withBlock1.Status == "待機")
                                {
                                    goto NextPartner;
                                }
                            }
                        }
                    }

                    // パートナーが見つからなかった
                    partners = new Unit[1];
                    return;
                    NextPartner:
                    ;
                }
                // パートナーが全員仲間にいる
                partners = new Unit[(cnum + 1)];
                return;
            }

            // 合体技の基点の設定
            if (tx == 0)
            {
                tx = x;
            }

            if (ty == 0)
            {
                ty = y;
            }

            // パートナーの検索範囲を設定

            if (crange == 1)
            {
                if (cnum >= 8)
                {
                    // 射程１で８体合体以上の場合は２マス以内
                    loop_limit = 12;
                }
                else if (cnum >= 4)
                {
                    // 射程１で４体合体以上の場合は斜め隣接可
                    loop_limit = 8;
                }
                else
                {
                    // どれにも該当していなければ隣接のみ
                    loop_limit = 4;
                }
            }
            else if (cnum >= 9)
            {
                // 射程２以上で９体合体以上の場合は２マス以内
                loop_limit = 12;
            }
            else if (cnum >= 5)
            {
                // 射程２以上で５体合体以上の場合は斜め隣接可
                loop_limit = 8;
            }
            else
            {
                // どれにも該当していなければ隣接のみ
                loop_limit = 4;
            }

            // 合体技斜め隣接可オプション
            if (Expression.IsOptionDefined("合体技斜め隣接可"))
            {
                if (loop_limit == 4)
                {
                    loop_limit = 8;
                }
            }

            partners = new Unit[1];
            var loopTo2 = cnum;
            for (i = 1; i <= loopTo2; i++)
            {
                // パートナーの名称
                uname = GeneralLib.LIndex(clist, i);
                var loopTo3 = loop_limit;
                for (j = 1; j <= loopTo3; j++)
                {
                    // パートナーの検索位置設定
                    // UPGRADE_NOTE: オブジェクト u をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                    u = null;
                    switch (j)
                    {
                        case 1:
                            {
                                if (tx > 1)
                                {
                                    u = Map.MapDataForUnit[tx - 1, ty];
                                }

                                break;
                            }

                        case 2:
                            {
                                if (tx < Map.MapWidth)
                                {
                                    u = Map.MapDataForUnit[tx + 1, ty];
                                }

                                break;
                            }

                        case 3:
                            {
                                if (ty > 1)
                                {
                                    u = Map.MapDataForUnit[tx, ty - 1];
                                }

                                break;
                            }

                        case 4:
                            {
                                if (ty < Map.MapHeight)
                                {
                                    u = Map.MapDataForUnit[tx, ty + 1];
                                }

                                break;
                            }

                        case 5:
                            {
                                if (tx > 1 && ty > 1)
                                {
                                    u = Map.MapDataForUnit[tx - 1, ty - 1];
                                }

                                break;
                            }

                        case 6:
                            {
                                if (tx < Map.MapWidth && ty < Map.MapHeight)
                                {
                                    u = Map.MapDataForUnit[tx + 1, ty + 1];
                                }

                                break;
                            }

                        case 7:
                            {
                                if (tx > 1 && ty < Map.MapHeight)
                                {
                                    u = Map.MapDataForUnit[tx - 1, ty + 1];
                                }

                                break;
                            }

                        case 8:
                            {
                                if (tx < Map.MapWidth && ty > 1)
                                {
                                    u = Map.MapDataForUnit[tx + 1, ty - 1];
                                }

                                break;
                            }

                        case 9:
                            {
                                if (tx > 2)
                                {
                                    u = Map.MapDataForUnit[tx - 2, ty];
                                }

                                break;
                            }

                        case 10:
                            {
                                if (tx < Map.MapWidth - 1)
                                {
                                    u = Map.MapDataForUnit[tx + 2, ty];
                                }

                                break;
                            }

                        case 11:
                            {
                                if (ty > 2)
                                {
                                    u = Map.MapDataForUnit[tx, ty - 2];
                                }

                                break;
                            }

                        case 12:
                            {
                                if (ty < Map.MapHeight - 1)
                                {
                                    u = Map.MapDataForUnit[tx, ty + 2];
                                }

                                break;
                            }
                    }

                    // ユニットが存在する？
                    if (u is null)
                    {
                        goto NextNeighbor;
                    }

                    {
                        var withBlock2 = u;
                        // 合体技のパートナーに該当する？
                        if ((withBlock2.Name ?? "") != (uname ?? ""))
                        {
                            // パイロット名でも確認
                            if ((withBlock2.MainPilot().Name ?? "") != (uname ?? ""))
                            {
                                goto NextNeighbor;
                            }
                        }

                        // ユニットが自分？
                        if (ReferenceEquals(u, this))
                        {
                            goto NextNeighbor;
                        }

                        // 既に選択済み？
                        var loopTo4 = Information.UBound(partners);
                        for (k = 1; k <= loopTo4; k++)
                        {
                            if (ReferenceEquals(u, partners[k]))
                            {
                                goto NextNeighbor;
                            }
                        }

                        // ユニットが敵？
                        if (IsEnemy(u))
                        {
                            goto NextNeighbor;
                        }

                        // 行動出来なければだめ
                        if (withBlock2.MaxAction() == 0 || withBlock2.IsConditionSatisfied("混乱") || withBlock2.IsConditionSatisfied("恐怖") || withBlock2.IsConditionSatisfied("憑依"))
                        {
                            goto NextNeighbor;
                        }

                        // 合体技にレベルが設定されていればパイロット間の信頼度をチェック
                        if (clevel > 0)
                        {
                            if (MainPilot().Relation(withBlock2.MainPilot()) < clevel || withBlock2.MainPilot().Relation(MainPilot()) < clevel)
                            {
                                goto NextNeighbor;
                            }
                        }

                        // パートナーが武器を使うための条件を満たしているかを判定
                        if (!check_formation)
                        {
                            if (ctype == "武装")
                            {
                                // 合体技と同名の武器を検索
                                var loopTo5 = withBlock2.CountWeapon();
                                for (k = 1; k <= loopTo5; k++)
                                {
                                    if ((withBlock2.Weapon(k).Name ?? "") == (cname ?? ""))
                                    {
                                        break;
                                    }
                                }

                                if (k <= withBlock2.CountWeapon())
                                {
                                    // 武器が使える？
                                    if (!withBlock2.IsWeaponMastered(k))
                                    {
                                        goto NextNeighbor;
                                    }

                                    if (withBlock2.Weapon(k).NecessaryMorale > 0)
                                    {
                                        if (withBlock2.MainPilot().Morale < withBlock2.Weapon(k).NecessaryMorale)
                                        {
                                            goto NextNeighbor;
                                        }
                                    }

                                    if (withBlock2.WeaponENConsumption(k) > 0)
                                    {
                                        if (withBlock2.EN < withBlock2.WeaponENConsumption(k))
                                        {
                                            goto NextNeighbor;
                                        }
                                    }

                                    if (withBlock2.Weapon(k).Bullet > 0)
                                    {
                                        if (withBlock2.Bullet(k) == 0)
                                        {
                                            goto NextNeighbor;
                                        }
                                    }

                                    if (withBlock2.WeaponLevel(k, "霊") > 0d)
                                    {
                                        if (withBlock2.MainPilot().Plana < 5d * withBlock2.WeaponLevel(k, "霊"))
                                        {
                                            goto NextNeighbor;
                                        }
                                    }
                                    else if (withBlock2.WeaponLevel(k, "プ") > 0d)
                                    {
                                        if (withBlock2.MainPilot().Plana < 5d * withBlock2.WeaponLevel(k, "プ"))
                                        {
                                            goto NextNeighbor;
                                        }
                                    }
                                }
                                else
                                {
                                    // 同名の武器を持っていなかった場合はチェック項目を限定
                                    if (cmorale > 0)
                                    {
                                        if (withBlock2.MainPilot().Morale < cmorale)
                                        {
                                            goto NextNeighbor;
                                        }
                                    }

                                    if (cen > 0)
                                    {
                                        if (withBlock2.EN < cen)
                                        {
                                            goto NextNeighbor;
                                        }
                                    }

                                    if (cplana > 0)
                                    {
                                        if (withBlock2.MainPilot().Plana < cplana)
                                        {
                                            goto NextNeighbor;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                // 合体技と同名のアビリティを検索
                                var loopTo6 = withBlock2.CountAbility();
                                for (k = 1; k <= loopTo6; k++)
                                {
                                    if ((withBlock2.Ability(k).Name ?? "") == (cname ?? ""))
                                    {
                                        break;
                                    }
                                }

                                if (k <= withBlock2.CountAbility())
                                {
                                    // アビリティが使える？
                                    if (!withBlock2.IsAbilityMastered(k))
                                    {
                                        goto NextNeighbor;
                                    }

                                    if (withBlock2.Ability(k).NecessaryMorale > 0)
                                    {
                                        if (withBlock2.MainPilot().Morale < withBlock2.Ability(k).NecessaryMorale)
                                        {
                                            goto NextNeighbor;
                                        }
                                    }

                                    if (withBlock2.AbilityENConsumption(k) > 0)
                                    {
                                        if (withBlock2.EN < withBlock2.AbilityENConsumption(k))
                                        {
                                            goto NextNeighbor;
                                        }
                                    }

                                    if (withBlock2.Ability(k).Stock > 0)
                                    {
                                        if (withBlock2.Stock(k) == 0)
                                        {
                                            goto NextNeighbor;
                                        }
                                    }

                                    if (withBlock2.AbilityLevel(k, "霊") > 0d)
                                    {
                                        if (withBlock2.MainPilot().Plana < 5d * withBlock2.AbilityLevel(k, "霊"))
                                        {
                                            goto NextNeighbor;
                                        }
                                    }
                                    else if (withBlock2.AbilityLevel(k, "プ") > 0d)
                                    {
                                        if (withBlock2.MainPilot().Plana < 5d * withBlock2.AbilityLevel(k, "プ"))
                                        {
                                            goto NextNeighbor;
                                        }
                                    }
                                }
                                else
                                {
                                    // 同名のアビリティを持っていなかった場合はチェック項目を限定
                                    if (cmorale > 0)
                                    {
                                        if (withBlock2.MainPilot().Morale < cmorale)
                                        {
                                            goto NextNeighbor;
                                        }
                                    }

                                    if (cen > 0)
                                    {
                                        if (withBlock2.EN < cen)
                                        {
                                            goto NextNeighbor;
                                        }
                                    }

                                    if (cplana > 0)
                                    {
                                        if (withBlock2.MainPilot().Plana < cplana)
                                        {
                                            goto NextNeighbor;
                                        }
                                    }
                                }
                            }
                        }
                        // フォーメーションのチェックだけの時も必要技能は調べておく
                        else if (ctype == "武装")
                        {
                            var loopTo7 = withBlock2.CountWeapon();
                            for (k = 1; k <= loopTo7; k++)
                            {
                                if ((withBlock2.Weapon(k).Name ?? "") == (cname ?? ""))
                                {
                                    break;
                                }
                            }

                            if (k <= withBlock2.CountWeapon())
                            {
                                if (!withBlock2.IsWeaponMastered(k))
                                {
                                    goto NextNeighbor;
                                }
                            }
                        }
                        else
                        {
                            var loopTo8 = withBlock2.CountAbility();
                            for (k = 1; k <= loopTo8; k++)
                            {
                                if ((withBlock2.Ability(k).Name ?? "") == (cname ?? ""))
                                {
                                    break;
                                }
                            }

                            if (k <= withBlock2.CountAbility())
                            {
                                if (!withBlock2.IsAbilityMastered(k))
                                {
                                    goto NextNeighbor;
                                }
                            }
                        }
                    }

                    // 見つかったパートナーを記録
                    Array.Resize(partners, i + 1);
                    partners[i] = u;
                    break;
                    NextNeighbor:
                    ;
                }

                // パートナーが見つからなかった？
                if (j > loop_limit)
                {
                    partners = new Unit[1];
                    return;
                }
            }

            // 合体技メッセージ判定用にパートナー一覧を記録
            Commands.SelectedPartners = new Unit[Information.UBound(partners) + 1];
            var loopTo9 = Information.UBound(partners);
            for (i = 1; i <= loopTo9; i++)
                Commands.SelectedPartners[i] = partners[i];
        }

        // 合体技攻撃に必要なパートナーが見つかるか？
        public bool IsCombinationAttackAvailable(int w, bool check_formation = false)
        {
            bool IsCombinationAttackAvailableRet = default;
            Unit[] partners;
            partners = new Unit[1];
            if (Status == "待機" || string.IsNullOrEmpty(Map.MapFileName))
            {
                // 出撃時以外は相手が仲間にいるだけでＯＫ
                CombinationPartner("武装", w, partners, x, y);
            }
            else if (WeaponMaxRange(w) == 1 && !IsWeaponClassifiedAs(w, "Ｍ"))
            {
                // 射程１の場合は自分の周りのいずれかの敵ユニットに対して合体技が使えればＯＫ
                if (x > 1)
                {
                    if (Map.MapDataForUnit[x - 1, y] is object)
                    {
                        if (IsEnemy(Map.MapDataForUnit[x - 1, y]))
                        {
                            CombinationPartner("武装", w, partners, (x - 1), y, check_formation);
                        }
                    }
                }

                if (Information.UBound(partners) == 0)
                {
                    if (x < Map.MapWidth)
                    {
                        if (Map.MapDataForUnit[x + 1, y] is object)
                        {
                            if (IsEnemy(Map.MapDataForUnit[x + 1, y]))
                            {
                                CombinationPartner("武装", w, partners, (x + 1), y, check_formation);
                            }
                        }
                    }
                }

                if (Information.UBound(partners) == 0)
                {
                    if (y > 1)
                    {
                        if (Map.MapDataForUnit[x, y - 1] is object)
                        {
                            if (IsEnemy(Map.MapDataForUnit[x, y - 1]))
                            {
                                CombinationPartner("武装", w, partners, x, (y - 1), check_formation);
                            }
                        }
                    }
                }

                if (Information.UBound(partners) == 0)
                {
                    if (y < Map.MapHeight)
                    {
                        if (Map.MapDataForUnit[x, y + 1] is object)
                        {
                            if (IsEnemy(Map.MapDataForUnit[x, y + 1]))
                            {
                                CombinationPartner("武装", w, partners, x, (y + 1), check_formation);
                            }
                        }
                    }
                }
            }
            else
            {
                // 射程２以上の場合は自分の周りにパートナーがいればＯＫ
                CombinationPartner("武装", w, partners, x, y, check_formation);
            }

            // 条件を満たすパートナーの組が見つかったか判定
            if (Information.UBound(partners) > 0)
            {
                IsCombinationAttackAvailableRet = true;
            }
            else
            {
                IsCombinationAttackAvailableRet = false;
            }

            return IsCombinationAttackAvailableRet;
        }

        // 合体技アビリティに必要なパートナーが見つかるか？
        public bool IsCombinationAbilityAvailable(int a, bool check_formation = false)
        {
            bool IsCombinationAbilityAvailableRet = default;
            Unit[] partners;
            partners = new Unit[1];
            if (Status == "待機" || string.IsNullOrEmpty(Map.MapFileName))
            {
                // 出撃時以外は相手が仲間にいるだけでＯＫ
                CombinationPartner("アビリティ", a, partners, x, y);
            }
            else if (AbilityMaxRange(a) == 1 && !IsAbilityClassifiedAs(a, "Ｍ"))
            {
                // 射程１の場合は自分の周りのいずれかの味方ユニットに対して合体技が使えればＯＫ
                if (x > 1)
                {
                    if (Map.MapDataForUnit[x - 1, y] is object)
                    {
                        if (IsAlly(Map.MapDataForUnit[x - 1, y]))
                        {
                            CombinationPartner("アビリティ", a, partners, (x - 1), y, check_formation);
                        }
                    }
                }

                if (Information.UBound(partners) == 0)
                {
                    if (x < Map.MapWidth)
                    {
                        if (Map.MapDataForUnit[x + 1, y] is object)
                        {
                            if (IsAlly(Map.MapDataForUnit[x + 1, y]))
                            {
                                CombinationPartner("アビリティ", a, partners, (x + 1), y, check_formation);
                            }
                        }
                    }
                }

                if (Information.UBound(partners) == 0)
                {
                    if (y > 1)
                    {
                        if (Map.MapDataForUnit[x, y - 1] is object)
                        {
                            if (IsAlly(Map.MapDataForUnit[x, y - 1]))
                            {
                                CombinationPartner("アビリティ", a, partners, x, (y - 1), check_formation);
                            }
                        }
                    }
                }

                if (Information.UBound(partners) == 0)
                {
                    if (y > Map.MapHeight)
                    {
                        if (Map.MapDataForUnit[x, y + 1] is object)
                        {
                            if (IsAlly(Map.MapDataForUnit[x, y + 1]))
                            {
                                CombinationPartner("アビリティ", a, partners, x, (y + 1), check_formation);
                            }
                        }
                    }
                }
            }
            else
            {
                // 射程２以上の場合は自分の周りにパートナーがいればＯＫ
                CombinationPartner("アビリティ", a, partners, x, y, check_formation);
            }

            // 条件を満たすパートナーの組が見つかったか判定
            if (Information.UBound(partners) > 0)
            {
                IsCombinationAbilityAvailableRet = true;
            }
            else
            {
                IsCombinationAbilityAvailableRet = false;
            }

            return IsCombinationAbilityAvailableRet;
        }

        // (tx,ty)にユニットが進入可能か？
        public bool IsAbleToEnter(int tx, int ty)
        {
            bool IsAbleToEnterRet = default;
            bool ignore_move_cost;

            // 使用不能の形態はどの地形に対しても進入不可能とみなす
            if (!IsAvailable())
            {
                IsAbleToEnterRet = false;
                return IsAbleToEnterRet;
            }

            // 単に必要技能をチェックしている場合？
            if (string.IsNullOrEmpty(Map.MapFileName))
            {
                IsAbleToEnterRet = true;
                return IsAbleToEnterRet;
            }

            // マップ外？
            if (tx < 1 || Map.MapWidth < tx || ty < 1 || Map.MapHeight < ty)
            {
                IsAbleToEnterRet = false;
                return IsAbleToEnterRet;
            }

            // 地形適応チェック
            switch (Map.TerrainClass(tx, ty) ?? "")
            {
                case "空":
                    {
                        if (!IsTransAvailable("空") && !CurrentForm().IsFeatureAvailable("空中移動"))
                        {
                            IsAbleToEnterRet = false;
                            return IsAbleToEnterRet;
                        }

                        break;
                    }

                case "水":
                    {
                        if (IsTransAvailable("空") || CurrentForm().IsFeatureAvailable("空中移動") || IsTransAvailable("水上"))
                        {
                            IsAbleToEnterRet = true;
                            return IsAbleToEnterRet;
                        }

                        if (get_Adaption(3) == 0 && !CurrentForm().IsFeatureAvailable("水中移動"))
                        {
                            IsAbleToEnterRet = false;
                            return IsAbleToEnterRet;
                        }

                        break;
                    }

                case "深水":
                    {
                        if (IsTransAvailable("空") || CurrentForm().IsFeatureAvailable("空中移動") || IsTransAvailable("水上"))
                        {
                            IsAbleToEnterRet = true;
                            return IsAbleToEnterRet;
                        }

                        if (!IsTransAvailable("水") && !CurrentForm().IsFeatureAvailable("水中移動"))
                        {
                            IsAbleToEnterRet = false;
                            return IsAbleToEnterRet;
                        }

                        break;
                    }

                case "宇宙":
                    {
                        if (get_Adaption(4) == 0 && !CurrentForm().IsFeatureAvailable("宇宙移動"))
                        {
                            IsAbleToEnterRet = false;
                            return IsAbleToEnterRet;
                        }

                        break;
                    }

                case "月面":
                    {
                        if (IsTransAvailable("空") || CurrentForm().IsFeatureAvailable("空中移動") || IsTransAvailable("宇") || CurrentForm().IsFeatureAvailable("宇宙移動"))
                        {
                            IsAbleToEnterRet = true;
                            return IsAbleToEnterRet;
                        }

                        break;
                    }

                default:
                    {
                        if (IsTransAvailable("空") || CurrentForm().IsFeatureAvailable("空中移動"))
                        {
                            IsAbleToEnterRet = true;
                            return IsAbleToEnterRet;
                        }

                        if (!IsTransAvailable("陸") && !CurrentForm().IsFeatureAvailable("陸上移動"))
                        {
                            IsAbleToEnterRet = false;
                            return IsAbleToEnterRet;
                        }

                        break;
                    }
            }

            // 進入不能？
            if (Map.TerrainMoveCost(tx, ty) >= 1000)
            {
                IsAbleToEnterRet = false;
                return IsAbleToEnterRet;
            }

            IsAbleToEnterRet = true;
            return IsAbleToEnterRet;
        }

        // この形態が使用可能か？ (Disable＆必要技能のチェック)
        public bool IsAvailable()
        {
            bool IsAvailableRet = default;
            int i;
            IsAvailableRet = true;

            // イベントコマンド「Disable」
            bool localIsDisabled() { string argfname = Name; var ret = IsDisabled(argfname); Name = argfname; return ret; }

            if (localIsDisabled())
            {
                IsAvailableRet = false;
                return IsAvailableRet;
            }

            // 制限時間の切れた形態？
            if (Status == "他形態")
            {
                if (IsConditionSatisfied("行動不能"))
                {
                    IsAvailableRet = false;
                    return IsAvailableRet;
                }
            }

            {
                var withBlock = CurrentForm();
                // 技能チェックが必要？
                if (withBlock.CountPilot() == 0 || !IsFeatureAvailable("必要技能") && !IsFeatureAvailable("不必要技能"))
                {
                    return IsAvailableRet;
                }

                // 必要技能をチェック
                var loopTo = CountFeature();
                for (i = 1; i <= loopTo; i++)
                {
                    switch (Feature(i) ?? "")
                    {
                        case "必要技能":
                            {
                                string localFeatureData() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                                bool localIsNecessarySkillSatisfied() { string argnabilities = hsc9e6151c7b7e42d6b233bb86f17bea66(); Pilot argp = null; var ret = withBlock.IsNecessarySkillSatisfied(argnabilities, p: argp); return ret; }

                                if (!localIsNecessarySkillSatisfied())
                                {
                                    IsAvailableRet = false;
                                    return IsAvailableRet;
                                }

                                break;
                            }

                        case "不必要技能":
                            {
                                string localFeatureData1() { object argIndex1 = i; var ret = FeatureData(argIndex1); return ret; }

                                if (withBlock.IsNecessarySkillSatisfied(localFeatureData1(), p: null))
                                {
                                    IsAvailableRet = false;
                                    return IsAvailableRet;
                                }

                                break;
                            }
                    }
                }
            }

            return IsAvailableRet;
        }

        // 必要技能を満たしているか？
        public bool IsNecessarySkillSatisfied(string nabilities, [Optional, DefaultParameterValue(null)] Pilot p)
        {
            bool IsNecessarySkillSatisfiedRet = default;
            int i, num;
            var nskill_list = new string[101];
            if (Strings.Len(nabilities) == 0)
            {
                IsNecessarySkillSatisfiedRet = true;
                return IsNecessarySkillSatisfiedRet;
            }

            num = GeneralLib.LLength(nabilities);
            var loopTo = GeneralLib.MinLng(num, 100);
            for (i = 1; i <= loopTo; i++)
                nskill_list[i] = GeneralLib.LIndex(nabilities, i);

            // 個々の必要条件をチェック
            i = 1;
            while (i <= GeneralLib.MinLng(num, 100))
            {
                if (IsNecessarySkillSatisfied2(nskill_list[i], p))
                {
                    // 必要条件が満たされた場合、その後の「or」をスキップ
                    if (i <= num - 2)
                    {
                        while (Strings.LCase(nskill_list[i + 1]) == "or")
                        {
                            i = (i + 2);
                            // 検査する必要条件が無くなったので必要技能が満たされたと判定
                            if (i == num)
                            {
                                IsNecessarySkillSatisfiedRet = true;
                                return IsNecessarySkillSatisfiedRet;
                            }
                            else if (i > num)
                            {
                                // orの後ろに必要条件がない
                                GUI.ErrorMessage(Name + "に対する必要技能「" + nabilities + "」が不正です");
                                SRC.TerminateSRC();
                            }
                        }
                    }
                }
                else
                {
                    // 必要条件が満たされなかった場合、その後に「or」がなければ
                    // 必要技能が満たされなかったと判定
                    if (i > num - 2)
                    {
                        return IsNecessarySkillSatisfiedRet;
                    }

                    i = (i + 1);
                    if (Strings.LCase(nskill_list[i]) != "or")
                    {
                        return IsNecessarySkillSatisfiedRet;
                    }
                }

                i = (i + 1);
            }

            IsNecessarySkillSatisfiedRet = true;
            return IsNecessarySkillSatisfiedRet;
        }

        public bool IsNecessarySkillSatisfied2(string ndata, Pilot p)
        {
            bool IsNecessarySkillSatisfied2Ret = default;
            string stype2, stype, sname;
            double slevel;
            double nlevel;
            var mp = default(Pilot);
            int i, j;

            // ステータスコマンド実行時は条件が満たされていると見なす？
            if (Strings.Left(ndata, 1) == "+")
            {
                if (Status == "出撃" && InterMission.InStatusCommand())
                {
                    IsNecessarySkillSatisfied2Ret = true;
                    return IsNecessarySkillSatisfied2Ret;
                }

                ndata = Strings.Mid(ndata, 2);
            }

            // 召喚者技能を参照？
            if (Strings.Left(ndata, 1) == "*")
            {
                if (Summoner is null)
                {
                    return IsNecessarySkillSatisfied2Ret;
                }

                IsNecessarySkillSatisfied2Ret = Summoner.IsNecessarySkillSatisfied2(Strings.Mid(ndata, 2), null);
                return IsNecessarySkillSatisfied2Ret;
            }

            i = Strings.InStr(ndata, "Lv");
            if (i > 0)
            {
                sname = Strings.Left(ndata, i - 1);
                nlevel = GeneralLib.StrToDbl(Strings.Mid(ndata, i + 2));
            }
            else
            {
                sname = ndata;
                nlevel = 1d;
            }

            // 不必要技能？
            if (Strings.Left(sname, 1) == "!")
            {
                bool localIsNecessarySkillSatisfied2() { string argndata = Strings.Mid(ndata, 2); var ret = IsNecessarySkillSatisfied2(argndata, p); return ret; }

                IsNecessarySkillSatisfied2Ret = !localIsNecessarySkillSatisfied2();
                return IsNecessarySkillSatisfied2Ret;
            }

            // 必要技能の判定に使用するパイロットを設定
            if (p is null)
            {
                if (CountPilot() > 0)
                {
                    mp = MainPilot();
                }
                else
                {
                    {
                        var withBlock = CurrentForm();
                        if (withBlock.CountPilot() > 0)
                        {
                            mp = withBlock.MainPilot();
                        }
                    }
                }
            }
            else
            {
                mp = p;
            }

            // ダミーパイロットの場合は無視
            if (mp is object)
            {
                if (mp.Nickname0 == "パイロット不在")
                {
                    // UPGRADE_NOTE: オブジェクト mp をガベージ コレクトするまでこのオブジェクトを破棄することはできません。 詳細については、'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"' をクリックしてください。
                    mp = null;
                }
            }

            slevel = -10000;

            // まず名称が変わらない必要技能を判定
            switch (sname ?? "")
            {
                case "レベル":
                    {
                        if (mp is object)
                        {
                            slevel = mp.Level;
                        }
                        else
                        {
                            slevel = 0d;
                        }

                        break;
                    }

                case "格闘":
                    {
                        if (mp is object)
                        {
                            slevel = mp.InfightBase;
                        }
                        else
                        {
                            slevel = 0d;
                        }

                        break;
                    }

                case "射撃":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            if (!mp.HasMana())
                            {
                                slevel = mp.ShootingBase;
                            }
                        }

                        break;
                    }

                case "魔力":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            if (mp.HasMana())
                            {
                                slevel = mp.ShootingBase;
                            }
                        }

                        break;
                    }

                case "命中":
                    {
                        if (mp is object)
                        {
                            slevel = mp.HitBase;
                        }
                        else
                        {
                            slevel = 0d;
                        }

                        break;
                    }

                case "回避":
                    {
                        if (mp is object)
                        {
                            slevel = mp.DodgeBase;
                        }
                        else
                        {
                            slevel = 0d;
                        }

                        break;
                    }

                case "技量":
                    {
                        if (mp is object)
                        {
                            slevel = mp.TechniqueBase;
                        }
                        else
                        {
                            slevel = 0d;
                        }

                        break;
                    }

                case "反応":
                    {
                        if (mp is object)
                        {
                            slevel = mp.IntuitionBase;
                        }
                        else
                        {
                            slevel = 0d;
                        }

                        break;
                    }

                case "格闘初期値":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            if (Expression.IsOptionDefined("攻撃力低成長"))
                            {
                                slevel = mp.InfightBase - mp.Level / 2;
                            }
                            else
                            {
                                slevel = mp.InfightBase - mp.Level;
                            }
                        }

                        break;
                    }

                case "射撃初期値":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            if (!mp.HasMana())
                            {
                                if (Expression.IsOptionDefined("攻撃力低成長"))
                                {
                                    slevel = mp.ShootingBase - mp.Level / 2;
                                }
                                else
                                {
                                    slevel = mp.ShootingBase - mp.Level;
                                }
                            }
                        }

                        break;
                    }

                case "魔力初期値":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            if (mp.HasMana())
                            {
                                if (Expression.IsOptionDefined("攻撃力低成長"))
                                {
                                    slevel = mp.ShootingBase - mp.Level / 2;
                                }
                                else
                                {
                                    slevel = mp.ShootingBase - mp.Level;
                                }
                            }
                        }

                        break;
                    }

                case "命中初期値":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            slevel = mp.HitBase - mp.Level;
                        }

                        break;
                    }

                case "回避初期値":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            slevel = mp.DodgeBase - mp.Level;
                        }

                        break;
                    }

                case "技量初期値":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            slevel = mp.TechniqueBase - mp.Level;
                        }

                        break;
                    }

                case "反応初期値":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            slevel = mp.IntuitionBase - mp.Level;
                        }

                        break;
                    }

                case "男性":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            if (mp.Sex == "男性")
                            {
                                slevel = 1d;
                            }

                            if (Data.PilotNum > 1)
                            {
                                var loopTo = CountPilot();
                                for (i = 1; i <= loopTo; i++)
                                {
                                    Pilot localPilot() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                                    if (localPilot().Sex == "男性")
                                    {
                                        slevel = 1d;
                                    }
                                }
                            }

                            var loopTo1 = CountSupport();
                            for (i = 1; i <= loopTo1; i++)
                            {
                                Pilot localSupport() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                                if (localSupport().Sex == "男性")
                                {
                                    slevel = 1d;
                                }
                            }

                            if (IsFeatureAvailable("追加サポート"))
                            {
                                if (AdditionalSupport().Sex == "男性")
                                {
                                    slevel = 1d;
                                }
                            }
                        }

                        break;
                    }

                case "女性":
                    {
                        slevel = 0d;
                        if (mp is object)
                        {
                            if (mp.Sex == "女性")
                            {
                                slevel = 1d;
                            }

                            if (Data.PilotNum > 1)
                            {
                                var loopTo2 = CountPilot();
                                for (i = 1; i <= loopTo2; i++)
                                {
                                    Pilot localPilot1() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                                    if (localPilot1().Sex == "女性")
                                    {
                                        slevel = 1d;
                                    }
                                }
                            }

                            var loopTo3 = CountSupport();
                            for (i = 1; i <= loopTo3; i++)
                            {
                                Pilot localSupport1() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                                if (localSupport1().Sex == "女性")
                                {
                                    slevel = 1d;
                                }
                            }

                            if (IsFeatureAvailable("追加サポート"))
                            {
                                if (AdditionalSupport().Sex == "女性")
                                {
                                    slevel = 1d;
                                }
                            }
                        }

                        break;
                    }

                case "生身":
                    {
                        if (IsHero())
                        {
                            slevel = 1d;
                        }
                        else
                        {
                            slevel = 0d;
                        }

                        break;
                    }

                case "瀕死":
                    {
                        if (HP <= MaxHP / 4)
                        {
                            slevel = 1d;
                        }
                        else
                        {
                            slevel = 0d;
                        }

                        break;
                    }

                case "ＨＰ":
                    {
                        slevel = 10d * HP / MaxHP;
                        break;
                    }

                case "ＥＮ":
                    {
                        slevel = 10d * EN / MaxEN;
                        break;
                    }

                case "気力":
                    {
                        if (mp is object)
                        {
                            slevel = mp.Morale - 100d;
                            slevel = slevel / 10d;
                        }
                        else
                        {
                            slevel = 0d;
                        }

                        break;
                    }

                case "ランク":
                    {
                        slevel = Rank;
                        break;
                    }

                case "地上":
                case "空中":
                case "水中":
                case "水上":
                case "宇宙":
                case "地中":
                    {
                        slevel = 0d;
                        if (Status == "出撃")
                        {
                            if ((sname ?? "") == (Area ?? ""))
                            {
                                slevel = 1d;
                            }
                        }

                        break;
                    }

                case "アイテム":
                    {
                        // 使い捨てアイテム表記用
                        slevel = 1d;
                        break;
                    }

                case "当て身技":
                case "自動反撃":
                    {
                        // アビリティで付加された当て身技及び自動反撃専用の武器が表示されるのを
                        // 防ぐため、これらの必要技能は常に満たされないとみなす
                        return IsNecessarySkillSatisfied2Ret;
                    }
            }

            // 上の条件のいずれかに該当？
            if (slevel != -10000)
            {
                // 指定された技能のレベルが必要なレベル以上の場合に必要技能が満たされたと判定
                if (slevel >= nlevel)
                {
                    IsNecessarySkillSatisfied2Ret = true;
                }

                return IsNecessarySkillSatisfied2Ret;
            }

            // 必要技能の種類を判別
            if (mp is object)
            {
                stype = mp.SkillType(sname);
            }
            else
            {
                stype = sname;
            }

            // 名称が変わる可能性がある必要技能を判定
            string iname;
            string uname;
            Unit u;
            int max_range;
            switch (stype ?? "")
            {
                case "超感覚":
                    {
                        if (p is object)
                        {
                            slevel = p.SkillLevel("超感覚", ref_mode: "");
                            if ((stype ?? "") != (sname ?? ""))
                            {
                                if ((p.SkillNameForNS(stype) ?? "") != (sname ?? ""))
                                {
                                    slevel = 0d;
                                }
                            }

                            slevel = slevel + p.SkillLevel("知覚強化", ref_mode: "");
                        }
                        else if (mp is object)
                        {
                            slevel = mp.SkillLevel("超感覚", ref_mode: "");
                            if (Data.PilotNum > 1)
                            {
                                var loopTo4 = CountPilot();
                                for (i = 2; i <= loopTo4; i++)
                                {
                                    {
                                        var withBlock1 = Pilot(i);
                                        slevel = GeneralLib.MaxDbl(slevel, withBlock1.SkillLevel("超感覚", ref_mode: ""));
                                        double localSkillLevel() { object argIndex1 = sname; string argref_mode = ""; var ret = withBlock1.SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                        slevel = GeneralLib.MaxDbl(slevel, localSkillLevel());
                                    }
                                }
                            }

                            var loopTo5 = CountSupport();
                            for (i = 1; i <= loopTo5; i++)
                            {
                                {
                                    var withBlock2 = Support(i);
                                    slevel = GeneralLib.MaxDbl(slevel, withBlock2.SkillLevel("超感覚", ref_mode: ""));
                                    double localSkillLevel1() { object argIndex1 = sname; string argref_mode = ""; var ret = withBlock2.SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                    slevel = GeneralLib.MaxDbl(slevel, localSkillLevel1());
                                }
                            }

                            if (IsFeatureAvailable("追加サポート"))
                            {
                                {
                                    var withBlock3 = AdditionalSupport();
                                    slevel = GeneralLib.MaxDbl(slevel, withBlock3.SkillLevel("超感覚", ref_mode: ""));
                                    double localSkillLevel2() { object argIndex1 = sname; string argref_mode = ""; var ret = withBlock3.SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                    slevel = GeneralLib.MaxDbl(slevel, localSkillLevel2());
                                }
                            }

                            if ((stype ?? "") != (sname ?? ""))
                            {
                                if ((mp.SkillNameForNS(stype) ?? "") != (sname ?? ""))
                                {
                                    slevel = 0d;
                                }
                            }

                            slevel = slevel + mp.SkillLevel("知覚強化", ref_mode: "");
                            if (Data.PilotNum > 1)
                            {
                                var loopTo6 = CountPilot();
                                for (i = 2; i <= loopTo6; i++)
                                {
                                    Pilot localPilot2() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                                    slevel = GeneralLib.MaxDbl(slevel, localPilot2().SkillLevel("知覚強化", ref_mode: ""));
                                }
                            }

                            var loopTo7 = CountSupport();
                            for (i = 1; i <= loopTo7; i++)
                            {
                                Pilot localSupport2() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                                slevel = GeneralLib.MaxDbl(slevel, localSupport2().SkillLevel("知覚強化", ref_mode: ""));
                            }

                            if (IsFeatureAvailable("追加サポート"))
                            {
                                slevel = GeneralLib.MaxDbl(slevel, AdditionalSupport().SkillLevel("知覚強化", ref_mode: ""));
                            }
                        }

                        break;
                    }

                case "同調率":
                    {
                        if (p is object)
                        {
                            slevel = p.SynchroRate();
                        }
                        else if (mp is object)
                        {
                            slevel = mp.SynchroRate();
                            if (Data.PilotNum > 1)
                            {
                                var loopTo8 = CountPilot();
                                for (i = 2; i <= loopTo8; i++)
                                {
                                    Pilot localPilot3() { object argIndex1 = i; var ret = Pilot(argIndex1); return ret; }

                                    slevel = GeneralLib.MaxDbl(slevel, localPilot3().SynchroRate());
                                }
                            }

                            var loopTo9 = CountSupport();
                            for (i = 1; i <= loopTo9; i++)
                            {
                                Pilot localSupport3() { object argIndex1 = i; var ret = Support(argIndex1); return ret; }

                                slevel = GeneralLib.MaxDbl(slevel, localSupport3().SynchroRate());
                            }

                            if (IsFeatureAvailable("追加サポート"))
                            {
                                slevel = GeneralLib.MaxDbl(slevel, AdditionalSupport().SynchroRate());
                            }
                        }

                        if ((stype ?? "") != (sname ?? ""))
                        {
                            if ((mp.SkillNameForNS(stype) ?? "") != (sname ?? ""))
                            {
                                slevel = 0d;
                            }
                        }

                        break;
                    }

                case "オーラ":
                    {
                        if (p is object)
                        {
                            slevel = p.SkillLevel("オーラ", ref_mode: "");
                        }
                        else if (mp is object)
                        {
                            slevel = AuraLevel();
                        }

                        if ((stype ?? "") != (sname ?? ""))
                        {
                            if ((mp.SkillNameForNS(stype) ?? "") != (sname ?? ""))
                            {
                                slevel = 0d;
                            }
                        }

                        break;
                    }

                case "霊力":
                    {
                        if (p is object)
                        {
                            slevel = p.Plana;
                        }
                        else if (mp is object)
                        {
                            slevel = mp.Plana;
                        }

                        if ((stype ?? "") != (sname ?? ""))
                        {
                            if ((mp.SkillNameForNS(stype) ?? "") != (sname ?? ""))
                            {
                                slevel = 0d;
                            }
                        }

                        break;
                    }

                default:
                    {
                        // 上記以外のパイロット用特殊能力

                        if (mp is object)
                        {
                            // 特定パイロット専用？
                            if ((sname ?? "") == (mp.Name ?? "") || (sname ?? "") == (mp.get_Nickname(false) ?? ""))
                            {
                                slevel = 1d;
                            }
                            else if ((stype ?? "") == (sname ?? ""))
                            {
                                slevel = mp.SkillLevel(stype, ref_mode: "");
                            }
                            else if ((mp.SkillNameForNS(stype) ?? "") == (sname ?? ""))
                            {
                                slevel = mp.SkillLevel(stype, ref_mode: "");
                            }

                            // パイロット数が括弧つきでない場合のみ
                            if (Data.PilotNum > 1)
                            {
                                // サブパイロットの技能を検索
                                var loopTo10 = CountPilot();
                                for (i = 2; i <= loopTo10; i++)
                                {
                                    {
                                        var withBlock4 = Pilot(i);
                                        if ((sname ?? "") == (withBlock4.Name ?? "") || (sname ?? "") == (withBlock4.get_Nickname(false) ?? ""))
                                        {
                                            slevel = 1d;
                                            break;
                                        }

                                        stype2 = withBlock4.SkillType(sname);
                                        if ((stype2 ?? "") == (sname ?? ""))
                                        {
                                            double localSkillLevel3() { object argIndex1 = stype2; string argref_mode = ""; var ret = withBlock4.SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                            slevel = GeneralLib.MaxDbl(slevel, localSkillLevel3());
                                        }
                                        else if ((withBlock4.SkillNameForNS(stype2) ?? "") == (sname ?? ""))
                                        {
                                            double localSkillLevel4() { object argIndex1 = stype2; string argref_mode = ""; var ret = withBlock4.SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                            slevel = GeneralLib.MaxDbl(slevel, localSkillLevel4());
                                        }
                                    }
                                }
                            }

                            // サポートパイロットの技能を検索
                            var loopTo11 = CountSupport();
                            for (i = 1; i <= loopTo11; i++)
                            {
                                {
                                    var withBlock5 = Support(i);
                                    if ((sname ?? "") == (withBlock5.Name ?? "") || (sname ?? "") == (withBlock5.get_Nickname(false) ?? ""))
                                    {
                                        slevel = 1d;
                                        break;
                                    }

                                    stype2 = withBlock5.SkillType(sname);
                                    if ((stype2 ?? "") == (sname ?? ""))
                                    {
                                        double localSkillLevel5() { object argIndex1 = stype2; string argref_mode = ""; var ret = withBlock5.SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                        slevel = GeneralLib.MaxDbl(slevel, localSkillLevel5());
                                    }
                                    else if ((withBlock5.SkillNameForNS(stype2) ?? "") == (sname ?? ""))
                                    {
                                        double localSkillLevel6() { object argIndex1 = stype2; string argref_mode = ""; var ret = withBlock5.SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                        slevel = GeneralLib.MaxDbl(slevel, localSkillLevel6());
                                    }
                                }
                            }

                            // 追加サポートの技能を検索
                            if (IsFeatureAvailable("追加サポート") && CountPilot() > 0)
                            {
                                {
                                    var withBlock6 = AdditionalSupport();
                                    if ((sname ?? "") == (withBlock6.Name ?? "") || (sname ?? "") == (withBlock6.get_Nickname(false) ?? ""))
                                    {
                                        slevel = 1d;
                                    }
                                    else
                                    {
                                        stype2 = withBlock6.SkillType(sname);
                                        if ((stype2 ?? "") == (sname ?? ""))
                                        {
                                            double localSkillLevel7() { object argIndex1 = stype2; string argref_mode = ""; var ret = withBlock6.SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                            slevel = GeneralLib.MaxDbl(slevel, localSkillLevel7());
                                        }
                                        else if ((withBlock6.SkillNameForNS(stype2) ?? "") == (sname ?? ""))
                                        {
                                            double localSkillLevel8() { object argIndex1 = stype2; string argref_mode = ""; var ret = withBlock6.SkillLevel(argIndex1, ref_mode: argref_mode); return ret; }

                                            slevel = GeneralLib.MaxDbl(slevel, localSkillLevel8());
                                        }
                                    }
                                }
                            }
                        }

                        if (slevel == 0d)
                        {
                            // ユニット名またはクラスに該当？
                            if ((sname ?? "") == (Name ?? "") || (sname ?? "") == (Nickname0 ?? "") || (sname ?? "") == (Class0 ?? ""))
                            {
                                slevel = 1d;
                            }
                        }

                        if (slevel == 0d)
                        {
                            if (Strings.Left(sname, 1) == "@")
                            {
                                // 地形を指定した必要技能
                                if (Status == "出撃" && 1 <= x && x <= Map.MapWidth && 1 <= y && y <= Map.MapHeight)
                                {
                                    if ((Strings.Mid(sname, 2) ?? "") == (Map.TerrainName(x, y) ?? ""))
                                    {
                                        slevel = 1d;
                                    }
                                }
                            }
                            else if (Strings.Right(sname, 2) == "装備")
                            {
                                // アイテムを指定した必要技能
                                iname = Strings.Left(sname, Strings.Len(sname) - 2);
                                var loopTo12 = CountItem();
                                for (i = 1; i <= loopTo12; i++)
                                {
                                    {
                                        var withBlock7 = Item(i);
                                        if (withBlock7.Activated)
                                        {
                                            if ((iname ?? "") == (withBlock7.Name ?? "") || (iname ?? "") == (withBlock7.Class0() ?? ""))
                                            {
                                                slevel = 1d;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            else if (Strings.Right(sname, 2) == "隣接" || Strings.Right(sname, 4) == "マス以内")
                            {
                                // 特定のユニットが近くにいることを指定した必要技能
                                if (Status == "出撃")
                                {
                                    if (Strings.Right(sname, 2) == "隣接")
                                    {
                                        uname = Strings.Left(sname, Strings.Len(sname) - 2);
                                        max_range = 1;
                                    }
                                    else
                                    {
                                        uname = Strings.Left(sname, Strings.Len(sname) - 5);
                                        max_range = GeneralLib.StrToLng(Strings.Mid(sname, Strings.Len(sname) - 4, 1));
                                    }

                                    var loopTo13 = GeneralLib.MinLng(x + max_range, Map.MapWidth);
                                    for (i = GeneralLib.MaxLng(x - max_range, 1); i <= loopTo13; i++)
                                    {
                                        var loopTo14 = GeneralLib.MinLng(y + max_range, Map.MapHeight);
                                        for (j = GeneralLib.MaxLng(y - max_range, 1); j <= loopTo14; j++)
                                        {
                                            u = Map.MapDataForUnit[i, j];

                                            // 距離が範囲外？
                                            if ((Math.Abs((x - i)) + Math.Abs((y - j))) > max_range)
                                            {
                                                goto NextNeighbor;
                                            }

                                            // ユニットがいない？
                                            if (u is null)
                                            {
                                                goto NextNeighbor;
                                            }

                                            // ユニットが自分？
                                            if (ReferenceEquals(u, this) || x == i && y == j)
                                            {
                                                goto NextNeighbor;
                                            }

                                            // ユニットが敵？
                                            if (IsEnemy(u))
                                            {
                                                goto NextNeighbor;
                                            }
                                            // 合体技のパートナーに該当するか
                                            if (uname == "母艦")
                                            {
                                                if (!u.IsFeatureAvailable("母艦"))
                                                {
                                                    goto NextNeighbor;
                                                }
                                            }
                                            else if ((u.Name ?? "") != (uname ?? "") && (u.MainPilot().Name ?? "") != (uname ?? ""))
                                            {
                                                goto NextNeighbor;
                                            }

                                            // 行動出来なければだめ
                                            if (u.MaxAction() == 0 || u.IsConditionSatisfied("混乱") || u.IsConditionSatisfied("恐怖") || u.IsConditionSatisfied("憑依"))
                                            {
                                                goto NextNeighbor;
                                            }

                                            // パートナーが見つかった
                                            IsNecessarySkillSatisfied2Ret = true;
                                            return IsNecessarySkillSatisfied2Ret;
                                            NextNeighbor:
                                            ;
                                        }
                                    }
                                }
                            }
                            else if (Strings.Right(sname, 2) == "状態")
                            {
                                // 特殊状態を指定した必要技能
                                if (IsConditionSatisfied(Strings.Left(sname, Strings.Len(sname) - 2)))
                                {
                                    slevel = 1d;
                                }
                            }
                        }

                        break;
                    }
            }

            // 指定された技能のレベルが必要なレベル以上の場合に必要技能が満たされたと判定
            if (slevel >= nlevel)
            {
                IsNecessarySkillSatisfied2Ret = true;
            }

            return IsNecessarySkillSatisfied2Ret;
        }

        // 能力 fname を封印されているか？
        public bool IsDisabled(string fname)
        {
            bool IsDisabledRet = default;
            if (Strings.Len(fname) == 0)
            {
                IsDisabledRet = false;
                return IsDisabledRet;
            }

            if (Expression.IsGlobalVariableDefined("Disable(" + fname + ")"))
            {
                IsDisabledRet = true;
                return IsDisabledRet;
            }

            if (Expression.IsGlobalVariableDefined("Disable(" + Name + "," + fname + ")"))
            {
                IsDisabledRet = true;
                return IsDisabledRet;
            }

            IsDisabledRet = false;
            return IsDisabledRet;
        }

        // 現在、自分が攻撃を受けている側かどうか判定
        public bool IsDefense()
        {
            bool IsDefenseRet = default;
            if ((Party ?? "") == (SRC.Stage ?? ""))
            {
                IsDefenseRet = false;
            }
            else
            {
                IsDefenseRet = true;
            }

            return IsDefenseRet;
        }
    }
}
